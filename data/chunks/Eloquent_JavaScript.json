[
  {
    "id": "Eloquent_JavaScript_0",
    "text": "Eloquent JavaScript\n4th edition\nMarijn Haverbeke\nCopyright \u00a9 2024 by Marijn Haverbeke\nThis work is licensed under a Creative Commons attribution-noncommercial\nlicense (http://creativecommons.org/licenses/by-nc/3.0/). All code in the\nbook may also be considered licensed under an MIT license (https://eloquentjavascript.\nnet/code/LICENSE).\nThe illustrations are contributed by various artists: Cover by P\u00e9chane Sumi-\ne. Chapter illustrations by Madalina Tantareanu. Pixel art in Chapters 7 and\n16 by Antonio Perdomo Pastor. Regular expression diagrams in Chapter 9\ngenerated with regexper.com by Jeff Avallone. Game concept for Chapter 16\nby Thomas Palef.\nYou can buy a print version of this book, with an extra bonus chapter included,\nprinted by No Starch Press at http://a-fwd.com/com=marijhaver-20&asin-\ncom=1593279507.\ni\nContents\nIntroduction\n1\nOn programming\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2\nWhy language matters . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_1",
    "text": "com=1593279507.\ni\nContents\nIntroduction\n1\nOn programming\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2\nWhy language matters . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\nWhat is JavaScript? . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n5\nCode, and what to do with it\n. . . . . . . . . . . . . . . . . . . . . . .\n7\nOverview of this book . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8\nTypographic conventions . . . . . . . . . . . . . . . . . . . . . . . . . .\n8\n1\nValues, Types, and Operators\n10\nValues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10\nNumbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n11\nStrings\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\nUnary operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15\nBoolean values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_2",
    "text": "13\nUnary operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15\nBoolean values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15\nEmpty values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n17\nAutomatic type conversion . . . . . . . . . . . . . . . . . . . . . . . . .\n18\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n20\n2\nProgram Structure\n21\nExpressions and statements\n. . . . . . . . . . . . . . . . . . . . . . . .\n21\nBindings\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n22\nBinding names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\nThe environment\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\nFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\nThe console.log function . . . . . . . . . . . . . . . . . . . . . . . . . .\n25\nReturn values\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n25",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_3",
    "text": "24\nThe console.log function . . . . . . . . . . . . . . . . . . . . . . . . . .\n25\nReturn values\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n25\nControl flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n26\nConditional execution . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n26\nwhile and do loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n28\nIndenting Code\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n30\nfor loops\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n31\nBreaking Out of a Loop\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n32\nii\nUpdating bindings succinctly\n. . . . . . . . . . . . . . . . . . . . . . .\n32\nDispatching on a value with switch . . . . . . . . . . . . . . . . . . . .\n33\nCapitalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n34\nComments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n34",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_4",
    "text": "33\nCapitalization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n34\nComments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n34\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n35\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n35\n3\nFunctions\n38\nDefining a function . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n38\nBindings and scopes . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n39\nNested scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n40\nFunctions as values . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n41\nDeclaration notation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n42\nArrow functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n42\nThe call stack\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n43\nOptional Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n44",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_5",
    "text": "42\nThe call stack\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n43\nOptional Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n44\nClosure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n45\nRecursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n47\nGrowing functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n50\nFunctions and side effects\n. . . . . . . . . . . . . . . . . . . . . . . . .\n52\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n53\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n53\n4\nData Structures: Objects and Arrays\n55\nThe weresquirrel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n55\nDatasets\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n56\nProperties\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n57\nMethods",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_6",
    "text": "55\nDatasets\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n56\nProperties\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n57\nMethods\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n57\nObjects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n58\nMutability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n61\nThe lycanthrope\u2019s log . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n62\nComputing correlation . . . . . . . . . . . . . . . . . . . . . . . . . . .\n64\nArray loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n65\nThe final analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n66\nFurther arrayology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n68\nStrings and their properties\n. . . . . . . . . . . . . . . . . . . . . . . .\n69\nRest parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n71",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_7",
    "text": "68\nStrings and their properties\n. . . . . . . . . . . . . . . . . . . . . . . .\n69\nRest parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n71\nThe Math object . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n72\nDestructuring\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n73\nOptional property access . . . . . . . . . . . . . . . . . . . . . . . . . .\n74\niii\nJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n75\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n76\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n76\n5\nHigher-Order Functions\n79\nAbstraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n80\nAbstracting repetition\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n80\nHigher-order functions\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n82\nScript dataset",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_8",
    "text": "80\nAbstracting repetition\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n80\nHigher-order functions\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n82\nScript dataset\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n83\nFiltering arrays\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n84\nTransforming with map . . . . . . . . . . . . . . . . . . . . . . . . . . .\n85\nSummarizing with reduce . . . . . . . . . . . . . . . . . . . . . . . . . .\n85\nComposability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n86\nStrings and character codes\n. . . . . . . . . . . . . . . . . . . . . . . .\n88\nRecognizing text . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n90\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n91\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n91\n6\nThe Secret Life of Objects\n93\nAbstract Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_9",
    "text": "91\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n91\n6\nThe Secret Life of Objects\n93\nAbstract Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n93\nMethods\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n94\nPrototypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n95\nClasses\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n97\nPrivate Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n99\nOverriding derived properties\n. . . . . . . . . . . . . . . . . . . . . . . 100\nMaps\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\nPolymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\nGetters, setters, and statics\n. . . . . . . . . . . . . . . . . . . . . . . . 103\nSymbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_10",
    "text": "Getters, setters, and statics\n. . . . . . . . . . . . . . . . . . . . . . . . 103\nSymbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\nThe iterator interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\nInheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\nThe instanceof operator . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\n7\nProject: A Robot\n112\nMeadowfield . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\nThe task\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\nPersistent data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\nSimulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\niv\nThe mail truck\u2019s route",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_11",
    "text": "Persistent data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\nSimulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\niv\nThe mail truck\u2019s route\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 118\nPathfinding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121\n8\nBugs and Errors\n123\nLanguage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123\nStrict mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\nTypes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\nTesting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\nError propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_12",
    "text": "Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\nError propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\nExceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130\nCleaning up after exceptions . . . . . . . . . . . . . . . . . . . . . . . . 131\nSelective catching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133\nAssertions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n9\nRegular Expressions\n138\nCreating a regular expression\n. . . . . . . . . . . . . . . . . . . . . . . 138\nTesting for matches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\nSets of characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_13",
    "text": "Testing for matches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\nSets of characters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\nInternational characters . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\nRepeating parts of a pattern . . . . . . . . . . . . . . . . . . . . . . . . 142\nGrouping subexpressions . . . . . . . . . . . . . . . . . . . . . . . . . . 143\nMatches and groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 143\nThe Date class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\nBoundaries and look-ahead . . . . . . . . . . . . . . . . . . . . . . . . . 145\nChoice patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\nThe mechanics of matching\n. . . . . . . . . . . . . . . . . . . . . . . . 147\nBacktracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147\nThe replace method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_14",
    "text": "Backtracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147\nThe replace method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149\nGreed . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150\nDynamically creating RegExp objects\n. . . . . . . . . . . . . . . . . . 152\nThe search method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152\nThe lastIndex property . . . . . . . . . . . . . . . . . . . . . . . . . . . 153\nParsing an INI file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154\nCode units and characters . . . . . . . . . . . . . . . . . . . . . . . . . 157\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159\nv\n10 Modules\n161\nModular programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161\nES modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_15",
    "text": "v\n10 Modules\n161\nModular programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161\nES modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162\nPackages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164\nCommonJS modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165\nBuilding and bundling\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 168\nModule design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171\n11 Asynchronous Programming\n173\nAsynchronicity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nCallbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175\nPromises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176\nFailure",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_16",
    "text": "Callbacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175\nPromises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176\nFailure\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\nCarla . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180\nBreaking In . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181\nAsync functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\nGenerators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184\nA Corvid Art Project . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\nThe event loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\nAsynchronous bugs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_17",
    "text": "Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191\n12 Project: A Programming Language\n193\nParsing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193\nThe evaluator\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197\nSpecial forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199\nThe environment\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\nFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202\nCompilation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203\nCheating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204\n13 JavaScript and the Browser\n206\nNetworks and the Internet . . . . . . . . . . . . . . . . . . . . . . . . . 206",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_18",
    "text": "Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204\n13 JavaScript and the Browser\n206\nNetworks and the Internet . . . . . . . . . . . . . . . . . . . . . . . . . 206\nThe Web . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208\nHTML\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208\nHTML and JavaScript\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 211\nvi\nIn the sandbox . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212\nCompatibility and the browser wars\n. . . . . . . . . . . . . . . . . . . 212\n14 The Document Object Model\n214\nDocument structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214\nTrees\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215\nThe standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216\nMoving through the tree . . . . . . . . . . . . . . . . . . . . . . . . . . 217\nFinding elements",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_19",
    "text": "The standard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216\nMoving through the tree . . . . . . . . . . . . . . . . . . . . . . . . . . 217\nFinding elements\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\nChanging the document\n. . . . . . . . . . . . . . . . . . . . . . . . . . 219\nCreating nodes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220\nAttributes\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222\nLayout\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222\nStyling\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224\nCascading styles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 226\nQuery selectors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227\nPositioning and animating . . . . . . . . . . . . . . . . . . . . . . . . . 228\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_20",
    "text": "Positioning and animating . . . . . . . . . . . . . . . . . . . . . . . . . 228\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230\n15 Handling Events\n233\nEvent handlers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 233\nEvents and DOM nodes\n. . . . . . . . . . . . . . . . . . . . . . . . . . 234\nEvent objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235\nPropagation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235\nDefault actions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\nKey events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\nPointer events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239\nScroll events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_21",
    "text": "Pointer events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239\nScroll events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 243\nFocus events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244\nLoad event . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\nEvents and the event loop . . . . . . . . . . . . . . . . . . . . . . . . . 245\nTimers\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 246\nDebouncing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249\n16 Project: A Platform Game\n251\nThe game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251\nThe technology\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252\nvii",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_22",
    "text": "16 Project: A Platform Game\n251\nThe game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251\nThe technology\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252\nvii\nLevels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252\nReading a level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253\nActors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255\nDrawing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258\nMotion and collision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263\nActor updates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266\nTracking keys\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\nRunning the game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271\n17 Drawing on Canvas\n273",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_23",
    "text": "Running the game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271\n17 Drawing on Canvas\n273\nSVG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\nThe canvas element . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 274\nLines and surfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\nPaths . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 276\nCurves\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\nDrawing a pie chart . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\nText . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281\nImages\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\nTransformation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_24",
    "text": "Images\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282\nTransformation\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\nStoring and clearing transformations . . . . . . . . . . . . . . . . . . . 286\nBack to the game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287\nChoosing a graphics interface . . . . . . . . . . . . . . . . . . . . . . . 292\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294\n18 HTTP and Forms\n296\nThe protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296\nBrowsers and HTTP\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 298\nFetch\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\nHTTP sandboxing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301\nAppreciating HTTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_25",
    "text": "HTTP sandboxing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301\nAppreciating HTTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301\nSecurity and HTTPS . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302\nForm fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\nFocus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\nDisabled fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305\nThe form as a whole\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 306\nText fields\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307\nCheckboxes and radio buttons . . . . . . . . . . . . . . . . . . . . . . . 309\nSelect fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310\nviii\nFile fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311\nStoring data client-side . . . . . . . . . . . . . . . . . . . . . . . . . . . 312",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_26",
    "text": "viii\nFile fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311\nStoring data client-side . . . . . . . . . . . . . . . . . . . . . . . . . . . 312\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n19 Project: A Pixel Art Editor\n318\nComponents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 318\nThe state . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\nDOM building . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\nThe canvas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 322\nThe application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325\nDrawing tools\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\nSaving and loading\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_27",
    "text": "Drawing tools\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\nSaving and loading\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 330\nUndo history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\nLet\u2019s draw\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 334\nWhy is this so hard?\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 335\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n20 Node.js\n338\nBackground . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 338\nThe node command . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339\nModules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 340\nInstalling with NPM\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 341\nThe filesystem module\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 343\nThe HTTP module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_28",
    "text": "The filesystem module\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 343\nThe HTTP module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344\nStreams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 346\nA file server\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 347\nSummary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 352\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 353\n21 Project: Skill-Sharing Website\n355\nDesign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355\nLong polling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 356\nHTTP interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 357\nThe server\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359\nThe client . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 366",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_29",
    "text": "The server\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359\nThe client . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 366\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 372\nExercise Hints\n374\nProgram Structure\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 374\nix\nFunctions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375\nData Structures: Objects and Arrays . . . . . . . . . . . . . . . . . . . 376\nHigher-Order Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . 378\nThe Secret Life of Objects . . . . . . . . . . . . . . . . . . . . . . . . . 379\nProject: A Robot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 380\nBugs and Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381\nRegular Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_30",
    "text": "Bugs and Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381\nRegular Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 381\nModules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 382\nAsynchronous Programming . . . . . . . . . . . . . . . . . . . . . . . . 383\nProject: A Programming Language . . . . . . . . . . . . . . . . . . . . 385\nThe Document Object Model . . . . . . . . . . . . . . . . . . . . . . . 386\nHandling Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 387\nProject: A Platform Game . . . . . . . . . . . . . . . . . . . . . . . . . 388\nDrawing on Canvas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 389\nHTTP and Forms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 391\nProject: A Pixel Art Editor . . . . . . . . . . . . . . . . . . . . . . . . 392\nNode.js . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_31",
    "text": "Project: A Pixel Art Editor . . . . . . . . . . . . . . . . . . . . . . . . 392\nNode.js . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 394\nProject: Skill-Sharing Website . . . . . . . . . . . . . . . . . . . . . . . 395\nx\n\u201cWe think we are creating the system for our own purposes. We\nbelieve we are making it in our own image... But the computer is\nnot really like us. It is a projection of a very slim part of ourselves:\nthat portion devoted to logic, order, rule, and clarity.\u201d\n\u2014Ellen Ullman, Close to the Machine: Technophilia and Its\nDiscontents\nIntroduction\nThis is a book about instructing computers. Computers are about as common\nas screwdrivers today, but they are quite a bit more complex, and making them\ndo what you want them to do isn\u2019t always easy.\nIf the task you have for your computer is a common, well-understood one,\nsuch as showing you your email or acting like a calculator, you can open the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_32",
    "text": "do what you want them to do isn\u2019t always easy.\nIf the task you have for your computer is a common, well-understood one,\nsuch as showing you your email or acting like a calculator, you can open the\nappropriate application and get to work. But for unique or open-ended tasks,\nthere often is no appropriate application.\nThat is where programming may come in. Programming is the act of con-\nstructing a program\u2014a set of precise instructions telling a computer what to do.\nBecause computers are dumb, pedantic beasts, programming is fundamentally\ntedious and frustrating.\nFortunately, if you can get over that fact\u2014and maybe even enjoy the rigor\nof thinking in terms that dumb machines can deal with\u2014programming can be\nrewarding. It allows you to do things in seconds that would take forever by\nhand. It is a way to make your computer tool do things that it couldn\u2019t do\nbefore. On top of that, it makes for a wonderful game of puzzle solving and\nabstract thinking.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_33",
    "text": "hand. It is a way to make your computer tool do things that it couldn\u2019t do\nbefore. On top of that, it makes for a wonderful game of puzzle solving and\nabstract thinking.\nMost programming is done with programming languages. A programming\nlanguage is an artificially constructed language used to instruct computers. It\nis interesting that the most effective way we\u2019ve found to communicate with a\ncomputer borrows so heavily from the way we communicate with each other.\nLike human languages, computer languages allow words and phrases to be\ncombined in new ways, making it possible to express ever new concepts.\nAt one point, language-based interfaces, such as the BASIC and DOS prompts\nof the 1980s and 1990s, were the main method of interacting with computers.\nFor routine computer use, these have largely been replaced with visual inter-\nfaces, which are easier to learn but offer less freedom. But if you know where\nto look, the languages are still there. One of them, JavaScript, is built into",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_34",
    "text": "faces, which are easier to learn but offer less freedom. But if you know where\nto look, the languages are still there. One of them, JavaScript, is built into\nevery modern web browser\u2014and is thus available on almost every device.\nThis book will try to make you familiar enough with this language to do\nuseful and amusing things with it.\n1\nOn programming\nBesides explaining JavaScript, I will introduce the basic principles of program-\nming. Programming, it turns out, is hard. The fundamental rules are simple\nand clear, but programs built on top of these rules tend to become complex\nenough to introduce their own rules and complexity. You\u2019re building your own\nmaze, in a way, and you can easily get lost in it.\nThere will be times when reading this book feels terribly frustrating. If you\nare new to programming, there will be a lot of new material to digest. Much of\nthis material will then be combined in ways that require you to make additional\nconnections.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_35",
    "text": "are new to programming, there will be a lot of new material to digest. Much of\nthis material will then be combined in ways that require you to make additional\nconnections.\nIt is up to you to make the necessary effort. When you are struggling to\nfollow the book, do not jump to any conclusions about your own capabilities.\nYou are fine\u2014you just need to keep at it. Take a break, reread some material,\nand make sure you read and understand the example programs and exercises.\nLearning is hard work, but everything you learn is yours and will make further\nlearning easier.\nWhen action grows unprofitable, gather information; when infor-\nmation grows unprofitable, sleep.\n\u2014Ursula K. Le Guin, The Left Hand of Darkness\nA program is many things. It is a piece of text typed by a programmer, it is\nthe directing force that makes the computer do what it does, it is data in the\ncomputer\u2019s memory, and, at the same time, it controls the actions performed",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_36",
    "text": "the directing force that makes the computer do what it does, it is data in the\ncomputer\u2019s memory, and, at the same time, it controls the actions performed\non this memory. Analogies that try to compare programs to familiar objects\ntend to fall short. A superficially fitting one is to compare a program to a\nmachine\u2014lots of separate parts tend to be involved, and to make the whole\nthing tick, we have to consider the ways in which these parts interconnect and\ncontribute to the operation of the whole.\nA computer is a physical machine that acts as a host for these immaterial\nmachines. Computers themselves can do only stupidly straightforward things.\nThe reason they are so useful is that they do these things at an incredibly\nhigh speed. A program can ingeniously combine an enormous number of these\nsimple actions to do very complicated things.\nA program is a building of thought. It is costless to build, it is weightless,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_37",
    "text": "high speed. A program can ingeniously combine an enormous number of these\nsimple actions to do very complicated things.\nA program is a building of thought. It is costless to build, it is weightless,\nand it grows easily under our typing hands. But as a program grows, so does\nits complexity. The skill of programming is the skill of building programs that\ndon\u2019t confuse the programmer. The best programs are those that manage to\ndo something interesting while still being easy to understand.\n2\nSome programmers believe that this complexity is best managed by using\nonly a small set of well-understood techniques in their programs. They have\ncomposed strict rules (\u201cbest practices\u201d) prescribing the form programs should\nhave and carefully stay within their safe little zone.\nThis is not only boring\u2014it is ineffective. New problems often require new\nsolutions. The field of programming is young and still developing rapidly, and",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_38",
    "text": "This is not only boring\u2014it is ineffective. New problems often require new\nsolutions. The field of programming is young and still developing rapidly, and\nit is varied enough to have room for wildly different approaches. There are\nmany terrible mistakes to make in program design, and you should go ahead\nand make them at least once so that you understand them. A sense of what a\ngood program looks like is developed with practice, not learned from a list of\nrules.\nWhy language matters\nIn the beginning, at the birth of computing, there were no programming lan-\nguages. Programs looked something like this:\n00110001 00000000 00000000\n00110001 00000001 00000001\n00110011 00000001 00000010\n01010001 00001011 00000010\n00100010 00000010 00001000\n01000011 00000001 00000000\n01000001 00000001 00000001\n00010000 00000010 00000000\n01100010 00000000 00000000\nThis is a program to add the numbers from 1 to 10 together and print the\nresult: 1 + 2 + ... + 10 = 55. It could run on a simple hypothetical machine.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_39",
    "text": "01100010 00000000 00000000\nThis is a program to add the numbers from 1 to 10 together and print the\nresult: 1 + 2 + ... + 10 = 55. It could run on a simple hypothetical machine.\nTo program early computers, it was necessary to set large arrays of switches\nin the right position or punch holes in strips of cardboard and feed them to\nthe computer. You can imagine how tedious and error prone this procedure\nwas. Even writing simple programs required much cleverness and discipline.\nComplex ones were nearly inconceivable.\nOf course, manually entering these arcane patterns of bits (the ones and\nzeros) did give the programmer a profound sense of being a mighty wizard.\nAnd that has to be worth something in terms of job satisfaction.\nEach line of the previous program contains a single instruction. It could be\nwritten in English like this:\n1. Store the number 0 in memory location 0.\n3\n2. Store the number 1 in memory location 1.\n3. Store the value of memory location 1 in memory location 2.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_40",
    "text": "written in English like this:\n1. Store the number 0 in memory location 0.\n3\n2. Store the number 1 in memory location 1.\n3. Store the value of memory location 1 in memory location 2.\n4. Subtract the number 11 from the value in memory location 2.\n5. If the value in memory location 2 is the number 0, continue with instruc-\ntion 9.\n6. Add the value of memory location 1 to memory location 0.\n7. Add the number 1 to the value of memory location 1.\n8. Continue with instruction 3.\n9. Output the value of memory location 0.\nAlthough that is already more readable than the soup of bits, it is still rather\nobscure. Using names instead of numbers for the instructions and memory\nlocations helps.\nSet \u201ctotal\u201d to 0.\nSet \u201ccount\u201d to 1.\n[loop]\nSet \u201ccompare\u201d to \u201ccount\u201d.\nSubtract 11 from \u201ccompare\u201d.\nIf \u201ccompare\u201d is 0, continue at [end].\nAdd \u201ccount\u201d to \u201ctotal\u201d.\nAdd 1 to \u201ccount\u201d.\nContinue at [loop].\n[end]\nOutput \u201ctotal\u201d.\nCan you see how the program works at this point? The first two lines give",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_41",
    "text": "If \u201ccompare\u201d is 0, continue at [end].\nAdd \u201ccount\u201d to \u201ctotal\u201d.\nAdd 1 to \u201ccount\u201d.\nContinue at [loop].\n[end]\nOutput \u201ctotal\u201d.\nCan you see how the program works at this point? The first two lines give\ntwo memory locations their starting values: total will be used to build up the\nresult of the computation, and count will keep track of the number that we are\ncurrently looking at. The lines using compare are probably the most confusing\nones. The program wants to see whether count is equal to 11 to decide whether\nit can stop running. Because our hypothetical machine is rather primitive, it\ncan test only whether a number is zero and make a decision based on that.\nIt therefore uses the memory location labeled compare to compute the value\nof count - 11 and makes a decision based on that value. The next two lines\nadd the value of count to the result and increment count by 1 every time the\nprogram decides that count is not 11 yet.\nHere is the same program in JavaScript:\n4\nlet total = 0, count = 1;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_42",
    "text": "add the value of count to the result and increment count by 1 every time the\nprogram decides that count is not 11 yet.\nHere is the same program in JavaScript:\n4\nlet total = 0, count = 1;\nwhile (count <= 10) {\ntotal += count;\ncount += 1;\n}\nconsole.log(total);\n// \u219255\nThis version gives us a few more improvements. Most importantly, there is\nno need to specify the way we want the program to jump back and forth\nanymore\u2014the while construct takes care of that. It continues executing the\nblock (wrapped in braces) below it as long as the condition it was given holds.\nThat condition is count <= 10, which means \u201cthe count is less than or equal\nto 10\u201d. We no longer have to create a temporary value and compare that to\nzero, which was just an uninteresting detail. Part of the power of programming\nlanguages is that they can take care of uninteresting details for us.\nAt the end of the program, after the while construct has finished, the console\n.log operation is used to write out the result.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_43",
    "text": "languages is that they can take care of uninteresting details for us.\nAt the end of the program, after the while construct has finished, the console\n.log operation is used to write out the result.\nFinally, here is what the program could look like if we happened to have\nthe convenient operations range and sum available, which respectively create a\ncollection of numbers within a range and compute the sum of a collection of\nnumbers:\nconsole.log(sum(range(1, 10)));\n// \u219255\nThe moral of this story is that the same program can be expressed in both long\nand short, unreadable and readable ways. The first version of the program was\nextremely obscure, whereas this last one is almost English: log the sum of the\nrange of numbers from 1 to 10. (We will see in later chapters how to define\noperations like sum and range.)\nA good programming language helps the programmer by allowing them to\ntalk about the actions that the computer has to perform on a higher level.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_44",
    "text": "operations like sum and range.)\nA good programming language helps the programmer by allowing them to\ntalk about the actions that the computer has to perform on a higher level.\nIt helps omit details, provides convenient building blocks (such as while and\nconsole.log), allows you to define your own building blocks (such as sum and\nrange), and makes those blocks easy to compose.\nWhat is JavaScript?\nJavaScript was introduced in 1995 as a way to add programs to web pages in the\nNetscape Navigator browser. The language has since been adopted by all other\nmajor graphical web browsers. It has made modern web applications possible\u2014\n5\nthat is, applications with which you can interact directly without doing a page\nreload for every action. JavaScript is also used in more traditional websites to\nprovide various forms of interactivity and cleverness.\nIt is important to note that JavaScript has almost nothing to do with the\nprogramming language named Java. The similar name was inspired by mar-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_45",
    "text": "provide various forms of interactivity and cleverness.\nIt is important to note that JavaScript has almost nothing to do with the\nprogramming language named Java. The similar name was inspired by mar-\nketing considerations rather than good judgment. When JavaScript was being\nintroduced, the Java language was being heavily marketed and was gaining\npopularity. Someone thought it was a good idea to try to ride along on this\nsuccess. Now we are stuck with the name.\nAfter its adoption outside of Netscape, a standard document was written to\ndescribe the way the JavaScript language should work so that the various pieces\nof software that claimed to support JavaScript could make sure they actually\nprovided the same language. This is called the ECMAScript standard, after\nthe Ecma International organization that conducted the standardization. In\npractice, the terms ECMAScript and JavaScript can be used interchangeably\u2014\nthey are two names for the same language.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_46",
    "text": "the Ecma International organization that conducted the standardization. In\npractice, the terms ECMAScript and JavaScript can be used interchangeably\u2014\nthey are two names for the same language.\nThere are those who will say terrible things about JavaScript. Many of these\nthings are true. When I was required to write something in JavaScript for the\nfirst time, I quickly came to despise it. It would accept almost anything I typed\nbut interpret it in a way that was completely different from what I meant. This\nhad a lot to do with the fact that I did not have a clue what I was doing, of\ncourse, but there is a real issue here: JavaScript is ridiculously liberal in what\nit allows. The idea behind this design was that it would make programming in\nJavaScript easier for beginners. In actuality, it mostly makes finding problems\nin your programs harder because the system will not point them out to you.\nThis flexibility also has its advantages, though. It leaves room for techniques",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_47",
    "text": "in your programs harder because the system will not point them out to you.\nThis flexibility also has its advantages, though. It leaves room for techniques\nthat are impossible in more rigid languages and makes for a pleasant, informal\nstyle of programming. After learning the language properly and working with\nit for a while, I have come to actually like JavaScript.\nThere have been several versions of JavaScript. ECMAScript version 3 was\nthe widely supported version during JavaScript\u2019s ascent to dominance, roughly\nbetween 2000 and 2010. During this time, work was underway on an ambitious\nversion 4, which planned a number of radical improvements and extensions to\nthe language. Changing a living, widely used language in such a radical way\nturned out to be politically di\ufb00icult, and work on version 4 was abandoned in\n2008. A much less ambitious version 5, which made only some uncontroversial\nimprovements, came out in 2009. In 2015, version 6 came out, a major update",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_48",
    "text": "2008. A much less ambitious version 5, which made only some uncontroversial\nimprovements, came out in 2009. In 2015, version 6 came out, a major update\nthat included some of the ideas planned for version 4. Since then we\u2019ve had\nnew, small updates every year.\nThe fact that JavaScript is evolving means that browsers have to constantly\n6\nkeep up. If you\u2019re using an older browser, it may not support every feature.\nThe language designers are careful to not make any changes that could break\nexisting programs, so new browsers can still run old programs. In this book,\nI\u2019m using the 2024 version of JavaScript.\nWeb browsers are not the only platforms on which JavaScript is used. Some\ndatabases, such as MongoDB and CouchDB, use JavaScript as their scripting\nand query language. Several platforms for desktop and server programming,\nmost notably the Node.js project (the subject of Chapter 20), provide an envi-\nronment for programming JavaScript outside of the browser.\nCode, and what to do with it",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_49",
    "text": "most notably the Node.js project (the subject of Chapter 20), provide an envi-\nronment for programming JavaScript outside of the browser.\nCode, and what to do with it\nCode is the text that makes up programs. Most chapters in this book contain\nquite a lot of code. I believe reading code and writing code are indispensable\nparts of learning to program. Try to not just glance over the examples\u2014read\nthem attentively and understand them. This may be slow and confusing at\nfirst, but I promise that you\u2019ll quickly get the hang of it. The same goes for\nthe exercises. Don\u2019t assume you understand them until you\u2019ve actually written\na working solution.\nI recommend you try your solutions to exercises in an actual JavaScript\ninterpreter. That way, you\u2019ll get immediate feedback on whether what you are\ndoing is working, and, I hope, you\u2019ll be tempted to experiment and go beyond\nthe exercises.\nThe easiest way to run the example code in the book\u2014and to experiment",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_50",
    "text": "doing is working, and, I hope, you\u2019ll be tempted to experiment and go beyond\nthe exercises.\nThe easiest way to run the example code in the book\u2014and to experiment\nwith it\u2014is to look it up in the online version of the book at https://eloquentjavascript.net.\nThere, you can click any code example to edit and run it and to see the output\nit produces. To work on the exercises, go to https://eloquentjavascript.net/\ncode, which provides starting code for each coding exercise and allows you to\nlook at the solutions.\nRunning the programs defined in this book outside of the book\u2019s website\nrequires some care. Many examples stand on their own and should work in\nany JavaScript environment. But code in later chapters is often written for\na specific environment (the browser or Node.js) and can run only there. In\naddition, many chapters define bigger programs, and the pieces of code that\nappear in them depend on each other or on external files. The sandbox on",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_51",
    "text": "addition, many chapters define bigger programs, and the pieces of code that\nappear in them depend on each other or on external files. The sandbox on\nthe website provides links to ZIP files containing all the scripts and data files\nnecessary to run the code for a given chapter.\n7\nOverview of this book\nThis book contains roughly three parts.\nThe first 12 chapters discuss the\nJavaScript language. The next seven chapters are about web browsers and the\nway JavaScript is used to program them. Finally, two chapters are devoted to\nNode.js, another environment to program JavaScript in. There are five project\nchapters in the book that describe larger example programs to give you a taste\nof actual programming.\nThe language part of the book starts with four chapters that introduce the\nbasic structure of the JavaScript language.\nThey discuss control structures\n(such as the while word you saw in this introduction), functions (writing your",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_52",
    "text": "basic structure of the JavaScript language.\nThey discuss control structures\n(such as the while word you saw in this introduction), functions (writing your\nown building blocks), and data structures. After these, you will be able to write\nbasic programs. Next, Chapters 5 and 6 introduce techniques to use functions\nand objects to write more abstract code and keep complexity under control.\nAfter a first project chapter that builds a crude delivery robot, the language\npart of the book continues with chapters on error handling and bug fixing,\nregular expressions (an important tool for working with text), modularity (an-\nother defense against complexity), and asynchronous programming (dealing\nwith events that take time). The second project chapter, where we implement\na programming language, concludes the first part of the book.\nThe second part of the book, Chapters 13 to 19, describes the tools that\nbrowser JavaScript has access to. You\u2019ll learn to display things on the screen",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_53",
    "text": "The second part of the book, Chapters 13 to 19, describes the tools that\nbrowser JavaScript has access to. You\u2019ll learn to display things on the screen\n(Chapters 14 and 17), respond to user input (Chapter 15), and communicate\nover the network (Chapter 18). There are again two project chapters in this\npart: building a platform game and a pixel paint program.\nChapter 20 describes Node.js, and Chapter 21 builds a small website using\nthat tool.\nTypographic conventions\nIn this book, text written in a monospaced font will represent elements of pro-\ngrams. Sometimes these are self-su\ufb00icient fragments, and sometimes they just\nrefer to part of a nearby program. Programs (of which you have already seen\na few) are written as follows:\nfunction factorial(n) {\nif (n == 0) {\nreturn 1;\n} else {\nreturn factorial(n - 1) * n;\n}\n8\n}\nSometimes, to show the output that a program produces, the expected output\nis written after it, with two slashes and an arrow in front.\nconsole.log(factorial(8));\n// \u219240320",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_54",
    "text": "}\n8\n}\nSometimes, to show the output that a program produces, the expected output\nis written after it, with two slashes and an arrow in front.\nconsole.log(factorial(8));\n// \u219240320\nGood luck!\n9\n\u201cBelow the surface of the machine, the program moves. Without\neffort, it expands and contracts. In great harmony, electrons scatter\nand regroup. The forms on the monitor are but ripples on the water.\nThe essence stays invisibly below.\u201d\n\u2014Master Yuan-Ma, The Book of Programming\nChapter 1\nValues, Types, and Operators\nIn the computer\u2019s world, there is only data. You can read data, modify data,\ncreate new data\u2014but that which isn\u2019t data cannot be mentioned. All this data\nis stored as long sequences of bits and is thus fundamentally alike.\nBits are any kind of two-valued things, usually described as zeros and ones.\nInside the computer, they take forms such as a high or low electrical charge,\na strong or weak signal, or a shiny or dull spot on the surface of a CD. Any",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_55",
    "text": "Inside the computer, they take forms such as a high or low electrical charge,\na strong or weak signal, or a shiny or dull spot on the surface of a CD. Any\npiece of discrete information can be reduced to a sequence of zeros and ones\nand thus represented in bits.\nFor example, we can express the number 13 in bits. This works the same\nway as a decimal number, but instead of 10 different digits, we have only 2,\nand the weight of each increases by a factor of 2 from right to left. Here are the\nbits that make up the number 13, with the weights of the digits shown below\nthem:\n0\n0\n0\n0\n1\n1\n0\n1\n128\n64\n32\n16\n8\n4\n2\n1\nThat\u2019s the binary number 00001101. Its nonzero digits stand for 8, 4, and 1,\nand add up to 13.\nValues\nImagine a sea of bits\u2014an ocean of them. A typical modern computer has more\nthan 100 billion bits in its volatile data storage (working memory). Nonvolatile\nstorage (the hard disk or equivalent) tends to have yet a few orders of magnitude\nmore.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_56",
    "text": "than 100 billion bits in its volatile data storage (working memory). Nonvolatile\nstorage (the hard disk or equivalent) tends to have yet a few orders of magnitude\nmore.\nTo be able to work with such quantities of bits without getting lost, we\nseparate them into chunks that represent pieces of information. In a JavaScript\nenvironment, those chunks are called values. Though all values are made of bits,\nthey play different roles. Every value has a type that determines its role. Some\nvalues are numbers, some values are pieces of text, some values are functions,\n10\nand so on.\nTo create a value, you must merely invoke its name. This is convenient. You\ndon\u2019t have to gather building material for your values or pay for them. You\njust call for one, and whoosh, you have it. Of course, values are not really\ncreated from thin air. Each one has to be stored somewhere, and if you want\nto use a gigantic number of them at the same time, you might run out of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_57",
    "text": "created from thin air. Each one has to be stored somewhere, and if you want\nto use a gigantic number of them at the same time, you might run out of\ncomputer memory. Fortunately, this is a problem only if you need them all\nsimultaneously. As soon as you no longer use a value, it will dissipate, leaving\nbehind its bits to be recycled as building material for the next generation of\nvalues.\nThe remainder of this chapter introduces the atomic elements of JavaScript\nprograms, that is, the simple value types and the operators that can act on\nsuch values.\nNumbers\nValues of the number type are, unsurprisingly, numeric values. In a JavaScript\nprogram, they are written as follows:\n13\nUsing that in a program will cause the bit pattern for the number 13 to come\ninto existence inside the computer\u2019s memory.\nJavaScript uses a fixed number of bits, 64 of them, to store a single number\nvalue. There are only so many patterns you can make with 64 bits, which limits",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_58",
    "text": "into existence inside the computer\u2019s memory.\nJavaScript uses a fixed number of bits, 64 of them, to store a single number\nvalue. There are only so many patterns you can make with 64 bits, which limits\nthe number of different numbers that can be represented. With N decimal\ndigits, you can represent 10N numbers. Similarly, given 64 binary digits, you\ncan represent 264 different numbers, which is about 18 quintillion (an 18 with\n18 zeros after it). That\u2019s a lot.\nComputer memory used to be much smaller, and people tended to use groups\nof 8 or 16 bits to represent their numbers. It was easy to accidentally overflow\nsuch small numbers\u2014to end up with a number that did not fit into the given\nnumber of bits. Today, even computers that fit in your pocket have plenty of\nmemory, so you are free to use 64-bit chunks, and you need to worry about\noverflow only when dealing with truly astronomical numbers.\nNot all whole numbers less than 18 quintillion fit in a JavaScript number,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_59",
    "text": "overflow only when dealing with truly astronomical numbers.\nNot all whole numbers less than 18 quintillion fit in a JavaScript number,\nthough. Those bits also store negative numbers, so one bit indicates the sign\nof the number. A bigger issue is representing nonwhole numbers. To do this,\nsome of the bits are used to store the position of the decimal point. The actual\nmaximum whole number that can be stored is more in the range of 9 quadrillion\n11\n(15 zeros)\u2014which is still pleasantly huge.\nFractional numbers are written using a dot:\n9.81\nFor very big or very small numbers, you may also use scientific notation by\nadding an e (for exponent), followed by the exponent of the number.\n2.998e8\nThat\u2019s 2.998 \u00d7 108 = 299,800,000.\nCalculations with whole numbers (also called integers) that are smaller than\nthe aforementioned 9 quadrillion are guaranteed to always be precise. Unfor-\ntunately, calculations with fractional numbers are generally not. Just as \u03c0 (pi)",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_60",
    "text": "the aforementioned 9 quadrillion are guaranteed to always be precise. Unfor-\ntunately, calculations with fractional numbers are generally not. Just as \u03c0 (pi)\ncannot be precisely expressed by a finite number of decimal digits, many num-\nbers lose some precision when only 64 bits are available to store them. This\nis a shame, but it causes practical problems only in specific situations. The\nimportant thing is to be aware of it and treat fractional digital numbers as\napproximations, not as precise values.\nArithmetic\nThe main thing to do with numbers is arithmetic. Arithmetic operations such\nas addition or multiplication take two number values and produce a new number\nfrom them. Here is what they look like in JavaScript:\n100 + 4 * 11\nThe + and * symbols are called operators. The first stands for addition and the\nsecond stands for multiplication. Putting an operator between two values will\napply it to those values and produce a new value.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_61",
    "text": "second stands for multiplication. Putting an operator between two values will\napply it to those values and produce a new value.\nDoes this example mean \u201cAdd 4 and 100, and multiply the result by 11\u201d,\nor is the multiplication done before the adding? As you might have guessed,\nthe multiplication happens first. As in mathematics, you can change this by\nwrapping the addition in parentheses.\n(100 + 4) * 11\nFor subtraction, there is the - operator.\nDivision can be done with the /\noperator.\nWhen operators appear together without parentheses, the order in which\nthey are applied is determined by the precedence of the operators. The example\nshows that multiplication comes before addition. The / operator has the same\nprecedence as *. Likewise, + and - have the same precedence. When multiple\n12\noperators with the same precedence appear next to each other, as in 1 - 2 + 1,\nthey are applied left to right: (1 - 2)+ 1.\nDon\u2019t worry too much about these precedence rules. When in doubt, just",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_62",
    "text": "12\noperators with the same precedence appear next to each other, as in 1 - 2 + 1,\nthey are applied left to right: (1 - 2)+ 1.\nDon\u2019t worry too much about these precedence rules. When in doubt, just\nadd parentheses.\nThere is one more arithmetic operator, which you might not immediately\nrecognize. The % symbol is used to represent the remainder operation. X % Y\nis the remainder of dividing X by Y. For example, 314 % 100 produces 14, and\n144 % 12 gives 0. The remainder operator\u2019s precedence is the same as that of\nmultiplication and division. You\u2019ll also often see this operator referred to as\nmodulo.\nSpecial numbers\nThere are three special values in JavaScript that are considered numbers but\ndon\u2019t behave like normal numbers. The first two are Infinity and -Infinity\n, which represent the positive and negative infinities.\nInfinity - 1 is still\nInfinity, and so on. Don\u2019t put too much trust in infinity-based computation,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_63",
    "text": ", which represent the positive and negative infinities.\nInfinity - 1 is still\nInfinity, and so on. Don\u2019t put too much trust in infinity-based computation,\nthough. It isn\u2019t mathematically sound, and it will quickly lead to the next\nspecial number: NaN.\nNaN stands for \u201cnot a number\u201d, even though it is a value of the number type.\nYou\u2019ll get this result when you, for example, try to calculate 0 / 0 (zero divided\nby zero), Infinity - Infinity, or any number of other numeric operations that\ndon\u2019t yield a meaningful result.\nStrings\nThe next basic data type is the string. Strings are used to represent text. They\nare written by enclosing their content in quotes.\n`Down on the sea`\n\"Lie on the ocean\"\n'Float on the ocean'\nYou can use single quotes, double quotes, or backticks to mark strings, as long\nas the quotes at the start and the end of the string match.\nYou can put almost anything between quotes to have JavaScript make a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_64",
    "text": "as the quotes at the start and the end of the string match.\nYou can put almost anything between quotes to have JavaScript make a\nstring value out of it. But a few characters are more di\ufb00icult. You can imagine\nhow putting quotes between quotes might be hard, since they will look like the\nend of the string. Newlines (the characters you get when you press enter)\ncan be included only when the string is quoted with backticks (`).\n13\nTo make it possible to include such characters in a string, the following\nnotation is used: a backslash (\\) inside quoted text indicates that the character\nafter it has a special meaning. This is called escaping the character. A quote\nthat is preceded by a backslash will not end the string but be part of it. When\nan n character occurs after a backslash, it is interpreted as a newline. Similarly,\na t after a backslash means a tab character. Take the following string:\n\"This is the first line\\nAnd this is the second\"\nThis is the actual text in that string:",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_65",
    "text": "a t after a backslash means a tab character. Take the following string:\n\"This is the first line\\nAnd this is the second\"\nThis is the actual text in that string:\nThis is the first line\nAnd this is the second\nThere are, of course, situations where you want a backslash in a string to be just\na backslash, not a special code. If two backslashes follow each other, they will\ncollapse together, and only one will be left in the resulting string value. This\nis how the string \u201cA newline character is written like \"\\n\".\u201d can be expressed:\n\"A newline character is written like \\\"\\\\n\\\".\"\nStrings, too, have to be modeled as a series of bits to be able to exist inside\nthe computer. The way JavaScript does this is based on the Unicode standard.\nThis standard assigns a number to virtually every character you would ever\nneed, including characters from Greek, Arabic, Japanese, Armenian, and so\non. If we have a number for every character, a string can be described by a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_66",
    "text": "need, including characters from Greek, Arabic, Japanese, Armenian, and so\non. If we have a number for every character, a string can be described by a\nsequence of numbers. And that\u2019s what JavaScript does.\nThere\u2019s a complication though: JavaScript\u2019s representation uses 16 bits per\nstring element, which can describe up to 216 different characters. However,\nUnicode defines more characters than that\u2014about twice as many, at this point.\nSo some characters, such as many emoji, take up two \u201ccharacter positions\u201d in\nJavaScript strings. We\u2019ll come back to this in Chapter 5.\nStrings cannot be divided, multiplied, or subtracted. The + operator can be\nused on them, not to add, but to concatenate\u2014to glue two strings together.\nThe following line will produce the string \"concatenate\":\n\"con\" + \"cat\" + \"e\" + \"nate\"\nString values have a number of associated functions (methods) that can be used\nto perform other operations on them. I\u2019ll say more about these in Chapter 4.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_67",
    "text": "\"con\" + \"cat\" + \"e\" + \"nate\"\nString values have a number of associated functions (methods) that can be used\nto perform other operations on them. I\u2019ll say more about these in Chapter 4.\nStrings written with single or double quotes behave very much the same\u2014\nthe only difference lies in which type of quote you need to escape inside of\nthem. Backtick-quoted strings, usually called template literals, can do a few\n14\nmore tricks. Apart from being able to span lines, they can also embed other\nvalues.\n`half of 100 is ${100 / 2}`\nWhen you write something inside ${} in a template literal, its result will be\ncomputed, converted to a string, and included at that position. This example\nproduces the string \"half of 100 is 50\".\nUnary operators\nNot all operators are symbols. Some are written as words. One example is the\ntypeof operator, which produces a string value naming the type of the value\nyou give it.\nconsole.log(typeof 4.5)\n// \u2192number\nconsole.log(typeof \"x\")\n// \u2192string",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_68",
    "text": "typeof operator, which produces a string value naming the type of the value\nyou give it.\nconsole.log(typeof 4.5)\n// \u2192number\nconsole.log(typeof \"x\")\n// \u2192string\nWe will use console.log in example code to indicate that we want to see the\nresult of evaluating something. (More about that in the next chapter.)\nThe other operators shown so far in this chapter all operated on two values,\nbut typeof takes only one. Operators that use two values are called binary\noperators, while those that take one are called unary operators. The minus\noperator (-) can be used both as a binary operator and as a unary operator.\nconsole.log(- (10 - 2))\n// \u2192-8\nBoolean values\nIt is often useful to have a value that distinguishes between only two possibili-\nties, like \u201cyes\u201d and \u201cno\u201d or \u201con\u201d and \u201coff\u201d. For this purpose, JavaScript has a\nBoolean type, which has just two values, true and false, written as those words.\nComparison\nHere is one way to produce Boolean values:\nconsole.log(3 > 2)\n// \u2192true\n15",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_69",
    "text": "Boolean type, which has just two values, true and false, written as those words.\nComparison\nHere is one way to produce Boolean values:\nconsole.log(3 > 2)\n// \u2192true\n15\nconsole.log(3 < 2)\n// \u2192false\nThe > and < signs are the traditional symbols for \u201cis greater than\u201d and \u201cis less\nthan\u201d, respectively. They are binary operators. Applying them results in a\nBoolean value that indicates whether they hold true in this case.\nStrings can be compared in the same way.\nconsole.log(\"Aardvark\" < \"Zoroaster\")\n// \u2192true\nThe way strings are ordered is roughly alphabetic but not really what you\u2019d\nexpect to see in a dictionary: uppercase letters are always \u201cless\u201d than lowercase\nones, so \"Z\" < \"a\", and nonalphabetic characters (!, -, and so on) are also\nincluded in the ordering. When comparing strings, JavaScript goes over the\ncharacters from left to right, comparing the Unicode codes one by one.\nOther similar operators are >= (greater than or equal to), <= (less than or",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_70",
    "text": "characters from left to right, comparing the Unicode codes one by one.\nOther similar operators are >= (greater than or equal to), <= (less than or\nequal to), == (equal to), and != (not equal to).\nconsole.log(\"Garnet\" != \"Ruby\")\n// \u2192true\nconsole.log(\"Pearl\" == \"Amethyst\")\n// \u2192false\nThere is only one value in JavaScript that is not equal to itself, and that is NaN\n(\u201cnot a number\u201d).\nconsole.log(NaN == NaN)\n// \u2192false\nNaN is supposed to denote the result of a nonsensical computation, and as such,\nit isn\u2019t equal to the result of any other nonsensical computations.\nLogical operators\nThere are also some operations that can be applied to Boolean values them-\nselves. JavaScript supports three logical operators: and, or, and not. These\ncan be used to \u201creason\u201d about Booleans.\nThe && operator represents logical and. It is a binary operator, and its result\nis true only if both the values given to it are true.\nconsole.log(true && false)\n// \u2192false\nconsole.log(true && true)\n// \u2192true\n16",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_71",
    "text": "is true only if both the values given to it are true.\nconsole.log(true && false)\n// \u2192false\nconsole.log(true && true)\n// \u2192true\n16\nThe || operator denotes logical or. It produces true if either of the values given\nto it is true.\nconsole.log(false || true)\n// \u2192true\nconsole.log(false || false)\n// \u2192false\nNot is written as an exclamation mark (!). It is a unary operator that flips the\nvalue given to it\u2014!true produces false and !false gives true.\nWhen mixing these Boolean operators with arithmetic and other operators,\nit is not always obvious when parentheses are needed. In practice, you can\nusually get by with knowing that of the operators we have seen so far, || has\nthe lowest precedence, then comes &&, then the comparison operators (>, ==,\nand so on), and then the rest. This order has been chosen such that, in typical\nexpressions like the following one, as few parentheses as possible are necessary:\n1 + 1 == 2 && 10 * 10 > 50",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_72",
    "text": "and so on), and then the rest. This order has been chosen such that, in typical\nexpressions like the following one, as few parentheses as possible are necessary:\n1 + 1 == 2 && 10 * 10 > 50\nThe last logical operator we will look at is not unary, not binary, but ternary,\noperating on three values. It is written with a question mark and a colon, like\nthis:\nconsole.log(true ? 1 : 2);\n// \u21921\nconsole.log(false ? 1 : 2);\n// \u21922\nThis one is called the conditional operator (or sometimes just the ternary oper-\nator since it is the only such operator in the language). The operator uses the\nvalue to the left of the question mark to decide which of the two other values\nto \u201cpick\u201d. If you write a ? b : c, the result will be b when a is true and c\notherwise.\nEmpty values\nThere are two special values, written null and undefined, that are used to\ndenote the absence of a meaningful value. They are themselves values, but\nthey carry no information.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_73",
    "text": "otherwise.\nEmpty values\nThere are two special values, written null and undefined, that are used to\ndenote the absence of a meaningful value. They are themselves values, but\nthey carry no information.\nMany operations in the language that don\u2019t produce a meaningful value yield\nundefined simply because they have to yield some value.\nThe difference in meaning between undefined and null is an accident of\nJavaScript\u2019s design, and it doesn\u2019t matter most of the time. In cases where\n17\nyou actually have to concern yourself with these values, I recommend treating\nthem as mostly interchangeable.\nAutomatic type conversion\nIn the introduction, I mentioned that JavaScript goes out of its way to accept\nalmost any program you give it, even programs that do odd things. This is\nnicely demonstrated by the following expressions:\nconsole.log(8 * null)\n// \u21920\nconsole.log(\"5\" - 1)\n// \u21924\nconsole.log(\"5\" + 1)\n// \u219251\nconsole.log(\"five\" * 2)\n// \u2192NaN\nconsole.log(false == 0)\n// \u2192true",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_74",
    "text": "nicely demonstrated by the following expressions:\nconsole.log(8 * null)\n// \u21920\nconsole.log(\"5\" - 1)\n// \u21924\nconsole.log(\"5\" + 1)\n// \u219251\nconsole.log(\"five\" * 2)\n// \u2192NaN\nconsole.log(false == 0)\n// \u2192true\nWhen an operator is applied to the \u201cwrong\u201d type of value, JavaScript will\nquietly convert that value to the type it needs, using a set of rules that often\naren\u2019t what you want or expect. This is called type coercion. The null in the\nfirst expression becomes 0 and the \"5\" in the second expression becomes 5 (from\nstring to number). Yet in the third expression, + tries string concatenation\nbefore numeric addition, so the 1 is converted to \"1\" (from number to string).\nWhen something that doesn\u2019t map to a number in an obvious way (such as\n\"five\" or undefined) is converted to a number, you get the value NaN. Further\narithmetic operations on NaN keep producing NaN, so if you find yourself getting\none of those in an unexpected place, look for accidental type conversions.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_75",
    "text": "arithmetic operations on NaN keep producing NaN, so if you find yourself getting\none of those in an unexpected place, look for accidental type conversions.\nWhen comparing values of the same type using the == operator, the outcome\nis easy to predict: you should get true when both values are the same, except\nin the case of NaN. But when the types differ, JavaScript uses a complicated\nand confusing set of rules to determine what to do. In most cases, it just tries\nto convert one of the values to the other value\u2019s type. However, when null or\nundefined occurs on either side of the operator, it produces true only if both\nsides are one of null or undefined.\nconsole.log(null == undefined);\n// \u2192true\nconsole.log(null == 0);\n// \u2192false\n18\nThat behavior is often useful. When you want to test whether a value has a\nreal value instead of null or undefined, you can compare it to null with the\n== or != operator.\nWhat if you want to test whether something refers to the precise value false?",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_76",
    "text": "real value instead of null or undefined, you can compare it to null with the\n== or != operator.\nWhat if you want to test whether something refers to the precise value false?\nExpressions like 0 == false and \"\" == false are also true because of automatic\ntype conversion. When you do not want any type conversions to happen, there\nare two additional operators: === and !==. The first tests whether a value is\nprecisely equal to the other, and the second tests whether it is not precisely\nequal. Thus \"\" === false is false, as expected.\nI recommend using the three-character comparison operators defensively to\nprevent unexpected type conversions from tripping you up. But when you\u2019re\ncertain the types on both sides will be the same, there is no problem with using\nthe shorter operators.\nShort-circuiting of logical operators\nThe logical operators && and || handle values of different types in a peculiar\nway. They will convert the value on their left side to Boolean type in order",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_77",
    "text": "Short-circuiting of logical operators\nThe logical operators && and || handle values of different types in a peculiar\nway. They will convert the value on their left side to Boolean type in order\nto decide what to do, but depending on the operator and the result of that\nconversion, they will return either the original left-hand value or the right-\nhand value.\nThe || operator, for example, will return the value to its left when that\nvalue can be converted to true and will return the value on its right otherwise.\nThis has the expected effect when the values are Boolean and does something\nanalogous for values of other types.\nconsole.log(null || \"user\")\n// \u2192user\nconsole.log(\"Agnes\" || \"user\")\n// \u2192Agnes\nWe can use this functionality as a way to fall back on a default value. If you\nhave a value that might be empty, you can put || after it with a replacement\nvalue. If the initial value can be converted to false, you\u2019ll get the replacement",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_78",
    "text": "have a value that might be empty, you can put || after it with a replacement\nvalue. If the initial value can be converted to false, you\u2019ll get the replacement\ninstead. The rules for converting strings and numbers to Boolean values state\nthat 0, NaN, and the empty string (\"\") count as false, while all the other values\ncount as true. That means 0 || -1 produces -1, and \"\" || \"!?\" yields \"!?\".\nThe ?? operator resembles || but returns the value on the right only if the\none on the left is null or undefined, not if it is some other value that can be\nconverted to false. Often, this is preferable to the behavior of ||.\nconsole.log(0 || 100);\n19\n// \u2192100\nconsole.log(0 ?? 100);\n// \u21920\nconsole.log(null ?? 100);\n// \u2192100\nThe && operator works similarly but the other way around. When the value to\nits left is something that converts to false, it returns that value, and otherwise\nit returns the value on its right.\nAnother important property of these two operators is that the part to their",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_79",
    "text": "its left is something that converts to false, it returns that value, and otherwise\nit returns the value on its right.\nAnother important property of these two operators is that the part to their\nright is evaluated only when necessary. In the case of true || X, no matter\nwhat X is\u2014even if it\u2019s a piece of program that does something terrible\u2014the\nresult will be true, and X is never evaluated. The same goes for false && X,\nwhich is false and will ignore X. This is called short-circuit evaluation.\nThe conditional operator works in a similar way. Of the second and third\nvalues, only the one that is selected is evaluated.\nSummary\nWe looked at four types of JavaScript values in this chapter: numbers, strings,\nBooleans, and undefined values. Such values are created by typing in their\nname (true, null) or value (13, \"abc\").\nYou can combine and transform values with operators. We saw binary op-\nerators for arithmetic (+, -, *, /, and %), string concatenation (+), comparison",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_80",
    "text": "name (true, null) or value (13, \"abc\").\nYou can combine and transform values with operators. We saw binary op-\nerators for arithmetic (+, -, *, /, and %), string concatenation (+), comparison\n(==, !=, ===, !==, <, >, <=, >=), and logic (&&, ||, ??), as well as several unary\noperators (- to negate a number, ! to negate logically, and typeof to find a\nvalue\u2019s type) and a ternary operator (?:) to pick one of two values based on a\nthird value.\nThis gives you enough information to use JavaScript as a pocket calculator\nbut not much more. The next chapter will start tying these expressions together\ninto basic programs.\n20\n\u201cAnd my heart glows bright red under my filmy, translucent skin and\nthey have to administer 10cc of JavaScript to get me to come back.\n(I respond well to toxins in the blood.) Man, that stuff will kick the\npeaches right out your gills!\u201d\n\u2014_why, Why\u2019s (Poignant) Guide to Ruby\nChapter 2\nProgram Structure",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_81",
    "text": "(I respond well to toxins in the blood.) Man, that stuff will kick the\npeaches right out your gills!\u201d\n\u2014_why, Why\u2019s (Poignant) Guide to Ruby\nChapter 2\nProgram Structure\nIn this chapter, we will start to do things that can actually be called program-\nming. We will expand our command of the JavaScript language beyond the\nnouns and sentence fragments we\u2019ve seen so far to the point where we can\nexpress meaningful prose.\nExpressions and statements\nIn Chapter 1, we made values and applied operators to them to get new values.\nCreating values like this is the main substance of any JavaScript program. But\nthat substance has to be framed in a larger structure to be useful. That\u2019s what\nwe\u2019ll cover in this chapter.\nA fragment of code that produces a value is called an expression. Every value\nthat is written literally (such as 22 or \"psychoanalysis\") is an expression. An\nexpression between parentheses is also an expression, as is a binary operator",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_82",
    "text": "that is written literally (such as 22 or \"psychoanalysis\") is an expression. An\nexpression between parentheses is also an expression, as is a binary operator\napplied to two expressions or a unary operator applied to one.\nThis shows part of the beauty of a language-based interface. Expressions\ncan contain other expressions in a way similar to how subsentences in human\nlanguages are nested\u2014a subsentence can contain its own subsentences, and\nso on. This allows us to build expressions that describe arbitrarily complex\ncomputations.\nIf an expression corresponds to a sentence fragment, a JavaScript statement\ncorresponds to a full sentence. A program is a list of statements.\nThe simplest kind of statement is an expression with a semicolon after it.\nThis is a program:\n1;\n!false;\nIt is a useless program, though. An expression can be content to just produce\na value, which can then be used by the enclosing code. However, a statement",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_83",
    "text": "This is a program:\n1;\n!false;\nIt is a useless program, though. An expression can be content to just produce\na value, which can then be used by the enclosing code. However, a statement\nstands on its own, so if it doesn\u2019t affect the world, it\u2019s useless. It may display\n21\nsomething on the screen, as with console.log, or change the state of the ma-\nchine in a way that will affect the statements that come after it. These changes\nare called side effects. The statements in the previous example just produce\nthe values 1 and true and then immediately throw them away. This leaves no\nimpression on the world at all. When you run this program, nothing observable\nhappens.\nIn some cases, JavaScript allows you to omit the semicolon at the end of a\nstatement. In other cases, it has to be there, or the next line will be treated\nas part of the same statement. The rules for when it can be safely omitted\nare somewhat complex and error prone. So in this book, every statement that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_84",
    "text": "as part of the same statement. The rules for when it can be safely omitted\nare somewhat complex and error prone. So in this book, every statement that\nneeds a semicolon will always get one. I recommend you do the same, at least\nuntil you\u2019ve learned more about the subtleties of missing semicolons.\nBindings\nHow does a program keep an internal state? How does it remember things?\nWe have seen how to produce new values from old values, but this does not\nchange the old values, and the new value must be used immediately or it will\ndissipate again. To catch and hold values, JavaScript provides a thing called a\nbinding, or variable.\nlet caught = 5 * 5;\nThat gives us a second kind of statement. The special word (keyword) let\nindicates that this sentence is going to define a binding. It is followed by the\nname of the binding and, if we want to immediately give it a value, by an =\noperator and an expression.\nThe example creates a binding called caught and uses it to grab hold of the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_85",
    "text": "name of the binding and, if we want to immediately give it a value, by an =\noperator and an expression.\nThe example creates a binding called caught and uses it to grab hold of the\nnumber that is produced by multiplying 5 by 5.\nAfter a binding has been defined, its name can be used as an expression. The\nvalue of such an expression is the value the binding currently holds. Here\u2019s an\nexample:\nlet ten = 10;\nconsole.log(ten * ten);\n// \u2192100\nWhen a binding points at a value, that does not mean it is tied to that value\nforever. The = operator can be used at any time on existing bindings to dis-\nconnect them from their current value and have them point to a new one:\nlet mood = \"light\";\n22\nconsole.log(mood);\n// \u2192light\nmood = \"dark\";\nconsole.log(mood);\n// \u2192dark\nYou should imagine bindings as tentacles rather than boxes.\nThey do not\ncontain values; they grasp them\u2014two bindings can refer to the same value. A\nprogram can access only the values to which it still has a reference. When you",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_86",
    "text": "They do not\ncontain values; they grasp them\u2014two bindings can refer to the same value. A\nprogram can access only the values to which it still has a reference. When you\nneed to remember something, you either grow a tentacle to hold on to it or\nreattach one of your existing tentacles to it.\nLet\u2019s look at another example. To remember the number of dollars that\nLuigi still owes you, you create a binding. When he pays back $35, you give\nthis binding a new value.\nlet luigisDebt = 140;\nluigisDebt = luigisDebt - 35;\nconsole.log(luigisDebt);\n// \u2192105\nWhen you define a binding without giving it a value, the tentacle has nothing\nto grasp, so it ends in thin air. If you ask for the value of an empty binding,\nyou\u2019ll get the value undefined.\nA single let statement may define multiple bindings. The definitions must\nbe separated by commas:\nlet one = 1, two = 2;\nconsole.log(one + two);\n// \u21923\nThe words var and const can also be used to create bindings, in a similar\nfashion to let.\nvar name = \"Ayda\";",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_87",
    "text": "be separated by commas:\nlet one = 1, two = 2;\nconsole.log(one + two);\n// \u21923\nThe words var and const can also be used to create bindings, in a similar\nfashion to let.\nvar name = \"Ayda\";\nconst greeting = \"Hello \";\nconsole.log(greeting + name);\n// \u2192Hello Ayda\nThe first of these, var (short for \u201cvariable\u201d), is the way bindings were declared\nin pre-2015 JavaScript, when let didn\u2019t exist yet. I\u2019ll get back to the precise\nway it differs from let in the next chapter. For now, remember that it mostly\ndoes the same thing, but we\u2019ll rarely use it in this book because it behaves\noddly in some situations.\nThe word const stands for constant. It defines a constant binding, which\n23\npoints at the same value for as long as it lives. This is useful for bindings that\njust give a name to a value so that you can easily refer to it later.\nBinding names\nBinding names can be any sequence of one or more letters. Digits can be part of\nbinding names\u2014catch22 is a valid name, for example\u2014but the name must not",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_88",
    "text": "Binding names\nBinding names can be any sequence of one or more letters. Digits can be part of\nbinding names\u2014catch22 is a valid name, for example\u2014but the name must not\nstart with a digit. A binding name may include dollar signs ($) or underscores\n(_) but no other punctuation or special characters.\nWords with a special meaning, such as let, are keywords, and may not be\nused as binding names. There are also a number of words that are \u201creserved\nfor use\u201d in future versions of JavaScript, which also can\u2019t be used as binding\nnames. The full list of keywords and reserved words is rather long:\nbreak case catch class const continue debugger default\ndelete do else enum export extends false finally for\nfunction if implements import interface in instanceof let\nnew package private protected public return static super\nswitch this throw true try typeof var void while with yield\nDon\u2019t worry about memorizing this list. When creating a binding produces",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_89",
    "text": "new package private protected public return static super\nswitch this throw true try typeof var void while with yield\nDon\u2019t worry about memorizing this list. When creating a binding produces\nan unexpected syntax error, check whether you\u2019re trying to define a reserved\nword.\nThe environment\nThe collection of bindings and their values that exist at a given time is called\nthe environment. When a program starts up, this environment is not empty. It\nalways contains bindings that are part of the language standard, and most of the\ntime, it also has bindings that provide ways to interact with the surrounding\nsystem. For example, in a browser, there are functions to interact with the\ncurrently loaded website and to read mouse and keyboard input.\nFunctions\nA lot of the values provided in the default environment have the type function.\nA function is a piece of program wrapped in a value. Such values can be applied\nin order to run the wrapped program. For example, in a browser environment,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_90",
    "text": "A function is a piece of program wrapped in a value. Such values can be applied\nin order to run the wrapped program. For example, in a browser environment,\nthe binding prompt holds a function that shows a little dialog asking for user\ninput. It is used like this:\n24\nprompt(\"Enter passcode\");\nExecuting a function is called invoking, calling, or applying it.\nYou can\ncall a function by putting parentheses after an expression that produces a\nfunction value. Usually you\u2019ll directly use the name of the binding that holds\nthe function. The values between the parentheses are given to the program\ninside the function. In the example, the prompt function uses the string that\nwe give it as the text to show in the dialog box. Values given to functions are\ncalled arguments. Different functions might need a different number or different\ntypes of arguments.\nThe prompt function isn\u2019t used much in modern web programming, mostly",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_91",
    "text": "called arguments. Different functions might need a different number or different\ntypes of arguments.\nThe prompt function isn\u2019t used much in modern web programming, mostly\nbecause you have no control over the way the resulting dialog looks, but it can\nbe helpful in toy programs and experiments.\nThe console.log function\nIn the examples, I used console.log to output values. Most JavaScript sys-\ntems (including all modern web browsers and Node.js) provide a console.log\nfunction that writes out its arguments to some text output device. In browsers,\nthe output lands in the JavaScript console. This part of the browser interface\nis hidden by default, but most browsers open it when you press F12 or, on a\nMac, command-option-I. If that does not work, search through the menus\nfor an item named Developer Tools or similar.\nThough binding names cannot contain period characters, console.log does\nhave one. This is because console.log isn\u2019t a simple binding, but an expression",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_92",
    "text": "for an item named Developer Tools or similar.\nThough binding names cannot contain period characters, console.log does\nhave one. This is because console.log isn\u2019t a simple binding, but an expression\nthat retrieves the log property from the value held by the console binding.\nWe\u2019ll find out exactly what this means in Chapter 4.\nReturn values\nShowing a dialog box or writing text to the screen is a side effect.\nMany\nfunctions are useful because of the side effects they produce. Functions may\n25\nalso produce values, in which case they don\u2019t need to have a side effect to\nbe useful. For example, the function Math.max takes any amount of number\narguments and gives back the greatest.\nconsole.log(Math.max(2, 4));\n// \u21924\nWhen a function produces a value, it is said to return that value. Anything that\nproduces a value is an expression in JavaScript, which means that function calls\ncan be used within larger expressions. In the following code, a call to Math.min,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_93",
    "text": "produces a value is an expression in JavaScript, which means that function calls\ncan be used within larger expressions. In the following code, a call to Math.min,\nwhich is the opposite of Math.max, is used as part of a plus expression:\nconsole.log(Math.min(2, 4) + 100);\n// \u2192102\nChapter 3 will explain how to write your own functions.\nControl flow\nWhen your program contains more than one statement, the statements are\nexecuted as though they were a story, from top to bottom. For example, the\nfollowing program has two statements. The first asks the user for a number,\nand the second, which is executed after the first, shows the square of that\nnumber:\nlet theNumber = Number(prompt(\"Pick a number\"));\nconsole.log(\"Your number is the square root of \" +\ntheNumber * theNumber);\nThe function Number converts a value to a number. We need that conversion\nbecause the result of prompt is a string value, and we want a number. There",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_94",
    "text": "theNumber * theNumber);\nThe function Number converts a value to a number. We need that conversion\nbecause the result of prompt is a string value, and we want a number. There\nare similar functions called String and Boolean that convert values to those\ntypes.\nHere is the rather trivial schematic representation of straight-line control\nflow:\nConditional execution\nNot all programs are straight roads.\nWe may, for example, want to create\na branching road where the program takes the proper branch based on the\nsituation at hand. This is called conditional execution.\n26\nConditional execution is created with the if keyword in JavaScript. In the\nsimple case, we want some code to be executed if, and only if, a certain condition\nholds. We might, for example, want to show the square of the input only if the\ninput is actually a number:\nlet theNumber = Number(prompt(\"Pick a number\"));\nif (!Number.isNaN(theNumber)) {\nconsole.log(\"Your number is the square root of \" +\ntheNumber * theNumber);\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_95",
    "text": "input is actually a number:\nlet theNumber = Number(prompt(\"Pick a number\"));\nif (!Number.isNaN(theNumber)) {\nconsole.log(\"Your number is the square root of \" +\ntheNumber * theNumber);\n}\nWith this modification, if you enter \u201cparrot\u201d, no output is shown.\nThe if keyword executes or skips a statement depending on the value of\na Boolean expression. The deciding expression is written after the keyword,\nbetween parentheses, followed by the statement to execute.\nThe Number.isNaN function is a standard JavaScript function that returns\ntrue only if the argument it is given is NaN. The Number function happens to\nreturn NaN when you give it a string that doesn\u2019t represent a valid number.\nThus, the condition translates to \u201cunless theNumber is not-a-number, do this\u201d.\nThe statement after the if is wrapped in braces ({ and }) in this example.\nThe braces can be used to group any number of statements into a single state-\nment, called a block. You could also have omitted them in this case, since they",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_96",
    "text": "The braces can be used to group any number of statements into a single state-\nment, called a block. You could also have omitted them in this case, since they\nhold only a single statement, but to avoid having to think about whether they\nare needed, most JavaScript programmers use them in every wrapped state-\nment like this. We\u2019ll mostly follow that convention in this book, except for the\noccasional one-liner.\nif (1 + 1 == 2) console.log(\"It's true\");\n// \u2192It's true\nYou often won\u2019t just have code that executes when a condition holds true, but\nalso code that handles the other case. This alternate path is represented by\nthe second arrow in the diagram. You can use the else keyword, together with\nif, to create two separate, alternative execution paths:\nlet theNumber = Number(prompt(\"Pick a number\"));\nif (!Number.isNaN(theNumber)) {\nconsole.log(\"Your number is the square root of \" +\ntheNumber * theNumber);\n27\n} else {\nconsole.log(\"Hey. Why didn't you give me a number?\");\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_97",
    "text": "if (!Number.isNaN(theNumber)) {\nconsole.log(\"Your number is the square root of \" +\ntheNumber * theNumber);\n27\n} else {\nconsole.log(\"Hey. Why didn't you give me a number?\");\n}\nIf you have more than two paths to choose from, you can \u201cchain\u201d multiple\nif/else pairs together. Here\u2019s an example:\nlet num = Number(prompt(\"Pick a number\"));\nif (num < 10) {\nconsole.log(\"Small\");\n} else if (num < 100) {\nconsole.log(\"Medium\");\n} else {\nconsole.log(\"Large\");\n}\nThe program will first check whether num is less than 10. If it is, it chooses that\nbranch, shows \"Small\", and is done. If it isn\u2019t, it takes the else branch, which\nitself contains a second if. If the second condition (< 100) holds, that means\nthe number is at least 10 but below 100, and \"Medium\" is shown. If it doesn\u2019t,\nthe second and last else branch is chosen.\nThe schema for this program looks something like this:\nwhile and do loops\nConsider a program that outputs all even numbers from 0 to 12. One way to\nwrite this is as follows:",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_98",
    "text": "The schema for this program looks something like this:\nwhile and do loops\nConsider a program that outputs all even numbers from 0 to 12. One way to\nwrite this is as follows:\nconsole.log(0);\nconsole.log(2);\nconsole.log(4);\nconsole.log(6);\nconsole.log(8);\nconsole.log(10);\nconsole.log(12);\nThat works, but the idea of writing a program is to make something less work,\nnot more. If we needed all even numbers less than 1,000, this approach would\n28\nbe unworkable. What we need is a way to run a piece of code multiple times.\nThis form of control flow is called a loop.\nLooping control flow allows us to go back to some point in the program where\nwe were before and repeat it with our current program state. If we combine\nthis with a binding that counts, we can do something like this:\nlet number = 0;\nwhile (number <= 12) {\nconsole.log(number);\nnumber = number + 2;\n}\n// \u21920\n// \u21922\n// \u2026\netcetera\nA statement starting with the keyword while creates a loop. The word while",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_99",
    "text": "let number = 0;\nwhile (number <= 12) {\nconsole.log(number);\nnumber = number + 2;\n}\n// \u21920\n// \u21922\n// \u2026\netcetera\nA statement starting with the keyword while creates a loop. The word while\nis followed by an expression in parentheses and then a statement, much like if.\nThe loop keeps entering that statement as long as the expression produces a\nvalue that gives true when converted to Boolean.\nThe number binding demonstrates the way a binding can track the progress\nof a program. Every time the loop repeats, number gets a value that is 2 more\nthan its previous value. At the beginning of every repetition, it is compared\nwith the number 12 to decide whether the program\u2019s work is finished.\nAs an example that actually does something useful, we can now write a\nprogram that calculates and shows the value of 210 (2 to the 10th power). We\nuse two bindings: one to keep track of our result and one to count how often\nwe have multiplied this result by 2. The loop tests whether the second binding",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_100",
    "text": "use two bindings: one to keep track of our result and one to count how often\nwe have multiplied this result by 2. The loop tests whether the second binding\nhas reached 10 yet and, if not, updates both bindings.\nlet result = 1;\nlet counter = 0;\nwhile (counter < 10) {\nresult = result * 2;\ncounter = counter + 1;\n}\nconsole.log(result);\n// \u21921024\nThe counter could also have started at 1 and checked for <= 10, but for reasons\n29\nthat will become apparent in Chapter 4, it is a good idea to get used to counting\nfrom 0.\nNote that JavaScript also has an operator for exponentiation (2 ** 10),\nwhich you would use to compute this in real code\u2014but that would have ruined\nthe example.\nA do loop is a control structure similar to a while loop. It differs only on one\npoint: a do loop always executes its body at least once, and it starts testing\nwhether it should stop only after that first execution. To reflect this, the test\nappears after the body of the loop:\nlet yourName;\ndo {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_101",
    "text": "whether it should stop only after that first execution. To reflect this, the test\nappears after the body of the loop:\nlet yourName;\ndo {\nyourName = prompt(\"Who are you?\");\n} while (!yourName);\nconsole.log(\"Hello \" + yourName);\nThis program will force you to enter a name. It will ask again and again until\nit gets something that is not an empty string. Applying the ! operator will\nconvert a value to Boolean type before negating it, and all strings except \"\"\nconvert to true. This means the loop continues going round until you provide\na non-empty name.\nIndenting Code\nIn the examples, I\u2019ve been adding spaces in front of statements that are part\nof some larger statement. These spaces are not required\u2014the computer will\naccept the program just fine without them. In fact, even the line breaks in\nprograms are optional. You could write a program as a single long line if you\nfelt like it.\nThe role of this indentation inside blocks is to make the structure of the code",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_102",
    "text": "programs are optional. You could write a program as a single long line if you\nfelt like it.\nThe role of this indentation inside blocks is to make the structure of the code\nstand out to human readers. In code where new blocks are opened inside other\nblocks, it can become hard to see where one block ends and another begins.\nWith proper indentation, the visual shape of a program corresponds to the\nshape of the blocks inside it. I like to use two spaces for every open block, but\ntastes differ\u2014some people use four spaces, and some people use tab characters.\nThe important thing is that each new block adds the same amount of space.\nif (false != true) {\nconsole.log(\"That makes sense.\");\nif (1 < 2) {\nconsole.log(\"No surprise there.\");\n}\n30\n}\nMost code editor programs will help by automatically indenting new lines the\nproper amount.\nfor loops\nMany loops follow the pattern shown in the while examples. First a \u201ccounter\u201d\nbinding is created to track the progress of the loop. Then comes a while loop,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_103",
    "text": "proper amount.\nfor loops\nMany loops follow the pattern shown in the while examples. First a \u201ccounter\u201d\nbinding is created to track the progress of the loop. Then comes a while loop,\nusually with a test expression that checks whether the counter has reached\nits end value. At the end of the loop body, the counter is updated to track\nprogress.\nBecause this pattern is so common, JavaScript and similar languages provide\na slightly shorter and more comprehensive form, the for loop:\nfor (let number = 0; number <= 12; number = number + 2) {\nconsole.log(number);\n}\n// \u21920\n// \u21922\n// \u2026\netcetera\nThis program is exactly equivalent to the earlier even-number-printing example.\nThe only change is that all the statements that are related to the \u201cstate\u201d of\nthe loop are grouped together after for.\nThe parentheses after a for keyword must contain two semicolons. The part\nbefore the first semicolon initializes the loop, usually by defining a binding.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_104",
    "text": "the loop are grouped together after for.\nThe parentheses after a for keyword must contain two semicolons. The part\nbefore the first semicolon initializes the loop, usually by defining a binding.\nThe second part is the expression that checks whether the loop must continue.\nThe final part updates the state of the loop after every iteration. In most cases,\nthis is shorter and clearer than a while construct.\nThis is the code that computes 210 using for instead of while:\nlet result = 1;\nfor (let counter = 0; counter < 10; counter = counter + 1) {\nresult = result * 2;\n}\nconsole.log(result);\n// \u21921024\n31\nBreaking Out of a Loop\nHaving the looping condition produce false is not the only way a loop can\nfinish. The break statement has the effect of immediately jumping out of the\nenclosing loop. Its use is demonstrated in the following program, which finds\nthe first number that is both greater than or equal to 20 and divisible by 7:\nfor (let current = 20; ; current = current + 1) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_105",
    "text": "the first number that is both greater than or equal to 20 and divisible by 7:\nfor (let current = 20; ; current = current + 1) {\nif (current % 7 == 0) {\nconsole.log(current);\nbreak;\n}\n}\n// \u219221\nUsing the remainder (%) operator is an easy way to test whether a number is\ndivisible by another number. If it is, the remainder of their division is zero.\nThe for construct in the example does not have a part that checks for the\nend of the loop. This means that the loop will never stop unless the break\nstatement inside is executed.\nIf you were to remove that break statement or you accidentally write an\nend condition that always produces true, your program would get stuck in an\ninfinite loop. A program stuck in an infinite loop will never finish running,\nwhich is usually a bad thing.\nThe continue keyword is similar to break in that it influences the progress\nof a loop. When continue is encountered in a loop body, control jumps out of\nthe body and continues with the loop\u2019s next iteration.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_106",
    "text": "of a loop. When continue is encountered in a loop body, control jumps out of\nthe body and continues with the loop\u2019s next iteration.\nUpdating bindings succinctly\nEspecially when looping, a program often needs to \u201cupdate\u201d a binding to hold\na value based on that binding\u2019s previous value.\ncounter = counter + 1;\nJavaScript provides a shortcut for this:\ncounter += 1;\nSimilar shortcuts work for many other operators, such as result *= 2 to double\nresult or counter -= 1 to count downward.\nThis allows us to further shorten our counting example:\nfor (let number = 0; number <= 12; number += 2) {\n32\nconsole.log(number);\n}\nFor counter += 1 and counter -= 1, there are even shorter equivalents: counter\n++ and counter--.\nDispatching on a value with switch\nIt is not uncommon for code to look like this:\nif (x == \"value1\") action1();\nelse if (x == \"value2\") action2();\nelse if (x == \"value3\") action3();\nelse defaultAction();\nThere is a construct called switch that is intended to express such a \u201cdis-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_107",
    "text": "if (x == \"value1\") action1();\nelse if (x == \"value2\") action2();\nelse if (x == \"value3\") action3();\nelse defaultAction();\nThere is a construct called switch that is intended to express such a \u201cdis-\npatch\u201d in a more direct way. Unfortunately, the syntax JavaScript uses for\nthis (which it inherited from the C/Java line of programming languages) is\nsomewhat awkward\u2014a chain of if statements may look better. Here is an\nexample:\nswitch (prompt(\"What is the weather like?\")) {\ncase \"rainy\":\nconsole.log(\"Remember to bring an umbrella.\");\nbreak;\ncase \"sunny\":\nconsole.log(\"Dress lightly.\");\ncase \"cloudy\":\nconsole.log(\"Go outside.\");\nbreak;\ndefault:\nconsole.log(\"Unknown weather type!\");\nbreak;\n}\nYou may put any number of case labels inside the block opened by switch.\nThe program will start executing at the label that corresponds to the value\nthat switch was given, or at default if no matching value is found. It will\ncontinue executing, even across other labels, until it reaches a break statement.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_108",
    "text": "that switch was given, or at default if no matching value is found. It will\ncontinue executing, even across other labels, until it reaches a break statement.\nIn some cases, such as the \"sunny\" case in the example, this can be used to\nshare some code between cases (it recommends going outside for both sunny\nand cloudy weather). Be careful, though\u2014it is easy to forget such a break,\nwhich will cause the program to execute code you do not want executed.\n33\nCapitalization\nBinding names may not contain spaces, yet it is often helpful to use multiple\nwords to clearly describe what the binding represents. These are pretty much\nyour choices for writing a binding name with several words in it:\nfuzzylittleturtle\nfuzzy_little_turtle\nFuzzyLittleTurtle\nfuzzyLittleTurtle\nThe first style can be hard to read. I rather like the look of the underscores,\nthough that style is a little painful to type. The standard JavaScript functions,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_109",
    "text": "FuzzyLittleTurtle\nfuzzyLittleTurtle\nThe first style can be hard to read. I rather like the look of the underscores,\nthough that style is a little painful to type. The standard JavaScript functions,\nand most JavaScript programmers, follow the final style\u2014they capitalize every\nword except the first.\nIt is not hard to get used to little things like that,\nand code with mixed naming styles can be jarring to read, so we follow this\nconvention.\nIn a few cases, such as the Number function, the first letter of a binding is\nalso capitalized. This was done to mark this function as a constructor. It will\nbecome clear what a constructor is in Chapter 6. For now, the important thing\nis to not be bothered by this apparent lack of consistency.\nComments\nOften, raw code does not convey all the information you want a program to\nconvey to human readers, or it conveys it in such a cryptic way that people\nmight not understand it. At other times, you might just want to include some",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_110",
    "text": "convey to human readers, or it conveys it in such a cryptic way that people\nmight not understand it. At other times, you might just want to include some\nrelated thoughts as part of your program. This is what comments are for.\nA comment is a piece of text that is part of a program but is completely\nignored by the computer. JavaScript has two ways of writing comments. To\nwrite a single-line comment, you can use two slash characters (//) and then\nthe comment text after it:\nlet accountBalance = calculateBalance(account);\n// It's a green hollow where a river sings\naccountBalance.adjust();\n// Madly catching white tatters in the grass.\nlet report = new Report();\n// Where the sun on the proud mountain rings:\naddToReport(accountBalance, report);\n// It's a little valley, foaming like light in a glass.\n34\nA // comment goes only to the end of the line. A section of text between\n/* and */ will be ignored in its entirety, regardless of whether it contains line",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_111",
    "text": "34\nA // comment goes only to the end of the line. A section of text between\n/* and */ will be ignored in its entirety, regardless of whether it contains line\nbreaks. This is useful for adding blocks of information about a file or a chunk\nof program:\n/*\nI first found this number scrawled on the back of an old\nnotebook. Since then, it has often dropped by, showing up in\nphone numbers and the serial numbers of products that I've\nbought. It obviously likes me, so I've decided to keep it.\n*/\nconst myNumber = 11213;\nSummary\nYou now know that a program is built out of statements, which themselves\nsometimes contain more statements. Statements tend to contain expressions,\nwhich themselves can be built out of smaller expressions.\nPutting statements after one another gives you a program that is executed\nfrom top to bottom. You can introduce disturbances in the flow of control\nby using conditional (if, else, and switch) and looping (while, do, and for)\nstatements.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_112",
    "text": "from top to bottom. You can introduce disturbances in the flow of control\nby using conditional (if, else, and switch) and looping (while, do, and for)\nstatements.\nBindings can be used to file pieces of data under a name, and they are useful\nfor tracking state in your program. The environment is the set of bindings\nthat are defined. JavaScript systems always put a number of useful standard\nbindings into your environment.\nFunctions are special values that encapsulate a piece of program. You can\ninvoke them by writing functionName(argument1, argument2). Such a function\ncall is an expression and may produce a value.\nExercises\nIf you are unsure how to test your solutions to the exercises, refer to the intro-\nduction.\nEach exercise starts with a problem description. Read this description and\ntry to solve the exercise. If you run into problems, consider reading the hints\nat the end of the book. You can find full solutions to the exercises online at",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_113",
    "text": "try to solve the exercise. If you run into problems, consider reading the hints\nat the end of the book. You can find full solutions to the exercises online at\nhttps://eloquentjavascript.net/code. If you want to learn something from the\nexercises, I recommend looking at the solutions only after you\u2019ve solved the\n35\nexercise, or at least after you\u2019ve attacked it long and hard enough to have a\nslight headache.\nLooping a triangle\nWrite a loop that makes seven calls to console.log to output the following\ntriangle:\n#\n##\n###\n####\n#####\n######\n#######\nIt may be useful to know that you can find the length of a string by writing\n.length after it.\nlet abc = \"abc\";\nconsole.log(abc.length);\n// \u21923\nFizzBuzz\nWrite a program that uses console.log to print all the numbers from 1 to 100,\nwith two exceptions. For numbers divisible by 3, print \"Fizz\" instead of the\nnumber, and for numbers divisible by 5 (and not 3), print \"Buzz\" instead.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_114",
    "text": "with two exceptions. For numbers divisible by 3, print \"Fizz\" instead of the\nnumber, and for numbers divisible by 5 (and not 3), print \"Buzz\" instead.\nWhen you have that working, modify your program to print \"FizzBuzz\" for\nnumbers that are divisible by both 3 and 5 (and still print \"Fizz\" or \"Buzz\"\nfor numbers divisible by only one of those).\n(This is actually an interview question that has been claimed to weed out\na significant percentage of programmer candidates. So if you solved it, your\nlabor market value just went up.)\nChessboard\nWrite a program that creates a string that represents an 8\u00d78 grid, using newline\ncharacters to separate lines. At each position of the grid there is either a space\nor a \"#\" character. The characters should form a chessboard.\nPassing this string to console.log should show something like this:\n# # # #\n36\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\nWhen you have a program that generates this pattern, define a binding size",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_115",
    "text": "# # # #\n36\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\n# # # #\nWhen you have a program that generates this pattern, define a binding size\n= 8 and change the program so that it works for any size, outputting a grid\nof the given width and height.\n37\n\u201cPeople think that computer science is the art of geniuses but the\nactual reality is the opposite, just many people doing things that\nbuild on each other, like a wall of mini stones.\u201d\n\u2014Donald Knuth\nChapter 3\nFunctions\nFunctions are one of the most central tools in JavaScript programming. The\nconcept of wrapping a piece of program in a value has many uses. It gives us\na way to structure larger programs, to reduce repetition, to associate names\nwith subprograms, and to isolate these subprograms from each other.\nThe most obvious application of functions is defining new vocabulary. Cre-\nating new words in prose is usually bad style, but in programming, it is indis-\npensable.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_116",
    "text": "The most obvious application of functions is defining new vocabulary. Cre-\nating new words in prose is usually bad style, but in programming, it is indis-\npensable.\nTypical adult English speakers have some 20,000 words in their vocabulary.\nFew programming languages come with 20,000 commands built in. And the\nvocabulary that is available tends to be more precisely defined, and thus less\nflexible, than in human language. Therefore, we have to introduce new words\nto avoid excessive verbosity.\nDefining a function\nA function definition is a regular binding where the value of the binding is\na function. For example, this code defines square to refer to a function that\nproduces the square of a given number:\nconst square = function(x) {\nreturn x * x;\n};\nconsole.log(square(12));\n// \u2192144\nA function is created with an expression that starts with the keyword function\n. Functions have a set of parameters (in this case, only x) and a body, which",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_117",
    "text": "};\nconsole.log(square(12));\n// \u2192144\nA function is created with an expression that starts with the keyword function\n. Functions have a set of parameters (in this case, only x) and a body, which\ncontains the statements that are to be executed when the function is called.\nThe body of a function created this way must always be wrapped in braces,\neven when it consists of only a single statement.\n38\nA function can have multiple parameters or no parameters at all. In the fol-\nlowing example, makeNoise does not list any parameter names, whereas roundTo\n(which rounds n to the nearest multiple of step) lists two:\nconst makeNoise = function() {\nconsole.log(\"Pling!\");\n};\nmakeNoise();\n// \u2192Pling!\nconst roundTo = function(n, step) {\nlet remainder = n % step;\nreturn n - remainder + (remainder < step / 2 ? 0 : step);\n};\nconsole.log(roundTo(23, 10));\n// \u219220\nSome functions, such as roundTo and square, produce a value, and some don\u2019t,\nsuch as makeNoise, whose only result is a side effect.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_118",
    "text": "};\nconsole.log(roundTo(23, 10));\n// \u219220\nSome functions, such as roundTo and square, produce a value, and some don\u2019t,\nsuch as makeNoise, whose only result is a side effect.\nA return statement\ndetermines the value the function returns. When control comes across such\na statement, it immediately jumps out of the current function and gives the\nreturned value to the code that called the function. A return keyword without\nan expression after it will cause the function to return undefined. Functions\nthat don\u2019t have a return statement at all, such as makeNoise, similarly return\nundefined.\nParameters to a function behave like regular bindings, but their initial values\nare given by the caller of the function, not the code in the function itself.\nBindings and scopes\nEach binding has a scope, which is the part of the program in which the binding\nis visible. For bindings defined outside of any function, block, or module (see\nChapter 10), the scope is the whole program\u2014you can refer to such bindings",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_119",
    "text": "is visible. For bindings defined outside of any function, block, or module (see\nChapter 10), the scope is the whole program\u2014you can refer to such bindings\nwherever you want. These are called global.\nBindings created for function parameters or declared inside a function can\nbe referenced only in that function, so they are known as local bindings. Ev-\nery time the function is called, new instances of these bindings are created.\nThis provides some isolation between functions\u2014each function call acts in its\nown little world (its local environment) and can often be understood without\nknowing a lot about what\u2019s going on in the global environment.\n39\nBindings declared with let and const are in fact local to the block in which\nthey are declared, so if you create one of those inside of a loop, the code before\nand after the loop cannot \u201csee\u201d it.\nIn pre-2015 JavaScript, only functions\ncreated new scopes, so old-style bindings, created with the var keyword, are",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_120",
    "text": "and after the loop cannot \u201csee\u201d it.\nIn pre-2015 JavaScript, only functions\ncreated new scopes, so old-style bindings, created with the var keyword, are\nvisible throughout the whole function in which they appear\u2014or throughout the\nglobal scope, if they are not in a function.\nlet x = 10;\n// global\nif (true) {\nlet y = 20; // local to block\nvar z = 30; // also global\n}\nEach scope can \u201clook out\u201d into the scope around it, so x is visible inside the\nblock in the example. The exception is when multiple bindings have the same\nname\u2014in that case, code can see only the innermost one. For example, when\nthe code inside the halve function refers to n, it is seeing its own n, not the\nglobal n.\nconst halve = function(n) {\nreturn n / 2;\n};\nlet n = 10;\nconsole.log(halve(100));\n// \u219250\nconsole.log(n);\n// \u219210\nNested scope\nJavaScript distinguishes not just global and local bindings. Blocks and func-\ntions can be created inside other blocks and functions, producing multiple de-\ngrees of locality.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_121",
    "text": "// \u219210\nNested scope\nJavaScript distinguishes not just global and local bindings. Blocks and func-\ntions can be created inside other blocks and functions, producing multiple de-\ngrees of locality.\nFor example, this function\u2014which outputs the ingredients needed to make\na batch of hummus\u2014has another function inside it:\nconst hummus = function(factor) {\nconst ingredient = function(amount, unit, name) {\nlet ingredientAmount = amount * factor;\nif (ingredientAmount > 1) {\nunit += \"s\";\n}\n40\nconsole.log(`${ingredientAmount} ${unit} ${name}`);\n};\ningredient(1, \"can\", \"chickpeas\");\ningredient(0.25, \"cup\", \"tahini\");\ningredient(0.25, \"cup\", \"lemon juice\");\ningredient(1, \"clove\", \"garlic\");\ningredient(2, \"tablespoon\", \"olive oil\");\ningredient(0.5, \"teaspoon\", \"cumin\");\n};\nThe code inside the ingredient function can see the factor binding from the\nouter function, but its local bindings, such as unit or ingredientAmount, are\nnot visible in the outer function.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_122",
    "text": "};\nThe code inside the ingredient function can see the factor binding from the\nouter function, but its local bindings, such as unit or ingredientAmount, are\nnot visible in the outer function.\nThe set of bindings visible inside a block is determined by the place of that\nblock in the program text. Each local scope can also see all the local scopes that\ncontain it, and all scopes can see the global scope. This approach to binding\nvisibility is called lexical scoping.\nFunctions as values\nA function binding usually simply acts as a name for a specific piece of the\nprogram. Such a binding is defined once and never changed. This makes it\neasy to confuse the function and its name.\nBut the two are different. A function value can do all the things that other\nvalues can do\u2014you can use it in arbitrary expressions, not just call it. It is\npossible to store a function value in a new binding, pass it as an argument to\na function, and so on. Similarly, a binding that holds a function is still just a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_123",
    "text": "possible to store a function value in a new binding, pass it as an argument to\na function, and so on. Similarly, a binding that holds a function is still just a\nregular binding and can, if not constant, be assigned a new value, like so:\nlet launchMissiles = function() {\nmissileSystem.launch(\"now\");\n};\nif (safeMode) {\nlaunchMissiles = function() {/* do nothing */};\n}\nIn Chapter 5, we\u2019ll discuss the interesting things that we can do by passing\nfunction values to other functions.\n41\nDeclaration notation\nThere is a slightly shorter way to create a function binding. When the function\nkeyword is used at the start of a statement, it works differently:\nfunction square(x) {\nreturn x * x;\n}\nThis is a function declaration. The statement defines the binding square and\npoints it at the given function. It is slightly easier to write and doesn\u2019t require\na semicolon after the function.\nThere is one subtlety with this form of function definition.\nconsole.log(\"The future says:\", future());",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_124",
    "text": "a semicolon after the function.\nThere is one subtlety with this form of function definition.\nconsole.log(\"The future says:\", future());\nfunction future() {\nreturn \"You'll never have flying cars\";\n}\nThe preceding code works, even though the function is defined below the code\nthat uses it. Function declarations are not part of the regular top-to-bottom\nflow of control. They are conceptually moved to the top of their scope and can\nbe used by all the code in that scope. This is sometimes useful because it offers\nthe freedom to order code in a way that seems the clearest, without worrying\nabout having to define all functions before they are used.\nArrow functions\nThere\u2019s a third notation for functions, which looks very different from the\nothers. Instead of the function keyword, it uses an arrow (=>) made up of an\nequal sign and a greater-than character (not to be confused with the greater-\nthan-or-equal operator, which is written >=):\nconst roundTo = (n, step) => {\nlet remainder = n % step;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_125",
    "text": "equal sign and a greater-than character (not to be confused with the greater-\nthan-or-equal operator, which is written >=):\nconst roundTo = (n, step) => {\nlet remainder = n % step;\nreturn n - remainder + (remainder < step / 2 ? 0 : step);\n};\nThe arrow comes after the list of parameters and is followed by the function\u2019s\nbody. It expresses something like \u201cthis input (the parameters) produces this\nresult (the body)\u201d.\nWhen there is only one parameter name, you can omit the parentheses\naround the parameter list. If the body is a single expression rather than a\n42\nblock in braces, that expression will be returned from the function. So, these\ntwo definitions of square do the same thing:\nconst square1 = (x) => { return x * x; };\nconst square2 = x => x * x;\nWhen an arrow function has no parameters at all, its parameter list is just an\nempty set of parentheses.\nconst horn = () => {\nconsole.log(\"Toot\");\n};\nThere\u2019s no deep reason to have both arrow functions and function expressions",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_126",
    "text": "empty set of parentheses.\nconst horn = () => {\nconsole.log(\"Toot\");\n};\nThere\u2019s no deep reason to have both arrow functions and function expressions\nin the language. Apart from a minor detail, which we\u2019ll discuss in Chapter 6,\nthey do the same thing. Arrow functions were added in 2015, mostly to make\nit possible to write small function expressions in a less verbose way. We\u2019ll use\nthem often in Chapter 5.\nThe call stack\nThe way control flows through functions is somewhat involved. Let\u2019s take a\ncloser look at it. Here is a simple program that makes a few function calls:\nfunction greet(who) {\nconsole.log(\"Hello \" + who);\n}\ngreet(\"Harry\");\nconsole.log(\"Bye\");\nA run through this program goes roughly like this: the call to greet causes\ncontrol to jump to the start of that function (line 2). The function calls console\n.log, which takes control, does its job, and then returns control to line 2. There,\nit reaches the end of the greet function, so it returns to the place that called",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_127",
    "text": ".log, which takes control, does its job, and then returns control to line 2. There,\nit reaches the end of the greet function, so it returns to the place that called\nit\u2014line 4. The line after that calls console.log again. After that returns, the\nprogram reaches its end.\nWe could show the flow of control schematically like this:\nnot in function\nin greet\nin console.log\nin greet\nnot in function\nin console.log\n43\nnot in function\nBecause a function has to jump back to the place that called it when it returns,\nthe computer must remember the context from which the call happened. In\none case, console.log has to return to the greet function when it is done. In\nthe other case, it returns to the end of the program.\nThe place where the computer stores this context is the call stack. Every\ntime a function is called, the current context is stored on top of this stack.\nWhen a function returns, it removes the top context from the stack and uses\nthat context to continue execution.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_128",
    "text": "time a function is called, the current context is stored on top of this stack.\nWhen a function returns, it removes the top context from the stack and uses\nthat context to continue execution.\nStoring this stack requires space in the computer\u2019s memory. When the stack\ngrows too big, the computer will fail with a message like \u201cout of stack space\u201d\nor \u201ctoo much recursion\u201d.\nThe following code illustrates this by asking the\ncomputer a really hard question that causes an infinite back-and-forth between\ntwo functions. Or rather, it would be infinite, if the computer had an infinite\nstack. As it is, we will run out of space, or \u201cblow the stack\u201d.\nfunction chicken() {\nreturn egg();\n}\nfunction egg() {\nreturn chicken();\n}\nconsole.log(chicken() + \" came first.\");\n// \u2192??\nOptional Arguments\nThe following code is allowed and executes without any problem:\nfunction square(x) { return x * x; }\nconsole.log(square(4, true, \"hedgehog\"));\n// \u219216",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_129",
    "text": "// \u2192??\nOptional Arguments\nThe following code is allowed and executes without any problem:\nfunction square(x) { return x * x; }\nconsole.log(square(4, true, \"hedgehog\"));\n// \u219216\nWe defined square with only one parameter. Yet when we call it with three,\nthe language doesn\u2019t complain. It ignores the extra arguments and computes\nthe square of the first one.\nJavaScript is extremely broad-minded about the number of arguments you\ncan pass to a function. If you pass too many, the extra ones are ignored. If\nyou pass too few, the missing parameters are assigned the value undefined.\nThe downside of this is that it is possible\u2014likely, even\u2014that you\u2019ll acciden-\ntally pass the wrong number of arguments to functions. And no one will tell you\n44\nabout it. The upside is that you can use this behavior to allow a function to be\ncalled with different numbers of arguments. For example, this minus function\ntries to imitate the - operator by acting on either one or two arguments:\nfunction minus(a, b) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_130",
    "text": "called with different numbers of arguments. For example, this minus function\ntries to imitate the - operator by acting on either one or two arguments:\nfunction minus(a, b) {\nif (b === undefined) return -a;\nelse return a - b;\n}\nconsole.log(minus(10));\n// \u2192-10\nconsole.log(minus(10, 5));\n// \u21925\nIf you write an = operator after a parameter, followed by an expression, the\nvalue of that expression will replace the argument when it is not given. For\nexample, this version of roundTo makes its second argument optional. If you\ndon\u2019t provide it or pass the value undefined, it will default to one:\nfunction roundTo(n, step = 1) {\nlet remainder = n % step;\nreturn n - remainder + (remainder < step / 2 ? 0 : step);\n};\nconsole.log(roundTo(4.5));\n// \u21925\nconsole.log(roundTo(4.5, 2));\n// \u21924\nThe next chapter will introduce a way in which a function body can get at\nthe whole list of arguments it was passed. This is helpful because it allows a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_131",
    "text": "// \u21925\nconsole.log(roundTo(4.5, 2));\n// \u21924\nThe next chapter will introduce a way in which a function body can get at\nthe whole list of arguments it was passed. This is helpful because it allows a\nfunction to accept any number of arguments. For example, console.log does\nthis, outputting all the values it is given:\nconsole.log(\"C\", \"O\", 2);\n// \u2192C O 2\nClosure\nThe ability to treat functions as values, combined with the fact that local\nbindings are re-created every time a function is called, brings up an interesting\nquestion: What happens to local bindings when the function call that created\nthem is no longer active?\n45\nThe following code shows an example of this. It defines a function, wrapValue,\nthat creates a local binding. It then returns a function that accesses and returns\nthis local binding.\nfunction wrapValue(n) {\nlet local = n;\nreturn () => local;\n}\nlet wrap1 = wrapValue(1);\nlet wrap2 = wrapValue(2);\nconsole.log(wrap1());\n// \u21921\nconsole.log(wrap2());\n// \u21922",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_132",
    "text": "this local binding.\nfunction wrapValue(n) {\nlet local = n;\nreturn () => local;\n}\nlet wrap1 = wrapValue(1);\nlet wrap2 = wrapValue(2);\nconsole.log(wrap1());\n// \u21921\nconsole.log(wrap2());\n// \u21922\nThis is allowed and works as you\u2019d hope\u2014both instances of the binding can\nstill be accessed. This situation is a good demonstration of the fact that local\nbindings are created anew for every call, and different calls don\u2019t affect each\nother\u2019s local bindings.\nThis feature\u2014being able to reference a specific instance of a local binding in\nan enclosing scope\u2014is called closure. A function that references bindings from\nlocal scopes around it is called a closure. This behavior not only frees you from\nhaving to worry about the lifetimes of bindings but also makes it possible to\nuse function values in some creative ways.\nWith a slight change, we can turn the previous example into a way to create\nfunctions that multiply by an arbitrary amount.\nfunction multiplier(factor) {\nreturn number => number * factor;\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_133",
    "text": "With a slight change, we can turn the previous example into a way to create\nfunctions that multiply by an arbitrary amount.\nfunction multiplier(factor) {\nreturn number => number * factor;\n}\nlet twice = multiplier(2);\nconsole.log(twice(5));\n// \u219210\nThe explicit local binding from the wrapValue example isn\u2019t really needed since\na parameter is itself a local binding.\nThinking about programs like this takes some practice. A good mental model\nis to think of function values as containing both the code in their body and the\nenvironment in which they are created. When called, the function body sees\nthe environment in which it was created, not the environment in which it is\ncalled.\nIn the previous example, multiplier is called and creates an environment in\n46\nwhich its factor parameter is bound to 2. The function value it returns, which\nis stored in twice, remembers this environment so that when that is called, it\nmultiplies its argument by 2.\nRecursion",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_134",
    "text": "46\nwhich its factor parameter is bound to 2. The function value it returns, which\nis stored in twice, remembers this environment so that when that is called, it\nmultiplies its argument by 2.\nRecursion\nIt is perfectly okay for a function to call itself, as long as it doesn\u2019t do it so\noften that it overflows the stack. A function that calls itself is called recursive.\nRecursion allows some functions to be written in a different style. Take, for\nexample, this power function, which does the same as the ** (exponentiation)\noperator:\nfunction power(base, exponent) {\nif (exponent == 0) {\nreturn 1;\n} else {\nreturn base * power(base, exponent - 1);\n}\n}\nconsole.log(power(2, 3));\n// \u21928\nThis is rather close to the way mathematicians define exponentiation and ar-\nguably describes the concept more clearly than the loop we used in Chapter 2.\nThe function calls itself multiple times with ever smaller exponents to achieve\nthe repeated multiplication.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_135",
    "text": "guably describes the concept more clearly than the loop we used in Chapter 2.\nThe function calls itself multiple times with ever smaller exponents to achieve\nthe repeated multiplication.\nHowever, this implementation has one problem: in typical JavaScript im-\nplementations, it\u2019s about three times slower than a version using a for loop.\nRunning through a simple loop is generally cheaper than calling a function\nmultiple times.\nThe dilemma of speed versus elegance is an interesting one. You can see it as\na kind of continuum between human-friendliness and machine-friendliness. Al-\nmost any program can be made faster by making it bigger and more convoluted.\nThe programmer has to find an appropriate balance.\nIn the case of the power function, an inelegant (looping) version is still fairly\nsimple and easy to read. It doesn\u2019t make much sense to replace it with a recur-\nsive function. Often, though, a program deals with such complex concepts that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_136",
    "text": "simple and easy to read. It doesn\u2019t make much sense to replace it with a recur-\nsive function. Often, though, a program deals with such complex concepts that\ngiving up some e\ufb00iciency in order to make the program more straightforward\nis helpful.\nWorrying about e\ufb00iciency can be a distraction. It\u2019s yet another factor that\n47\ncomplicates program design, and when you\u2019re doing something that\u2019s already\ndi\ufb00icult, that extra thing to worry about can be paralyzing.\nTherefore, you should generally start by writing something that\u2019s correct\nand easy to understand. If you\u2019re worried that it\u2019s too slow\u2014which it usually\nisn\u2019t since most code simply isn\u2019t executed often enough to take any significant\namount of time\u2014you can measure afterward and improve it if necessary.\nRecursion is not always just an ine\ufb00icient alternative to looping. Some prob-\nlems really are easier to solve with recursion than with loops. Most often these\nare problems that require exploring or processing several \u201cbranches\u201d, each of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_137",
    "text": "lems really are easier to solve with recursion than with loops. Most often these\nare problems that require exploring or processing several \u201cbranches\u201d, each of\nwhich might branch out again into even more branches.\nConsider this puzzle: by starting from the number 1 and repeatedly either\nadding 5 or multiplying by 3, an infinite set of numbers can be produced. How\nwould you write a function that, given a number, tries to find a sequence of\nsuch additions and multiplications that produces that number? For example,\nthe number 13 could be reached by first multiplying by 3 and then adding 5\ntwice, whereas the number 15 cannot be reached at all.\nHere is a recursive solution:\nfunction findSolution(target) {\nfunction find(current, history) {\nif (current == target) {\nreturn history;\n} else if (current > target) {\nreturn null;\n} else {\nreturn find(current + 5, `(${history} + 5)`) ??\nfind(current * 3, `(${history} * 3)`);\n}\n}\nreturn find(1, \"1\");\n}\nconsole.log(findSolution(24));",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_138",
    "text": "} else if (current > target) {\nreturn null;\n} else {\nreturn find(current + 5, `(${history} + 5)`) ??\nfind(current * 3, `(${history} * 3)`);\n}\n}\nreturn find(1, \"1\");\n}\nconsole.log(findSolution(24));\n// \u2192(((1 * 3) + 5) * 3)\nNote that this program doesn\u2019t necessarily find the shortest sequence of oper-\nations. It is satisfied when it finds any sequence at all.\nIt\u2019s okay if you don\u2019t see how this code works right away. Let\u2019s work through\nit since it makes for a great exercise in recursive thinking.\nThe inner function find does the actual recursing. It takes two arguments:\nthe current number and a string that records how we reached this number. If\nit finds a solution, it returns a string that shows how to get to the target. If it\n48\ncan find no solution starting from this number, it returns null.\nTo do this, the function performs one of three actions. If the current number\nis the target number, the current history is a way to reach that target, so it",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_139",
    "text": "To do this, the function performs one of three actions. If the current number\nis the target number, the current history is a way to reach that target, so it\nis returned. If the current number is greater than the target, there\u2019s no sense\nin further exploring this branch because both adding and multiplying will only\nmake the number bigger, so it returns null. Finally, if we\u2019re still below the\ntarget number, the function tries both possible paths that start from the current\nnumber by calling itself twice, once for addition and once for multiplication. If\nthe first call returns something that is not null, it is returned. Otherwise, the\nsecond call is returned, regardless of whether it produces a string or null.\nTo better understand how this function produces the effect we\u2019re looking for,\nlet\u2019s look at all the calls to find that are made when searching for a solution\nfor the number 13:\nfind(1, \"1\")\nfind(6, \"(1 + 5)\")\nfind(11, \"((1 + 5) + 5)\")\nfind(16, \"(((1 + 5) + 5) + 5)\")\ntoo big",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_140",
    "text": "let\u2019s look at all the calls to find that are made when searching for a solution\nfor the number 13:\nfind(1, \"1\")\nfind(6, \"(1 + 5)\")\nfind(11, \"((1 + 5) + 5)\")\nfind(16, \"(((1 + 5) + 5) + 5)\")\ntoo big\nfind(33, \"(((1 + 5) + 5) * 3)\")\ntoo big\nfind(18, \"((1 + 5) * 3)\")\ntoo big\nfind(3, \"(1 * 3)\")\nfind(8, \"((1 * 3) + 5)\")\nfind(13, \"(((1 * 3) + 5) + 5)\")\nfound!\nThe indentation indicates the depth of the call stack. The first time find is\ncalled, the function starts by calling itself to explore the solution that starts\nwith (1 + 5). That call will further recurse to explore every continued solution\nthat yields a number less than or equal to the target number. Since it doesn\u2019t\nfind one that hits the target, it returns null back to the first call.\nThere\nthe ?? operator causes the call that explores (1 * 3) to happen. This search\nhas more luck\u2014its first recursive call, through yet another recursive call, hits\nupon the target number. That innermost call returns a string, and each of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_141",
    "text": "has more luck\u2014its first recursive call, through yet another recursive call, hits\nupon the target number. That innermost call returns a string, and each of\nthe ?? operators in the intermediate calls passes that string along, ultimately\nreturning the solution.\n49\nGrowing functions\nThere are two more or less natural ways for functions to be introduced into\nprograms.\nThe first occurs when you find yourself writing similar code multiple times.\nYou\u2019d prefer not to do that, as having more code means more space for mistakes\nto hide and more material to read for people trying to understand the program.\nSo you take the repeated functionality, find a good name for it, and put it into\na function.\nThe second way is that you find you need some functionality that you haven\u2019t\nwritten yet and that sounds like it deserves its own function. You start by\nnaming the function, and then write its body. You might even start writing\ncode that uses the function before you actually define the function itself.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_142",
    "text": "naming the function, and then write its body. You might even start writing\ncode that uses the function before you actually define the function itself.\nHow di\ufb00icult it is to find a good name for a function is a good indication\nof how clear a concept it is that you\u2019re trying to wrap. Let\u2019s go through an\nexample.\nWe want to write a program that prints two numbers: the numbers of cows\nand chickens on a farm, with the words Cows and Chickens after them and zeros\npadded before both numbers so that they are always three digits long:\n007 Cows\n011 Chickens\nThis asks for a function of two arguments\u2014the number of cows and the number\nof chickens. Let\u2019s get coding.\nfunction printFarmInventory(cows, chickens) {\nlet cowString = String(cows);\nwhile (cowString.length < 3) {\ncowString = \"0\" + cowString;\n}\nconsole.log(`${cowString} Cows`);\nlet chickenString = String(chickens);\nwhile (chickenString.length < 3) {\nchickenString = \"0\" + chickenString;\n}\nconsole.log(`${chickenString} Chickens`);\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_143",
    "text": "}\nconsole.log(`${cowString} Cows`);\nlet chickenString = String(chickens);\nwhile (chickenString.length < 3) {\nchickenString = \"0\" + chickenString;\n}\nconsole.log(`${chickenString} Chickens`);\n}\nprintFarmInventory(7, 11);\nWriting .length after a string expression will give us the length of that string.\nThus, the while loops keep adding zeros in front of the number strings until\nthey are at least three characters long.\n50\nMission accomplished! But just as we are about to send the farmer the code\n(along with a hefty invoice), she calls and tells us she\u2019s also started keeping\npigs, and couldn\u2019t we please extend the software to also print pigs?\nWe sure can. But just as we\u2019re in the process of copying and pasting those\nfour lines one more time, we stop and reconsider. There has to be a better way.\nHere\u2019s a first attempt:\nfunction printZeroPaddedWithLabel(number, label) {\nlet numberString = String(number);\nwhile (numberString.length < 3) {\nnumberString = \"0\" + numberString;\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_144",
    "text": "Here\u2019s a first attempt:\nfunction printZeroPaddedWithLabel(number, label) {\nlet numberString = String(number);\nwhile (numberString.length < 3) {\nnumberString = \"0\" + numberString;\n}\nconsole.log(`${numberString} ${label}`);\n}\nfunction printFarmInventory(cows, chickens, pigs) {\nprintZeroPaddedWithLabel(cows, \"Cows\");\nprintZeroPaddedWithLabel(chickens, \"Chickens\");\nprintZeroPaddedWithLabel(pigs, \"Pigs\");\n}\nprintFarmInventory(7, 11, 3);\nIt works! But that name, printZeroPaddedWithLabel, is a little awkward. It\nconflates three things\u2014printing, zero-padding, and adding a label\u2014into a sin-\ngle function.\nInstead of lifting out the repeated part of our program wholesale, let\u2019s try\nto pick out a single concept:\nfunction zeroPad(number, width) {\nlet string = String(number);\nwhile (string.length < width) {\nstring = \"0\" + string;\n}\nreturn string;\n}\nfunction printFarmInventory(cows, chickens, pigs) {\nconsole.log(`${zeroPad(cows, 3)} Cows`);\nconsole.log(`${zeroPad(chickens, 3)} Chickens`);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_145",
    "text": "string = \"0\" + string;\n}\nreturn string;\n}\nfunction printFarmInventory(cows, chickens, pigs) {\nconsole.log(`${zeroPad(cows, 3)} Cows`);\nconsole.log(`${zeroPad(chickens, 3)} Chickens`);\nconsole.log(`${zeroPad(pigs, 3)} Pigs`);\n}\nprintFarmInventory(7, 16, 3);\n51\nA function with a nice, obvious name like zeroPad makes it easier for someone\nwho reads the code to figure out what it does. Such a function is also useful in\nmore situations than just this specific program. For example, you could use it\nto help print nicely aligned tables of numbers.\nHow smart and versatile should our function be? We could write anything,\nfrom a terribly simple function that can only pad a number to be three charac-\nters wide to a complicated generalized number-formatting system that handles\nfractional numbers, negative numbers, alignment of decimal dots, padding with\ndifferent characters, and so on.\nA useful principle is to refrain from adding cleverness unless you are ab-\nsolutely sure you\u2019re going to need it.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_146",
    "text": "different characters, and so on.\nA useful principle is to refrain from adding cleverness unless you are ab-\nsolutely sure you\u2019re going to need it.\nIt can be tempting to write general\n\u201cframeworks\u201d for every bit of functionality you come across. Resist that urge.\nYou won\u2019t get any real work done\u2014you\u2019ll be too busy writing code that you\nnever use.\nFunctions and side effects\nFunctions can be roughly divided into those that are called for their side effects\nand those that are called for their return value (though it is also possible to\nboth have side effects and return a value).\nThe first helper function in the farm example, printZeroPaddedWithLabel,\nis called for its side effect: it prints a line. The second version, zeroPad, is\ncalled for its return value. It is no coincidence that the second is useful in more\nsituations than the first. Functions that create values are easier to combine in\nnew ways than functions that directly perform side effects.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_147",
    "text": "situations than the first. Functions that create values are easier to combine in\nnew ways than functions that directly perform side effects.\nA pure function is a specific kind of value-producing function that not only\nhas no side effects but also doesn\u2019t rely on side effects from other code\u2014for\nexample, it doesn\u2019t read global bindings whose value might change. A pure\nfunction has the pleasant property that, when called with the same arguments,\nit always produces the same value (and doesn\u2019t do anything else). A call to\nsuch a function can be substituted by its return value without changing the\nmeaning of the code. When you are not sure that a pure function is working\ncorrectly, you can test it by simply calling it and know that if it works in that\ncontext, it will work in any context. Nonpure functions tend to require more\nscaffolding to test.\nStill, there\u2019s no need to feel bad when writing functions that are not pure.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_148",
    "text": "context, it will work in any context. Nonpure functions tend to require more\nscaffolding to test.\nStill, there\u2019s no need to feel bad when writing functions that are not pure.\nSide effects are often useful. There\u2019s no way to write a pure version of console\n.log, for example, and console.log is good to have. Some operations are also\neasier to express in an e\ufb00icient way when we use side effects.\n52\nSummary\nThis chapter taught you how to write your own functions. The function key-\nword, when used as an expression, can create a function value. When used as\na statement, it can be used to declare a binding and give it a function as its\nvalue. Arrow functions are yet another way to create functions.\n// Define f to hold a function value\nconst f = function(a) {\nconsole.log(a + 2);\n};\n// Declare g to be a function\nfunction g(a, b) {\nreturn a * b * 3.5;\n}\n// A less verbose function value\nlet h = a => a % 3;\nA key part of understanding functions is understanding scopes. Each block",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_149",
    "text": "};\n// Declare g to be a function\nfunction g(a, b) {\nreturn a * b * 3.5;\n}\n// A less verbose function value\nlet h = a => a % 3;\nA key part of understanding functions is understanding scopes. Each block\ncreates a new scope. Parameters and bindings declared in a given scope are\nlocal and not visible from the outside.\nBindings declared with var behave\ndifferently\u2014they end up in the nearest function scope or the global scope.\nSeparating the tasks your program performs into different functions is help-\nful. You won\u2019t have to repeat yourself as much, and functions can help organize\na program by grouping code into pieces that do specific things.\nExercises\nMinimum\nThe previous chapter introduced the standard function Math.min that returns\nits smallest argument. We can write a function like that ourselves now. Define\nthe function min that takes two arguments and returns their minimum.\nRecursion\nWe\u2019ve seen that we can use % (the remainder operator) to test whether a number",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_150",
    "text": "the function min that takes two arguments and returns their minimum.\nRecursion\nWe\u2019ve seen that we can use % (the remainder operator) to test whether a number\nis even or odd by using % 2 to see whether it\u2019s divisible by two. Here\u2019s another\nway to define whether a positive whole number is even or odd:\n\u2022 Zero is even.\n53\n\u2022 One is odd.\n\u2022 For any other number N, its evenness is the same as N - 2.\nDefine a recursive function isEven corresponding to this description. The\nfunction should accept a single parameter (a positive, whole number) and return\na Boolean.\nTest it on 50 and 75. See how it behaves on -1. Why? Can you think of a\nway to fix this?\nBean counting\nYou can get the Nth character, or letter, from a string by writing [N] after the\nstring (for example, string[2]). The resulting value will be a string containing\nonly one character (for example, \"b\"). The first character has position 0, which\ncauses the last one to be found at position string.length - 1. In other words,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_151",
    "text": "only one character (for example, \"b\"). The first character has position 0, which\ncauses the last one to be found at position string.length - 1. In other words,\na two-character string has length 2, and its characters have positions 0 and 1.\nWrite a function called countBs that takes a string as its only argument and\nreturns a number that indicates how many uppercase B characters there are in\nthe string.\nNext, write a function called countChar that behaves like countBs, except\nit takes a second argument that indicates the character that is to be counted\n(rather than counting only uppercase B characters). Rewrite countBs to make\nuse of this new function.\n54\n\u201cOn two occasions I have been asked, \u2018Pray, Mr. Babbage, if you put\ninto the machine wrong figures, will the right answers come out?\u2019\n[...] I am not able rightly to apprehend the kind of confusion of ideas\nthat could provoke such a question.\u201d\n\u2014Charles Babbage, Passages from the Life of a Philosopher (1864)\nChapter 4",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_152",
    "text": "[...] I am not able rightly to apprehend the kind of confusion of ideas\nthat could provoke such a question.\u201d\n\u2014Charles Babbage, Passages from the Life of a Philosopher (1864)\nChapter 4\nData Structures: Objects and Arrays\nNumbers, Booleans, and strings are the atoms from which data structures are\nbuilt. Many types of information require more than one atom, though. Ob-\njects allow us to group values\u2014including other objects\u2014to build more complex\nstructures.\nThe programs we have built so far have been limited by the fact that they\nwere operating only on simple data types. After learning the basics of data\nstructures in this chapter, you\u2019ll know enough to start writing useful programs.\nThe chapter will work through a more or less realistic programming example,\nintroducing concepts as they apply to the problem at hand. The example code\nwill often build on functions and bindings introduced earlier in the book.\nThe online coding sandbox for the book (https://eloquentjavascript.net/code)",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_153",
    "text": "will often build on functions and bindings introduced earlier in the book.\nThe online coding sandbox for the book (https://eloquentjavascript.net/code)\nprovides a way to run code in the context of a particular chapter. If you decide\nto work through the examples in another environment, be sure to first download\nthe full code for this chapter from the sandbox page.\nThe weresquirrel\nEvery now and then, usually between 8 p.m. and 10 p.m., Jacques finds himself\ntransforming into a small furry rodent with a bushy tail.\nOn one hand, Jacques is quite glad that he doesn\u2019t have classic lycanthropy.\nTurning into a squirrel does cause fewer problems than turning into a wolf.\nInstead of having to worry about accidentally eating the neighbor (that would\nbe awkward), he worries about being eaten by the neighbor\u2019s cat. After two\noccasions of waking up on a precariously thin branch in the crown of an oak,\nnaked and disoriented, he has taken to locking the doors and windows of his",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_154",
    "text": "occasions of waking up on a precariously thin branch in the crown of an oak,\nnaked and disoriented, he has taken to locking the doors and windows of his\nroom at night and putting a few walnuts on the floor to keep himself busy.\nBut Jacques would prefer to get rid of his condition entirely. The irregular\noccurrences of the transformation make him suspect that they might be trig-\ngered by something. For a while, he believed that it happened only on days\nwhen he had been near oak trees. However, avoiding oak trees did not solve\n55\nthe problem.\nSwitching to a more scientific approach, Jacques has started keeping a daily\nlog of everything he does on a given day and whether he changed form. With\nthis data he hopes to narrow down the conditions that trigger the transforma-\ntions.\nThe first thing he needs is a data structure to store this information.\nDatasets\nTo work with a chunk of digital data, we first have to find a way to represent",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_155",
    "text": "tions.\nThe first thing he needs is a data structure to store this information.\nDatasets\nTo work with a chunk of digital data, we first have to find a way to represent\nit in our machine\u2019s memory. Say, for example, that we want to represent a\ncollection of the numbers 2, 3, 5, 7, and 11.\nWe could get creative with strings\u2014after all, strings can have any length, so\nwe can put a lot of data into them\u2014and use \"2 3 5 7 11\" as our representation.\nBut this is awkward. We\u2019d have to somehow extract the digits and convert them\nback to numbers to access them.\nFortunately, JavaScript provides a data type specifically for storing sequences\nof values. It is called an array and is written as a list of values between square\nbrackets, separated by commas.\nlet listOfNumbers = [2, 3, 5, 7, 11];\nconsole.log(listOfNumbers[2]);\n// \u21925\nconsole.log(listOfNumbers[0]);\n// \u21922\nconsole.log(listOfNumbers[2 - 1]);\n// \u21923\nThe notation for getting at the elements inside an array also uses square brack-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_156",
    "text": "console.log(listOfNumbers[2]);\n// \u21925\nconsole.log(listOfNumbers[0]);\n// \u21922\nconsole.log(listOfNumbers[2 - 1]);\n// \u21923\nThe notation for getting at the elements inside an array also uses square brack-\nets. A pair of square brackets immediately after an expression, with another\nexpression inside of them, will look up the element in the left-hand expression\nthat corresponds to the index given by the expression in the brackets.\nThe first index of an array is zero, not one, so the first element is retrieved\nwith listOfNumbers[0]. Zero-based counting has a long tradition in technology\nand in certain ways makes a lot of sense, but it takes some getting used to.\nThink of the index as the number of items to skip, counting from the start of\nthe array.\n56\nProperties\nWe\u2019ve seen a few expressions like myString.length (to get the length of a string)\nand Math.max (the maximum function) in past chapters.\nThese expressions\naccess a property of some value. In the first case, we access the length property",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_157",
    "text": "and Math.max (the maximum function) in past chapters.\nThese expressions\naccess a property of some value. In the first case, we access the length property\nof the value in myString. In the second, we access the property named max in\nthe Math object (which is a collection of mathematics-related constants and\nfunctions).\nAlmost all JavaScript values have properties. The exceptions are null and\nundefined. If you try to access a property on one of these nonvalues, you get\nan error:\nnull.length;\n// \u2192TypeError: null has no properties\nThe two main ways to access properties in JavaScript are with a dot and with\nsquare brackets. Both value.x and value[x] access a property on value\u2014but\nnot necessarily the same property. The difference is in how x is interpreted.\nWhen using a dot, the word after the dot is the literal name of the property.\nWhen using square brackets, the expression between the brackets is evaluated\nto get the property name.\nWhereas value.x fetches the property of value",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_158",
    "text": "When using square brackets, the expression between the brackets is evaluated\nto get the property name.\nWhereas value.x fetches the property of value\nnamed \u201cx\u201d, value[x] takes the value of the variable named x and uses that,\nconverted to a string, as the property name.\nIf you know that the property in which you are interested is called color,\nyou say value.color. If you want to extract the property named by the value\nheld in the binding i, you say value[i]. Property names are strings. They\ncan be any string, but the dot notation works only with names that look like\nvalid binding names\u2014starting with a letter or underscore, and containing only\nletters, numbers, and underscores. If you want to access a property named 2\nor John Doe, you must use square brackets: value[2] or value[\"John Doe\"].\nThe elements in an array are stored as the array\u2019s properties, using numbers\nas property names. Because you can\u2019t use the dot notation with numbers and",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_159",
    "text": "The elements in an array are stored as the array\u2019s properties, using numbers\nas property names. Because you can\u2019t use the dot notation with numbers and\nusually want to use a binding that holds the index anyway, you have to use the\nbracket notation to get at them.\nJust like strings, arrays have a length property that tells us how many ele-\nments the array has.\nMethods\nBoth string and array values contain, in addition to the length property, a\nnumber of properties that hold function values.\n57\nlet doh = \"Doh\";\nconsole.log(typeof doh.toUpperCase);\n// \u2192function\nconsole.log(doh.toUpperCase());\n// \u2192DOH\nEvery string has a toUpperCase property. When called, it will return a copy of\nthe string in which all letters have been converted to uppercase. There is also\ntoLowerCase, going the other way.\nInterestingly, even though the call to toUpperCase does not pass any argu-\nments, the function somehow has access to the string \"Doh\", the value whose",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_160",
    "text": "toLowerCase, going the other way.\nInterestingly, even though the call to toUpperCase does not pass any argu-\nments, the function somehow has access to the string \"Doh\", the value whose\nproperty we called. You\u2019ll find out how this works in Chapter 6.\nProperties that contain functions are generally called methods of the value\nthey belong to, as in \u201ctoUpperCase is a method of a string\u201d.\nThis example demonstrates two methods you can use to manipulate arrays.\nlet sequence = [1, 2, 3];\nsequence.push(4);\nsequence.push(5);\nconsole.log(sequence);\n// \u2192[1, 2, 3, 4, 5]\nconsole.log(sequence.pop());\n// \u21925\nconsole.log(sequence);\n// \u2192[1, 2, 3, 4]\nThe push method adds values to the end of an array. The pop method does the\nopposite, removing the last value in the array and returning it.\nThese somewhat silly names are the traditional terms for operations on a\nstack. A stack, in programming, is a data structure that allows you to push",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_161",
    "text": "These somewhat silly names are the traditional terms for operations on a\nstack. A stack, in programming, is a data structure that allows you to push\nvalues into it and pop them out again in the opposite order so that the thing\nthat was added last is removed first. Stacks are common in programming\u2014you\nmight remember the function call stack from the previous chapter, which is an\ninstance of the same idea.\nObjects\nBack to the weresquirrel. A set of daily log entries can be represented as an\narray, but the entries do not consist of just a number or a string\u2014each entry\nneeds to store a list of activities and a Boolean value that indicates whether\nJacques turned into a squirrel or not. Ideally, we would like to group these\ntogether into a single value and then put those grouped values into an array of\n58\nlog entries.\nValues of the type object are arbitrary collections of properties. One way to\ncreate an object is by using braces as an expression.\nlet day1 = {\nsquirrel: false,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_162",
    "text": "58\nlog entries.\nValues of the type object are arbitrary collections of properties. One way to\ncreate an object is by using braces as an expression.\nlet day1 = {\nsquirrel: false,\nevents: [\"work\", \"touched tree\", \"pizza\", \"running\"]\n};\nconsole.log(day1.squirrel);\n// \u2192false\nconsole.log(day1.wolf);\n// \u2192undefined\nday1.wolf = false;\nconsole.log(day1.wolf);\n// \u2192false\nInside the braces, you write a list of properties separated by commas. Each\nproperty has a name followed by a colon and a value. When an object is written\nover multiple lines, indenting it as shown in this example helps with readability.\nProperties whose names aren\u2019t valid binding names or valid numbers must be\nquoted:\nlet descriptions = {\nwork: \"Went to work\",\n\"touched tree\": \"Touched a tree\"\n};\nThis means that braces have two meanings in JavaScript.\nAt the start of\na statement, they begin a block of statements. In any other position, they\ndescribe an object. Fortunately, it is rarely useful to start a statement with an",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_163",
    "text": "At the start of\na statement, they begin a block of statements. In any other position, they\ndescribe an object. Fortunately, it is rarely useful to start a statement with an\nobject in braces, so the ambiguity between these two is not much of a problem.\nThe one case where this does come up is when you want to return an object\nfrom a shorthand arrow function\u2014you can\u2019t write n => {prop: n} since the\nbraces will be interpreted as a function body. Instead, you have to put a set of\nparentheses around the object to make it clear that it is an expression.\nReading a property that doesn\u2019t exist will give you the value undefined.\nIt is possible to assign a value to a property expression with the = operator.\nThis will replace the property\u2019s value if it already existed or create a new\nproperty on the object if it didn\u2019t.\nTo briefly return to our tentacle model of bindings\u2014property bindings are\nsimilar. They grasp values, but other bindings and properties might be holding",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_164",
    "text": "property on the object if it didn\u2019t.\nTo briefly return to our tentacle model of bindings\u2014property bindings are\nsimilar. They grasp values, but other bindings and properties might be holding\nonto those same values. You can think of objects as octopuses with any number\nof tentacles, each of which has a name written on it.\n59\nThe delete operator cuts off a tentacle from such an octopus. It is a unary\noperator that, when applied to an object property, will remove the named\nproperty from the object. This is not a common thing to do, but it is possible.\nlet anObject = {left: 1, right: 2};\nconsole.log(anObject.left);\n// \u21921\ndelete anObject.left;\nconsole.log(anObject.left);\n// \u2192undefined\nconsole.log(\"left\" in anObject);\n// \u2192false\nconsole.log(\"right\" in anObject);\n// \u2192true\nThe binary in operator, when applied to a string and an object, tells you\nwhether that object has a property with that name. The difference between",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_165",
    "text": "// \u2192false\nconsole.log(\"right\" in anObject);\n// \u2192true\nThe binary in operator, when applied to a string and an object, tells you\nwhether that object has a property with that name. The difference between\nsetting a property to undefined and actually deleting it is that in the first case,\nthe object still has the property (it just doesn\u2019t have a very interesting value),\nwhereas in the second case, the property is no longer present and in will return\nfalse.\nTo find out what properties an object has, you can use the Object.keys\nfunction. Give the function an object and it will return an array of strings\u2014\nthe object\u2019s property names:\nconsole.log(Object.keys({x: 0, y: 0, z: 2}));\n// \u2192[\"x\", \"y\", \"z\"]\nThere\u2019s an Object.assign function that copies all properties from one object\ninto another:\nlet objectA = {a: 1, b: 2};\nObject.assign(objectA, {b: 3, c: 4});\nconsole.log(objectA);\n// \u2192{a: 1, b: 3, c: 4}\nArrays, then, are just a kind of object specialized for storing sequences of things.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_166",
    "text": "let objectA = {a: 1, b: 2};\nObject.assign(objectA, {b: 3, c: 4});\nconsole.log(objectA);\n// \u2192{a: 1, b: 3, c: 4}\nArrays, then, are just a kind of object specialized for storing sequences of things.\nIf you evaluate typeof [], it produces \"object\". You can visualize arrays as\nlong, flat octopuses with all their tentacles in a neat row, labeled with numbers.\nJacques will represent the journal that Jacques keeps as an array of objects:\nlet journal = [\n{events: [\"work\", \"touched tree\", \"pizza\",\n\"running\", \"television\"],\nsquirrel: false},\n60\n{events: [\"work\", \"ice cream\", \"cauliflower\",\n\"lasagna\", \"touched tree\", \"brushed teeth\"],\nsquirrel: false},\n{events: [\"weekend\", \"cycling\", \"break\", \"peanuts\",\n\"beer\"],\nsquirrel: true},\n/* And so on... */\n];\nMutability\nWe will get to actual programming soon, but first, there\u2019s one more piece of\ntheory to understand.\nWe saw that object values can be modified. The types of values discussed in",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_167",
    "text": "];\nMutability\nWe will get to actual programming soon, but first, there\u2019s one more piece of\ntheory to understand.\nWe saw that object values can be modified. The types of values discussed in\nearlier chapters, such as numbers, strings, and Booleans, are all immutable\u2014it\nis impossible to change values of those types. You can combine them and derive\nnew values from them, but when you take a specific string value, that value\nwill always remain the same. The text inside it cannot be changed. If you\nhave a string that contains \"cat\", it is not possible for other code to change a\ncharacter in your string to make it spell \"rat\".\nObjects work differently. You can change their properties, causing a single\nobject value to have different content at different times.\nWhen we have two numbers, 120 and 120, we can consider them precisely\nthe same number, whether or not they refer to the same physical bits. With\nobjects, there is a difference between having two references to the same object",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_168",
    "text": "the same number, whether or not they refer to the same physical bits. With\nobjects, there is a difference between having two references to the same object\nand having two different objects that contain the same properties. Consider\nthe following code:\nlet object1 = {value: 10};\nlet object2 = object1;\nlet object3 = {value: 10};\nconsole.log(object1 == object2);\n// \u2192true\nconsole.log(object1 == object3);\n// \u2192false\nobject1.value = 15;\nconsole.log(object2.value);\n// \u219215\nconsole.log(object3.value);\n// \u219210\n61\nThe object1 and object2 bindings grasp the same object, which is why chang-\ning object1 also changes the value of object2.\nThey are said to have the\nsame identity. The binding object3 points to a different object, which initially\ncontains the same properties as object1 but lives a separate life.\nBindings can also be changeable or constant, but this is separate from the\nway their values behave. Even though number values don\u2019t change, you can",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_169",
    "text": "Bindings can also be changeable or constant, but this is separate from the\nway their values behave. Even though number values don\u2019t change, you can\nuse a let binding to keep track of a changing number by changing the value\nat which the binding points. Similarly, though a const binding to an object\ncan itself not be changed and will continue to point at the same object, the\ncontents of that object might change.\nconst score = {visitors: 0, home: 0};\n// This is okay\nscore.visitors = 1;\n// This isn't allowed\nscore = {visitors: 1, home: 1};\nWhen you compare objects with JavaScript\u2019s == operator, it compares by iden-\ntity: it will produce true only if both objects are precisely the same value.\nComparing different objects will return false, even if they have identical prop-\nerties.\nThere is no \u201cdeep\u201d comparison operation built into JavaScript that\ncompares objects by contents, but it is possible to write it yourself (which is\none of the exercises at the end of this chapter).",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_170",
    "text": "There is no \u201cdeep\u201d comparison operation built into JavaScript that\ncompares objects by contents, but it is possible to write it yourself (which is\none of the exercises at the end of this chapter).\nThe lycanthrope's log\nJacques starts up his JavaScript interpreter and sets up the environment he\nneeds to keep his journal:\nlet journal = [];\nfunction addEntry(events, squirrel) {\njournal.push({events, squirrel});\n}\nNote that the object added to the journal looks a little odd. Instead of declaring\nproperties like events: events, it just gives a property name: events. This is\nshorthand that means the same thing\u2014if a property name in brace notation\nisn\u2019t followed by a value, its value is taken from the binding with the same\nname.\nEvery evening at 10 p.m.\u2014or sometimes the next morning, after climbing\ndown from the top shelf of his bookcase\u2014Jacques records the day:\n62\naddEntry([\"work\", \"touched tree\", \"pizza\", \"running\",\n\"television\"], false);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_171",
    "text": "down from the top shelf of his bookcase\u2014Jacques records the day:\n62\naddEntry([\"work\", \"touched tree\", \"pizza\", \"running\",\n\"television\"], false);\naddEntry([\"work\", \"ice cream\", \"cauliflower\", \"lasagna\",\n\"touched tree\", \"brushed teeth\"], false);\naddEntry([\"weekend\", \"cycling\", \"break\", \"peanuts\",\n\"beer\"], true);\nOnce he has enough data points, he intends to use statistics to find out which\nof these events may be related to the squirrelifications.\nCorrelation is a measure of dependence between statistical variables. A sta-\ntistical variable is not quite the same as a programming variable. In statistics\nyou typically have a set of measurements, and each variable is measured for\nevery measurement. Correlation between variables is usually expressed as a\nvalue that ranges from -1 to 1. Zero correlation means the variables are not\nrelated. A correlation of 1 indicates that the two are perfectly related\u2014if you\nknow one, you also know the other. Negative 1 also means that the variables",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_172",
    "text": "related. A correlation of 1 indicates that the two are perfectly related\u2014if you\nknow one, you also know the other. Negative 1 also means that the variables\nare perfectly related but are opposites\u2014when one is true, the other is false.\nTo compute the measure of correlation between two Boolean variables, we\ncan use the phi coe\ufb00icient (\u03c6). This is a formula whose input is a frequency\ntable containing the number of times the different combinations of the variables\nwere observed. The output of the formula is a number between -1 and 1 that\ndescribes the correlation.\nWe could take the event of eating pizza and put that in a frequency table\nlike this, where each number indicates the number of times that combination\noccurred in our measurements.\nNo squirrel, no pizza 76\nSquirrel, no pizza\n4\nNo squirrel, pizza\n9\nSquirrel, pizza\n1\nIf we call that table n, we can compute \u03c6 using the following formula:\n\u03c6 = n11n00 \u2212n10n01\n\u221an1\u2022n0\u2022n\u20221n\u20220\n(4.1)",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_173",
    "text": "No squirrel, no pizza 76\nSquirrel, no pizza\n4\nNo squirrel, pizza\n9\nSquirrel, pizza\n1\nIf we call that table n, we can compute \u03c6 using the following formula:\n\u03c6 = n11n00 \u2212n10n01\n\u221an1\u2022n0\u2022n\u20221n\u20220\n(4.1)\n(If at this point you\u2019re putting the book down to focus on a terrible flashback\nto 10th grade math class\u2014hold on! I do not intend to torture you with endless\n63\npages of cryptic notation\u2014it\u2019s just this one formula for now. And even with\nthis one, all we do is turn it into JavaScript.)\nThe notation n01 indicates the number of measurements where the first vari-\nable (squirrelness) is false (0) and the second variable (pizza) is true (1). In\nthe pizza table, n01 is 9.\nThe value n1\u2022 refers to the sum of all measurements where the first variable\nis true, which is 5 in the example table. Likewise, n\u20220 refers to the sum of the\nmeasurements where the second variable is false.\nSo for the pizza table, the part above the division line (the dividend) would",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_174",
    "text": "measurements where the second variable is false.\nSo for the pizza table, the part above the division line (the dividend) would\nbe 1\u00d776\u22124\u00d79 = 40, and the part below it (the divisor) would be the square\nroot of 5\u00d785\u00d710\u00d780, or \u221a340, 000. This comes out to \u03c6 \u22480.069, which is tiny.\nEating pizza does not appear to have influence on the transformations.\nComputing correlation\nWe can represent a two-by-two table in JavaScript with a four-element array\n([76, 9, 4, 1]). We could also use other representations, such as an array con-\ntaining two two-element arrays ([[76, 9], [4, 1]]) or an object with property\nnames like \"11\" and \"01\", but the flat array is simple and makes the expres-\nsions that access the table pleasantly short. We\u2019ll interpret the indices to the\narray as two-bit binary numbers, where the leftmost (most significant) digit\nrefers to the squirrel variable and the rightmost (least significant) digit refers\nto the event variable. For example, the binary number 10 refers to the case",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_175",
    "text": "refers to the squirrel variable and the rightmost (least significant) digit refers\nto the event variable. For example, the binary number 10 refers to the case\nwhere Jacques did turn into a squirrel, but the event (say, \u201cpizza\u201d) didn\u2019t oc-\ncur. This happened four times. And since binary 10 is 2 in decimal notation,\nwe will store this number at index 2 of the array.\nThis is the function that computes the \u03c6 coe\ufb00icient from such an array:\nfunction phi(table) {\nreturn (table[3] * table[0] - table[2] * table[1]) /\nMath.sqrt((table[2] + table[3]) *\n(table[0] + table[1]) *\n(table[1] + table[3]) *\n(table[0] + table[2]));\n}\nconsole.log(phi([76, 9, 4, 1]));\n// \u21920.068599434\nThis is a direct translation of the \u03c6 formula into JavaScript. Math.sqrt is the\nsquare root function, as provided by the Math object in a standard JavaScript\n64\nenvironment. We have to add two fields from the table to get fields like n1\u2022\nbecause the sums of rows or columns are not stored directly in our data struc-\nture.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_176",
    "text": "64\nenvironment. We have to add two fields from the table to get fields like n1\u2022\nbecause the sums of rows or columns are not stored directly in our data struc-\nture.\nJacques keeps his journal for three months. The resulting dataset is available\nin the coding sandbox for this chapter (https://eloquentjavascript.net/code#4),\nwhere it is stored in the JOURNAL binding, and in a downloadable file.\nTo extract a two-by-two table for a specific event from the journal, we must\nloop over all the entries and tally how many times the event occurs in relation\nto squirrel transformations:\nfunction tableFor(event, journal) {\nlet table = [0, 0, 0, 0];\nfor (let i = 0; i < journal.length; i++) {\nlet entry = journal[i], index = 0;\nif (entry.events.includes(event)) index += 1;\nif (entry.squirrel) index += 2;\ntable[index] += 1;\n}\nreturn table;\n}\nconsole.log(tableFor(\"pizza\", JOURNAL));\n// \u2192[76, 9, 4, 1]\nArrays have an includes method that checks whether a given value exists in",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_177",
    "text": "table[index] += 1;\n}\nreturn table;\n}\nconsole.log(tableFor(\"pizza\", JOURNAL));\n// \u2192[76, 9, 4, 1]\nArrays have an includes method that checks whether a given value exists in\nthe array. The function uses that to determine whether the event name it is\ninterested in is part of the event list for a given day.\nThe body of the loop in tableFor figures out which box in the table each\njournal entry falls into by checking whether the entry contains the specific event\nit\u2019s interested in and whether the event happens alongside a squirrel incident.\nThe loop then adds one to the correct box in the table.\nWe now have the tools we need to compute individual correlations. The only\nstep remaining is to find a correlation for every type of event that was recorded\nand see whether anything stands out.\nArray loops\nIn the tableFor function, there\u2019s a loop like this:\nfor (let i = 0; i < JOURNAL.length; i++) {\nlet entry = JOURNAL[i];\n// Do something with entry\n}\n65",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_178",
    "text": "and see whether anything stands out.\nArray loops\nIn the tableFor function, there\u2019s a loop like this:\nfor (let i = 0; i < JOURNAL.length; i++) {\nlet entry = JOURNAL[i];\n// Do something with entry\n}\n65\nThis kind of loop is common in classical JavaScript\u2014going over arrays one\nelement at a time is something that comes up a lot, and to do that you\u2019d run\na counter over the length of the array and pick out each element in turn.\nThere is a simpler way to write such loops in modern JavaScript:\nfor (let entry of JOURNAL) {\nconsole.log(`${entry.events.length} events.`);\n}\nWhen a for loop uses the word of after its variable definition, it will loop over\nthe elements of the value given after of. This works not only for arrays but\nalso for strings and some other data structures. We\u2019ll discuss how it works in\nChapter 6.\nThe final analysis\nWe need to compute a correlation for every type of event that occurs in the\ndataset. To do that, we first need to find every type of event.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_179",
    "text": "Chapter 6.\nThe final analysis\nWe need to compute a correlation for every type of event that occurs in the\ndataset. To do that, we first need to find every type of event.\nfunction journalEvents(journal) {\nlet events = [];\nfor (let entry of journal) {\nfor (let event of entry.events) {\nif (!events.includes(event)) {\nevents.push(event);\n}\n}\n}\nreturn events;\n}\nconsole.log(journalEvents(JOURNAL));\n// \u2192[\"carrot\", \"exercise\", \"weekend\", \"bread\", \u2026]\nBy adding any event names that aren\u2019t already in it to the events array, the\nfunction collects every type of event.\nUsing that function, we can see all the correlations:\nfor (let event of journalEvents(JOURNAL)) {\nconsole.log(event + \":\", phi(tableFor(event, JOURNAL)));\n}\n// \u2192carrot:\n0.0140970969\n// \u2192exercise: 0.0685994341\n// \u2192weekend:\n0.1371988681\n// \u2192bread:\n-0.0757554019\n66\n// \u2192pudding: -0.0648203724\n// And so on...\nMost correlations seem to lie close to zero. Eating carrots, bread, or pudding",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_180",
    "text": "// \u2192weekend:\n0.1371988681\n// \u2192bread:\n-0.0757554019\n66\n// \u2192pudding: -0.0648203724\n// And so on...\nMost correlations seem to lie close to zero. Eating carrots, bread, or pudding\napparently does not trigger squirrel-lycanthropy. The transformations do seem\nto occur somewhat more often on weekends. Let\u2019s filter the results to show\nonly correlations greater than 0.1 or less than -0.1:\nfor (let event of journalEvents(JOURNAL)) {\nlet correlation = phi(tableFor(event, JOURNAL));\nif (correlation > 0.1 || correlation < -0.1) {\nconsole.log(event + \":\", correlation);\n}\n}\n// \u2192weekend:\n0.1371988681\n// \u2192brushed teeth: -0.3805211953\n// \u2192candy:\n0.1296407447\n// \u2192work:\n-0.1371988681\n// \u2192spaghetti:\n0.2425356250\n// \u2192reading:\n0.1106828054\n// \u2192peanuts:\n0.5902679812\nAha! There are two factors with a correlation clearly stronger than the others.\nEating peanuts has a strong positive effect on the chance of turning into a\nsquirrel, whereas brushing teeth has a significant negative effect.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_181",
    "text": "Eating peanuts has a strong positive effect on the chance of turning into a\nsquirrel, whereas brushing teeth has a significant negative effect.\nInteresting. Let\u2019s try something.\nfor (let entry of JOURNAL) {\nif (entry.events.includes(\"peanuts\") &&\n!entry.events.includes(\"brushed teeth\")) {\nentry.events.push(\"peanut teeth\");\n}\n}\nconsole.log(phi(tableFor(\"peanut teeth\", JOURNAL)));\n// \u21921\nThat\u2019s a strong result. The phenomenon occurs precisely when Jacques eats\npeanuts and fails to brush his teeth. If only he weren\u2019t such a slob about dental\nhygiene, he\u2019d never even have noticed his affliction.\nKnowing this, Jacques stops eating peanuts altogether and finds that his\ntransformations stop.\nBut it takes only a few months for him to notice that something is missing\nfrom this entirely human way of living. Without his feral adventures, Jacques\nhardly feels alive at all. He decides he\u2019d rather be a full-time wild animal.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_182",
    "text": "from this entirely human way of living. Without his feral adventures, Jacques\nhardly feels alive at all. He decides he\u2019d rather be a full-time wild animal.\nAfter building a beautiful little tree house in the forest and equipping it with\n67\na peanut butter dispenser and a ten-year supply of peanut butter, he changes\nform one last time, and lives the short and energetic life of a squirrel.\nFurther arrayology\nBefore finishing the chapter, I want to introduce you to a few more object-\nrelated concepts. I\u2019ll start with some generally useful array methods.\nWe saw push and pop, which add and remove elements at the end of an array,\nearlier in this chapter. The corresponding methods for adding and removing\nthings at the start of an array are called unshift and shift.\nlet todoList = [];\nfunction remember(task) {\ntodoList.push(task);\n}\nfunction getTask() {\nreturn todoList.shift();\n}\nfunction rememberUrgently(task) {\ntodoList.unshift(task);\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_183",
    "text": "let todoList = [];\nfunction remember(task) {\ntodoList.push(task);\n}\nfunction getTask() {\nreturn todoList.shift();\n}\nfunction rememberUrgently(task) {\ntodoList.unshift(task);\n}\nThis program manages a queue of tasks. You add tasks to the end of the queue\nby calling remember(\"groceries\"), and when you\u2019re ready to do something,\nyou call getTask() to get (and remove) the front item from the queue. The\nrememberUrgently function also adds a task but adds it to the front instead of\nthe back of the queue.\nTo search for a specific value, arrays provide an indexOf method. The method\nsearches through the array from the start to the end and returns the index at\nwhich the requested value was found\u2014or -1 if it wasn\u2019t found. To search from\nthe end instead of the start, there\u2019s a similar method called lastIndexOf:\nconsole.log([1, 2, 3, 2, 1].indexOf(2));\n// \u21921\nconsole.log([1, 2, 3, 2, 1].lastIndexOf(2));\n// \u21923\nBoth indexOf and lastIndexOf take an optional second argument that indicates",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_184",
    "text": "console.log([1, 2, 3, 2, 1].indexOf(2));\n// \u21921\nconsole.log([1, 2, 3, 2, 1].lastIndexOf(2));\n// \u21923\nBoth indexOf and lastIndexOf take an optional second argument that indicates\nwhere to start searching.\nAnother fundamental array method is slice, which takes start and end in-\ndices and returns an array that has only the elements between them. The start\nindex is inclusive and the end index is exclusive.\n68\nconsole.log([0, 1, 2, 3, 4].slice(2, 4));\n// \u2192[2, 3]\nconsole.log([0, 1, 2, 3, 4].slice(2));\n// \u2192[2, 3, 4]\nWhen the end index is not given, slice will take all of the elements after the\nstart index. You can also omit the start index to copy the entire array.\nThe concat method can be used to append arrays together to create a new\narray, similar to what the + operator does for strings.\nThe following example shows both concat and slice in action. It takes an\narray and an index and returns a new array that is a copy of the original array\nwith the element at the given index removed:",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_185",
    "text": "The following example shows both concat and slice in action. It takes an\narray and an index and returns a new array that is a copy of the original array\nwith the element at the given index removed:\nfunction remove(array, index) {\nreturn array.slice(0, index)\n.concat(array.slice(index + 1));\n}\nconsole.log(remove([\"a\", \"b\", \"c\", \"d\", \"e\"], 2));\n// \u2192[\"a\", \"b\", \"d\", \"e\"]\nIf you pass concat an argument that is not an array, that value will be added\nto the new array as if it were a one-element array.\nStrings and their properties\nWe can read properties like length and toUpperCase from string values. But if\nwe try to add a new property, it doesn\u2019t stick.\nlet kim = \"Kim\";\nkim.age = 88;\nconsole.log(kim.age);\n// \u2192undefined\nValues of type string, number, and Boolean are not objects, and though the lan-\nguage doesn\u2019t complain if you try to set new properties on them, it doesn\u2019t ac-\ntually store those properties. As mentioned earlier, such values are immutable\nand cannot be changed.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_186",
    "text": "guage doesn\u2019t complain if you try to set new properties on them, it doesn\u2019t ac-\ntually store those properties. As mentioned earlier, such values are immutable\nand cannot be changed.\nBut these types do have built-in properties. Every string value has a number\nof methods. Some very useful ones are slice and indexOf, which resemble the\narray methods of the same name:\nconsole.log(\"coconuts\".slice(4, 7));\n// \u2192nut\nconsole.log(\"coconut\".indexOf(\"u\"));\n69\n// \u21925\nOne difference is that a string\u2019s indexOf can search for a string containing more\nthan one character, whereas the corresponding array method looks only for a\nsingle element:\nconsole.log(\"one two three\".indexOf(\"ee\"));\n// \u219211\nThe trim method removes whitespace (spaces, newlines, tabs, and similar char-\nacters) from the start and end of a string:\nconsole.log(\"\nokay \\n \".trim());\n// \u2192okay\nThe zeroPad function from the previous chapter also exists as a method. It is\ncalled padStart and takes the desired length and padding character as argu-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_187",
    "text": "console.log(\"\nokay \\n \".trim());\n// \u2192okay\nThe zeroPad function from the previous chapter also exists as a method. It is\ncalled padStart and takes the desired length and padding character as argu-\nments:\nconsole.log(String(6).padStart(3, \"0\"));\n// \u2192006\nYou can split a string on every occurrence of another string with split and\njoin it again with join:\nlet sentence = \"Secretarybirds specialize in stomping\";\nlet words = sentence.split(\" \");\nconsole.log(words);\n// \u2192[\"Secretarybirds\", \"specialize\", \"in\", \"stomping\"]\nconsole.log(words.join(\". \"));\n// \u2192Secretarybirds. specialize. in. stomping\nA string can be repeated with the repeat method, which creates a new string\ncontaining multiple copies of the original string, glued together:\nconsole.log(\"LA\".repeat(3));\n// \u2192LALALA\nWe have already seen the string type\u2019s length property. Accessing the individ-\nual characters in a string looks like accessing array elements (with a complica-\ntion that we\u2019ll discuss in Chapter 5).\nlet string = \"abc\";",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_188",
    "text": "ual characters in a string looks like accessing array elements (with a complica-\ntion that we\u2019ll discuss in Chapter 5).\nlet string = \"abc\";\nconsole.log(string.length);\n// \u21923\nconsole.log(string[1]);\n// \u2192b\n70\nRest parameters\nIt can be useful for a function to accept any number of arguments. For example,\nMath.max computes the maximum of all the arguments it is given. To write\nsuch a function, you put three dots before the function\u2019s last parameter, like\nthis:\nfunction max(...numbers) {\nlet result = -Infinity;\nfor (let number of numbers) {\nif (number > result) result = number;\n}\nreturn result;\n}\nconsole.log(max(4, 1, 9, -2));\n// \u21929\nWhen such a function is called, the rest parameter is bound to an array con-\ntaining all further arguments. If there are other parameters before it, their\nvalues aren\u2019t part of that array. When, as in max, it is the only parameter, it\nwill hold all arguments.\nYou can use a similar three-dot notation to call a function with an array of\narguments.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_189",
    "text": "values aren\u2019t part of that array. When, as in max, it is the only parameter, it\nwill hold all arguments.\nYou can use a similar three-dot notation to call a function with an array of\narguments.\nlet numbers = [5, 1, 7];\nconsole.log(max(...numbers));\n// \u21927\nThis \u201cspreads\u201d out the array into the function call, passing its elements as\nseparate arguments.\nIt is possible to include an array like that along with\nother arguments, as in max(9, ...numbers, 2).\nSquare bracket array notation similarly allows the triple-dot operator to\nspread another array into the new array:\nlet words = [\"never\", \"fully\"];\nconsole.log([\"will\", ...words, \"understand\"]);\n// \u2192[\"will\", \"never\", \"fully\", \"understand\"]\nThis works even in curly brace objects, where it adds all properties from another\nobject. If a property is added multiple times, the last value to be added wins:\nlet coordinates = {x: 10, y: 0};\nconsole.log({...coordinates, y: 5, z: 1});\n// \u2192{x: 10, y: 5, z: 1}\n71\nThe Math object",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_190",
    "text": "object. If a property is added multiple times, the last value to be added wins:\nlet coordinates = {x: 10, y: 0};\nconsole.log({...coordinates, y: 5, z: 1});\n// \u2192{x: 10, y: 5, z: 1}\n71\nThe Math object\nAs we\u2019ve seen, Math is a grab bag of number-related utility functions such as\nMath.max (maximum), Math.min (minimum), and Math.sqrt (square root).\nThe Math object is used as a container to group a bunch of related function-\nality. There is only one Math object, and it is almost never useful as a value.\nRather, it provides a namespace so that all these functions and values do not\nhave to be global bindings.\nHaving too many global bindings \u201cpollutes\u201d the namespace. The more names\nhave been taken, the more likely you are to accidentally overwrite the value of\nsome existing binding. For example, it\u2019s not unlikely you\u2019ll want to name some-\nthing max in one of your programs. Since JavaScript\u2019s built-in max function is\ntucked safely inside the Math object, you don\u2019t have to worry about overwriting",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_191",
    "text": "thing max in one of your programs. Since JavaScript\u2019s built-in max function is\ntucked safely inside the Math object, you don\u2019t have to worry about overwriting\nit.\nMany languages will stop you, or at least warn you, when you are defining\na binding with a name that is already taken. JavaScript does this for bindings\nyou declared with let or const but\u2014perversely\u2014not for standard bindings nor\nfor bindings declared with var or function.\nBack to the Math object. If you need to do trigonometry, Math can help. It\ncontains cos (cosine), sin (sine), and tan (tangent), as well as their inverse\nfunctions, acos, asin, and atan, respectively. The number \u03c0 (pi)\u2014or at least\nthe closest approximation that fits in a JavaScript number\u2014is available as Math\n.PI. There is an old programming tradition of writing the names of constant\nvalues in all caps.\nfunction randomPointOnCircle(radius) {\nlet angle = Math.random() * 2 * Math.PI;\nreturn {x: radius * Math.cos(angle),\ny: radius * Math.sin(angle)};\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_192",
    "text": "values in all caps.\nfunction randomPointOnCircle(radius) {\nlet angle = Math.random() * 2 * Math.PI;\nreturn {x: radius * Math.cos(angle),\ny: radius * Math.sin(angle)};\n}\nconsole.log(randomPointOnCircle(2));\n// \u2192{x: 0.3667, y: 1.966}\nIf you\u2019re not familiar with sines and cosines, don\u2019t worry. I\u2019ll explain them\nwhen they are used in Chapter 14.\nThe previous example used Math.random. This is a function that returns a\nnew pseudorandom number between 0 (inclusive) and 1 (exclusive) every time\nyou call it:\nconsole.log(Math.random());\n// \u21920.36993729369714856\nconsole.log(Math.random());\n72\n// \u21920.727367032552138\nconsole.log(Math.random());\n// \u21920.40180766698904335\nThough computers are deterministic machines\u2014they always react the same way\nif given the same input\u2014it is possible to have them produce numbers that ap-\npear random. To do that, the machine keeps some hidden value, and whenever\nyou ask for a new random number, it performs complicated computations on",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_193",
    "text": "pear random. To do that, the machine keeps some hidden value, and whenever\nyou ask for a new random number, it performs complicated computations on\nthis hidden value to create a new value. It stores a new value and returns some\nnumber derived from it. That way, it can produce ever new, hard-to-predict\nnumbers in a way that seems random.\nIf we want a whole random number instead of a fractional one, we can use\nMath.floor (which rounds down to the nearest whole number) on the result of\nMath.random:\nconsole.log(Math.floor(Math.random() * 10));\n// \u21922\nMultiplying the random number by 10 gives us a number greater than or equal\nto 0 and below 10. Since Math.floor rounds down, this expression will produce,\nwith equal chance, any number from 0 through 9.\nThere are also the functions Math.ceil (for \u201cceiling\u201d, which rounds up to\na whole number), Math.round (to the nearest whole number), and Math.abs,\nwhich takes the absolute value of a number, meaning it negates negative values",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_194",
    "text": "a whole number), Math.round (to the nearest whole number), and Math.abs,\nwhich takes the absolute value of a number, meaning it negates negative values\nbut leaves positive ones as they are.\nDestructuring\nLet\u2019s return to the phi function for a moment.\nfunction phi(table) {\nreturn (table[3] * table[0] - table[2] * table[1]) /\nMath.sqrt((table[2] + table[3]) *\n(table[0] + table[1]) *\n(table[1] + table[3]) *\n(table[0] + table[2]));\n}\nOne reason this function is awkward to read is that we have a binding pointing\nat our array, but we\u2019d much prefer to have bindings for the elements of the\narray\u2014that is, let n00 = table[0] and so on. Fortunately, there is a succinct\nway to do this in JavaScript:\n73\nfunction phi([n00, n01, n10, n11]) {\nreturn (n11 * n00 - n10 * n01) /\nMath.sqrt((n10 + n11) * (n00 + n01) *\n(n01 + n11) * (n00 + n10));\n}\nThis also works for bindings created with let, var, or const. If you know that\nthe value you are binding is an array, you can use square brackets to \u201clook",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_195",
    "text": "(n01 + n11) * (n00 + n10));\n}\nThis also works for bindings created with let, var, or const. If you know that\nthe value you are binding is an array, you can use square brackets to \u201clook\ninside\u201d of the value, binding its contents.\nA similar trick works for objects, using braces instead of square brackets.\nlet {name} = {name: \"Faraji\", age: 23};\nconsole.log(name);\n// \u2192Faraji\nNote that if you try to destructure null or undefined, you get an error, much\nas you would if you directly try to access a property of those values.\nOptional property access\nWhen you aren\u2019t sure whether a given value produces an object, but still want\nto read a property from it when it does, you can use a variant of the dot\nnotation: object?.property.\nfunction city(object) {\nreturn object.address?.city;\n}\nconsole.log(city({address: {city: \"Toronto\"}}));\n// \u2192Toronto\nconsole.log(city({name: \"Vera\"}));\n// \u2192undefined\nThe expression a?.b means the same as a.b when a isn\u2019t null or undefined.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_196",
    "text": "}\nconsole.log(city({address: {city: \"Toronto\"}}));\n// \u2192Toronto\nconsole.log(city({name: \"Vera\"}));\n// \u2192undefined\nThe expression a?.b means the same as a.b when a isn\u2019t null or undefined.\nWhen it is, it evaluates to undefined. This can be convenient when, as in the\nexample, you aren\u2019t sure that a given property exists or when a variable might\nhold an undefined value.\nA similar notation can be used with square bracket access, and even with\nfunction calls, by putting ?. in front of the parentheses or brackets:\nconsole.log(\"string\".notAMethod?.());\n// \u2192undefined\nconsole.log({}.arrayProp?.[0]);\n// \u2192undefined\n74\nJSON\nBecause properties grasp their value rather than contain it, objects and ar-\nrays are stored in the computer\u2019s memory as sequences of bits holding the\naddresses\u2014the place in memory\u2014of their contents. An array with another ar-\nray inside of it consists of (at least) one memory region for the inner array and\nanother for the outer array, containing (among other things) a number that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_197",
    "text": "ray inside of it consists of (at least) one memory region for the inner array and\nanother for the outer array, containing (among other things) a number that\nrepresents the address of the inner array.\nIf you want to save data in a file for later or send it to another computer over\nthe network, you have to somehow convert these tangles of memory addresses\nto a description that can be stored or sent. You could send over your entire\ncomputer memory along with the address of the value you\u2019re interested in, I\nsuppose, but that doesn\u2019t seem like the best approach.\nWhat we can do is serialize the data. That means it is converted into a\nflat description. A popular serialization format is called JSON (pronounced\n\u201cJason\u201d), which stands for JavaScript Object Notation. It is widely used as a\ndata storage and communication format on the web, even with languages other\nthan JavaScript.\nJSON looks similar to JavaScript\u2019s way of writing arrays and objects, with a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_198",
    "text": "data storage and communication format on the web, even with languages other\nthan JavaScript.\nJSON looks similar to JavaScript\u2019s way of writing arrays and objects, with a\nfew restrictions. All property names have to be surrounded by double quotes,\nand only simple data expressions are allowed\u2014no function calls, bindings, or\nanything that involves actual computation.\nComments are not allowed in\nJSON.\nA journal entry might look like this when represented as JSON data:\n{\n\"squirrel\": false,\n\"events\": [\"work\", \"touched tree\", \"pizza\", \"running\"]\n}\nJavaScript gives us the functions JSON.stringify and JSON.parse to convert\ndata to and from this format. The first takes a JavaScript value and returns\na JSON-encoded string. The second takes such a string and converts it to the\nvalue it encodes:\nlet string = JSON.stringify({squirrel: false,\nevents: [\"weekend\"]});\nconsole.log(string);\n// \u2192{\"squirrel\":false,\"events\":[\"weekend\"]}\nconsole.log(JSON.parse(string).events);\n// \u2192[\"weekend\"]\n75\nSummary",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_199",
    "text": "let string = JSON.stringify({squirrel: false,\nevents: [\"weekend\"]});\nconsole.log(string);\n// \u2192{\"squirrel\":false,\"events\":[\"weekend\"]}\nconsole.log(JSON.parse(string).events);\n// \u2192[\"weekend\"]\n75\nSummary\nObjects and arrays provide ways to group several values into a single value.\nThis allows us to put a bunch of related things in a bag and run around with\nthe bag instead of wrapping our arms around all of the individual things and\ntrying to hold on to them separately.\nMost values in JavaScript have properties, with the exceptions being null\nand undefined. Properties are accessed using value.prop or value[\"prop\"].\nObjects tend to use names for their properties and store more or less a fixed\nset of them. Arrays, on the other hand, usually contain varying amounts of\nconceptually identical values and use numbers (starting from 0) as the names\nof their properties.\nThere are some named properties in arrays, such as length and a number of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_200",
    "text": "conceptually identical values and use numbers (starting from 0) as the names\nof their properties.\nThere are some named properties in arrays, such as length and a number of\nmethods. Methods are functions that live in properties and (usually) act on\nthe value of which they are a property.\nYou can iterate over arrays using a special kind of for loop:\nfor (let\nelement of array).\nExercises\nThe sum of a range\nThe introduction of this book alluded to the following as a nice way to compute\nthe sum of a range of numbers:\nconsole.log(sum(range(1, 10)));\nWrite a range function that takes two arguments, start and end, and returns\nan array containing all the numbers from start up to and including end.\nNext, write a sum function that takes an array of numbers and returns the\nsum of these numbers.\nRun the example program and see whether it does\nindeed return 55.\nAs a bonus assignment, modify your range function to take an optional third",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_201",
    "text": "sum of these numbers.\nRun the example program and see whether it does\nindeed return 55.\nAs a bonus assignment, modify your range function to take an optional third\nargument that indicates the \u201cstep\u201d value used when building the array. If no\nstep is given, the elements should go up by increments of one, corresponding\nto the old behavior. The function call range(1, 10, 2) should return [1,\n3, 5, 7, 9].\nMake sure this also works with negative step values so that\nrange(5, 2, -1) produces [5, 4, 3, 2].\n76\nReversing an array\nArrays have a reverse method that changes the array by inverting the order in\nwhich its elements appear. For this exercise, write two functions, reverseArray\nand reverseArrayInPlace. The first, reverseArray, should take an array as its\nargument and produce a new array that has the same elements in the inverse\norder. The second, reverseArrayInPlace, should do what the reverse method\ndoes: modify the array given as its argument by reversing its elements. Neither",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_202",
    "text": "order. The second, reverseArrayInPlace, should do what the reverse method\ndoes: modify the array given as its argument by reversing its elements. Neither\nmay use the standard reverse method.\nThinking back to the notes about side effects and pure functions in the\nprevious chapter, which variant do you expect to be useful in more situations?\nWhich one runs faster?\nA list\nAs generic blobs of values, objects can be used to build all sorts of data struc-\ntures. A common data structure is the list (not to be confused with arrays).\nA list is a nested set of objects, with the first object holding a reference to the\nsecond, the second to the third, and so on:\nlet list = {\nvalue: 1,\nrest: {\nvalue: 2,\nrest: {\nvalue: 3,\nrest: null\n}\n}\n};\nThe resulting objects form a chain, as shown in the following diagram:\nvalue: 1\nrest:\nvalue: 2\nrest:\nvalue: 3\nrest: null\nA nice thing about lists is that they can share parts of their structure. For",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_203",
    "text": "The resulting objects form a chain, as shown in the following diagram:\nvalue: 1\nrest:\nvalue: 2\nrest:\nvalue: 3\nrest: null\nA nice thing about lists is that they can share parts of their structure. For\nexample, if I create two new values {value: 0, rest: list} and {value: -1,\nrest: list} (with list referring to the binding defined earlier), they are both\nindependent lists, but they share the structure that makes up their last three\nelements. The original list is also still a valid three-element list.\nWrite a function arrayToList that builds up a list structure like the one\n77\nshown when given [1, 2, 3] as argument. Also write a listToArray function\nthat produces an array from a list. Add the helper functions prepend, which\ntakes an element and a list and creates a new list that adds the element to the\nfront of the input list, and nth, which takes a list and a number and returns\nthe element at the given position in the list (with zero referring to the first",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_204",
    "text": "front of the input list, and nth, which takes a list and a number and returns\nthe element at the given position in the list (with zero referring to the first\nelement) or undefined when there is no such element.\nIf you haven\u2019t already, also write a recursive version of nth.\nDeep comparison\nThe == operator compares objects by identity, but sometimes you\u2019d prefer to\ncompare the values of their actual properties.\nWrite a function deepEqual that takes two values and returns true only\nif they are the same value or are objects with the same properties, where\nthe values of the properties are equal when compared with a recursive call to\ndeepEqual.\nTo find out whether values should be compared directly (using the === op-\nerator for that) or have their properties compared, you can use the typeof\noperator. If it produces \"object\" for both values, you should do a deep com-\nparison. But you have to take one silly exception into account: because of a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_205",
    "text": "operator. If it produces \"object\" for both values, you should do a deep com-\nparison. But you have to take one silly exception into account: because of a\nhistorical accident, typeof null also produces \"object\".\nThe Object.keys function will be useful when you need to go over the prop-\nerties of objects to compare them.\n78\n\u201c\nThere are two ways of constructing a software design: One way is to\nmake it so simple that there are obviously no deficiencies, and the\nother way is to make it so complicated that there are no obvious\ndeficiencies.\u201d\n\u2014C.A.R. Hoare, 1980 ACM Turing Award Lecture\nChapter 5\nHigher-Order Functions\nA large program is a costly program, and not just because of the time it takes\nto build.\nSize almost always involves complexity, and complexity confuses\nprogrammers. Confused programmers, in turn, introduce mistakes (bugs) into\nprograms. A large program then provides a lot of space for these bugs to hide,\nmaking them hard to find.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_206",
    "text": "programmers. Confused programmers, in turn, introduce mistakes (bugs) into\nprograms. A large program then provides a lot of space for these bugs to hide,\nmaking them hard to find.\nLet\u2019s briefly go back to the final two example programs in the introduction.\nThe first is self contained and six lines long.\nlet total = 0, count = 1;\nwhile (count <= 10) {\ntotal += count;\ncount += 1;\n}\nconsole.log(total);\nThe second relies on two external functions and is one line long.\nconsole.log(sum(range(1, 10)));\nWhich one is more likely to contain a bug?\nIf we count the size of the definitions of sum and range, the second program\nis also big\u2014even bigger than the first. But still, I\u2019d argue that it is more likely\nto be correct.\nThis is because the solution is expressed in a vocabulary that corresponds to\nthe problem being solved. Summing a range of numbers isn\u2019t about loops and\ncounters. It is about ranges and sums.\nThe definitions of this vocabulary (the functions sum and range) will still",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_207",
    "text": "the problem being solved. Summing a range of numbers isn\u2019t about loops and\ncounters. It is about ranges and sums.\nThe definitions of this vocabulary (the functions sum and range) will still\ninvolve loops, counters, and other incidental details.\nBut because they are\nexpressing simpler concepts than the program as a whole, they are easier to\nget right.\n79\nAbstraction\nIn the context of programming, these kinds of vocabularies are usually called\nabstractions. Abstractions give us the ability to talk about problems at a higher\n(or more abstract) level, without getting sidetracked by uninteresting details.\nAs an analogy, compare these two recipes for pea soup. The first goes like\nthis:\nPut 1 cup of dried peas per person into a container. Add water\nuntil the peas are well covered. Leave the peas in water for at least\n12 hours. Take the peas out of the water and put them in a cooking\npan. Add 4 cups of water per person. Cover the pan and keep the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_208",
    "text": "until the peas are well covered. Leave the peas in water for at least\n12 hours. Take the peas out of the water and put them in a cooking\npan. Add 4 cups of water per person. Cover the pan and keep the\npeas simmering for two hours. Take half an onion per person. Cut\nit into pieces with a knife. Add it to the peas. Take a stalk of\ncelery per person. Cut it into pieces with a knife. Add it to the\npeas. Take a carrot per person. Cut it into pieces. With a knife!\nAdd it to the peas. Cook for 10 more minutes.\nAnd this is the second recipe:\nPer person: 1 cup dried split peas, 4 cups of water, half a chopped\nonion, a stalk of celery, and a carrot.\nSoak peas for 12 hours. Simmer for 2 hours. Chop and add veg-\netables. Cook for 10 more minutes.\nThe second is shorter and easier to interpret. But you do need to understand\na few more cooking-related words such as soak, simmer, chop, and, I guess,\nvegetable.\nWhen programming, we can\u2019t rely on all the words we need to be waiting for",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_209",
    "text": "a few more cooking-related words such as soak, simmer, chop, and, I guess,\nvegetable.\nWhen programming, we can\u2019t rely on all the words we need to be waiting for\nus in the dictionary. Thus, we might fall into the pattern of the first recipe\u2014\nwork out the precise steps the computer has to perform, one by one, blind to\nthe higher-level concepts they express.\nIt is a useful skill, in programming, to notice when you are working at too\nlow a level of abstraction.\nAbstracting repetition\nPlain functions, as we\u2019ve seen them so far, are a good way to build abstractions.\nBut sometimes they fall short.\nIt is common for a program to do something a given number of times. You\ncan write a for loop for that, like this:\n80\nfor (let i = 0; i < 10; i++) {\nconsole.log(i);\n}\nCan we abstract \u201cdoing something N times\u201d as a function? Well, it\u2019s easy to\nwrite a function that calls console.log N times.\nfunction repeatLog(n) {\nfor (let i = 0; i < n; i++) {\nconsole.log(i);\n}\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_210",
    "text": "}\nCan we abstract \u201cdoing something N times\u201d as a function? Well, it\u2019s easy to\nwrite a function that calls console.log N times.\nfunction repeatLog(n) {\nfor (let i = 0; i < n; i++) {\nconsole.log(i);\n}\n}\nBut what if we want to do something other than logging the numbers? Since\n\u201cdoing something\u201d can be represented as a function and functions are just\nvalues, we can pass our action as a function value.\nfunction repeat(n, action) {\nfor (let i = 0; i < n; i++) {\naction(i);\n}\n}\nrepeat(3, console.log);\n// \u21920\n// \u21921\n// \u21922\nWe don\u2019t have to pass a predefined function to repeat. Often, it is easier to\ncreate a function value on the spot instead.\nlet labels = [];\nrepeat(5, i => {\nlabels.push(`Unit ${i + 1}`);\n});\nconsole.log(labels);\n// \u2192[\"Unit 1\", \"Unit 2\", \"Unit 3\", \"Unit 4\", \"Unit 5\"]\nThis is structured a little like a for loop\u2014it first describes the kind of loop and\nthen provides a body. However, the body is now written as a function value,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_211",
    "text": "This is structured a little like a for loop\u2014it first describes the kind of loop and\nthen provides a body. However, the body is now written as a function value,\nwhich is wrapped in the parentheses of the call to repeat. This is why it has\nto be closed with the closing brace and closing parenthesis. In cases like this\nexample, where the body is a single small expression, you could also omit the\nbraces and write the loop on a single line.\n81\nHigher-order functions\nFunctions that operate on other functions, either by taking them as arguments\nor by returning them, are called higher-order functions. Since we have already\nseen that functions are regular values, there is nothing particularly remarkable\nabout the fact that such functions exist. The term comes from mathemat-\nics, where the distinction between functions and other values is taken more\nseriously.\nHigher-order functions allow us to abstract over actions, not just values.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_212",
    "text": "ics, where the distinction between functions and other values is taken more\nseriously.\nHigher-order functions allow us to abstract over actions, not just values.\nThey come in several forms. For example, we can have functions that create\nnew functions.\nfunction greaterThan(n) {\nreturn m => m > n;\n}\nlet greaterThan10 = greaterThan(10);\nconsole.log(greaterThan10(11));\n// \u2192true\nWe can also have functions that change other functions.\nfunction noisy(f) {\nreturn (...args) => {\nconsole.log(\"calling with\", args);\nlet result = f(...args);\nconsole.log(\"called with\", args, \", returned\", result);\nreturn result;\n};\n}\nnoisy(Math.min)(3, 2, 1);\n// \u2192calling with [3, 2, 1]\n// \u2192called with [3, 2, 1] , returned 1\nWe can even write functions that provide new types of control flow.\nfunction unless(test, then) {\nif (!test) then();\n}\nrepeat(3, n => {\nunless(n % 2 == 1, () => {\nconsole.log(n, \"is even\");\n});\n});\n// \u21920 is even\n82\n// \u21922 is even",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_213",
    "text": "function unless(test, then) {\nif (!test) then();\n}\nrepeat(3, n => {\nunless(n % 2 == 1, () => {\nconsole.log(n, \"is even\");\n});\n});\n// \u21920 is even\n82\n// \u21922 is even\nThere is a built-in array method, forEach, that provides something like a for\n/of loop as a higher-order function.\n[\"A\", \"B\"].forEach(l => console.log(l));\n// \u2192A\n// \u2192B\nScript dataset\nOne area where higher-order functions shine is data processing. To process\ndata, we\u2019ll need some actual example data. This chapter will use a dataset\nabout scripts\u2014writing systems such as Latin, Cyrillic, or Arabic.\nRemember Unicode, the system that assigns a number to each character in\nwritten language, from Chapter 1? Most of these characters are associated\nwith a specific script. The standard contains 140 different scripts, of which 81\nare still in use today and 59 are historic.\nThough I can fluently read only Latin characters, I appreciate the fact that\npeople are writing texts in at least 80 other writing systems, many of which I",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_214",
    "text": "are still in use today and 59 are historic.\nThough I can fluently read only Latin characters, I appreciate the fact that\npeople are writing texts in at least 80 other writing systems, many of which I\nwouldn\u2019t even recognize. For example, here\u2019s a sample of Tamil handwriting:\nThe example dataset contains some pieces of information about the 140\nscripts defined in Unicode. It is available in the coding sandbox for this chapter\n(https://eloquentjavascript.net/code#5) as the SCRIPTS binding. The binding\ncontains an array of objects, each of which describes a script.\n{\nname: \"Coptic\",\nranges: [[994, 1008], [11392, 11508], [11513, 11520]],\ndirection: \"ltr\",\nyear: -200,\nliving: false,\nlink: \"https://en.wikipedia.org/wiki/Coptic_alphabet\"\n}\nSuch an object tells us the name of the script, the Unicode ranges assigned to\nit, the direction in which it is written, the (approximate) origin time, whether\n83\nit is still in use, and a link to more information. The direction may be \"ltr\"",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_215",
    "text": "it, the direction in which it is written, the (approximate) origin time, whether\n83\nit is still in use, and a link to more information. The direction may be \"ltr\"\nfor left to right, \"rtl\" for right to left (the way Arabic and Hebrew text are\nwritten), or \"ttb\" for top to bottom (as with Mongolian writing).\nThe ranges property contains an array of Unicode character ranges, each of\nwhich is a two-element array containing a lower bound and an upper bound.\nAny character codes within these ranges are assigned to the script. The lower\nbound is inclusive (code 994 is a Coptic character) and the upper bound is\nnoninclusive (code 1008 isn\u2019t).\nFiltering arrays\nIf we want to find the scripts in the dataset that are still in use, the following\nfunction might be helpful. It filters out elements in an array that don\u2019t pass a\ntest.\nfunction filter(array, test) {\nlet passed = [];\nfor (let element of array) {\nif (test(element)) {\npassed.push(element);\n}\n}\nreturn passed;\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_216",
    "text": "test.\nfunction filter(array, test) {\nlet passed = [];\nfor (let element of array) {\nif (test(element)) {\npassed.push(element);\n}\n}\nreturn passed;\n}\nconsole.log(filter(SCRIPTS, script => script.living));\n// \u2192[{name: \"Adlam\", \u2026}, \u2026]\nThe function uses the argument named test, a function value, to fill a \u201cgap\u201d\nin the computation\u2014the process of deciding which elements to collect.\nNote how the filter function, rather than deleting elements from the ex-\nisting array, builds up a new array with only the elements that pass the test.\nThis function is pure. It does not modify the array it is given.\nLike forEach, filter is a standard array method. The example defined the\nfunction only to show what it does internally. From now on, we\u2019ll use it like\nthis instead:\nconsole.log(SCRIPTS.filter(s => s.direction == \"ttb\"));\n// \u2192[{name: \"Mongolian\", \u2026}, \u2026]\n84\nTransforming with map\nSay we have an array of objects representing scripts, produced by filtering the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_217",
    "text": "console.log(SCRIPTS.filter(s => s.direction == \"ttb\"));\n// \u2192[{name: \"Mongolian\", \u2026}, \u2026]\n84\nTransforming with map\nSay we have an array of objects representing scripts, produced by filtering the\nSCRIPTS array somehow. We want an array of names instead, which is easier\nto inspect.\nThe map method transforms an array by applying a function to all of its\nelements and building a new array from the returned values. The new array\nwill have the same length as the input array, but its content will have been\nmapped to a new form by the function.\nfunction map(array, transform) {\nlet mapped = [];\nfor (let element of array) {\nmapped.push(transform(element));\n}\nreturn mapped;\n}\nlet rtlScripts = SCRIPTS.filter(s => s.direction == \"rtl\");\nconsole.log(map(rtlScripts, s => s.name));\n// \u2192[\"Adlam\", \"Arabic\", \"Imperial Aramaic\", \u2026]\nLike forEach and filter, map is a standard array method.\nSummarizing with reduce\nAnother common thing to do with arrays is to compute a single value from",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_218",
    "text": "// \u2192[\"Adlam\", \"Arabic\", \"Imperial Aramaic\", \u2026]\nLike forEach and filter, map is a standard array method.\nSummarizing with reduce\nAnother common thing to do with arrays is to compute a single value from\nthem. Our recurring example, summing a collection of numbers, is an instance\nof this. Another example is finding the script with the most characters.\nThe higher-order operation that represents this pattern is called reduce (some-\ntimes also called fold). It builds a value by repeatedly taking a single element\nfrom the array and combining it with the current value. When summing num-\nbers, you\u2019d start with the number zero and, for each element, add that to the\nsum.\nThe parameters to reduce are, apart from the array, a combining function\nand a start value. This function is a little less straightforward than filter and\nmap, so take a close look at it:\nfunction reduce(array, combine, start) {\nlet current = start;\nfor (let element of array) {\ncurrent = combine(current, element);\n}\n85",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_219",
    "text": "map, so take a close look at it:\nfunction reduce(array, combine, start) {\nlet current = start;\nfor (let element of array) {\ncurrent = combine(current, element);\n}\n85\nreturn current;\n}\nconsole.log(reduce([1, 2, 3, 4], (a, b) => a + b, 0));\n// \u219210\nThe standard array method reduce, which of course corresponds to this func-\ntion, has an added convenience. If your array contains at least one element,\nyou are allowed to leave off the start argument. The method will take the first\nelement of the array as its start value and start reducing at the second element.\nconsole.log([1, 2, 3, 4].reduce((a, b) => a + b));\n// \u219210\nTo use reduce (twice) to find the script with the most characters, we can write\nsomething like this:\nfunction characterCount(script) {\nreturn script.ranges.reduce((count, [from, to]) => {\nreturn count + (to - from);\n}, 0);\n}\nconsole.log(SCRIPTS.reduce((a, b) => {\nreturn characterCount(a) < characterCount(b) ? b : a;\n}));\n// \u2192{name: \"Han\", \u2026}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_220",
    "text": "return count + (to - from);\n}, 0);\n}\nconsole.log(SCRIPTS.reduce((a, b) => {\nreturn characterCount(a) < characterCount(b) ? b : a;\n}));\n// \u2192{name: \"Han\", \u2026}\nThe characterCount function reduces the ranges assigned to a script by sum-\nming their sizes. Note the use of destructuring in the parameter list of the\nreducer function. The second call to reduce then uses this to find the largest\nscript by repeatedly comparing two scripts and returning the larger one.\nThe Han script has more than 89,000 characters assigned to it in the Unicode\nstandard, making it by far the biggest writing system in the dataset. Han is a\nscript sometimes used for Chinese, Japanese, and Korean text. Those languages\nshare a lot of characters, though they tend to write them differently. The (US-\nbased) Unicode Consortium decided to treat them as a single writing system\nto save character codes. This is called Han unification and still makes some\npeople very angry.\nComposability",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_221",
    "text": "based) Unicode Consortium decided to treat them as a single writing system\nto save character codes. This is called Han unification and still makes some\npeople very angry.\nComposability\nConsider how we would have written the previous example (finding the biggest\nscript) without higher-order functions. The code is not that much worse.\n86\nlet biggest = null;\nfor (let script of SCRIPTS) {\nif (biggest == null ||\ncharacterCount(biggest) < characterCount(script)) {\nbiggest = script;\n}\n}\nconsole.log(biggest);\n// \u2192{name: \"Han\", \u2026}\nThere are a few more bindings, and the program is four lines longer, but it is\nstill very readable.\nThe abstractions these functions provide really shine when you need to com-\npose operations. As an example, let\u2019s write code that finds the average year of\norigin for living and dead scripts in the dataset.\nfunction average(array) {\nreturn array.reduce((a, b) => a + b) / array.length;\n}\nconsole.log(Math.round(average(\nSCRIPTS.filter(s => s.living).map(s => s.year))));",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_222",
    "text": "function average(array) {\nreturn array.reduce((a, b) => a + b) / array.length;\n}\nconsole.log(Math.round(average(\nSCRIPTS.filter(s => s.living).map(s => s.year))));\n// \u21921165\nconsole.log(Math.round(average(\nSCRIPTS.filter(s => !s.living).map(s => s.year))));\n// \u2192204\nAs you can see, the dead scripts in Unicode are, on average, older than the\nliving ones. This is not a terribly meaningful or surprising statistic. But I hope\nyou\u2019ll agree that the code used to compute it isn\u2019t hard to read. You can see\nit as a pipeline: we start with all scripts, filter out the living (or dead) ones,\ntake the years from those, average them, and round the result.\nYou could definitely also write this computation as one big loop.\nlet total = 0, count = 0;\nfor (let script of SCRIPTS) {\nif (script.living) {\ntotal += script.year;\ncount += 1;\n}\n}\nconsole.log(Math.round(total / count));\n// \u21921165\nHowever, it is harder to see what was being computed and how. And because\n87",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_223",
    "text": "if (script.living) {\ntotal += script.year;\ncount += 1;\n}\n}\nconsole.log(Math.round(total / count));\n// \u21921165\nHowever, it is harder to see what was being computed and how. And because\n87\nintermediate results aren\u2019t represented as coherent values, it\u2019d be a lot more\nwork to extract something like average into a separate function.\nIn terms of what the computer is actually doing, these two approaches are\nalso quite different. The first will build up new arrays when running filter\nand map, whereas the second computes only some numbers, doing less work.\nYou can usually afford the readable approach, but if you\u2019re processing huge\narrays and doing so many times, the less abstract style might be worth the\nextra speed.\nStrings and character codes\nOne interesting use of this dataset would be figuring out what script a piece of\ntext is using. Let\u2019s go through a program that does this.\nRemember that each script has an array of character code ranges associated",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_224",
    "text": "text is using. Let\u2019s go through a program that does this.\nRemember that each script has an array of character code ranges associated\nwith it. Given a character code, we could use a function like this to find the\ncorresponding script (if any):\nfunction characterScript(code) {\nfor (let script of SCRIPTS) {\nif (script.ranges.some(([from, to]) => {\nreturn code >= from && code < to;\n})) {\nreturn script;\n}\n}\nreturn null;\n}\nconsole.log(characterScript(121));\n// \u2192{name: \"Latin\", \u2026}\nThe some method is another higher-order function. It takes a test function and\ntells you whether that function returns true for any of the elements in the array.\nBut how do we get the character codes in a string?\nIn Chapter 1 I mentioned that JavaScript strings are encoded as a sequence\nof 16-bit numbers. These are called code units. A Unicode character code was\ninitially supposed to fit within such a unit (which gives you a little over 65,000\ncharacters).\nWhen it became clear that wasn\u2019t going to be enough, many",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_225",
    "text": "initially supposed to fit within such a unit (which gives you a little over 65,000\ncharacters).\nWhen it became clear that wasn\u2019t going to be enough, many\npeople balked at the need to use more memory per character. To address these\nconcerns, UTF-16, the format also used by JavaScript strings, was invented. It\ndescribes most common characters using a single 16-bit code unit but uses a\npair of two such units for others.\n88\nUTF-16 is generally considered a bad idea today. It seems almost inten-\ntionally designed to invite mistakes. It\u2019s easy to write programs that pretend\ncode units and characters are the same thing. And if your language doesn\u2019t use\ntwo-unit characters, that will appear to work just fine. But as soon as some-\none tries to use such a program with some less common Chinese characters,\nit breaks. Fortunately, with the advent of emoji, everybody has started us-\ning two-unit characters, and the burden of dealing with such problems is more\nfairly distributed.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_226",
    "text": "it breaks. Fortunately, with the advent of emoji, everybody has started us-\ning two-unit characters, and the burden of dealing with such problems is more\nfairly distributed.\nUnfortunately, obvious operations on JavaScript strings, such as getting their\nlength through the length property and accessing their content using square\nbrackets, deal only with code units.\n// Two emoji characters, horse and shoe\nlet horseShoe = \"\ud83d\udc34\ud83d\udc5f\";\nconsole.log(horseShoe.length);\n// \u21924\nconsole.log(horseShoe[0]);\n// \u2192(Invalid half-character)\nconsole.log(horseShoe.charCodeAt(0));\n// \u219255357 (Code of the half-character)\nconsole.log(horseShoe.codePointAt(0));\n// \u2192128052 (Actual code for horse emoji)\nJavaScript\u2019s charCodeAt method gives you a code unit, not a full character code.\nThe codePointAt method, added later, does give a full Unicode character, so\nwe could use that to get characters from a string. But the argument passed to\ncodePointAt is still an index into the sequence of code units. To run over all",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_227",
    "text": "we could use that to get characters from a string. But the argument passed to\ncodePointAt is still an index into the sequence of code units. To run over all\ncharacters in a string, we\u2019d still need to deal with the question of whether a\ncharacter takes up one or two code units.\nIn the previous chapter, I mentioned that a for/of loop can also be used\non strings. Like codePointAt, this type of loop was introduced at a time when\npeople were acutely aware of the problems with UTF-16. When you use it to\nloop over a string, it gives you real characters, not code units.\nlet roseDragon = \"\ud83c\udf39\ud83d\udc09\";\nfor (let char of roseDragon) {\nconsole.log(char);\n}\n// \u2192\ud83c\udf39\n// \u2192\ud83d\udc09\nIf you have a character (which will be a string of one or two code units), you\ncan use codePointAt(0) to get its code.\n89\nRecognizing text\nWe have a characterScript function and a way to correctly loop over charac-\nters. The next step is to count the characters that belong to each script. The",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_228",
    "text": "89\nRecognizing text\nWe have a characterScript function and a way to correctly loop over charac-\nters. The next step is to count the characters that belong to each script. The\nfollowing counting abstraction will be useful there:\nfunction countBy(items, groupName) {\nlet counts = [];\nfor (let item of items) {\nlet name = groupName(item);\nlet known = counts.find(c => c.name == name);\nif (!known) {\ncounts.push({name, count: 1});\n} else {\nknown.count++;\n}\n}\nreturn counts;\n}\nconsole.log(countBy([1, 2, 3, 4, 5], n => n > 2));\n// \u2192[{name: false, count: 2}, {name: true, count: 3}]\nThe countBy function expects a collection (anything that we can loop over with\nfor/of) and a function that computes a group name for a given element. It\nreturns an array of objects, each of which names a group and tells you the\nnumber of elements that were found in that group.\nIt uses another array method, find, which goes over the elements in the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_229",
    "text": "returns an array of objects, each of which names a group and tells you the\nnumber of elements that were found in that group.\nIt uses another array method, find, which goes over the elements in the\narray and returns the first one for which a function returns true. It returns\nundefined when it finds no such element.\nUsing countBy, we can write the function that tells us which scripts are used\nin a piece of text.\nfunction textScripts(text) {\nlet scripts = countBy(text, char => {\nlet script = characterScript(char.codePointAt(0));\nreturn script ? script.name : \"none\";\n}).filter(({name}) => name != \"none\");\nlet total = scripts.reduce((n, {count}) => n + count, 0);\nif (total == 0) return \"No scripts found\";\nreturn scripts.map(({name, count}) => {\nreturn `${Math.round(count * 100 / total)}% ${name}`;\n}).join(\", \");\n90\n}\nconsole.log(textScripts('\u82f1\u56fd\u7684\u72d7\u8bf4\"woof\", \u4fc4\u7f57\u65af\u7684\u72d7\u8bf4\"\u0442\u044f\u0432\"'));\n// \u219261% Han, 22% Latin, 17% Cyrillic\nThe function first counts the characters by name, using characterScript to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_230",
    "text": "}).join(\", \");\n90\n}\nconsole.log(textScripts('\u82f1\u56fd\u7684\u72d7\u8bf4\"woof\", \u4fc4\u7f57\u65af\u7684\u72d7\u8bf4\"\u0442\u044f\u0432\"'));\n// \u219261% Han, 22% Latin, 17% Cyrillic\nThe function first counts the characters by name, using characterScript to\nassign them a name and falling back to the string \"none\" for characters that\naren\u2019t part of any script. The filter call drops the entry for \"none\" from the\nresulting array, since we aren\u2019t interested in those characters.\nTo be able to compute percentages, we first need the total number of charac-\nters that belong to a script, which we can compute with reduce. If we find no\nsuch characters, the function returns a specific string. Otherwise, it transforms\nthe counting entries into readable strings with map and then combines them\nwith join.\nSummary\nBeing able to pass function values to other functions is a deeply useful aspect\nof JavaScript. It allows us to write functions that model computations with\n\u201cgaps\u201d in them. The code that calls these functions can fill in the gaps by\nproviding function values.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_231",
    "text": "of JavaScript. It allows us to write functions that model computations with\n\u201cgaps\u201d in them. The code that calls these functions can fill in the gaps by\nproviding function values.\nArrays provide a number of useful higher-order methods.\nYou can use\nforEach to loop over the elements in an array. The filter method returns\na new array containing only the elements that pass the predicate function.\nYou can transform an array by putting each element through a function using\nmap. You can use reduce to combine all the elements in an array into a single\nvalue. The some method tests whether any element matches a given predicate\nfunction, while find finds the first element that matches a predicate.\nExercises\nFlattening\nUse the reduce method in combination with the concat method to \u201cflatten\u201d\nan array of arrays into a single array that has all the elements of the original\narrays.\nYour own loop\nWrite a higher-order function loop that provides something like a for loop",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_232",
    "text": "an array of arrays into a single array that has all the elements of the original\narrays.\nYour own loop\nWrite a higher-order function loop that provides something like a for loop\nstatement. It should take a value, a test function, an update function, and\n91\na body function. Each iteration, it should first run the test function on the\ncurrent loop value and stop if that returns false. It should then call the body\nfunction, giving it the current value, and finally call the update function to\ncreate a new value and start over from the beginning.\nWhen defining the function, you can use a regular loop to do the actual\nlooping.\nEverything\nArrays also have an every method analogous to the some method. This method\nreturns true when the given function returns true for every element in the array.\nIn a way, some is a version of the || operator that acts on arrays, and every is\nlike the && operator.\nImplement every as a function that takes an array and a predicate function",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_233",
    "text": "In a way, some is a version of the || operator that acts on arrays, and every is\nlike the && operator.\nImplement every as a function that takes an array and a predicate function\nas parameters. Write two versions, one using a loop and one using the some\nmethod.\nDominant writing direction\nWrite a function that computes the dominant writing direction in a string of\ntext. Remember that each script object has a direction property that can be\n\"ltr\" (left to right), \"rtl\" (right to left), or \"ttb\" (top to bottom).\nThe dominant direction is the direction of a majority of the characters that\nhave a script associated with them. The characterScript and countBy func-\ntions defined earlier in the chapter are probably useful here.\n92\n\u201cAn abstract data type is realized by writing a special kind of program\n[\u2026] which defines the type in terms of the operations which can be\nperformed on it.\u201d\n\u2014Barbara Liskov, Programming with Abstract Data Types\nChapter 6\nThe Secret Life of Objects",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_234",
    "text": "[\u2026] which defines the type in terms of the operations which can be\nperformed on it.\u201d\n\u2014Barbara Liskov, Programming with Abstract Data Types\nChapter 6\nThe Secret Life of Objects\nChapter 4 introduced JavaScript\u2019s objects as containers that hold other data.\nIn programming culture, object-oriented programming is a set of techniques that\nuse objects as the central principle of program organization. Though no one\nreally agrees on its precise definition, object-oriented programming has shaped\nthe design of many programming languages, including JavaScript. This chapter\ndescribes the way these ideas can be applied in JavaScript.\nAbstract Data Types\nThe main idea in object-oriented programming is to use objects, or rather\ntypes of objects, as the unit of program organization. Setting up a program\nas a number of strictly separated object types provides a way to think about\nits structure and thus to enforce some kind of discipline, preventing everything\nfrom becoming entangled.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_235",
    "text": "as a number of strictly separated object types provides a way to think about\nits structure and thus to enforce some kind of discipline, preventing everything\nfrom becoming entangled.\nThe way to do this is to think of objects somewhat like you\u2019d think of an elec-\ntric mixer or other consumer appliance. The people who design and assemble a\nmixer have to do specialized work requiring material science and understanding\nof electricity. They cover all that up in a smooth plastic shell so that the people\nwho only want to mix pancake batter don\u2019t have to worry about all that\u2014they\nhave to understand only the few knobs that the mixer can be operated with.\nSimilarly, an abstract data type, or object class, is a subprogram that may\ncontain arbitrarily complicated code but exposes a limited set of methods and\nproperties that people working with it are supposed to use. This allows large\nprograms to be built up out of a number of appliance types, limiting the degree",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_236",
    "text": "properties that people working with it are supposed to use. This allows large\nprograms to be built up out of a number of appliance types, limiting the degree\nto which these different parts are entangled by requiring them to only interact\nwith each other in specific ways.\nIf a problem is found in one such object class, it can often be repaired or\neven completely rewritten without impacting the rest of the program. Even\nbetter, it may be possible to use object classes in multiple different programs,\navoiding the need to recreate their functionality from scratch. You can think\n93\nof JavaScript\u2019s built-in data structures, such as arrays and strings, as such\nreusable abstract data types.\nEach abstract data type has an interface, the collection of operations that\nexternal code can perform on it. Any details beyond that interface are encap-\nsulated, treated as internal to the type and of no concern to the rest of the\nprogram.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_237",
    "text": "external code can perform on it. Any details beyond that interface are encap-\nsulated, treated as internal to the type and of no concern to the rest of the\nprogram.\nEven basic things like numbers can be thought of as an abstract data type\nwhose interface allows us to add them, multiply them, compare them, and so\non.\nIn fact, the fixation on single objects as the main unit of organization\nin classical object-oriented programming is somewhat unfortunate since useful\npieces of functionality often involve a group of different object classes working\nclosely together.\nMethods\nIn JavaScript, methods are nothing more than properties that hold function\nvalues. This is a simple method:\nfunction speak(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n}\nlet whiteRabbit = {type: \"white\", speak};\nlet hungryRabbit = {type: \"hungry\", speak};\nwhiteRabbit.speak(\"Oh my fur and whiskers\");\n// \u2192The white rabbit says 'Oh my fur and whiskers'\nhungryRabbit.speak(\"Got any carrots?\");",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_238",
    "text": "let hungryRabbit = {type: \"hungry\", speak};\nwhiteRabbit.speak(\"Oh my fur and whiskers\");\n// \u2192The white rabbit says 'Oh my fur and whiskers'\nhungryRabbit.speak(\"Got any carrots?\");\n// \u2192The hungry rabbit says 'Got any carrots?'\nTypically a method needs to do something with the object on which it was\ncalled. When a function is called as a method\u2014looked up as a property and\nimmediately called, as in object.method()\u2014the binding called this in its body\nautomatically points at the object on which it was called.\nYou can think of this as an extra parameter that is passed to the function\nin a different way than regular parameters. If you want to provide it explicitly,\nyou can use a function\u2019s call method, which takes the this value as its first\nargument and treats further arguments as normal parameters.\nspeak.call(whiteRabbit, \"Hurry\");\n// \u2192The white rabbit says 'Hurry'\nSince each function has its own this binding whose value depends on the way",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_239",
    "text": "speak.call(whiteRabbit, \"Hurry\");\n// \u2192The white rabbit says 'Hurry'\nSince each function has its own this binding whose value depends on the way\nit is called, you cannot refer to the this of the wrapping scope in a regular\n94\nfunction defined with the function keyword.\nArrow functions are different\u2014they do not bind their own this but can see\nthe this binding of the scope around them. Thus, you can do something like\nthe following code, which references this from inside a local function:\nlet finder = {\nfind(array) {\nreturn array.some(v => v == this.value);\n},\nvalue: 5\n};\nconsole.log(finder.find([4, 5]));\n// \u2192true\nA property like find(array) in an object expression is a shorthand way of\ndefining a method. It creates a property called find and gives it a function as\nits value.\nIf I had written the argument to some using the function keyword, this code\nwouldn\u2019t work.\nPrototypes\nOne way to create a rabbit object type with a speak method would be to create",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_240",
    "text": "its value.\nIf I had written the argument to some using the function keyword, this code\nwouldn\u2019t work.\nPrototypes\nOne way to create a rabbit object type with a speak method would be to create\na helper function that has a rabbit type as its parameter and returns an object\nholding that as its type property and our speak function in its speak property.\nAll rabbits share that same method. Especially for types with many methods,\nit would be nice if there were a way to keep a type\u2019s methods in a single place,\nrather than adding them to each object individually.\nIn JavaScript, prototypes are the way to do that. Objects can be linked to\nother objects, to magically get all the properties that other object has. Plain\nold objects created with {} notation are linked to an object called Object.\nprototype.\nlet empty = {};\nconsole.log(empty.toString);\n// \u2192function toString()\u2026{}\nconsole.log(empty.toString());\n// \u2192[object Object]",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_241",
    "text": "prototype.\nlet empty = {};\nconsole.log(empty.toString);\n// \u2192function toString()\u2026{}\nconsole.log(empty.toString());\n// \u2192[object Object]\nIt looks like we just pulled a property out of an empty object. But in fact,\ntoString is a method stored in Object.prototype, meaning it is available in\nmost objects.\n95\nWhen an object gets a request for a property that it doesn\u2019t have, its proto-\ntype will be searched for the property. If that doesn\u2019t have it, the prototype\u2019s\nprototype is searched, and so on until an object without prototype is reached\n(Object.prototype is such an object).\nconsole.log(Object.getPrototypeOf({}) == Object.prototype);\n// \u2192true\nconsole.log(Object.getPrototypeOf(Object.prototype));\n// \u2192null\nAs you\u2019d guess, Object.getPrototypeOf returns the prototype of an object.\nMany objects don\u2019t directly have Object.prototype as their prototype but\ninstead have another object that provides a different set of default proper-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_242",
    "text": "Many objects don\u2019t directly have Object.prototype as their prototype but\ninstead have another object that provides a different set of default proper-\nties. Functions derive from Function.prototype and arrays derive from Array\n.prototype.\nconsole.log(Object.getPrototypeOf(Math.max) ==\nFunction.prototype);\n// \u2192true\nconsole.log(Object.getPrototypeOf([]) == Array.prototype);\n// \u2192true\nSuch a prototype object will itself have a prototype, often Object.prototype,\nso that it still indirectly provides methods like toString.\nYou can use Object.create to create an object with a specific prototype.\nlet protoRabbit = {\nspeak(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n}\n};\nlet blackRabbit = Object.create(protoRabbit);\nblackRabbit.type = \"black\";\nblackRabbit.speak(\"I am fear and darkness\");\n// \u2192The black rabbit says 'I am fear and darkness'\nThe \u201cproto\u201d rabbit acts as a container for the properties shared by all rabbits.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_243",
    "text": "blackRabbit.speak(\"I am fear and darkness\");\n// \u2192The black rabbit says 'I am fear and darkness'\nThe \u201cproto\u201d rabbit acts as a container for the properties shared by all rabbits.\nAn individual rabbit object, like the black rabbit, contains properties that\napply only to itself\u2014in this case its type\u2014and derives shared properties from\nits prototype.\n96\nClasses\nJavaScript\u2019s prototype system can be interpreted as a somewhat free-form take\non abstract data types or classes. A class defines the shape of a type of object\u2014\nwhat methods and properties it has. Such an object is called an instance of\nthe class.\nPrototypes are useful for defining properties for which all instances of a class\nshare the same value. Properties that differ per instance, such as our rabbits\u2019\ntype property, need to be stored directly in the objects themselves.\nTo create an instance of a given class, you have to make an object that\nderives from the proper prototype, but you also have to make sure it itself has",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_244",
    "text": "To create an instance of a given class, you have to make an object that\nderives from the proper prototype, but you also have to make sure it itself has\nthe properties that instances of this class are supposed to have. This is what a\nconstructor function does.\nfunction makeRabbit(type) {\nlet rabbit = Object.create(protoRabbit);\nrabbit.type = type;\nreturn rabbit;\n}\nJavaScript\u2019s class notation makes it easier to define this type of function, along\nwith a prototype object.\nclass Rabbit {\nconstructor(type) {\nthis.type = type;\n}\nspeak(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n}\n}\nThe class keyword starts a class declaration, which allows us to define a con-\nstructor and a set of methods together. Any number of methods may be written\ninside the declaration\u2019s braces. This code has the effect of defining a binding\ncalled Rabbit, which holds a function that runs the code in constructor and\nhas a prototype property that holds the speak method.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_245",
    "text": "called Rabbit, which holds a function that runs the code in constructor and\nhas a prototype property that holds the speak method.\nThis function cannot be called like a normal function.\nConstructors, in\nJavaScript, are called by putting the keyword new in front of them. Doing so\ncreates a fresh instance object whose prototype is the object from the function\u2019s\nprototype property, then runs the function with this bound to the new object,\nand finally returns the object.\nlet killerRabbit = new Rabbit(\"killer\");\n97\nIn fact, class was only introduced in the 2015 edition of JavaScript.\nAny\nfunction can be used as a constructor, and before 2015, the way to define a class\nwas to write a regular function and then manipulate its prototype property.\nfunction ArchaicRabbit(type) {\nthis.type = type;\n}\nArchaicRabbit.prototype.speak = function(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n};\nlet oldSchoolRabbit = new ArchaicRabbit(\"old school\");",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_246",
    "text": "this.type = type;\n}\nArchaicRabbit.prototype.speak = function(line) {\nconsole.log(`The ${this.type} rabbit says '${line}'`);\n};\nlet oldSchoolRabbit = new ArchaicRabbit(\"old school\");\nFor this reason, all non-arrow functions start with a prototype property holding\nan empty object.\nBy convention, the names of constructors are capitalized so that they can\neasily be distinguished from other functions.\nIt is important to understand the distinction between the way a prototype\nis associated with a constructor (through its prototype property) and the way\nobjects have a prototype (which can be found with Object.getPrototypeOf).\nThe actual prototype of a constructor is Function.prototype since construc-\ntors are functions. The constructor function\u2019s prototype property holds the\nprototype used for instances created through it.\nconsole.log(Object.getPrototypeOf(Rabbit) ==\nFunction.prototype);\n// \u2192true\nconsole.log(Object.getPrototypeOf(killerRabbit) ==\nRabbit.prototype);\n// \u2192true",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_247",
    "text": "console.log(Object.getPrototypeOf(Rabbit) ==\nFunction.prototype);\n// \u2192true\nconsole.log(Object.getPrototypeOf(killerRabbit) ==\nRabbit.prototype);\n// \u2192true\nConstructors will typically add some per-instance properties to this. It is also\npossible to declare properties directly in the class declaration. Unlike methods,\nsuch properties are added to instance objects and not the prototype.\nclass Particle {\nspeed = 0;\nconstructor(position) {\nthis.position = position;\n}\n}\nLike function, class can be used both in statements and in expressions. When\nused as an expression, it doesn\u2019t define a binding but just produces the con-\nstructor as a value. You are allowed to omit the class name in a class expression.\n98\nlet object = new class { getWord() { return \"hello\"; } };\nconsole.log(object.getWord());\n// \u2192hello\nPrivate Properties\nIt is common for classes to define some properties and methods for internal\nuse that are not part of their interface. These are called private properties, as",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_248",
    "text": "// \u2192hello\nPrivate Properties\nIt is common for classes to define some properties and methods for internal\nuse that are not part of their interface. These are called private properties, as\nopposed to public ones, which are part of the object\u2019s external interface.\nTo declare a private method, put a # sign in front of its name. Such methods\ncan be called only from inside the class declaration that defines them.\nclass SecretiveObject {\n#getSecret() {\nreturn \"I ate all the plums\";\n}\ninterrogate() {\nlet shallISayIt = this.#getSecret();\nreturn \"never\";\n}\n}\nWhen a class does not declare a constructor, it will automatically get an empty\none.\nIf you try to call #getSecret from outside the class, you get an error. Its\nexistence is entirely hidden inside the class declaration.\nTo use private instance properties, you must declare them. Regular proper-\nties can be created by just assigning to them, but private properties must be\ndeclared in the class declaration to be available at all.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_249",
    "text": "ties can be created by just assigning to them, but private properties must be\ndeclared in the class declaration to be available at all.\nThis class implements an appliance for getting a random whole number below\na given maximum number. It has only one public property: getNumber.\nclass RandomSource {\n#max;\nconstructor(max) {\nthis.#max = max;\n}\ngetNumber() {\nreturn Math.floor(Math.random() * this.#max);\n}\n}\n99\nOverriding derived properties\nWhen you add a property to an object, whether it is present in the prototype or\nnot, the property is added to the object itself. If there was already a property\nwith the same name in the prototype, this property will no longer affect the\nobject, as it is now hidden behind the object\u2019s own property.\nRabbit.prototype.teeth = \"small\";\nconsole.log(killerRabbit.teeth);\n// \u2192small\nkillerRabbit.teeth = \"long, sharp, and bloody\";\nconsole.log(killerRabbit.teeth);\n// \u2192long, sharp, and bloody\nconsole.log((new Rabbit(\"basic\")).teeth);\n// \u2192small",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_250",
    "text": "// \u2192small\nkillerRabbit.teeth = \"long, sharp, and bloody\";\nconsole.log(killerRabbit.teeth);\n// \u2192long, sharp, and bloody\nconsole.log((new Rabbit(\"basic\")).teeth);\n// \u2192small\nconsole.log(Rabbit.prototype.teeth);\n// \u2192small\nThe following diagram sketches the situation after this code has run.\nThe\nRabbit and Object prototypes lie behind killerRabbit as a kind of backdrop,\nwhere properties that are not found in the object itself can be looked up.\ntoString: <function>\n...\nteeth: \"small\"\nspeak: <function>\nkillerRabbit\nteeth: \"long, sharp, ...\"\ntype: \"killer\"\nRabbit\nprototype\nObject\ncreate: <function>\nprototype\n...\nOverriding properties that exist in a prototype can be a useful thing to\ndo.\nAs the rabbit teeth example shows, overriding can be used to express\nexceptional properties in instances of a more generic class of objects while\nletting the nonexceptional objects take a standard value from their prototype.\nOverriding is also used to give the standard function and array prototypes a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_251",
    "text": "letting the nonexceptional objects take a standard value from their prototype.\nOverriding is also used to give the standard function and array prototypes a\ndifferent toString method than the basic object prototype.\nconsole.log(Array.prototype.toString ==\nObject.prototype.toString);\n// \u2192false\nconsole.log([1, 2].toString());\n// \u21921,2\nCalling toString on an array gives a result similar to calling .join(\",\") on\nit\u2014it puts commas between the values in the array. Directly calling Object.\n100\nprototype.toString with an array produces a different string. That function\ndoesn\u2019t know about arrays, so it simply puts the word object and the name of\nthe type between square brackets.\nconsole.log(Object.prototype.toString.call([1, 2]));\n// \u2192[object Array]\nMaps\nWe saw the word map used in the previous chapter for an operation that trans-\nforms a data structure by applying a function to its elements. Confusing as\nit is, in programming the same word is used for a related but rather different\nthing.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_252",
    "text": "forms a data structure by applying a function to its elements. Confusing as\nit is, in programming the same word is used for a related but rather different\nthing.\nA map (noun) is a data structure that associates values (the keys) with other\nvalues. For example, you might want to map names to ages. It is possible to\nuse objects for this.\nlet ages = {\nBoris: 39,\nLiang: 22,\nJ\u00falia: 62\n};\nconsole.log(`J\u00falia is ${ages[\"J\u00falia\"]}`);\n// \u2192J\u00falia is 62\nconsole.log(\"Is Jack's age known?\", \"Jack\" in ages);\n// \u2192Is Jack's age known? false\nconsole.log(\"Is toString's age known?\", \"toString\" in ages);\n// \u2192Is toString's age known? true\nHere, the object\u2019s property names are the people\u2019s names and the property\nvalues are their ages. But we certainly didn\u2019t list anybody named toString in\nour map. Yet because plain objects derive from Object.prototype, it looks like\nthe property is there.\nFor this reason, using plain objects as maps is dangerous. There are several",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_253",
    "text": "our map. Yet because plain objects derive from Object.prototype, it looks like\nthe property is there.\nFor this reason, using plain objects as maps is dangerous. There are several\npossible ways to avoid this problem. First, you can create objects with no\nprototype. If you pass null to Object.create, the resulting object will not\nderive from Object.prototype and can be safely used as a map.\nconsole.log(\"toString\" in Object.create(null));\n// \u2192false\nObject property names must be strings. If you need a map whose keys can\u2019t\n101\neasily be converted to strings\u2014such as objects\u2014you cannot use an object as\nyour map.\nFortunately, JavaScript comes with a class called Map that is written for this\nexact purpose. It stores a mapping and allows any type of keys.\nlet ages = new Map();\nages.set(\"Boris\", 39);\nages.set(\"Liang\", 22);\nages.set(\"J\u00falia\", 62);\nconsole.log(`J\u00falia is ${ages.get(\"J\u00falia\")}`);\n// \u2192J\u00falia is 62\nconsole.log(\"Is Jack's age known?\", ages.has(\"Jack\"));\n// \u2192Is Jack's age known? false",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_254",
    "text": "ages.set(\"Liang\", 22);\nages.set(\"J\u00falia\", 62);\nconsole.log(`J\u00falia is ${ages.get(\"J\u00falia\")}`);\n// \u2192J\u00falia is 62\nconsole.log(\"Is Jack's age known?\", ages.has(\"Jack\"));\n// \u2192Is Jack's age known? false\nconsole.log(ages.has(\"toString\"));\n// \u2192false\nThe methods set, get, and has are part of the interface of the Map object.\nWriting a data structure that can quickly update and search a large set of\nvalues isn\u2019t easy, but we don\u2019t have to worry about that. Someone else did it\nfor us, and we can go through this simple interface to use their work.\nIf you do have a plain object that you need to treat as a map for some reason,\nit is useful to know that Object.keys returns only an object\u2019s own keys, not\nthose in the prototype. As an alternative to the in operator, you can use the\nObject.hasOwn function, which ignores the object\u2019s prototype.\nconsole.log(Object.hasOwn({x: 1}, \"x\"));\n// \u2192true\nconsole.log(Object.hasOwn({x: 1}, \"toString\"));\n// \u2192false\nPolymorphism",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_255",
    "text": "Object.hasOwn function, which ignores the object\u2019s prototype.\nconsole.log(Object.hasOwn({x: 1}, \"x\"));\n// \u2192true\nconsole.log(Object.hasOwn({x: 1}, \"toString\"));\n// \u2192false\nPolymorphism\nWhen you call the String function (which converts a value to a string) on an\nobject, it will call the toString method on that object to try to create a mean-\ningful string from it. I mentioned that some of the standard prototypes define\ntheir own version of toString so they can create a string that contains more\nuseful information than \"[object Object]\". You can also do that yourself.\nRabbit.prototype.toString = function() {\nreturn `a ${this.type} rabbit`;\n};\n102\nconsole.log(String(killerRabbit));\n// \u2192a killer rabbit\nThis is a simple instance of a powerful idea. When a piece of code is written\nto work with objects that have a certain interface\u2014in this case, a toString\nmethod\u2014any kind of object that happens to support this interface can be\nplugged into the code and will be able to work with it.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_256",
    "text": "method\u2014any kind of object that happens to support this interface can be\nplugged into the code and will be able to work with it.\nThis technique is called polymorphism.\nPolymorphic code can work with\nvalues of different shapes, as long as they support the interface it expects.\nAn example of a widely used interface is that of array-like objects that have\na length property holding a number and numbered properties for each of their\nelements. Both arrays and strings support this interface, as do various other\nobjects, some of which we\u2019ll see later in the chapters about the browser. Our\nimplementation of forEach from Chapter 5 works on anything that provides\nthis interface. In fact, so does Array.prototype.forEach.\nArray.prototype.forEach.call({\nlength: 2,\n0: \"A\",\n1: \"B\"\n}, elt => console.log(elt));\n// \u2192A\n// \u2192B\nGetters, setters, and statics\nInterfaces often contain plain properties, not just methods. For example, Map",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_257",
    "text": "length: 2,\n0: \"A\",\n1: \"B\"\n}, elt => console.log(elt));\n// \u2192A\n// \u2192B\nGetters, setters, and statics\nInterfaces often contain plain properties, not just methods. For example, Map\nobjects have a size property that tells you how many keys are stored in them.\nIt is not necessary for such an object to compute and store such a property\ndirectly in the instance. Even properties that are accessed directly may hide a\nmethod call. Such methods are called getters and are defined by writing get in\nfront of the method name in an object expression or class declaration.\nlet varyingSize = {\nget size() {\nreturn Math.floor(Math.random() * 100);\n}\n};\nconsole.log(varyingSize.size);\n// \u219273\nconsole.log(varyingSize.size);\n103\n// \u219249\nWhenever someone reads from this object\u2019s size property, the associated method\nis called. You can do a similar thing when a property is written to, using a\nsetter.\nclass Temperature {\nconstructor(celsius) {\nthis.celsius = celsius;\n}\nget fahrenheit() {\nreturn this.celsius * 1.8 + 32;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_258",
    "text": "setter.\nclass Temperature {\nconstructor(celsius) {\nthis.celsius = celsius;\n}\nget fahrenheit() {\nreturn this.celsius * 1.8 + 32;\n}\nset fahrenheit(value) {\nthis.celsius = (value - 32) / 1.8;\n}\nstatic fromFahrenheit(value) {\nreturn new Temperature((value - 32) / 1.8);\n}\n}\nlet temp = new Temperature(22);\nconsole.log(temp.fahrenheit);\n// \u219271.6\ntemp.fahrenheit = 86;\nconsole.log(temp.celsius);\n// \u219230\nThe Temperature class allows you to read and write the temperature in either\ndegrees Celsius or degrees Fahrenheit, but internally it stores only Celsius and\nautomatically converts to and from Celsius in the fahrenheit getter and setter.\nSometimes you want to attach some properties directly to your constructor\nfunction rather than to the prototype.\nSuch methods won\u2019t have access to\na class instance but can, for example, be used to provide additional ways to\ncreate instances.\nInside a class declaration, methods or properties that have static written",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_259",
    "text": "a class instance but can, for example, be used to provide additional ways to\ncreate instances.\nInside a class declaration, methods or properties that have static written\nbefore their name are stored on the constructor. For example, the Temperature\nclass allows you to write Temperature.fromFahrenheit(100) to create a tem-\nperature using degrees Fahrenheit.\nlet boil = Temperature.fromFahrenheit(212);\nconsole.log(boil.celsius);\n// \u2192100\n104\nSymbols\nI mentioned in Chapter 4 that a for/of loop can loop over several kinds of\ndata structures. This is another case of polymorphism\u2014such loops expect the\ndata structure to expose a specific interface, which arrays and strings do. And\nwe can also add this interface to our own objects! But before we can do that,\nwe need to briefly take a look at the symbol type.\nIt is possible for multiple interfaces to use the same property name for dif-\nferent things. For example, on array-like objects, length refers to the number",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_260",
    "text": "It is possible for multiple interfaces to use the same property name for dif-\nferent things. For example, on array-like objects, length refers to the number\nof elements in the collection. But an object interface describing a hiking route\ncould use length to provide the length of the route in meters. It would not be\npossible for an object to conform to both these interfaces.\nAn object trying to be a route and array-like (maybe to enumerate its way-\npoints) is somewhat far-fetched, and this kind of problem isn\u2019t that common in\npractice. For things like the iteration protocol, though, the language designers\nneeded a type of property that really doesn\u2019t conflict with any others. So in\n2015, symbols were added to the language.\nMost properties, including all those we have seen so far, are named with\nstrings. But it is also possible to use symbols as property names. Symbols are\nvalues created with the Symbol function. Unlike strings, newly created symbols",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_261",
    "text": "strings. But it is also possible to use symbols as property names. Symbols are\nvalues created with the Symbol function. Unlike strings, newly created symbols\nare unique\u2014you cannot create the same symbol twice.\nlet sym = Symbol(\"name\");\nconsole.log(sym == Symbol(\"name\"));\n// \u2192false\nRabbit.prototype[sym] = 55;\nconsole.log(killerRabbit[sym]);\n// \u219255\nThe string you pass to Symbol is included when you convert it to a string and\ncan make it easier to recognize a symbol when, for example, showing it in the\nconsole. But it has no meaning beyond that\u2014multiple symbols may have the\nsame name.\nBeing both unique and usable as property names makes symbols suitable\nfor defining interfaces that can peacefully live alongside other properties, no\nmatter what their names are.\nconst length = Symbol(\"length\");\nArray.prototype[length] = 0;\nconsole.log([1, 2].length);\n// \u21922\n105\nconsole.log([1, 2][length]);\n// \u21920\nIt is possible to include symbol properties in object expressions and classes by",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_262",
    "text": "Array.prototype[length] = 0;\nconsole.log([1, 2].length);\n// \u21922\n105\nconsole.log([1, 2][length]);\n// \u21920\nIt is possible to include symbol properties in object expressions and classes by\nusing square brackets around the property name. That causes the expression\nbetween the brackets to be evaluated to produce the property name, analogous\nto the square bracket property access notation.\nlet myTrip = {\nlength: 2,\n0: \"Lankwitz\",\n1: \"Babelsberg\",\n[length]: 21500\n};\nconsole.log(myTrip[length], myTrip.length);\n// \u219221500 2\nThe iterator interface\nThe object given to a for/of loop is expected to be iterable. This means it has\na method named with the Symbol.iterator symbol (a symbol value defined by\nthe language, stored as a property of the Symbol function).\nWhen called, that method should return an object that provides a second\ninterface, iterator. This is the actual thing that iterates. It has a next method\nthat returns the next result. That result should be an object with a value",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_263",
    "text": "interface, iterator. This is the actual thing that iterates. It has a next method\nthat returns the next result. That result should be an object with a value\nproperty that provides the next value, if there is one, and a done property,\nwhich should be true when there are no more results and false otherwise.\nNote that the next, value, and done property names are plain strings, not\nsymbols. Only Symbol.iterator, which is likely to be added to a lot of different\nobjects, is an actual symbol.\nWe can directly use this interface ourselves.\nlet okIterator = \"OK\"[Symbol.iterator]();\nconsole.log(okIterator.next());\n// \u2192{value: \"O\", done: false}\nconsole.log(okIterator.next());\n// \u2192{value: \"K\", done: false}\nconsole.log(okIterator.next());\n// \u2192{value: undefined, done: true}\nLet\u2019s implement an iterable data structure similar to the linked list from the\nexercise in Chapter 4. We\u2019ll write the list as a class this time.\n106\nclass List {\nconstructor(value, rest) {\nthis.value = value;\nthis.rest = rest;\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_264",
    "text": "exercise in Chapter 4. We\u2019ll write the list as a class this time.\n106\nclass List {\nconstructor(value, rest) {\nthis.value = value;\nthis.rest = rest;\n}\nget length() {\nreturn 1 + (this.rest ? this.rest.length : 0);\n}\nstatic fromArray(array) {\nlet result = null;\nfor (let i = array.length - 1; i >= 0; i--) {\nresult = new this(array[i], result);\n}\nreturn result;\n}\n}\nNote that this, in a static method, points at the constructor of the class, not\nan instance\u2014there is no instance around when a static method is called.\nIterating over a list should return all the list\u2019s elements from start to end.\nWe\u2019ll write a separate class for the iterator.\nclass ListIterator {\nconstructor(list) {\nthis.list = list;\n}\nnext() {\nif (this.list == null) {\nreturn {done: true};\n}\nlet value = this.list.value;\nthis.list = this.list.rest;\nreturn {value, done: false};\n}\n}\nThe class tracks the progress of iterating through the list by updating its list",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_265",
    "text": "return {done: true};\n}\nlet value = this.list.value;\nthis.list = this.list.rest;\nreturn {value, done: false};\n}\n}\nThe class tracks the progress of iterating through the list by updating its list\nproperty to move to the next list object whenever a value is returned and\nreports that it is done when that list is empty (null).\nLet\u2019s set up the List class to be iterable. Throughout this book, I\u2019ll occa-\nsionally use after-the-fact prototype manipulation to add methods to classes\nso that the individual pieces of code remain small and self contained. In a\n107\nregular program, where there is no need to split the code into small pieces,\nyou\u2019d declare these methods directly in the class instead.\nList.prototype[Symbol.iterator] = function() {\nreturn new ListIterator(this);\n};\nWe can now loop over a list with for/of.\nlet list = List.fromArray([1, 2, 3]);\nfor (let element of list) {\nconsole.log(element);\n}\n// \u21921\n// \u21922\n// \u21923\nThe ... syntax in array notation and function calls similarly works with any",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_266",
    "text": "let list = List.fromArray([1, 2, 3]);\nfor (let element of list) {\nconsole.log(element);\n}\n// \u21921\n// \u21922\n// \u21923\nThe ... syntax in array notation and function calls similarly works with any\niterable object. For example, you can use [...value] to create an array con-\ntaining the elements in an arbitrary iterable object.\nconsole.log([...\"PCI\"]);\n// \u2192[\"P\", \"C\", \"I\"]\nInheritance\nImagine we need a list type much like the List class we saw before, but because\nwe will be asking for its length all the time, we don\u2019t want it to have to scan\nthrough its rest every time. Instead, we want to store the length in every\ninstance for e\ufb00icient access.\nJavaScript\u2019s prototype system makes it possible to create a new class, much\nlike the old class, but with new definitions for some of its properties.\nThe\nprototype for the new class derives from the old prototype but adds a new\ndefinition for, say, the length getter.\nIn object-oriented programming terms, this is called inheritance. The new",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_267",
    "text": "The\nprototype for the new class derives from the old prototype but adds a new\ndefinition for, say, the length getter.\nIn object-oriented programming terms, this is called inheritance. The new\nclass inherits properties and behavior from the old class.\nclass LengthList extends List {\n#length;\nconstructor(value, rest) {\nsuper(value, rest);\nthis.#length = super.length;\n}\n108\nget length() {\nreturn this.#length;\n}\n}\nconsole.log(LengthList.fromArray([1, 2, 3]).length);\n// \u21923\nThe use of the word extends indicates that this class shouldn\u2019t be directly\nbased on the default Object prototype but on some other class. This is called\nthe superclass. The derived class is the subclass.\nTo initialize a LengthList instance, the constructor calls the constructor of\nits superclass through the super keyword. This is necessary because if this\nnew object is to behave (roughly) like a List, it is going to need the instance\nproperties that lists have.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_268",
    "text": "its superclass through the super keyword. This is necessary because if this\nnew object is to behave (roughly) like a List, it is going to need the instance\nproperties that lists have.\nThe constructor then stores the list\u2019s length in a private property. If we had\nwritten this.length there, the class\u2019s own getter would have been called, which\ndoesn\u2019t work yet since #length hasn\u2019t been filled in yet. We can use super.\nsomething to call methods and getters on the superclass\u2019s prototype, which is\noften useful.\nInheritance allows us to build slightly different data types from existing data\ntypes with relatively little work. It is a fundamental part of the object-oriented\ntradition, alongside encapsulation and polymorphism. But while the latter two\nare now generally regarded as wonderful ideas, inheritance is more controversial.\nWhereas encapsulation and polymorphism can be used to separate pieces\nof code from one another, reducing the tangledness of the overall program,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_269",
    "text": "Whereas encapsulation and polymorphism can be used to separate pieces\nof code from one another, reducing the tangledness of the overall program,\ninheritance fundamentally ties classes together, creating more tangle. When\ninheriting from a class, you usually have to know more about how it works than\nwhen simply using it. Inheritance can be a useful tool to make some types of\nprograms more succinct, but it shouldn\u2019t be the first tool you reach for, and\nyou probably shouldn\u2019t actively go looking for opportunities to construct class\nhierarchies (family trees of classes).\nThe instanceof operator\nIt is occasionally useful to know whether an object was derived from a specific\nclass. For this, JavaScript provides a binary operator called instanceof.\nconsole.log(\nnew LengthList(1, null) instanceof LengthList);\n109\n// \u2192true\nconsole.log(new LengthList(2, null) instanceof List);\n// \u2192true\nconsole.log(new List(3, null) instanceof LengthList);\n// \u2192false\nconsole.log([1] instanceof Array);\n// \u2192true",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_270",
    "text": "109\n// \u2192true\nconsole.log(new LengthList(2, null) instanceof List);\n// \u2192true\nconsole.log(new List(3, null) instanceof LengthList);\n// \u2192false\nconsole.log([1] instanceof Array);\n// \u2192true\nThe operator will see through inherited types, so a LengthList is an instance\nof List. The operator can also be applied to standard constructors like Array.\nAlmost every object is an instance of Object.\nSummary\nObjects do more than just hold their own properties. They have prototypes,\nwhich are other objects. They\u2019ll act as if they have properties they don\u2019t have\nas long as their prototype has that property.\nSimple objects have Object.\nprototype as their prototype.\nConstructors, which are functions whose names usually start with a capital\nletter, can be used with the new operator to create new objects.\nThe new\nobject\u2019s prototype will be the object found in the prototype property of the\nconstructor. You can make good use of this by putting the properties that all",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_271",
    "text": "The new\nobject\u2019s prototype will be the object found in the prototype property of the\nconstructor. You can make good use of this by putting the properties that all\nvalues of a given type share into their prototype. There\u2019s a class notation that\nprovides a clear way to define a constructor and its prototype.\nYou can define getters and setters to secretly call methods every time an\nobject\u2019s property is accessed. Static methods are methods stored in a class\u2019s\nconstructor rather than its prototype.\nThe instanceof operator can, given an object and a constructor, tell you\nwhether that object is an instance of that constructor.\nOne useful thing to do with objects is to specify an interface for them and\ntell everybody that they are supposed to talk to your object only through that\ninterface. The rest of the details that make up your object are now encapsulated,\nhidden behind the interface. You can use private properties to hide a part of\nyour object from the outside world.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_272",
    "text": "interface. The rest of the details that make up your object are now encapsulated,\nhidden behind the interface. You can use private properties to hide a part of\nyour object from the outside world.\nMore than one type may implement the same interface. Code written to use\nan interface automatically knows how to work with any number of different\nobjects that provide the interface. This is called polymorphism.\nWhen implementing multiple classes that differ in only some details, it can\nbe helpful to write the new classes as subclasses of an existing class, inheriting\npart of its behavior.\n110\nExercises\nA vector type\nWrite a class Vec that represents a vector in two-dimensional space. It takes x\nand y parameters (numbers), that it saves to properties of the same name.\nGive the Vec prototype two methods, plus and minus, that take another\nvector as a parameter and return a new vector that has the sum or difference\nof the two vectors\u2019 (this and the parameter) x and y values.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_273",
    "text": "vector as a parameter and return a new vector that has the sum or difference\nof the two vectors\u2019 (this and the parameter) x and y values.\nAdd a getter property length to the prototype that computes the length of\nthe vector\u2014that is, the distance of the point (x, y) from the origin (0, 0).\nGroups\nThe standard JavaScript environment provides another data structure called\nSet. Like an instance of Map, a set holds a collection of values. Unlike Map, it\ndoes not associate other values with those\u2014it just tracks which values are part\nof the set. A value can be part of a set only once\u2014adding it again doesn\u2019t have\nany effect.\nWrite a class called Group (since Set is already taken). Like Set, it has add,\ndelete, and has methods. Its constructor creates an empty group, add adds\na value to the group (but only if it isn\u2019t already a member), delete removes\nits argument from the group (if it was a member), and has returns a Boolean\nvalue indicating whether its argument is a member of the group.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_274",
    "text": "its argument from the group (if it was a member), and has returns a Boolean\nvalue indicating whether its argument is a member of the group.\nUse the === operator, or something equivalent such as indexOf, to determine\nwhether two values are the same.\nGive the class a static from method that takes an iterable object as its ar-\ngument and creates a group that contains all the values produced by iterating\nover it.\nIterable groups\nMake the Group class from the previous exercise iterable. Refer to the section\nabout the iterator interface earlier in the chapter if you aren\u2019t clear on the\nexact form of the interface anymore.\nIf you used an array to represent the group\u2019s members, don\u2019t just return the\niterator created by calling the Symbol.iterator method on the array. That\nwould work, but it defeats the purpose of this exercise.\nIt is okay if your iterator behaves strangely when the group is modified during\niteration.\n111\n\u201cThe question of whether Machines Can Think [...] is about as",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_275",
    "text": "It is okay if your iterator behaves strangely when the group is modified during\niteration.\n111\n\u201cThe question of whether Machines Can Think [...] is about as\nrelevant as the question of whether Submarines Can Swim.\u201d\n\u2014Edsger Dijkstra, The Threats to Computing Science\nChapter 7\nProject: A Robot\nIn \u201cproject\u201d chapters, I\u2019ll stop pummeling you with new theory for a brief mo-\nment, and instead we\u2019ll work through a program together. Theory is necessary\nto learn to program, but reading and understanding actual programs is just as\nimportant.\nOur project in this chapter is to build an automaton, a little program that\nperforms a task in a virtual world. Our automaton will be a mail-delivery robot\npicking up and dropping off parcels.\nMeadowfield\nThe village of Meadowfield isn\u2019t very big. It consists of 11 places with 14 roads\nbetween them. It can be described with this array of roads:\nconst roads = [\n\"Alice's House-Bob's House\",\n\"Alice's House-Cabin\",\n\"Alice's House-Post Office\",",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_276",
    "text": "between them. It can be described with this array of roads:\nconst roads = [\n\"Alice's House-Bob's House\",\n\"Alice's House-Cabin\",\n\"Alice's House-Post Office\",\n\"Bob's House-Town Hall\",\n\"Daria's House-Ernie's House\", \"Daria's House-Town Hall\",\n\"Ernie's House-Grete's House\", \"Grete's House-Farm\",\n\"Grete's House-Shop\",\n\"Marketplace-Farm\",\n\"Marketplace-Post Office\",\n\"Marketplace-Shop\",\n\"Marketplace-Town Hall\",\n\"Shop-Town Hall\"\n];\n112\nThe network of roads in the village forms a graph. A graph is a collection of\npoints (places in the village) with lines between them (roads). This graph will\nbe the world that our robot moves through.\nThe array of strings isn\u2019t very easy to work with. What we\u2019re interested in\nis the destinations that we can reach from a given place. Let\u2019s convert the list\nof roads to a data structure that, for each place, tells us what can be reached\nfrom there.\nfunction buildGraph(edges) {\nlet graph = Object.create(null);\nfunction addEdge(from, to) {\nif (from in graph) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_277",
    "text": "from there.\nfunction buildGraph(edges) {\nlet graph = Object.create(null);\nfunction addEdge(from, to) {\nif (from in graph) {\ngraph[from].push(to);\n} else {\ngraph[from] = [to];\n}\n}\nfor (let [from, to] of edges.map(r => r.split(\"-\"))) {\naddEdge(from, to);\naddEdge(to, from);\n}\nreturn graph;\n}\nconst roadGraph = buildGraph(roads);\nGiven an array of edges, buildGraph creates a map object that, for each node,\nstores an array of connected nodes.\nIt uses the split method to go from\n113\nthe road strings\u2014which have the form \"Start-End\")\u2014to two-element arrays\ncontaining the start and end as separate strings.\nThe task\nOur robot will be moving around the village.\nThere are parcels in various\nplaces, each addressed to some other place. The robot picks up parcels when\nit comes across them and delivers them when it arrives at their destinations.\nThe automaton must decide, at each point, where to go next. It has finished\nits task when all parcels have been delivered.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_278",
    "text": "it comes across them and delivers them when it arrives at their destinations.\nThe automaton must decide, at each point, where to go next. It has finished\nits task when all parcels have been delivered.\nTo be able to simulate this process, we must define a virtual world that can\ndescribe it. This model tells us where the robot is and where the parcels are.\nWhen the robot has decided to move somewhere, we need to update the model\nto reflect the new situation.\nIf you\u2019re thinking in terms of object-oriented programming, your first impulse\nmight be to start defining objects for the various elements in the world: a class\nfor the robot, one for a parcel, maybe one for places. These could then hold\nproperties that describe their current state, such as the pile of parcels at a\nlocation, which we could change when updating the world.\nThis is wrong.\nAt least, it usually is.\nThe fact that something sounds\nlike an object does not automatically mean that it should be an object in your",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_279",
    "text": "This is wrong.\nAt least, it usually is.\nThe fact that something sounds\nlike an object does not automatically mean that it should be an object in your\nprogram. Reflexively writing classes for every concept in your application tends\nto leave you with a collection of interconnected objects that each have their\nown internal, changing state. Such programs are often hard to understand and\nthus easy to break.\nInstead, let\u2019s condense the village\u2019s state down to the minimal set of values\nthat define it. There\u2019s the robot\u2019s current location and the collection of unde-\nlivered parcels, each of which has a current location and a destination address.\nThat\u2019s it.\nWhile we\u2019re at it, let\u2019s make it so that we don\u2019t change this state when the\nrobot moves but rather compute a new state for the situation after the move.\nclass VillageState {\nconstructor(place, parcels) {\nthis.place = place;\nthis.parcels = parcels;\n}\nmove(destination) {\nif (!roadGraph[this.place].includes(destination)) {\nreturn this;\n114",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_280",
    "text": "class VillageState {\nconstructor(place, parcels) {\nthis.place = place;\nthis.parcels = parcels;\n}\nmove(destination) {\nif (!roadGraph[this.place].includes(destination)) {\nreturn this;\n114\n} else {\nlet parcels = this.parcels.map(p => {\nif (p.place != this.place) return p;\nreturn {place: destination, address: p.address};\n}).filter(p => p.place != p.address);\nreturn new VillageState(destination, parcels);\n}\n}\n}\nThe move method is where the action happens. It first checks whether there is\na road going from the current place to the destination, and if not, it returns\nthe old state, since this is not a valid move.\nNext, the method creates a new state with the destination as the robot\u2019s\nnew place. It also needs to create a new set of parcels\u2014parcels that the robot\nis carrying (that are at the robot\u2019s current place) need to be moved along\nto the new place. And parcels that are addressed to the new place need to\nbe delivered\u2014that is, they need to be removed from the set of undelivered",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_281",
    "text": "to the new place. And parcels that are addressed to the new place need to\nbe delivered\u2014that is, they need to be removed from the set of undelivered\nparcels. The call to map takes care of the moving, and the call to filter does\nthe delivering.\nParcel objects aren\u2019t changed when they are moved but re-created. The move\nmethod gives us a new village state but leaves the old one entirely intact.\nlet first = new VillageState(\n\"Post Office\",\n[{place: \"Post Office\", address: \"Alice's House\"}]\n);\nlet next = first.move(\"Alice's House\");\nconsole.log(next.place);\n// \u2192Alice's House\nconsole.log(next.parcels);\n// \u2192[]\nconsole.log(first.place);\n// \u2192Post Office\nThe move causes the parcel to be delivered, which is reflected in the next state.\nBut the initial state still describes the situation where the robot is at the post\no\ufb00ice and the parcel is undelivered.\n115\nPersistent data\nData structures that don\u2019t change are called immutable or persistent. They",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_282",
    "text": "o\ufb00ice and the parcel is undelivered.\n115\nPersistent data\nData structures that don\u2019t change are called immutable or persistent. They\nbehave a lot like strings and numbers in that they are who they are and stay\nthat way, rather than containing different things at different times.\nIn JavaScript, just about everything can be changed, so working with values\nthat are supposed to be persistent requires some restraint. There is a function\ncalled Object.freeze that changes an object so that writing to its properties\nis ignored. You could use that to make sure your objects aren\u2019t changed, if\nyou want to be careful. Freezing does require the computer to do some extra\nwork, and having updates ignored is just about as likely to confuse someone\nas having them do the wrong thing. I usually prefer to just tell people that a\ngiven object shouldn\u2019t be messed with and hope they remember it.\nlet object = Object.freeze({value: 5});\nobject.value = 10;\nconsole.log(object.value);\n// \u21925",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_283",
    "text": "given object shouldn\u2019t be messed with and hope they remember it.\nlet object = Object.freeze({value: 5});\nobject.value = 10;\nconsole.log(object.value);\n// \u21925\nWhy am I going out of my way to not change objects when the language is\nobviously expecting me to? Because it helps me understand my programs. This\nis about complexity management again. When the objects in my system are\nfixed, stable things, I can consider operations on them in isolation\u2014moving\nto Alice\u2019s house from a given start state always produces the same new state.\nWhen objects change over time, that adds a whole new dimension of complexity\nto this kind of reasoning.\nFor a small system like the one we are building in this chapter, we could\nhandle that bit of extra complexity. But the most important limit on what kind\nof systems we can build is how much we can understand. Anything that makes\nyour code easier to understand makes it possible to build a more ambitious\nsystem.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_284",
    "text": "of systems we can build is how much we can understand. Anything that makes\nyour code easier to understand makes it possible to build a more ambitious\nsystem.\nUnfortunately, although understanding a system built on persistent data\nstructures is easier, designing one, especially when your programming language\nisn\u2019t helping, can be a little harder. We\u2019ll look for opportunities to use persis-\ntent data structures in this book, but we\u2019ll also be using changeable ones.\nSimulation\nA delivery robot looks at the world and decides in which direction it wants to\nmove. So we could say that a robot is a function that takes a VillageState\nobject and returns the name of a nearby place.\n116\nBecause we want robots to be able to remember things so they can make\nand execute plans, we also pass them their memory and allow them to return\na new memory. Thus, the thing a robot returns is an object containing both\nthe direction it wants to move in and a memory value that will be given back",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_285",
    "text": "a new memory. Thus, the thing a robot returns is an object containing both\nthe direction it wants to move in and a memory value that will be given back\nto it the next time it is called.\nfunction runRobot(state, robot, memory) {\nfor (let turn = 0;; turn++) {\nif (state.parcels.length == 0) {\nconsole.log(`Done in ${turn} turns`);\nbreak;\n}\nlet action = robot(state, memory);\nstate = state.move(action.direction);\nmemory = action.memory;\nconsole.log(`Moved to ${action.direction}`);\n}\n}\nConsider what a robot has to do to \u201csolve\u201d a given state. It must pick up all\nparcels by visiting every location that has a parcel and deliver them by visiting\nevery location to which a parcel is addressed, but only after picking up the\nparcel.\nWhat is the dumbest strategy that could possibly work? The robot could\njust walk in a random direction every turn. That means, with great likelihood,\nit will eventually run into all parcels and then also at some point reach the\nplace where they should be delivered.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_286",
    "text": "just walk in a random direction every turn. That means, with great likelihood,\nit will eventually run into all parcels and then also at some point reach the\nplace where they should be delivered.\nHere\u2019s what that could look like:\nfunction randomPick(array) {\nlet choice = Math.floor(Math.random() * array.length);\nreturn array[choice];\n}\nfunction randomRobot(state) {\nreturn {direction: randomPick(roadGraph[state.place])};\n}\nRemember that Math.random() returns a number between 0 and 1\u2014but always\nbelow 1. Multiplying such a number by the length of an array and then applying\nMath.floor to it gives us a random index for the array.\nSince this robot does not need to remember anything, it ignores its second\nargument (remember that JavaScript functions can be called with extra argu-\nments without ill effects) and omits the memory property in its returned object.\n117\nTo put this sophisticated robot to work, we\u2019ll first need a way to create a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_287",
    "text": "ments without ill effects) and omits the memory property in its returned object.\n117\nTo put this sophisticated robot to work, we\u2019ll first need a way to create a\nnew state with some parcels. A static method (written here by directly adding\na property to the constructor) is a good place to put that functionality.\nVillageState.random = function(parcelCount = 5) {\nlet parcels = [];\nfor (let i = 0; i < parcelCount; i++) {\nlet address = randomPick(Object.keys(roadGraph));\nlet place;\ndo {\nplace = randomPick(Object.keys(roadGraph));\n} while (place == address);\nparcels.push({place, address});\n}\nreturn new VillageState(\"Post Office\", parcels);\n};\nWe don\u2019t want any parcels to be sent from the same place that they are ad-\ndressed to. For this reason, the do loop keeps picking new places when it gets\none that\u2019s equal to the address.\nLet\u2019s start up a virtual world.\nrunRobot(VillageState.random(), randomRobot);\n// \u2192Moved to Marketplace\n// \u2192Moved to Town Hall\n// \u2192\u2026\n// \u2192Done in 63 turns",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_288",
    "text": "one that\u2019s equal to the address.\nLet\u2019s start up a virtual world.\nrunRobot(VillageState.random(), randomRobot);\n// \u2192Moved to Marketplace\n// \u2192Moved to Town Hall\n// \u2192\u2026\n// \u2192Done in 63 turns\nIt takes the robot a lot of turns to deliver the parcels because it isn\u2019t planning\nahead very well. We\u2019ll address that soon.\nThe mail truck's route\nWe should be able to do a lot better than the random robot. An easy improve-\nment would be to take a hint from the way real-world mail delivery works. If\nwe find a route that passes all places in the village, the robot could run that\nroute twice, at which point it is guaranteed to be done. Here is one such route\n(starting from the post o\ufb00ice):\nconst mailRoute = [\n\"Alice's House\", \"Cabin\", \"Alice's House\", \"Bob's House\",\n\"Town Hall\", \"Daria's House\", \"Ernie's House\",\n\"Grete's House\", \"Shop\", \"Grete's House\", \"Farm\",\n\"Marketplace\", \"Post Office\"\n118\n];\nTo implement the route-following robot, we\u2019ll need to make use of robot mem-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_289",
    "text": "\"Grete's House\", \"Shop\", \"Grete's House\", \"Farm\",\n\"Marketplace\", \"Post Office\"\n118\n];\nTo implement the route-following robot, we\u2019ll need to make use of robot mem-\nory. The robot keeps the rest of its route in its memory and drops the first\nelement every turn.\nfunction routeRobot(state, memory) {\nif (memory.length == 0) {\nmemory = mailRoute;\n}\nreturn {direction: memory[0], memory: memory.slice(1)};\n}\nThis robot is a lot faster already. It\u2019ll take a maximum of 26 turns (twice the\n13-step route) but usually less.\nPathfinding\nStill, I wouldn\u2019t really call blindly following a fixed route intelligent behavior.\nThe robot could work more e\ufb00iciently if it adjusted its behavior to the actual\nwork that needs to be done.\nTo do that, it has to be able to deliberately move toward a given parcel or\ntoward the location where a parcel has to be delivered. Doing that, even when\nthe goal is more than one move away, will require some kind of route-finding\nfunction.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_290",
    "text": "toward the location where a parcel has to be delivered. Doing that, even when\nthe goal is more than one move away, will require some kind of route-finding\nfunction.\nThe problem of finding a route through a graph is a typical search problem.\nWe can tell whether a given solution (a route) is valid, but we can\u2019t directly\ncompute the solution the way we could for 2 + 2. Instead, we have to keep\ncreating potential solutions until we find one that works.\nThe number of possible routes through a graph is infinite. But when search-\ning for a route from A to B, we are interested only in the ones that start at\nA. We also don\u2019t care about routes that visit the same place twice\u2014those are\ndefinitely not the most e\ufb00icient route anywhere. So that cuts down on the\nnumber of routes that the route finder has to consider.\nIn fact, since we are mostly interested in the shortest route, we want to make\nsure we look at short routes before we look at longer ones. A good approach",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_291",
    "text": "In fact, since we are mostly interested in the shortest route, we want to make\nsure we look at short routes before we look at longer ones. A good approach\nwould be to \u201cgrow\u201d routes from the starting point, exploring every reachable\nplace that hasn\u2019t been visited yet until a route reaches the goal. That way,\nwe\u2019ll explore only routes that are potentially interesting, and we know that the\nfirst route we find is the shortest route (or one of the shortest routes, if there\nare more than one).\n119\nHere is a function that does this:\nfunction findRoute(graph, from, to) {\nlet work = [{at: from, route: []}];\nfor (let i = 0; i < work.length; i++) {\nlet {at, route} = work[i];\nfor (let place of graph[at]) {\nif (place == to) return route.concat(place);\nif (!work.some(w => w.at == place)) {\nwork.push({at: place, route: route.concat(place)});\n}\n}\n}\n}\nThe exploring has to be done in the right order\u2014the places that were reached",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_292",
    "text": "if (!work.some(w => w.at == place)) {\nwork.push({at: place, route: route.concat(place)});\n}\n}\n}\n}\nThe exploring has to be done in the right order\u2014the places that were reached\nfirst have to be explored first. We can\u2019t immediately explore a place as soon\nas we reach it because that would mean places reached from there would also\nbe explored immediately, and so on, even though there may be other, shorter\npaths that haven\u2019t yet been explored.\nTherefore, the function keeps a work list. This is an array of places that\nshould be explored next, along with the route that got us there. It starts with\njust the start position and an empty route.\nThe search then operates by taking the next item in the list and exploring\nthat, which means it looks at all roads going from that place. If one of them\nis the goal, a finished route can be returned. Otherwise, if we haven\u2019t looked\nat this place before, a new item is added to the list. If we have looked at it",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_293",
    "text": "is the goal, a finished route can be returned. Otherwise, if we haven\u2019t looked\nat this place before, a new item is added to the list. If we have looked at it\nbefore, since we are looking at short routes first, we\u2019ve found either a longer\nroute to that place or one precisely as long as the existing one, and we don\u2019t\nneed to explore it.\nYou can visualize this as a web of known routes crawling out from the start\nlocation, growing evenly on all sides (but never tangling back into itself). As\nsoon as the first thread reaches the goal location, that thread is traced back to\nthe start, giving us our route.\nOur code doesn\u2019t handle the situation where there are no more work items\non the work list because we know that our graph is connected, meaning that\nevery location can be reached from all other locations. We\u2019ll always be able to\nfind a route between two points, and the search can\u2019t fail.\nfunction goalOrientedRobot({place, parcels}, route) {\nif (route.length == 0) {\nlet parcel = parcels[0];",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_294",
    "text": "find a route between two points, and the search can\u2019t fail.\nfunction goalOrientedRobot({place, parcels}, route) {\nif (route.length == 0) {\nlet parcel = parcels[0];\nif (parcel.place != place) {\n120\nroute = findRoute(roadGraph, place, parcel.place);\n} else {\nroute = findRoute(roadGraph, place, parcel.address);\n}\n}\nreturn {direction: route[0], memory: route.slice(1)};\n}\nThis robot uses its memory value as a list of directions to move in, just like the\nroute-following robot. Whenever that list is empty, it has to figure out what to\ndo next. It takes the first undelivered parcel in the set and, if that parcel hasn\u2019t\nbeen picked up yet, plots a route toward it. If the parcel has been picked up,\nit still needs to be delivered, so the robot creates a route toward the delivery\naddress instead.\nThis robot usually finishes the task of delivering 5 parcels in about 16 turns.\nThat\u2019s slightly better than routeRobot but still definitely not optimal. We\u2019ll\ncontinue refining it in the exercises.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_295",
    "text": "This robot usually finishes the task of delivering 5 parcels in about 16 turns.\nThat\u2019s slightly better than routeRobot but still definitely not optimal. We\u2019ll\ncontinue refining it in the exercises.\nExercises\nMeasuring a robot\nIt\u2019s hard to objectively compare robots by just letting them solve a few sce-\nnarios. Maybe one robot just happened to get easier tasks or the kind of tasks\nthat it is good at, whereas the other didn\u2019t.\nWrite a function compareRobots that takes two robots (and their starting\nmemory). It should generate 100 tasks and let both of the robots solve each\nof these tasks. When done, it should output the average number of steps each\nrobot took per task.\nFor the sake of fairness, make sure you give each task to both robots, rather\nthan generating different tasks per robot.\nRobot efficiency\nCan you write a robot that finishes the delivery task faster than goalOrientedRobot\n? If you observe that robot\u2019s behavior, what obviously stupid things does it",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_296",
    "text": "Robot efficiency\nCan you write a robot that finishes the delivery task faster than goalOrientedRobot\n? If you observe that robot\u2019s behavior, what obviously stupid things does it\ndo? How could those be improved?\nIf you solved the previous exercise, you might want to use your compareRobots\nfunction to verify whether you improved the robot.\n121\nPersistent group\nMost data structures provided in a standard JavaScript environment aren\u2019t\nvery well suited for persistent use. Arrays have slice and concat methods,\nwhich allow us to easily create new arrays without damaging the old one. But\nSet, for example, has no methods for creating a new set with an item added or\nremoved.\nWrite a new class PGroup, similar to the Group class from Chapter 6, which\nstores a set of values. Like Group, it has add, delete, and has methods. Its add\nmethod, however, should return a new PGroup instance with the given member\nadded and leave the old one unchanged. Similarly, delete should create a new",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_297",
    "text": "method, however, should return a new PGroup instance with the given member\nadded and leave the old one unchanged. Similarly, delete should create a new\ninstance without a given member.\nThe class should work for values of any type, not just strings. It does not\nhave to be e\ufb00icient when used with large numbers of values.\nThe constructor shouldn\u2019t be part of the class\u2019s interface (though you\u2019ll def-\ninitely want to use it internally). Instead, there is an empty instance, PGroup.\nempty, that can be used as a starting value.\nWhy do you need only one PGroup.empty value rather than having a function\nthat creates a new, empty map every time?\n122\n\u201cDebugging is twice as hard as writing the code in the first place.\nTherefore, if you write the code as cleverly as possible, you are, by\ndefinition, not smart enough to debug it.\u201d\n\u2014Brian Kernighan and P.J. Plauger, The Elements of Programming\nStyle\nChapter 8\nBugs and Errors\nFlaws in computer programs are usually called bugs. It makes programmers",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_298",
    "text": "\u2014Brian Kernighan and P.J. Plauger, The Elements of Programming\nStyle\nChapter 8\nBugs and Errors\nFlaws in computer programs are usually called bugs. It makes programmers\nfeel good to imagine them as little things that just happen to crawl into our\nwork. In reality, of course, we put them there ourselves.\nIf a program is crystallized thought, we can roughly categorize bugs into\nthose caused by the thoughts being confused and those caused by mistakes\nintroduced while converting a thought to code. The former type is generally\nharder to diagnose and fix than the latter.\nLanguage\nMany mistakes could be pointed out to us automatically by the computer if it\nknew enough about what we\u2019re trying to do. But here, JavaScript\u2019s looseness\nis a hindrance. Its concept of bindings and properties is vague enough that\nit will rarely catch typos before actually running the program. Even then, it\nallows you to do some clearly nonsensical things without complaint, such as\ncomputing true * \"monkey\".",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_299",
    "text": "it will rarely catch typos before actually running the program. Even then, it\nallows you to do some clearly nonsensical things without complaint, such as\ncomputing true * \"monkey\".\nThere are some things that JavaScript does complain about. Writing a pro-\ngram that does not follow the language\u2019s grammar will immediately make the\ncomputer complain. Other things, such as calling something that\u2019s not a func-\ntion or looking up a property on an undefined value, will cause an error to be\nreported when the program tries to perform the action.\nOften, however, your nonsense computation will merely produce NaN (not a\nnumber) or an undefined value, while the program happily continues, convinced\nthat it\u2019s doing something meaningful. The mistake will manifest itself only\nlater, after the bogus value has traveled through several functions. It might\nnot trigger an error at all, but silently cause the program\u2019s output to be wrong.\nFinding the source of such problems can be di\ufb00icult.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_300",
    "text": "not trigger an error at all, but silently cause the program\u2019s output to be wrong.\nFinding the source of such problems can be di\ufb00icult.\nThe process of finding mistakes\u2014bugs\u2014in programs is called debugging.\n123\nStrict mode\nJavaScript can be made a little stricter by enabling strict mode. This can done\nby putting the string \"use strict\" at the top of a file or a function body.\nHere\u2019s an example:\nfunction canYouSpotTheProblem() {\n\"use strict\";\nfor (counter = 0; counter < 10; counter++) {\nconsole.log(\"Happy happy\");\n}\n}\ncanYouSpotTheProblem();\n// \u2192ReferenceError: counter is not defined\nCode inside classes and modules (which we will discuss in Chapter 10) is au-\ntomatically strict. The old nonstrict behavior still exists only because some\nold code might depend on it, and the language designers work hard to avoid\nbreaking any existing programs.\nNormally, when you forget to put let in front of your binding, as with\ncounter in the example, JavaScript quietly creates a global binding and uses",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_301",
    "text": "breaking any existing programs.\nNormally, when you forget to put let in front of your binding, as with\ncounter in the example, JavaScript quietly creates a global binding and uses\nthat. In strict mode, an error is reported instead. This is very helpful. It should\nbe noted, though, that this doesn\u2019t work when the binding in question already\nexists somewhere in scope. In that case, the loop will still quietly overwrite the\nvalue of the binding.\nAnother change in strict mode is that the this binding holds the value\nundefined in functions that are not called as methods. When making such\na call outside of strict mode, this refers to the global scope object, which is\nan object whose properties are the global bindings. So if you accidentally call\na method or constructor incorrectly in strict mode, JavaScript will produce\nan error as soon as it tries to read something from this, rather than happily\nwriting to the global scope.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_302",
    "text": "a method or constructor incorrectly in strict mode, JavaScript will produce\nan error as soon as it tries to read something from this, rather than happily\nwriting to the global scope.\nFor example, consider the following code, which calls a constructor function\nwithout the new keyword so that its this will not refer to a newly constructed\nobject:\nfunction Person(name) { this.name = name; }\nlet ferdinand = Person(\"Ferdinand\"); // oops\nconsole.log(name);\n// \u2192Ferdinand\nThe bogus call to Person succeeded, but returned an undefined value and cre-\n124\nated the global binding name. In strict mode, the result is different.\n\"use strict\";\nfunction Person(name) { this.name = name; }\nlet ferdinand = Person(\"Ferdinand\"); // forgot new\n// \u2192TypeError: Cannot set property 'name' of undefined\nWe are immediately told that something is wrong. This is helpful.\nFortunately, constructors created with the class notation will always com-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_303",
    "text": "// \u2192TypeError: Cannot set property 'name' of undefined\nWe are immediately told that something is wrong. This is helpful.\nFortunately, constructors created with the class notation will always com-\nplain if they are called without new, making this less of a problem even in\nnonstrict mode.\nStrict mode does a few more things. It disallows giving a function multiple\nparameters with the same name and removes certain problematic language\nfeatures entirely (such as the with statement, which is so wrong it is not further\ndiscussed in this book).\nIn short, putting \"use strict\" at the top of your program rarely hurts and\nmight help you spot a problem.\nTypes\nSome languages want to know the types of all your bindings and expressions\nbefore even running a program. They will tell you right away when a type\nis used in an inconsistent way. JavaScript considers types only when actually\nrunning the program, and even there often tries to implicitly convert values to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_304",
    "text": "is used in an inconsistent way. JavaScript considers types only when actually\nrunning the program, and even there often tries to implicitly convert values to\nthe type it expects, so it\u2019s not much help.\nStill, types provide a useful framework for talking about programs. A lot of\nmistakes come from being confused about the kind of value that goes into or\ncomes out of a function. If you have that information written down, you\u2019re less\nlikely to get confused.\nYou could add a comment like the following before the findRoute function\nfrom the previous chapter to describe its type:\n// (graph: Object, from: string, to: string) => string[]\nfunction findRoute(graph, from, to) {\n// ...\n}\nThere are a number of different conventions for annotating JavaScript programs\nwith types.\nOne thing about types is that they need to introduce their own complexity\nto be able to describe enough code to be useful. What do you think would be\nthe type of the randomPick function that returns a random element from an",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_305",
    "text": "to be able to describe enough code to be useful. What do you think would be\nthe type of the randomPick function that returns a random element from an\n125\narray? You\u2019d need to introduce a type variable, T, which can stand in for any\ntype, so that you can give randomPick a type like (T[])\u2192T (function from an\narray of Ts to a T).\nWhen the types of a program are known, it is possible for the computer to\ncheck them for you, pointing out mistakes before the program is run. There\nare several JavaScript dialects that add types to the language and check them.\nThe most popular one is called TypeScript. If you are interested in adding\nmore rigor to your programs, I recommend you give it a try.\nIn this book, we will continue using raw, dangerous, untyped JavaScript\ncode.\nTesting\nIf the language is not going to do much to help us find mistakes, we\u2019ll have to\nfind them the hard way: by running the program and seeing whether it does\nthe right thing.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_306",
    "text": "code.\nTesting\nIf the language is not going to do much to help us find mistakes, we\u2019ll have to\nfind them the hard way: by running the program and seeing whether it does\nthe right thing.\nDoing this by hand, again and again, is a really bad idea. Not only is it\nannoying but it also tends to be ineffective, since it takes too much time to\nexhaustively test everything every time you make a change.\nComputers are good at repetitive tasks, and testing is the ideal repetitive\ntask. Automated testing is the process of writing a program that tests another\nprogram. Writing tests is a bit more work than testing manually, but once\nyou\u2019ve done it, you gain a kind of superpower: it takes you only a few seconds\nto verify that your program still behaves properly in all the situations you\nwrote tests for. When you break something, you\u2019ll immediately notice rather\nthan randomly running into it at some later time.\nTests usually take the form of little labeled programs that verify some aspect",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_307",
    "text": "than randomly running into it at some later time.\nTests usually take the form of little labeled programs that verify some aspect\nof your code. For example, a set of tests for the (standard, probably already\ntested by someone else) toUpperCase method might look like this:\nfunction test(label, body) {\nif (!body()) console.log(`Failed: ${label}`);\n}\ntest(\"convert Latin text to uppercase\", () => {\nreturn \"hello\".toUpperCase() == \"HELLO\";\n});\ntest(\"convert Greek text to uppercase\", () => {\nreturn \"\u03a7\u03b1\u03af\u03c1\u03b5\u03c4\u03b5\".toUpperCase() == \"\u03a7\u0391\u038a\u03a1\u0395\u03a4\u0395\";\n});\ntest(\"don't convert case-less characters\", () => {\n126\nreturn \".\"\u0645\u0631\u062d\u0628\u0627toUpperCase() == \";\"\u0645\u0631\u062d\u0628\u0627\n});\nWriting tests like this tends to produce rather repetitive, awkward code. For-\ntunately, there exist pieces of software that help you build and run collections\nof tests (test suites) by providing a language (in the form of functions and\nmethods) suited to expressing tests and by outputting informative information",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_308",
    "text": "of tests (test suites) by providing a language (in the form of functions and\nmethods) suited to expressing tests and by outputting informative information\nwhen a test fails. These are usually called test runners.\nSome code is easier to test than other code. Generally, the more external\nobjects that the code interacts with, the harder it is to set up the context in\nwhich to test it. The style of programming shown in the previous chapter,\nwhich uses self-contained persistent values rather than changing objects, tends\nto be easy to test.\nDebugging\nOnce you notice there is something wrong with your program because it mis-\nbehaves or produces errors, the next step is to figure out what the problem\nis.\nSometimes it is obvious. The error message will point at a specific line of\nyour program, and if you look at the error description and that line of code,\nyou can often see the problem.\nBut not always. Sometimes the line that triggered the problem is simply the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_309",
    "text": "your program, and if you look at the error description and that line of code,\nyou can often see the problem.\nBut not always. Sometimes the line that triggered the problem is simply the\nfirst place where a flaky value produced elsewhere gets used in an invalid way.\nIf you have been solving the exercises in earlier chapters, you will probably\nhave already experienced such situations.\nThe following example program tries to convert a whole number to a string\nin a given base (decimal, binary, and so on) by repeatedly picking out the last\ndigit and then dividing the number to get rid of this digit. But the strange\noutput that it currently produces suggests that it has a bug.\nfunction numberToString(n, base = 10) {\nlet result = \"\", sign = \"\";\nif (n < 0) {\nsign = \"-\";\nn = -n;\n}\ndo {\nresult = String(n % base) + result;\nn /= base;\n} while (n > 0);\nreturn sign + result;\n127\n}\nconsole.log(numberToString(13, 10));\n// \u21921.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e\u2026-3181.3",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_310",
    "text": "n = -n;\n}\ndo {\nresult = String(n % base) + result;\nn /= base;\n} while (n > 0);\nreturn sign + result;\n127\n}\nconsole.log(numberToString(13, 10));\n// \u21921.5e-3231.3e-3221.3e-3211.3e-3201.3e-3191.3e\u2026-3181.3\nEven if you see the problem already, pretend for a moment that you don\u2019t. We\nknow that our program is malfunctioning, and we want to find out why.\nThis is where you must resist the urge to start making random changes to\nthe code to see whether that makes it better. Instead, think. Analyze what is\nhappening and come up with a theory of why it might be happening. Then\nmake additional observations to test this theory\u2014or, if you don\u2019t yet have a\ntheory, make additional observations to help you come up with one.\nPutting a few strategic console.log calls into the program is a good way to\nget additional information about what the program is doing. In this case, we\nwant n to take the values 13, 1, and then 0. Let\u2019s write out its value at the\nstart of the loop.\n13\n1.3\n0.13\n0.013\u2026\n1.5e-323",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_311",
    "text": "want n to take the values 13, 1, and then 0. Let\u2019s write out its value at the\nstart of the loop.\n13\n1.3\n0.13\n0.013\u2026\n1.5e-323\nRight. Dividing 13 by 10 does not produce a whole number. Instead of n /=\nbase, what we actually want is n = Math.floor(n / base) so that the number\nis properly \u201cshifted\u201d to the right.\nAn alternative to using console.log to peek into the program\u2019s behavior is to\nuse the debugger capabilities of your browser. Browsers come with the ability\nto set a breakpoint on a specific line of your code. When the execution of the\nprogram reaches a line with a breakpoint, it is paused, and you can inspect the\nvalues of bindings at that point. I won\u2019t go into details, as debuggers differ\nfrom browser to browser, but look in your browser\u2019s developer tools or search\nthe web for instructions.\nAnother way to set a breakpoint is to include a debugger statement (con-\nsisting simply of that keyword) in your program.\nIf the developer tools of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_312",
    "text": "the web for instructions.\nAnother way to set a breakpoint is to include a debugger statement (con-\nsisting simply of that keyword) in your program.\nIf the developer tools of\nyour browser are active, the program will pause whenever it reaches such a\nstatement.\nError propagation\nNot all problems can be prevented by the programmer, unfortunately. If your\nprogram communicates with the outside world in any way, it is possible to get\n128\nmalformed input, to become overloaded with work, or to have the network fail.\nIf you\u2019re programming only for yourself, you can afford to just ignore such\nproblems until they occur. But if you build something that is going to be used\nby anybody else, you usually want the program to do better than just crash.\nSometimes the right thing to do is take the bad input in stride and continue\nrunning. In other cases, it is better to report to the user what went wrong and\nthen give up. In either situation the program has to actively do something in",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_313",
    "text": "running. In other cases, it is better to report to the user what went wrong and\nthen give up. In either situation the program has to actively do something in\nresponse to the problem.\nSay you have a function promptNumber that asks the user for a number and\nreturns it. What should it return if the user inputs \u201corange\u201d?\nOne option is to make it return a special value. Common choices for such\nvalues are null, undefined, or -1.\nfunction promptNumber(question) {\nlet result = Number(prompt(question));\nif (Number.isNaN(result)) return null;\nelse return result;\n}\nconsole.log(promptNumber(\"How many trees do you see?\"));\nNow any code that calls promptNumber must check whether an actual number\nwas read and, failing that, must somehow recover\u2014maybe by asking again or\nby filling in a default value. Or it could again return a special value to its caller\nto indicate that it failed to do what it was asked.\nIn many situations, mostly when errors are common and the caller should",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_314",
    "text": "to indicate that it failed to do what it was asked.\nIn many situations, mostly when errors are common and the caller should\nbe explicitly taking them into account, returning a special value is a good\nway to indicate an error. It does, however, have its downsides. First, what\nif the function can already return every possible kind of value?\nIn such a\nfunction, you\u2019ll have to do something like wrap the result in an object to be\nable to distinguish success from failure, the way the next method on the iterator\ninterface does.\nfunction lastElement(array) {\nif (array.length == 0) {\nreturn {failed: true};\n} else {\nreturn {value: array[array.length - 1]};\n}\n}\nThe second issue with returning special values is that it can lead to awkward\ncode. If a piece of code calls promptNumber 10 times, it has to check 10 times\n129\nwhether null was returned. If its response to finding null is to simply return\nnull itself, callers of the function will in turn have to check for it, and so on.\nExceptions",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_315",
    "text": "129\nwhether null was returned. If its response to finding null is to simply return\nnull itself, callers of the function will in turn have to check for it, and so on.\nExceptions\nWhen a function cannot proceed normally, what we would often like to do is\njust stop what we are doing and immediately jump to a place that knows how\nto handle the problem. This is what exception handling does.\nExceptions are a mechanism that makes it possible for code that runs into\na problem to raise (or throw) an exception. An exception can be any value.\nRaising one somewhat resembles a super-charged return from a function: it\njumps out of not just the current function but also its callers, all the way down\nto the first call that started the current execution. This is called unwinding\nthe stack. You may remember the stack of function calls mentioned in Chapter\n3. An exception zooms down this stack, throwing away all the call contexts it\nencounters.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_316",
    "text": "the stack. You may remember the stack of function calls mentioned in Chapter\n3. An exception zooms down this stack, throwing away all the call contexts it\nencounters.\nIf exceptions always zoomed right down to the bottom of the stack, they\nwould not be of much use. They\u2019d just provide a novel way to blow up your\nprogram. Their power lies in the fact that you can set \u201cobstacles\u201d along the\nstack to catch the exception as it is zooming down. Once you\u2019ve caught an\nexception, you can do something with it to address the problem and then\ncontinue to run the program.\nHere\u2019s an example:\nfunction promptDirection(question) {\nlet result = prompt(question);\nif (result.toLowerCase() == \"left\") return \"L\";\nif (result.toLowerCase() == \"right\") return \"R\";\nthrow new Error(\"Invalid direction: \" + result);\n}\nfunction look() {\nif (promptDirection(\"Which way?\") == \"L\") {\nreturn \"a house\";\n} else {\nreturn \"two angry bears\";\n}\n}\ntry {\nconsole.log(\"You see\", look());\n} catch (error) {\n130",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_317",
    "text": "}\nfunction look() {\nif (promptDirection(\"Which way?\") == \"L\") {\nreturn \"a house\";\n} else {\nreturn \"two angry bears\";\n}\n}\ntry {\nconsole.log(\"You see\", look());\n} catch (error) {\n130\nconsole.log(\"Something went wrong: \" + error);\n}\nThe throw keyword is used to raise an exception. Catching one is done by\nwrapping a piece of code in a try block, followed by the keyword catch. When\nthe code in the try block causes an exception to be raised, the catch block is\nevaluated, with the name in parentheses bound to the exception value. After\nthe catch block finishes\u2014or if the try block finishes without problems\u2014the\nprogram proceeds beneath the entire try/catch statement.\nIn this case, we used the Error constructor to create our exception value.\nThis is a standard JavaScript constructor that creates an object with a message\nproperty.\nInstances of Error also gather information about the call stack\nthat existed when the exception was created, a so-called stack trace.\nThis",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_318",
    "text": "property.\nInstances of Error also gather information about the call stack\nthat existed when the exception was created, a so-called stack trace.\nThis\ninformation is stored in the stack property and can be helpful when trying\nto debug a problem: it tells us the function where the problem occurred and\nwhich functions made the failing call.\nNote that the look function completely ignores the possibility that promptDirection\nmight go wrong. This is the big advantage of exceptions: error-handling code\nis necessary only at the point where the error occurs and at the point where it\nis handled. The functions in between can forget all about it.\nWell, almost...\nCleaning up after exceptions\nThe effect of an exception is another kind of control flow. Every action that\nmight cause an exception, which is pretty much every function call and property\naccess, might cause control to suddenly leave your code.\nThis means when code has several side effects, even if its \u201cregular\u201d control",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_319",
    "text": "access, might cause control to suddenly leave your code.\nThis means when code has several side effects, even if its \u201cregular\u201d control\nflow looks like they\u2019ll always all happen, an exception might prevent some of\nthem from taking place.\nHere is some really bad banking code:\nconst accounts = {\na: 100,\nb: 0,\nc: 20\n};\nfunction getAccount() {\nlet accountName = prompt(\"Enter an account name\");\nif (!Object.hasOwn(accounts, accountName)) {\nthrow new Error(`No such account: ${accountName}`);\n131\n}\nreturn accountName;\n}\nfunction transfer(from, amount) {\nif (accounts[from] < amount) return;\naccounts[from] -= amount;\naccounts[getAccount()] += amount;\n}\nThe transfer function transfers a sum of money from a given account to an-\nother, asking for the name of the other account in the process. If given an\ninvalid account name, getAccount throws an exception.\nBut transfer first removes the money from the account and then calls\ngetAccount before it adds it to another account.\nIf it is broken off by an",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_320",
    "text": "invalid account name, getAccount throws an exception.\nBut transfer first removes the money from the account and then calls\ngetAccount before it adds it to another account.\nIf it is broken off by an\nexception at that point, it\u2019ll just make the money disappear.\nThat code could have been written a little more intelligently, for example by\ncalling getAccount before it starts moving money around. But often problems\nlike this occur in more subtle ways. Even functions that don\u2019t look like they\nwill throw an exception might do so in exceptional circumstances or when they\ncontain a programmer mistake.\nOne way to address this is to use fewer side effects. Again, a programming\nstyle that computes new values instead of changing existing data helps. If a\npiece of code stops running in the middle of creating a new value, no existing\ndata structures were damaged, making it easier to recover.\nSince that isn\u2019t always practical, try statements have another feature: they",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_321",
    "text": "data structures were damaged, making it easier to recover.\nSince that isn\u2019t always practical, try statements have another feature: they\nmay be followed by a finally block either instead of or in addition to a catch\nblock. A finally block says \u201cno matter what happens, run this code after\ntrying to run the code in the try block.\u201d\nfunction transfer(from, amount) {\nif (accounts[from] < amount) return;\nlet progress = 0;\ntry {\naccounts[from] -= amount;\nprogress = 1;\naccounts[getAccount()] += amount;\nprogress = 2;\n} finally {\nif (progress == 1) {\naccounts[from] += amount;\n}\n}\n132\n}\nThis version of the function tracks its progress, and if, when leaving, it notices\nthat it was aborted at a point where it had created an inconsistent program\nstate, it repairs the damage it did.\nNote that even though the finally code is run when an exception is thrown\nin the try block, it does not interfere with the exception. After the finally\nblock runs, the stack continues unwinding.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_322",
    "text": "Note that even though the finally code is run when an exception is thrown\nin the try block, it does not interfere with the exception. After the finally\nblock runs, the stack continues unwinding.\nWriting programs that operate reliably even when exceptions pop up in un-\nexpected places is hard. Many people simply don\u2019t bother, and because ex-\nceptions are typically reserved for exceptional circumstances, the problem may\noccur so rarely that it is never even noticed. Whether that is a good thing or\na really bad thing depends on how much damage the software will do when it\nfails.\nSelective catching\nWhen an exception makes it all the way to the bottom of the stack without\nbeing caught, it gets handled by the environment. What this means differs\nbetween environments. In browsers, a description of the error typically gets\nwritten to the JavaScript console (reachable through the browser\u2019s Tools or\nDeveloper menu).\nNode.js, the browserless JavaScript environment we will",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_323",
    "text": "written to the JavaScript console (reachable through the browser\u2019s Tools or\nDeveloper menu).\nNode.js, the browserless JavaScript environment we will\ndiscuss in Chapter 20, is more careful about data corruption. It aborts the\nwhole process when an unhandled exception occurs.\nFor programmer mistakes, just letting the error go through is often the best\nyou can do. An unhandled exception is a reasonable way to signal a broken\nprogram, and the JavaScript console will, on modern browsers, provide you\nwith some information about which function calls were on the stack when the\nproblem occurred.\nFor problems that are expected to happen during routine use, crashing with\nan unhandled exception is a terrible strategy.\nInvalid uses of the language, such as referencing a nonexistent binding, look-\ning up a property on null, or calling something that\u2019s not a function, will also\nresult in exceptions being raised. Such exceptions can also be caught.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_324",
    "text": "ing up a property on null, or calling something that\u2019s not a function, will also\nresult in exceptions being raised. Such exceptions can also be caught.\nWhen a catch body is entered, all we know is that something in our try\nbody caused an exception. But we don\u2019t know what did or which exception it\ncaused.\nJavaScript (in a rather glaring omission) doesn\u2019t provide direct support for\nselectively catching exceptions: either you catch them all or you don\u2019t catch\n133\nany. This makes it tempting to assume that the exception you get is the one\nyou were thinking about when you wrote the catch block.\nBut it might not be. Some other assumption might be violated, or you might\nhave introduced a bug that is causing an exception. Here is an example that\nattempts to keep on calling promptDirection until it gets a valid answer:\nfor (;;) {\ntry {\nlet dir = promtDirection(\"Where?\"); // \u2190typo!\nconsole.log(\"You chose \", dir);\nbreak;\n} catch (e) {\nconsole.log(\"Not a valid direction. Try again.\");\n}\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_325",
    "text": "for (;;) {\ntry {\nlet dir = promtDirection(\"Where?\"); // \u2190typo!\nconsole.log(\"You chose \", dir);\nbreak;\n} catch (e) {\nconsole.log(\"Not a valid direction. Try again.\");\n}\n}\nThe for (;;) construct is a way to intentionally create a loop that doesn\u2019t\nterminate on its own. We break out of the loop only when a valid direction\nis given. Unfortunately, we misspelled promptDirection, which will result in\nan \u201cundefined variable\u201d error. Because the catch block completely ignores its\nexception value (e), assuming it knows what the problem is, it wrongly treats\nthe binding error as indicating bad input. Not only does this cause an infinite\nloop but it also \u201cburies\u201d the useful error message about the misspelled binding.\nAs a general rule, don\u2019t blanket-catch exceptions unless it is for the purpose\nof \u201crouting\u201d them somewhere\u2014for example, over the network to tell another\nsystem that our program crashed. And even then, think carefully about how\nyou might be hiding information.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_326",
    "text": "of \u201crouting\u201d them somewhere\u2014for example, over the network to tell another\nsystem that our program crashed. And even then, think carefully about how\nyou might be hiding information.\nWe want to catch a specific kind of exception. We can do this by checking\nin the catch block whether the exception we got is the one we are interested\nin, and if not, rethrow it. But how do we recognize an exception?\nWe could compare its message property against the error message we happen\nto expect. But that\u2019s a shaky way to write code\u2014we\u2019d be using information\nthat\u2019s intended for human consumption (the message) to make a programmatic\ndecision. As soon as someone changes (or translates) the message, the code will\nstop working.\nRather, let\u2019s define a new type of error and use instanceof to identify it.\nclass InputError extends Error {}\nfunction promptDirection(question) {\nlet result = prompt(question);\nif (result.toLowerCase() == \"left\") return \"L\";\nif (result.toLowerCase() == \"right\") return \"R\";\n134",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_327",
    "text": "function promptDirection(question) {\nlet result = prompt(question);\nif (result.toLowerCase() == \"left\") return \"L\";\nif (result.toLowerCase() == \"right\") return \"R\";\n134\nthrow new InputError(\"Invalid direction: \" + result);\n}\nThe new error class extends Error. It doesn\u2019t define its own constructor, which\nmeans that it inherits the Error constructor, which expects a string message\nas argument. In fact, it doesn\u2019t define anything at all\u2014the class is empty.\nInputError objects behave like Error objects, except that they have a different\nclass by which we can recognize them.\nNow the loop can catch these more carefully.\nfor (;;) {\ntry {\nlet dir = promptDirection(\"Where?\");\nconsole.log(\"You chose \", dir);\nbreak;\n} catch (e) {\nif (e instanceof InputError) {\nconsole.log(\"Not a valid direction. Try again.\");\n} else {\nthrow e;\n}\n}\n}\nThis will catch only instances of InputError and let unrelated exceptions through.\nIf you reintroduce the typo, the undefined binding error will be properly re-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_328",
    "text": "} else {\nthrow e;\n}\n}\n}\nThis will catch only instances of InputError and let unrelated exceptions through.\nIf you reintroduce the typo, the undefined binding error will be properly re-\nported.\nAssertions\nAssertions are checks inside a program that verify that something is the way\nit is supposed to be. They are used not to handle situations that can come up\nin normal operation but to find programmer mistakes.\nIf, for example, firstElement is described as a function that should never be\ncalled on empty arrays, we might write it like this:\nfunction firstElement(array) {\nif (array.length == 0) {\nthrow new Error(\"firstElement called with []\");\n}\nreturn array[0];\n}\nNow, instead of silently returning undefined (which you get when reading an\n135\narray property that does not exist), this will loudly blow up your program\nas soon as you misuse it. This makes it less likely for such mistakes to go\nunnoticed and easier to find their cause when they occur.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_329",
    "text": "as soon as you misuse it. This makes it less likely for such mistakes to go\nunnoticed and easier to find their cause when they occur.\nI do not recommend trying to write assertions for every possible kind of bad\ninput. That\u2019d be a lot of work and would lead to very noisy code. You\u2019ll want\nto reserve them for mistakes that are easy to make (or that you find yourself\nmaking).\nSummary\nAn important part of programming is finding, diagnosing, and fixing bugs.\nProblems can become easier to notice if you have an automated test suite or\nadd assertions to your programs.\nProblems caused by factors outside the program\u2019s control should usually be\nactively planned for. Sometimes, when the problem can be handled locally,\nspecial return values are a good way to track them. Otherwise, exceptions may\nbe preferable.\nThrowing an exception causes the call stack to be unwound until the next\nenclosing try/catch block or until the bottom of the stack.\nThe exception",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_330",
    "text": "be preferable.\nThrowing an exception causes the call stack to be unwound until the next\nenclosing try/catch block or until the bottom of the stack.\nThe exception\nvalue will be given to the catch block that catches it, which should verify that\nit is actually the expected kind of exception and then do something with it.\nTo help address the unpredictable control flow caused by exceptions, finally\nblocks can be used to ensure that a piece of code always runs when a block\nfinishes.\nExercises\nRetry\nSay you have a function primitiveMultiply that in 20 percent of cases mul-\ntiplies two numbers and in the other 80 percent of cases raises an exception\nof type MultiplicatorUnitFailure. Write a function that wraps this clunky\nfunction and just keeps trying until a call succeeds, after which it returns the\nresult.\nMake sure you handle only the exceptions you are trying to handle.\nThe locked box\nConsider the following (rather contrived) object:\n136\nconst box = new class {\nlocked = true;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_331",
    "text": "result.\nMake sure you handle only the exceptions you are trying to handle.\nThe locked box\nConsider the following (rather contrived) object:\n136\nconst box = new class {\nlocked = true;\n#content = [];\nunlock() { this.locked = false; }\nlock() { this.locked = true;\n}\nget content() {\nif (this.locked) throw new Error(\"Locked!\");\nreturn this.#content;\n}\n};\nIt is a box with a lock. There is an array in the box, but you can get at it only\nwhen the box is unlocked.\nWrite a function called withBoxUnlocked that takes a function value as ar-\ngument, unlocks the box, runs the function, and then ensures that the box\nis locked again before returning, regardless of whether the argument function\nreturned normally or threw an exception.\nFor extra points, make sure that if you call withBoxUnlocked when the box\nis already unlocked, the box stays unlocked.\n137\n\u201cSome people, when confronted with a problem, think \u2018I know, I\u2019ll\nuse regular expressions.\u2019 Now they have two problems.\u201d\n\u2014Jamie Zawinski\nChapter 9",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_332",
    "text": "is already unlocked, the box stays unlocked.\n137\n\u201cSome people, when confronted with a problem, think \u2018I know, I\u2019ll\nuse regular expressions.\u2019 Now they have two problems.\u201d\n\u2014Jamie Zawinski\nChapter 9\nRegular Expressions\nProgramming tools and techniques survive and spread in a chaotic, evolutionary\nway. It\u2019s not always the best or most brilliant ones that win, but rather the\nones that function well enough within the right niche or that happen to be\nintegrated with another successful piece of technology.\nIn this chapter, I will discuss one such tool, regular expressions. Regular\nexpressions are a way to describe patterns in string data. They form a small,\nseparate language that is part of JavaScript and many other languages and\nsystems.\nRegular expressions are both terribly awkward and extremely useful. Their\nsyntax is cryptic and the programming interface JavaScript provides for them\nis clumsy. But they are a powerful tool for inspecting and processing strings.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_333",
    "text": "syntax is cryptic and the programming interface JavaScript provides for them\nis clumsy. But they are a powerful tool for inspecting and processing strings.\nProperly understanding regular expressions will make you a more effective pro-\ngrammer.\nCreating a regular expression\nA regular expression is a type of object. It can be either constructed with\nthe RegExp constructor or written as a literal value by enclosing a pattern in\nforward slash (/) characters.\nlet re1 = new RegExp(\"abc\");\nlet re2 = /abc/;\nBoth of those regular expression objects represent the same pattern: an a\ncharacter followed by a b followed by a c.\nWhen using the RegExp constructor, the pattern is written as a normal string,\nso the usual rules apply for backslashes.\nThe second notation, where the pattern appears between slash characters,\ntreats backslashes somewhat differently. First, since a forward slash ends the\npattern, we need to put a backslash before any forward slash that we want",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_334",
    "text": "treats backslashes somewhat differently. First, since a forward slash ends the\npattern, we need to put a backslash before any forward slash that we want\nto be part of the pattern. In addition, backslashes that aren\u2019t part of special\n138\ncharacter codes (like \\n) will be preserved, rather than ignored as they are\nin strings, and change the meaning of the pattern. Some characters, such as\nquestion marks and plus signs, have special meanings in regular expressions and\nmust be preceded by a backslash if they are meant to represent the character\nitself.\nlet aPlus = /A\\+/;\nTesting for matches\nRegular expression objects have a number of methods. The simplest one is\ntest. If you pass it a string, it will return a Boolean telling you whether the\nstring contains a match of the pattern in the expression.\nconsole.log(/abc/.test(\"abcde\"));\n// \u2192true\nconsole.log(/abc/.test(\"abxde\"));\n// \u2192false\nA regular expression consisting of only nonspecial characters simply represents",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_335",
    "text": "console.log(/abc/.test(\"abcde\"));\n// \u2192true\nconsole.log(/abc/.test(\"abxde\"));\n// \u2192false\nA regular expression consisting of only nonspecial characters simply represents\nthat sequence of characters. If abc occurs anywhere in the string we are testing\nagainst (not just at the start), test will return true.\nSets of characters\nFinding out whether a string contains abc could just as well be done with a call\nto indexOf. Regular expressions are useful because they allow us to describe\nmore complicated patterns.\nSay we want to match any number. In a regular expression, putting a set\nof characters between square brackets makes that part of the expression match\nany of the characters between the brackets.\nBoth of the following expressions match all strings that contain a digit:\nconsole.log(/[0123456789]/.test(\"in 1992\"));\n// \u2192true\nconsole.log(/[0-9]/.test(\"in 1992\"));\n// \u2192true\nWithin square brackets, a hyphen (-) between two characters can be used",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_336",
    "text": "console.log(/[0123456789]/.test(\"in 1992\"));\n// \u2192true\nconsole.log(/[0-9]/.test(\"in 1992\"));\n// \u2192true\nWithin square brackets, a hyphen (-) between two characters can be used\nto indicate a range of characters, where the ordering is determined by the\ncharacter\u2019s Unicode number. Characters 0 to 9 sit right next to each other in\n139\nthis ordering (codes 48 to 57), so [0-9] covers all of them and matches any\ndigit.\nA number of common character groups have their own built-in shortcuts.\nDigits are one of them: \\d means the same thing as [0-9].\n\\d\nAny digit character\n\\w\nAn alphanumeric character (\u201cword character\u201d)\n\\s\nAny whitespace character (space, tab, newline, and similar)\n\\D\nA character that is not a digit\n\\W\nA nonalphanumeric character\n\\S\nA nonwhitespace character\n.\nAny character except for newline\nYou could match a date and time format like 01-30-2003 15:20 with the\nfollowing expression:\nlet dateTime = /\\d\\d-\\d\\d-\\d\\d\\d\\d \\d\\d:\\d\\d/;\nconsole.log(dateTime.test(\"01-30-2003 15:20\"));",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_337",
    "text": "You could match a date and time format like 01-30-2003 15:20 with the\nfollowing expression:\nlet dateTime = /\\d\\d-\\d\\d-\\d\\d\\d\\d \\d\\d:\\d\\d/;\nconsole.log(dateTime.test(\"01-30-2003 15:20\"));\n// \u2192true\nconsole.log(dateTime.test(\"30-jan-2003 15:20\"));\n// \u2192false\nThat regular expression looks completely awful, doesn\u2019t it? Half of it is back-\nslashes, producing a background noise that makes it hard to spot the actual\npattern expressed. We\u2019ll see a slightly improved version of this expression later.\nThese backslash codes can also be used inside square brackets. For example,\n[\\d.] means any digit or a period character. The period itself, between square\nbrackets, loses its special meaning. The same goes for other special characters,\nsuch as the plus sign (+).\nTo invert a set of characters\u2014that is, to express that you want to match any\ncharacter except the ones in the set\u2014you can write a caret (^) character after\nthe opening bracket.\nlet nonBinary = /[^01]/;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_338",
    "text": "character except the ones in the set\u2014you can write a caret (^) character after\nthe opening bracket.\nlet nonBinary = /[^01]/;\nconsole.log(nonBinary.test(\"1100100010100110\"));\n// \u2192false\nconsole.log(nonBinary.test(\"0111010112101001\"));\n// \u2192true\nInternational characters\nBecause of JavaScript\u2019s initial simplistic implementation and the fact that this\nsimplistic approach was later set in stone as standard behavior, JavaScript\u2019s\n140\nregular expressions are rather dumb about characters that do not appear in\nthe English language. For example, as far as JavaScript\u2019s regular expressions\nare concerned, a \u201cword character\u201d is only one of the 26 characters in the Latin\nalphabet (uppercase or lowercase), decimal digits, and, for some reason, the\nunderscore character. Things like \u00e9 or \u00df, which most definitely are word char-\nacters, will not match \\w (and will match uppercase \\W, the nonword category).\nBy a strange historical accident, \\s (whitespace) does not have this problem",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_339",
    "text": "acters, will not match \\w (and will match uppercase \\W, the nonword category).\nBy a strange historical accident, \\s (whitespace) does not have this problem\nand matches all characters that the Unicode standard considers whitespace,\nincluding things like the nonbreaking space and the Mongolian vowel separator.\nIt is possible to use \\p in a regular expression to match all characters to which\nthe Unicode standard assigns a given property. This allows us to match things\nlike letters in a more cosmopolitan way. However, again due to compatibility\nwith the original language standards, those are recognized only when you put\na u character (for Unicode) after the regular expression.\n\\p{L}\nAny letter\n\\p{N}\nAny numeric character\n\\p{P}\nAny punctuation character\n\\P{L}\nAny nonletter (uppercase P inverts)\n\\p{Script=Hangul}\nAny character from the given script (see Chapter 5)\nUsing \\w for text processing that may need to handle non-English text (or",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_340",
    "text": "\\P{L}\nAny nonletter (uppercase P inverts)\n\\p{Script=Hangul}\nAny character from the given script (see Chapter 5)\nUsing \\w for text processing that may need to handle non-English text (or\neven English text with borrowed words like \u201cclich\u00e9\u201d) is a liability, since it won\u2019t\ntreat characters like \u201c\u00e9\u201d as letters. Though they tend to be a bit more verbose,\n\\p property groups are more robust.\nconsole.log(/\\p{L}/u.test(\"\u03b1\"));\n// \u2192true\nconsole.log(/\\p{L}/u.test(\"!\"));\n// \u2192false\nconsole.log(/\\p{Script=Greek}/u.test(\"\u03b1\"));\n// \u2192true\nconsole.log(/\\p{Script=Arabic}/u.test(\"\u03b1\"));\n// \u2192false\nOn the other hand, if you are matching numbers in order to do something\nwith them, you often do want \\d for digits, since converting arbitrary numeric\ncharacters into a JavaScript number is not something that a function like Number\ncan do for you.\n141\nRepeating parts of a pattern\nWe now know how to match a single digit. What if we want to match a whole\nnumber\u2014a sequence of one or more digits?",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_341",
    "text": "can do for you.\n141\nRepeating parts of a pattern\nWe now know how to match a single digit. What if we want to match a whole\nnumber\u2014a sequence of one or more digits?\nWhen you put a plus sign (+) after something in a regular expression, it\nindicates that the element may be repeated more than once.\nThus, /\\d+/\nmatches one or more digit characters.\nconsole.log(/'\\d+'/.test(\"'123'\"));\n// \u2192true\nconsole.log(/'\\d+'/.test(\"''\"));\n// \u2192false\nconsole.log(/'\\d*'/.test(\"'123'\"));\n// \u2192true\nconsole.log(/'\\d*'/.test(\"''\"));\n// \u2192true\nThe star (*) has a similar meaning but also allows the pattern to match zero\ntimes. Something with a star after it never prevents a pattern from matching\u2014\nit\u2019ll just match zero instances if it can\u2019t find any suitable text to match.\nA question mark (?) makes a part of a pattern optional, meaning it may\noccur zero times or one time.\nIn the following example, the u character is\nallowed to occur, but the pattern also matches when it is missing:\nlet neighbor = /neighbou?r/;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_342",
    "text": "occur zero times or one time.\nIn the following example, the u character is\nallowed to occur, but the pattern also matches when it is missing:\nlet neighbor = /neighbou?r/;\nconsole.log(neighbor.test(\"neighbour\"));\n// \u2192true\nconsole.log(neighbor.test(\"neighbor\"));\n// \u2192true\nTo indicate that a pattern should occur a precise number of times, use braces.\nPutting {4} after an element, for example, requires it to occur exactly four\ntimes. It is also possible to specify a range this way: {2,4} means the element\nmust occur at least twice and at most four times.\nHere is another version of the date and time pattern that allows both single-\nand double-digit days, months, and hours. It is also slightly easier to decipher.\nlet dateTime = /\\d{1,2}-\\d{1,2}-\\d{4} \\d{1,2}:\\d{2}/;\nconsole.log(dateTime.test(\"1-30-2003 8:45\"));\n// \u2192true\nYou can also specify open-ended ranges when using braces by omitting the\nnumber after the comma. For example, {5,} means five or more times.\n142\nGrouping subexpressions",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_343",
    "text": "// \u2192true\nYou can also specify open-ended ranges when using braces by omitting the\nnumber after the comma. For example, {5,} means five or more times.\n142\nGrouping subexpressions\nTo use an operator like * or + on more than one element at a time, you must\nuse parentheses. A part of a regular expression that is enclosed in parentheses\ncounts as a single element as far as the operators following it are concerned.\nlet cartoonCrying = /boo+(hoo+)+/i;\nconsole.log(cartoonCrying.test(\"Boohoooohoohooo\"));\n// \u2192true\nThe first and second + characters apply only to the second o in boo and hoo,\nrespectively. The third + applies to the whole group (hoo+), matching one or\nmore sequences like that.\nThe i at the end of the expression in the example makes this regular expres-\nsion case insensitive, allowing it to match the uppercase B in the input string,\neven though the pattern is itself all lowercase.\nMatches and groups\nThe test method is the absolute simplest way to match a regular expression.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_344",
    "text": "even though the pattern is itself all lowercase.\nMatches and groups\nThe test method is the absolute simplest way to match a regular expression.\nIt tells you only whether it matched and nothing else. Regular expressions also\nhave an exec (execute) method that will return null if no match was found\nand return an object with information about the match otherwise.\nlet match = /\\d+/.exec(\"one two 100\");\nconsole.log(match);\n// \u2192[\"100\"]\nconsole.log(match.index);\n// \u21928\nAn object returned from exec has an index property that tells us where in\nthe string the successful match begins. Other than that, the object looks like\n(and in fact is) an array of strings, whose first element is the string that was\nmatched. In the previous example, this is the sequence of digits that we were\nlooking for.\nString values have a match method that behaves similarly.\nconsole.log(\"one two 100\".match(/\\d+/));\n// \u2192[\"100\"]\nWhen the regular expression contains subexpressions grouped with parentheses,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_345",
    "text": "String values have a match method that behaves similarly.\nconsole.log(\"one two 100\".match(/\\d+/));\n// \u2192[\"100\"]\nWhen the regular expression contains subexpressions grouped with parentheses,\nthe text that matched those groups will also show up in the array. The whole\nmatch is always the first element. The next element is the part matched by the\n143\nfirst group (the one whose opening parenthesis comes first in the expression),\nthen the second group, and so on.\nlet quotedText = /'([^']*)'/;\nconsole.log(quotedText.exec(\"she said 'hello'\"));\n// \u2192[\"'hello'\", \"hello\"]\nWhen a group does not end up being matched at all (for example, when followed\nby a question mark), its position in the output array will hold undefined. When\na group is matched multiple times (for example, when followed by a +), only\nthe last match ends up in the array.\nconsole.log(/bad(ly)?/.exec(\"bad\"));\n// \u2192[\"bad\", undefined]\nconsole.log(/(\\d)+/.exec(\"123\"));\n// \u2192[\"123\", \"3\"]",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_346",
    "text": "the last match ends up in the array.\nconsole.log(/bad(ly)?/.exec(\"bad\"));\n// \u2192[\"bad\", undefined]\nconsole.log(/(\\d)+/.exec(\"123\"));\n// \u2192[\"123\", \"3\"]\nIf you want to use parentheses purely for grouping, without having them show\nup in the array of matches, you can put ?: after the opening parenthesis.\nconsole.log(/(?:na)+/.exec(\"banana\"));\n// \u2192[\"nana\"]\nGroups can be useful for extracting parts of a string. If we don\u2019t just want\nto verify whether a string contains a date but also extract it and construct an\nobject that represents it, we can wrap parentheses around the digit patterns\nand directly pick the date out of the result of exec.\nBut first we\u2019ll take a brief detour to discuss the built-in way to represent\ndate and time values in JavaScript.\nThe Date class\nJavaScript has a standard Date class for representing dates, or rather, points\nin time. If you simply create a date object using new, you get the current date\nand time.\nconsole.log(new Date());",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_347",
    "text": "JavaScript has a standard Date class for representing dates, or rather, points\nin time. If you simply create a date object using new, you get the current date\nand time.\nconsole.log(new Date());\n// \u2192Fri Feb 02 2024 18:03:06 GMT+0100 (CET)\nYou can also create an object for a specific time.\nconsole.log(new Date(2009, 11, 9));\n// \u2192Wed Dec 09 2009 00:00:00 GMT+0100 (CET)\nconsole.log(new Date(2009, 11, 9, 12, 59, 59, 999));\n// \u2192Wed Dec 09 2009 12:59:59 GMT+0100 (CET)\n144\nJavaScript uses a convention where month numbers start at zero (so December\nis 11), yet day numbers start at one. This is confusing and silly. Be careful.\nThe last four arguments (hours, minutes, seconds, and milliseconds) are op-\ntional and taken to be zero when not given.\nTimestamps are stored as the number of milliseconds since the start of 1970,\nin the UTC time zone. This follows a convention set by \u201cUnix time\u201d, which\nwas invented around that time. You can use negative numbers for times before",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_348",
    "text": "in the UTC time zone. This follows a convention set by \u201cUnix time\u201d, which\nwas invented around that time. You can use negative numbers for times before\n1970. The getTime method on a date object returns this number. It is big, as\nyou can imagine.\nconsole.log(new Date(2013, 11, 19).getTime());\n// \u21921387407600000\nconsole.log(new Date(1387407600000));\n// \u2192Thu Dec 19 2013 00:00:00 GMT+0100 (CET)\nIf you give the Date constructor a single argument, that argument is treated as\nsuch a millisecond count. You can get the current millisecond count by creating\na new Date object and calling getTime on it or by calling the Date.now function.\nDate objects provide methods such as getFullYear, getMonth, getDate, getHours\n, getMinutes, and getSeconds to extract their components. Besides getFullYear\nthere\u2019s also getYear, which gives you the year minus 1900 (such as 98 or 125)\nand is mostly useless.\nPutting parentheses around the parts of the expression that we are interested",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_349",
    "text": "there\u2019s also getYear, which gives you the year minus 1900 (such as 98 or 125)\nand is mostly useless.\nPutting parentheses around the parts of the expression that we are interested\nin, we can now create a date object from a string.\nfunction getDate(string) {\nlet [_, month, day, year] =\n/(\\d{1,2})-(\\d{1,2})-(\\d{4})/.exec(string);\nreturn new Date(year, month - 1, day);\n}\nconsole.log(getDate(\"1-30-2003\"));\n// \u2192Thu Jan 30 2003 00:00:00 GMT+0100 (CET)\nThe underscore (_) binding is ignored and used only to skip the full match\nelement in the array returned by exec.\nBoundaries and look-ahead\nUnfortunately, getDate will also happily extract a date from the string \"100-1-30000\"\n. A match may happen anywhere in the string, so in this case, it\u2019ll just start\nat the second character and end at the second-to-last character.\nIf we want to enforce that the match must span the whole string, we can add\n145\nthe markers ^ and $. The caret matches the start of the input string, whereas",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_350",
    "text": "If we want to enforce that the match must span the whole string, we can add\n145\nthe markers ^ and $. The caret matches the start of the input string, whereas\nthe dollar sign matches the end. Thus /^\\d+$/ matches a string consisting\nentirely of one or more digits, /^!/ matches any string that starts with an\nexclamation mark, and /x^/ does not match any string (there cannot be an x\nbefore the start of the string).\nThere is also a \\b marker that matches word boundaries, positions that have\na word character on one side, and a nonword character on the other. Unfortu-\nnately, these use the same simplistic concept of word characters as \\w and are\ntherefore not very reliable.\nNote that these boundary markers don\u2019t match any actual characters. They\njust enforce that a given condition holds at the place where it appears in the\npattern.\nLook-ahead tests do something similar. They provide a pattern and will make\nthe match fail if the input doesn\u2019t match that pattern, but don\u2019t actually move",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_351",
    "text": "pattern.\nLook-ahead tests do something similar. They provide a pattern and will make\nthe match fail if the input doesn\u2019t match that pattern, but don\u2019t actually move\nthe match position forward. They are written between (?= and ).\nconsole.log(/a(?=e)/.exec(\"braeburn\"));\n// \u2192[\"a\"]\nconsole.log(/a(?! )/.exec(\"a b\"));\n// \u2192null\nThe e in the first example is necessary to match, but is not part of the matched\nstring. The (?! ) notation expresses a negative look-ahead. This matches only\nif the pattern in the parentheses doesn\u2019t match, causing the second example to\nmatch only a characters that don\u2019t have a space after them.\nChoice patterns\nSay we want to know whether a piece of text contains not only a number but a\nnumber followed by one of the words pig, cow, or chicken, or any of their plural\nforms.\nWe could write three regular expressions and test them in turn, but there is\na nicer way. The pipe character (|) denotes a choice between the pattern to its",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_352",
    "text": "forms.\nWe could write three regular expressions and test them in turn, but there is\na nicer way. The pipe character (|) denotes a choice between the pattern to its\nleft and the pattern to its right. We can use it in expressions like this:\nlet animalCount = /\\d+ (pig|cow|chicken)s?/;\nconsole.log(animalCount.test(\"15 pigs\"));\n// \u2192true\nconsole.log(animalCount.test(\"15 pugs\"));\n// \u2192false\nParentheses can be used to limit the part of the pattern to which the pipe\n146\noperator applies, and you can put multiple such operators next to each other\nto express a choice between more than two alternatives.\nThe mechanics of matching\nConceptually, when you use exec or test, the regular expression engine looks\nfor a match in your string by trying to match the expression first from the start\nof the string, then from the second character, and so on until it finds a match\nor reaches the end of the string. It\u2019ll either return the first match that can be\nfound or fail to find any match at all.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_353",
    "text": "or reaches the end of the string. It\u2019ll either return the first match that can be\nfound or fail to find any match at all.\nTo do the actual matching, the engine treats a regular expression something\nlike a flow diagram. This is the diagram for the livestock expression in the\nprevious example:\ndigit\n\u201c\u201d\ngroup #1\n\u201cpig\u201d\n\u201ccow\u201d\n\u201cchicken\u201d\n\u201cs\u201d\nIf we can find a path from the left side of the diagram to the right side, our\nexpression matches. We keep a current position in the string, and every time\nwe move through a box, we verify that the part of the string after our current\nposition matches that box.\nBacktracking\nThe regular expression /^([01]+b|[\\da-f]+h|\\d+)$/ matches either a binary\nnumber followed by a b, a hexadecimal number (that is, base 16, with the\nletters a to f standing for the digits 10 to 15) followed by an h, or a regular\ndecimal number with no su\ufb00ix character. This is the corresponding diagram:\n147\nStart of line\ngroup #1\nOne of:\n\u201c0\u201d\n\u201c1\u201d\n\u201cb\u201d\nOne of:\ndigit\n-\n\u201ca\u201d\n\u201cf\u201d\n\u201ch\u201d\ndigit",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_354",
    "text": "decimal number with no su\ufb00ix character. This is the corresponding diagram:\n147\nStart of line\ngroup #1\nOne of:\n\u201c0\u201d\n\u201c1\u201d\n\u201cb\u201d\nOne of:\ndigit\n-\n\u201ca\u201d\n\u201cf\u201d\n\u201ch\u201d\ndigit\nEnd of line\nWhen matching this expression, the top (binary) branch will often be entered\neven though the input does not actually contain a binary number.\nWhen\nmatching the string \"103\", for example, it becomes clear only at the 3 that we\nare in the wrong branch. The string does match the expression, just not the\nbranch we are currently in.\nSo the matcher backtracks. When entering a branch, it remembers its current\nposition (in this case, at the start of the string, just past the first boundary box\nin the diagram) so that it can go back and try another branch if the current one\ndoes not work out. For the string \"103\", after encountering the 3 character, the\nmatcher starts trying the branch for hexadecimal numbers, which fails again\nbecause there is no h after the number. It then tries the decimal number branch.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_355",
    "text": "matcher starts trying the branch for hexadecimal numbers, which fails again\nbecause there is no h after the number. It then tries the decimal number branch.\nThis one fits, and a match is reported after all.\nThe matcher stops as soon as it finds a full match.\nThis means that if\nmultiple branches could potentially match a string, only the first one (ordered\nby where the branches appear in the regular expression) is used.\nBacktracking also happens for repetition operators like + and *.\nIf you\nmatch /^.*x/ against \"abcxe\", the .* part will first try to consume the whole\nstring. The engine will then realize that it needs an x to match the pattern.\nSince there is no x past the end of the string, the star operator tries to match\none character less. But the matcher doesn\u2019t find an x after abcx either, so it\nbacktracks again, matching the star operator to just abc. Now it finds an x\nwhere it needs it and reports a successful match from positions 0 to 4.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_356",
    "text": "backtracks again, matching the star operator to just abc. Now it finds an x\nwhere it needs it and reports a successful match from positions 0 to 4.\nIt is possible to write regular expressions that will do a lot of backtracking.\nThis problem occurs when a pattern can match a piece of input in many dif-\nferent ways. For example, if we get confused while writing a binary-number\nregular expression, we might accidentally write something like /([01]+)+b/.\n148\n\"b\"\nGroup #1\nOne of:\n\"1\"\n\"0\"\nIf that tries to match some long series of zeros and ones with no trailing b\ncharacter, the matcher first goes through the inner loop until it runs out of\ndigits. Then it notices there is no b, so it backtracks one position, goes through\nthe outer loop once, and gives up again, trying to backtrack out of the inner\nloop once more. It will continue to try every possible route through these two\nloops. This means the amount of work doubles with each additional character.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_357",
    "text": "loop once more. It will continue to try every possible route through these two\nloops. This means the amount of work doubles with each additional character.\nFor even just a few dozen characters, the resulting match will take practically\nforever.\nThe replace method\nString values have a replace method that can be used to replace part of the\nstring with another string.\nconsole.log(\"papa\".replace(\"p\", \"m\"));\n// \u2192mapa\nThe first argument can also be a regular expression, in which case the first\nmatch of the regular expression is replaced. When a g option (for global) is\nadded after the regular expression, all matches in the string will be replaced,\nnot just the first.\nconsole.log(\"Borobudur\".replace(/[ou]/, \"a\"));\n// \u2192Barobudur\nconsole.log(\"Borobudur\".replace(/[ou]/g, \"a\"));\n// \u2192Barabadar\nThe real power of using regular expressions with replace comes from the fact\nthat we can refer to matched groups in the replacement string. For example,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_358",
    "text": "// \u2192Barabadar\nThe real power of using regular expressions with replace comes from the fact\nthat we can refer to matched groups in the replacement string. For example,\nsay we have a big string containing the names of people, one name per line, in\nthe format Lastname, Firstname. If we want to swap these names and remove\nthe comma to get a Firstname Lastname format, we can use the following code:\n149\nconsole.log(\n\"Liskov, Barbara\\nMcCarthy, John\\nMilner, Robin\"\n.replace(/(\\p{L}+), (\\p{L}+)/gu, \"$2 $1\"));\n// \u2192Barbara Liskov\n//\nJohn McCarthy\n//\nRobin Milner\nThe $1 and $2 in the replacement string refer to the parenthesized groups in\nthe pattern. $1 is replaced by the text that matched against the first group, $2\nby the second, and so on, up to $9. The whole match can be referred to with\n$&.\nIt is possible to pass a function\u2014rather than a string\u2014as the second argu-\nment to replace. For each replacement, the function will be called with the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_359",
    "text": "$&.\nIt is possible to pass a function\u2014rather than a string\u2014as the second argu-\nment to replace. For each replacement, the function will be called with the\nmatched groups (as well as the whole match) as arguments, and its return value\nwill be inserted into the new string.\nHere\u2019s an example:\nlet stock = \"1 lemon, 2 cabbages, and 101 eggs\";\nfunction minusOne(match, amount, unit) {\namount = Number(amount) - 1;\nif (amount == 1) { // only one left, remove the 's'\nunit = unit.slice(0, unit.length - 1);\n} else if (amount == 0) {\namount = \"no\";\n}\nreturn amount + \" \" + unit;\n}\nconsole.log(stock.replace(/(\\d+) (\\p{L}+)/gu, minusOne));\n// \u2192no lemon, 1 cabbage, and 100 eggs\nThis code takes a string, finds all occurrences of a number followed by an\nalphanumeric word, and returns a string that has one less of every such quantity.\nThe (\\d+) group ends up as the amount argument to the function, and the (\\\np{L}+) group gets bound to unit. The function converts amount to a number\u2014",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_360",
    "text": "The (\\d+) group ends up as the amount argument to the function, and the (\\\np{L}+) group gets bound to unit. The function converts amount to a number\u2014\nwhich always works, since it matched \\d+ earlier\u2014and makes some adjustments\nin case there is only one or zero left.\nGreed\nWe can use replace to write a function that removes all comments from a piece\nof JavaScript code. Here is a first attempt:\nfunction stripComments(code) {\n150\nreturn code.replace(/\\/\\/.*|\\/\\*[^]*\\*\\//g, \"\");\n}\nconsole.log(stripComments(\"1 + /* 2 */3\"));\n// \u21921 + 3\nconsole.log(stripComments(\"x = 10;// ten!\"));\n// \u2192x = 10;\nconsole.log(stripComments(\"1 /* a */+/* b */ 1\"));\n// \u21921\n1\nThe part before the | operator matches two slash characters followed by any\nnumber of non-newline characters. The part for multiline comments is more\ninvolved. We use [^] (any character that is not in the empty set of characters)\nas a way to match any character. We cannot just use a period here because",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_361",
    "text": "involved. We use [^] (any character that is not in the empty set of characters)\nas a way to match any character. We cannot just use a period here because\nblock comments can continue on a new line, and the period character does not\nmatch newline characters.\nBut the output for the last line appears to have gone wrong. Why?\nThe [^]* part of the expression, as I described in the section on backtracking,\nwill first match as much as it can. If that causes the next part of the pattern to\nfail, the matcher moves back one character and tries again from there. In the\nexample, the matcher first tries to match the whole rest of the string and then\nmoves back from there. It will find an occurrence of */ after going back four\ncharacters and match that. This is not what we wanted\u2014the intention was to\nmatch a single comment, not to go all the way to the end of the code and find\nthe end of the last block comment.\nBecause of this behavior, we say the repetition operators (+, *, ?, and {}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_362",
    "text": "match a single comment, not to go all the way to the end of the code and find\nthe end of the last block comment.\nBecause of this behavior, we say the repetition operators (+, *, ?, and {}\n) are greedy, meaning they match as much as they can and backtrack from\nthere. If you put a question mark after them (+?, *?, ??, {}?), they become\nnongreedy and start by matching as little as possible, matching more only when\nthe remaining pattern does not fit the smaller match.\nAnd that is exactly what we want in this case. By having the star match\nthe smallest stretch of characters that brings us to a */, we consume one block\ncomment and nothing more.\nfunction stripComments(code) {\nreturn code.replace(/\\/\\/.*|\\/\\*[^]*?\\*\\//g, \"\");\n}\nconsole.log(stripComments(\"1 /* a */+/* b */ 1\"));\n// \u21921 + 1\nA lot of bugs in regular expression programs can be traced to unintentionally\nusing a greedy operator where a nongreedy one would work better. When using\na repetition operator, prefer the nongreedy variant.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_363",
    "text": "using a greedy operator where a nongreedy one would work better. When using\na repetition operator, prefer the nongreedy variant.\n151\nDynamically creating RegExp objects\nIn some cases you may not know the exact pattern you need to match against\nwhen you are writing your code. Say you want to test for the user\u2019s name in\na piece of text. You can build up a string and use the RegExp constructor on\nthat.\nlet name = \"harry\";\nlet regexp = new RegExp(\"(^|\\\\s)\" + name + \"($|\\\\s)\", \"gi\");\nconsole.log(regexp.test(\"Harry is a dodgy character.\"));\n// \u2192true\nWhen creating the \\s part of the string, we have to use two backslashes because\nwe are writing them in a normal string, not a slash-enclosed regular expression.\nThe second argument to the RegExp constructor contains the options for the\nregular expression\u2014in this case, \"gi\" for global and case insensitive.\nBut what if the name is \"dea+hl[]rd\" because our user is a nerdy teenager?",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_364",
    "text": "regular expression\u2014in this case, \"gi\" for global and case insensitive.\nBut what if the name is \"dea+hl[]rd\" because our user is a nerdy teenager?\nThat would result in a nonsensical regular expression that won\u2019t actually match\nthe user\u2019s name.\nTo work around this, we can add backslashes before any character that has\na special meaning.\nlet name = \"dea+hl[]rd\";\nlet escaped = name.replace(/[\\\\[.+*?(){|^$]/g, \"\\\\$&\");\nlet regexp = new RegExp(\"(^|\\\\s)\" + escaped + \"($|\\\\s)\",\n\"gi\");\nlet text = \"This dea+hl[]rd guy is super annoying.\";\nconsole.log(regexp.test(text));\n// \u2192true\nThe search method\nWhile the indexOf method on strings cannot be called with a regular expression,\nthere is another method, search, that does expect a regular expression. Like\nindexOf, it returns the first index on which the expression was found, or -1\nwhen it wasn\u2019t found.\nconsole.log(\"\nword\".search(/\\S/));\n// \u21922\nconsole.log(\"\n\".search(/\\S/));\n// \u2192-1",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_365",
    "text": "indexOf, it returns the first index on which the expression was found, or -1\nwhen it wasn\u2019t found.\nconsole.log(\"\nword\".search(/\\S/));\n// \u21922\nconsole.log(\"\n\".search(/\\S/));\n// \u2192-1\nUnfortunately, there is no way to indicate that the match should start at a\n152\ngiven offset (like we can with the second argument to indexOf), which would\noften be useful.\nThe lastIndex property\nThe exec method similarly does not provide a convenient way to start searching\nfrom a given position in the string. But it does provide an inconvenient way.\nRegular expression objects have properties. One such property is source,\nwhich contains the string that expression was created from. Another property\nis lastIndex, which controls, in some limited circumstances, where the next\nmatch will start.\nThose circumstances are that the regular expression must have the global\n(g) or sticky (y) option enabled, and the match must happen through the exec\nmethod. Again, a less confusing solution would have been to just allow an",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_366",
    "text": "(g) or sticky (y) option enabled, and the match must happen through the exec\nmethod. Again, a less confusing solution would have been to just allow an\nextra argument to be passed to exec, but confusion is an essential feature of\nJavaScript\u2019s regular expression interface.\nlet pattern = /y/g;\npattern.lastIndex = 3;\nlet match = pattern.exec(\"xyzzy\");\nconsole.log(match.index);\n// \u21924\nconsole.log(pattern.lastIndex);\n// \u21925\nIf the match was successful, the call to exec automatically updates the lastIndex\nproperty to point after the match. If no match was found, lastIndex is set back\nto 0, which is also the value it has in a newly constructed regular expression\nobject.\nThe difference between the global and the sticky options is that when sticky is\nenabled, the match will succeed only if it starts directly at lastIndex, whereas\nwith global, it will search ahead for a position where a match can start.\nlet global = /abc/g;\nconsole.log(global.exec(\"xyz abc\"));\n// \u2192[\"abc\"]\nlet sticky = /abc/y;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_367",
    "text": "with global, it will search ahead for a position where a match can start.\nlet global = /abc/g;\nconsole.log(global.exec(\"xyz abc\"));\n// \u2192[\"abc\"]\nlet sticky = /abc/y;\nconsole.log(sticky.exec(\"xyz abc\"));\n// \u2192null\nWhen using a shared regular expression value for multiple exec calls, these\nautomatic updates to the lastIndex property can cause problems. Your regular\nexpression might be accidentally starting at an index left over from a previous\n153\ncall.\nlet digit = /\\d/g;\nconsole.log(digit.exec(\"here it is: 1\"));\n// \u2192[\"1\"]\nconsole.log(digit.exec(\"and now: 1\"));\n// \u2192null\nAnother interesting effect of the global option is that it changes the way the\nmatch method on strings works. When called with a global expression, instead\nof returning an array similar to that returned by exec, match will find all\nmatches of the pattern in the string and return an array containing the matched\nstrings.\nconsole.log(\"Banana\".match(/an/g));\n// \u2192[\"an\", \"an\"]\nSo be cautious with global regular expressions.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_368",
    "text": "matches of the pattern in the string and return an array containing the matched\nstrings.\nconsole.log(\"Banana\".match(/an/g));\n// \u2192[\"an\", \"an\"]\nSo be cautious with global regular expressions.\nThe cases where they are\nnecessary\u2014calls to replace and places where you want to explicitly use lastIndex\n\u2014are typically the situations where you want to use them.\nA common thing to do is to find all the matches of a regular expression in a\nstring. We can do this by using the matchAll method.\nlet input = \"A string with 3 numbers in it... 42 and 88.\";\nlet matches = input.matchAll(/\\d+/g);\nfor (let match of matches) {\nconsole.log(\"Found\", match[0], \"at\", match.index);\n}\n// \u2192Found 3 at 14\n//\nFound 42 at 33\n//\nFound 88 at 40\nThis method returns an array of match arrays. The regular expression given\nto matchAll must have g enabled.\nParsing an INI file\nTo conclude the chapter, we\u2019ll look at a problem that calls for regular expres-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_369",
    "text": "to matchAll must have g enabled.\nParsing an INI file\nTo conclude the chapter, we\u2019ll look at a problem that calls for regular expres-\nsions. Imagine we are writing a program to automatically collect information\nabout our enemies from the internet. (We will not actually write that program\nhere, just the part that reads the configuration file. Sorry.) The configuration\nfile looks like this:\nsearchengine=https://duckduckgo.com/?q=$1\n154\nspitefulness=9.7\n; comments are preceded by a semicolon...\n; each section concerns an individual enemy\n[larry]\nfullname=Larry Doe\ntype=kindergarten bully\nwebsite=http://www.geocities.com/CapeCanaveral/11451\n[davaeorn]\nfullname=Davaeorn\ntype=evil wizard\noutputdir=/home/marijn/enemies/davaeorn\nThe exact rules for this format\u2014which is a widely used file format, usually\ncalled an INI file\u2014are as follows:\n\u2022 Blank lines and lines starting with semicolons are ignored.\n\u2022 Lines wrapped in [ and ] start a new section.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_370",
    "text": "called an INI file\u2014are as follows:\n\u2022 Blank lines and lines starting with semicolons are ignored.\n\u2022 Lines wrapped in [ and ] start a new section.\n\u2022 Lines containing an alphanumeric identifier followed by an = character\nadd a setting to the current section.\n\u2022 Anything else is invalid.\nOur task is to convert a string like this into an object whose properties hold\nstrings for settings written before the first section header and subobjects for\nsections, with those subobjects holding the section\u2019s settings.\nSince the format has to be processed line by line, splitting up the file into\nseparate lines is a good start. We saw the split method in Chapter 4. Some\noperating systems, however, use not just a newline character to separate lines\nbut a carriage return character followed by a newline (\"\\r\\n\"). Given that\nthe split method also allows a regular expression as its argument, we can use\na regular expression like /\\r?\\n/ to split in a way that allows both \"\\n\" and\n\"\\r\\n\" between lines.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_371",
    "text": "the split method also allows a regular expression as its argument, we can use\na regular expression like /\\r?\\n/ to split in a way that allows both \"\\n\" and\n\"\\r\\n\" between lines.\nfunction parseINI(string) {\n// Start with an object to hold the top-level fields\nlet result = {};\nlet section = result;\nfor (let line of string.split(/\\r?\\n/)) {\nlet match;\nif (match = line.match(/^(\\w+)=(.*)$/)) {\nsection[match[1]] = match[2];\n155\n} else if (match = line.match(/^\\[(.*)\\]$/)) {\nsection = result[match[1]] = {};\n} else if (!/^\\s*(;|$)/.test(line)) {\nthrow new Error(\"Line '\" + line + \"' is not valid.\");\n}\n};\nreturn result;\n}\nconsole.log(parseINI(`\nname=Vasilis\n[address]\ncity=Tessaloniki`));\n// \u2192{name: \"Vasilis\", address: {city: \"Tessaloniki\"}}\nThe code goes over the file\u2019s lines and builds up an object. Properties at the\ntop are stored directly into that object, whereas properties found in sections are\nstored in a separate section object. The section binding points at the object",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_372",
    "text": "top are stored directly into that object, whereas properties found in sections are\nstored in a separate section object. The section binding points at the object\nfor the current section.\nThere are two kinds of significant lines\u2014section headers or property lines.\nWhen a line is a regular property, it is stored in the current section. When it\nis a section header, a new section object is created, and section is set to point\nat it.\nNote the recurring use of ^ and $ to make sure the expression matches the\nwhole line, not just part of it. Leaving these out results in code that mostly\nworks but behaves strangely for some input, which can be a di\ufb00icult bug to\ntrack down.\nThe pattern if (match = string.match(...)) makes use of the fact that the\nvalue of an assignment expression (=) is the assigned value. You often aren\u2019t\nsure that your call to match will succeed, so you can access the resulting object\nonly inside an if statement that tests for this.\nTo not break the pleasant",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_373",
    "text": "sure that your call to match will succeed, so you can access the resulting object\nonly inside an if statement that tests for this.\nTo not break the pleasant\nchain of else if forms, we assign the result of the match to a binding and\nimmediately use that assignment as the test for the if statement.\nIf a line is not a section header or a property, the function checks whether\nit is a comment or an empty line using the expression /^\\s*(;|$)/ to match\nlines that either contain only whitespace, or whitespace followed by a semicolon\n(making the rest of the line a comment). When a line doesn\u2019t match any of\nthe expected forms, the function throws an exception.\n156\nCode units and characters\nAnother design mistake that\u2019s been standardized in JavaScript regular expres-\nsions is that by default, operators like . or ? work on code units (as discussed\nin Chapter 5), not actual characters. This means characters that are composed\nof two code units behave strangely.\nconsole.log(/\ud83c\udf4e{3}/.test(\"\ud83c\udf4e\ud83c\udf4e\ud83c\udf4e\"));",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_374",
    "text": "in Chapter 5), not actual characters. This means characters that are composed\nof two code units behave strangely.\nconsole.log(/\ud83c\udf4e{3}/.test(\"\ud83c\udf4e\ud83c\udf4e\ud83c\udf4e\"));\n// \u2192false\nconsole.log(/<.>/.test(\"<\ud83c\udf39>\"));\n// \u2192false\nconsole.log(/<.>/u.test(\"<\ud83c\udf39>\"));\n// \u2192true\nThe problem is that the \ud83c\udf4ein the first line is treated as two code units, and\n{3} is applied only to the second unit. Similarly, the dot matches a single code\nunit, not the two that make up the rose emoji.\nYou must add the u (Unicode) option to your regular expression to make it\ntreat such characters properly.\nconsole.log(/\ud83c\udf4e{3}/u.test(\"\ud83c\udf4e\ud83c\udf4e\ud83c\udf4e\"));\n// \u2192true\nSummary\nRegular expressions are objects that represent patterns in strings. They use\ntheir own language to express these patterns.\n157\n/abc/\nA sequence of characters\n/[abc]/\nAny character from a set of characters\n/[^abc]/\nAny character not in a set of characters\n/[0-9]/\nAny character in a range of characters\n/x+/\nOne or more occurrences of the pattern x\n/x+?/\nOne or more occurrences, nongreedy\n/x*/",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_375",
    "text": "/[^abc]/\nAny character not in a set of characters\n/[0-9]/\nAny character in a range of characters\n/x+/\nOne or more occurrences of the pattern x\n/x+?/\nOne or more occurrences, nongreedy\n/x*/\nZero or more occurrences\n/x?/\nZero or one occurrence\n/x{2,4}/\nTwo to four occurrences\n/(abc)/\nA group\n/a|b|c/\nAny one of several patterns\n/\\d/\nAny digit character\n/\\w/\nAn alphanumeric character (\u201cword character\u201d)\n/\\s/\nAny whitespace character\n/./\nAny character except newlines\n/\\p{L}/u\nAny letter character\n/^/\nStart of input\n/$/\nEnd of input\n/(?=a)/\nA look-ahead test\nA regular expression has a method test to test whether a given string\nmatches it. It also has a method exec that, when a match is found, returns\nan array containing all matched groups. Such an array has an index property\nthat indicates where the match started.\nStrings have a match method to match them against a regular expression\nand a search method to search for one, returning only the starting position",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_376",
    "text": "that indicates where the match started.\nStrings have a match method to match them against a regular expression\nand a search method to search for one, returning only the starting position\nof the match. Their replace method can replace matches of a pattern with a\nreplacement string or function.\nRegular expressions can have options, which are written after the closing\nslash. The i option makes the match case insensitive. The g option makes the\nexpression global, which, among other things, causes the replace method to\nreplace all instances instead of just the first. The y option makes and expression\nsticky, which means that it will not search ahead and skip part of the string\nwhen looking for a match. The u option turns on Unicode mode, which enables\n\\p syntax and fixes a number of problems around the handling of characters\nthat take up two code units.\nRegular expressions are a sharp tool with an awkward handle. They simplify",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_377",
    "text": "\\p syntax and fixes a number of problems around the handling of characters\nthat take up two code units.\nRegular expressions are a sharp tool with an awkward handle. They simplify\nsome tasks tremendously but can quickly become unmanageable when applied\nto complex problems. Part of knowing how to use them is resisting the urge to\ntry to shoehorn things into them that they cannot cleanly express.\n158\nExercises\nIt is almost unavoidable that, in the course of working on these exercises,\nyou will get confused and frustrated by some regular expression\u2019s inexplicable\nbehavior. Sometimes it helps to enter your expression into an online tool like\ndebuggex.com to see whether its visualization corresponds to what you intended\nand to experiment with the way it responds to various input strings.\nRegexp golf\nCode golf is a term used for the game of trying to express a particular program\nin as few characters as possible. Similarly, regexp golf is the practice of writing",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_378",
    "text": "Regexp golf\nCode golf is a term used for the game of trying to express a particular program\nin as few characters as possible. Similarly, regexp golf is the practice of writing\nas tiny a regular expression as possible to match a given pattern and only that\npattern.\nFor each of the following items, write a regular expression to test whether\nthe given pattern occurs in a string. The regular expression should match only\nstrings containing the pattern. When your expression works, see whether you\ncan make it any smaller.\n1. car and cat\n2. pop and prop\n3. ferret, ferry, and ferrari\n4. Any word ending in ious\n5. A whitespace character followed by a period, comma, colon, or semicolon\n6. A word longer than six letters\n7. A word without the letter e (or E)\nRefer to the table in the chapter summary for help. Test each solution with\na few test strings.\nQuoting style\nImagine you have written a story and used single quotation marks throughout",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_379",
    "text": "Refer to the table in the chapter summary for help. Test each solution with\na few test strings.\nQuoting style\nImagine you have written a story and used single quotation marks throughout\nto mark pieces of dialogue. Now you want to replace all the dialogue quotes\nwith double quotes, while keeping the single quotes used in contractions like\naren\u2019t.\nThink of a pattern that distinguishes these two kinds of quote usage and\ncraft a call to the replace method that does the proper replacement.\n159\nNumbers again\nWrite an expression that matches only JavaScript-style numbers. It must sup-\nport an optional minus or plus sign in front of the number, the decimal dot,\nand exponent notation\u20145e-3 or 1E10\u2014again with an optional sign in front of\nthe exponent. Also note that it is not necessary for there to be digits in front\nof or after the dot, but the number cannot be a dot alone. That is, .5 and 5.\nare valid JavaScript numbers, but a lone dot isn\u2019t.\n160",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_380",
    "text": "of or after the dot, but the number cannot be a dot alone. That is, .5 and 5.\nare valid JavaScript numbers, but a lone dot isn\u2019t.\n160\n\u201cWrite code that is easy to delete, not easy to extend.\u201d\n\u2014Tef, programming is terrible\nChapter 10\nModules\nIdeally, a program has a clear, straightforward structure. The way it works is\neasy to explain, and each part plays a well-defined role.\nIn practice, programs grow organically. Pieces of functionality are added as\nthe programmer identifies new needs. Keeping such a program well structured\nrequires constant attention and work. This is work that will pay off only in the\nfuture, the next time someone works on the program, so it\u2019s tempting to neglect\nit and allow the various parts of the program to become deeply entangled.\nThis causes two practical issues. First, understanding an entangled system\nis hard. If everything can touch everything else, it is di\ufb00icult to look at any\ngiven piece in isolation. You are forced to build up a holistic understanding",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_381",
    "text": "is hard. If everything can touch everything else, it is di\ufb00icult to look at any\ngiven piece in isolation. You are forced to build up a holistic understanding\nof the entire thing. Second, if you want to use any of the functionality from\nsuch a program in another situation, rewriting it may be easier than trying to\ndisentangle it from its context.\nThe phrase \u201cbig ball of mud\u201d is often used for such large, structureless pro-\ngrams. Everything sticks together, and when you try to pick out a piece, the\nwhole thing comes apart, and you succeed only in making a mess.\nModular programs\nModules are an attempt to avoid these problems. A module is a piece of program\nthat specifies which other pieces it relies on and which functionality it provides\nfor other modules to use (its interface).\nModule interfaces have a lot in common with object interfaces, as we saw\nthem in Chapter 6. They make part of the module available to the outside\nworld and keep the rest private.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_382",
    "text": "Module interfaces have a lot in common with object interfaces, as we saw\nthem in Chapter 6. They make part of the module available to the outside\nworld and keep the rest private.\nBut the interface that a module provides for others to use is only half the\nstory. A good module system also requires modules to specify which code they\nuse from other modules. These relations are called dependencies. If module A\nuses functionality from module B, it is said to depend on that module. When\nthese are clearly specified in the module itself, they can be used to figure out\n161\nwhich other modules need to be present to be able to use a given module and\nto automatically load dependencies.\nWhen the ways in which modules interact with each other are explicit, a\nsystem becomes more like LEGO, where pieces interact through well-defined\nconnectors, and less like mud, where everything mixes with everything else.\nES modules\nThe original JavaScript language did not have any concept of a module. All",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_383",
    "text": "connectors, and less like mud, where everything mixes with everything else.\nES modules\nThe original JavaScript language did not have any concept of a module. All\nscripts ran in the same scope, and accessing a function defined in another\nscript was done by referencing the global bindings created by that script. This\nactively encouraged accidental, hard-to-see entanglement of code and invited\nproblems like unrelated scripts trying to use the same binding name.\nSince ECMAScript 2015, JavaScript supports two different types of pro-\ngrams. Scripts behave in the old way: their bindings are defined in the global\nscope, and they have no way to directly reference other scripts.\nModules\nget their own separate scope and support the import and export keywords,\nwhich aren\u2019t available in scripts, to declare their dependencies and interface.\nThis module system is usually called ES modules (where ES stands for EC-\nMAScript).\nA modular program is composed of a number of such modules, wired together",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_384",
    "text": "This module system is usually called ES modules (where ES stands for EC-\nMAScript).\nA modular program is composed of a number of such modules, wired together\nvia their imports and exports.\nThe following example module converts between day names and numbers (as\nreturned by Date\u2019s getDay method). It defines a constant that is not part of its\ninterface, and two functions that are. It has no dependencies.\nconst names = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\"];\nexport function dayName(number) {\nreturn names[number];\n}\nexport function dayNumber(name) {\nreturn names.indexOf(name);\n}\nThe export keyword can be put in front of a function, class, or binding definition\nto indicate that that binding is part of the module\u2019s interface. This makes it\npossible for other modules to use that binding by importing it.\nimport {dayName} from \"./dayname.js\";\nlet now = new Date();\n162\nconsole.log(`Today is ${dayName(now.getDay())}`);\n// \u2192Today is Monday",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_385",
    "text": "possible for other modules to use that binding by importing it.\nimport {dayName} from \"./dayname.js\";\nlet now = new Date();\n162\nconsole.log(`Today is ${dayName(now.getDay())}`);\n// \u2192Today is Monday\nThe import keyword, followed by a list of binding names in braces, makes\nbindings from another module available in the current module. Modules are\nidentified by quoted strings.\nHow such a module name is resolved to an actual program differs by platform.\nThe browser treats them as web addresses, whereas Node.js resolves them to\nfiles. When you run a module, all the other modules it depends on\u2014and the\nmodules those depend on\u2014are loaded, and the exported bindings are made\navailable to the modules that import them.\nImport and export declarations cannot appear inside of functions, loops,\nor other blocks. They are immediately resolved when the module is loaded,\nregardless of how the code in the module executes. To reflect this, they must\nappear only in the outer module body.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_386",
    "text": "or other blocks. They are immediately resolved when the module is loaded,\nregardless of how the code in the module executes. To reflect this, they must\nappear only in the outer module body.\nA module\u2019s interface thus consists of a collection of named bindings, which\nother modules that depend on the module can access. Imported bindings can\nbe renamed to give them a new local name using as after their name.\nimport {dayName as nomDeJour} from \"./dayname.js\";\nconsole.log(nomDeJour(3));\n// \u2192Wednesday\nA module may also have a special export named default, which is often used\nfor modules that only export a single binding. To define a default export, you\nwrite export default before an expression, a function declaration, or a class\ndeclaration.\nexport default [\"Winter\", \"Spring\", \"Summer\", \"Autumn\"];\nSuch a binding is imported by omitting the braces around the name of the\nimport.\nimport seasonNames from \"./seasonname.js\";",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_387",
    "text": "declaration.\nexport default [\"Winter\", \"Spring\", \"Summer\", \"Autumn\"];\nSuch a binding is imported by omitting the braces around the name of the\nimport.\nimport seasonNames from \"./seasonname.js\";\nTo import all bindings from a module at the same time, you can use import *.\nYou provide a name, and that name will be bound to an object holding all\nthe module\u2019s exports. This can be useful when you are using a lot of different\nexports.\nimport * as dayName from \"./dayname.js\";\nconsole.log(dayName.dayName(3));\n// \u2192Wednesday\n163\nPackages\nOne of the advantages of building a program out of separate pieces and being\nable to run some of those pieces on their own is that you might be able to use\nthe same piece in different programs.\nBut how do you set this up? Say I want to use the parseINI function from\nChapter 9 in another program. If it is clear what the function depends on (in\nthis case, nothing), I can just copy that module into my new project and use",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_388",
    "text": "Chapter 9 in another program. If it is clear what the function depends on (in\nthis case, nothing), I can just copy that module into my new project and use\nit. But then, if I find a mistake in the code, I\u2019ll probably fix it in whichever\nprogram I\u2019m working with at the time and forget to also fix it in the other\nprogram.\nOnce you start duplicating code, you\u2019ll quickly find yourself wasting time\nand energy moving copies around and keeping them up to date. That\u2019s where\npackages come in. A package is a chunk of code that can be distributed (copied\nand installed). It may contain one or more modules and has information about\nwhich other packages it depends on. A package also usually comes with doc-\numentation explaining what it does so that people who didn\u2019t write it might\nstill be able to use it.\nWhen a problem is found in a package or a new feature is added, the package\nis updated. Now the programs that depend on it (which may also be packages)",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_389",
    "text": "still be able to use it.\nWhen a problem is found in a package or a new feature is added, the package\nis updated. Now the programs that depend on it (which may also be packages)\ncan copy the new version to get the improvements that were made to the code.\nWorking in this way requires infrastructure. We need a place to store and find\npackages and a convenient way to install and upgrade them. In the JavaScript\nworld, this infrastructure is provided by NPM (https://npmjs.com).\nNPM is two things: an online service where you can download (and upload)\npackages, and a program (bundled with Node.js) that helps you install and\nmanage them.\nAt the time of writing, there are more than three million different packages\navailable on NPM. A large portion of those are rubbish, to be fair. But almost\nevery useful, publicly available JavaScript package can be found on NPM. For\nexample, an INI file parser, similar to the one we built in Chapter 9, is available\nunder the package name ini.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_390",
    "text": "every useful, publicly available JavaScript package can be found on NPM. For\nexample, an INI file parser, similar to the one we built in Chapter 9, is available\nunder the package name ini.\nChapter 20 will show how to install such packages locally using the npm\ncommand line program.\nHaving quality packages available for download is extremely valuable.\nIt\nmeans that we can often avoid reinventing a program that 100 people have\nwritten before and get a solid, well-tested implementation at the press of a few\nkeys.\nSoftware is cheap to copy, so once someone has written it, distributing it to\nother people is an e\ufb00icient process. Writing it in the first place is work, though,\n164\nand responding to people who have found problems in the code or who want\nto propose new features is even more work.\nBy default, you own the copyright to the code you write, and other peo-\nple may use it only with your permission. But because some people are just",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_391",
    "text": "to propose new features is even more work.\nBy default, you own the copyright to the code you write, and other peo-\nple may use it only with your permission. But because some people are just\nnice and because publishing good software can help make you a little bit fa-\nmous among programmers, many packages are published under a license that\nexplicitly allows other people to use it.\nMost code on NPM is licensed this way. Some licenses require you to also\npublish code that you build on top of the package under the same license.\nOthers are less demanding, requiring only that you keep the license with the\ncode as you distribute it. The JavaScript community mostly uses the latter\ntype of license. When using other people\u2019s packages, make sure you are aware\nof their licenses.\nNow, instead of writing our own INI file parser, we can use one from NPM.\nimport {parse} from \"ini\";\nconsole.log(parse(\"x = 10\\ny = 20\"));\n// \u2192{x: \"10\", y: \"20\"}\nCommonJS modules",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_392",
    "text": "of their licenses.\nNow, instead of writing our own INI file parser, we can use one from NPM.\nimport {parse} from \"ini\";\nconsole.log(parse(\"x = 10\\ny = 20\"));\n// \u2192{x: \"10\", y: \"20\"}\nCommonJS modules\nBefore 2015, when the JavaScript language had no built-in module system, peo-\nple were already building large systems in JavaScript. To make that workable,\nthey needed modules.\nThe community designed its own improvised module systems on top of the\nlanguage.\nThese use functions to create a local scope for the modules and\nregular objects to represent module interfaces.\nInitially, people just manually wrapped their entire module in an \u201cimmedi-\nately invoked function expression\u201d to create the module\u2019s scope and assigned\ntheir interface objects to a single global variable.\nconst weekDay = function() {\nconst names = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\"];\nreturn {\nname(number) { return names[number]; },\nnumber(name) { return names.indexOf(name); }\n};\n}();",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_393",
    "text": "const names = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n\"Thursday\", \"Friday\", \"Saturday\"];\nreturn {\nname(number) { return names[number]; },\nnumber(name) { return names.indexOf(name); }\n};\n}();\n165\nconsole.log(weekDay.name(weekDay.number(\"Sunday\")));\n// \u2192Sunday\nThis style of modules provides isolation, to a certain degree, but it does not\ndeclare dependencies. Instead, it just puts its interface into the global scope\nand expects its dependencies, if any, to do the same. This is not ideal.\nIf we implement our own module loader, we can do better. The most widely\nused approach to bolted-on JavaScript modules is called CommonJS modules.\nNode.js used this module system from the start (though it now also knows how\nto load ES modules), and it is the module system used by many packages on\nNPM.\nA CommonJS module looks like a regular script, but it has access to two\nbindings that it uses to interact with other modules. The first is a function",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_394",
    "text": "NPM.\nA CommonJS module looks like a regular script, but it has access to two\nbindings that it uses to interact with other modules. The first is a function\ncalled require. When you call this with the module name of your dependency,\nit makes sure the module is loaded and returns its interface. The second is an\nobject named exports, which is the interface object for the module. It starts\nout empty and you add properties to it to define exported values.\nThis CommonJS example module provides a date-formatting function. It\nuses two packages from NPM\u2014ordinal to convert numbers to strings like \"1\nst\" and \"2nd\", and date-names to get the English names for weekdays and\nmonths. It exports a single function, formatDate, which takes a Date object\nand a template string.\nThe template string may contain codes that direct the format, such as YYYY\nfor the full year and Do for the ordinal day of the month. You could give it a\nstring like \"MMMM Do YYYY\" to get output like November 22nd 2017.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_395",
    "text": "for the full year and Do for the ordinal day of the month. You could give it a\nstring like \"MMMM Do YYYY\" to get output like November 22nd 2017.\nconst ordinal = require(\"ordinal\");\nconst {days, months} = require(\"date-names\");\nexports.formatDate = function(date, format) {\nreturn format.replace(/YYYY|M(MMM)?|Do?|dddd/g, tag => {\nif (tag == \"YYYY\") return date.getFullYear();\nif (tag == \"M\") return date.getMonth();\nif (tag == \"MMMM\") return months[date.getMonth()];\nif (tag == \"D\") return date.getDate();\nif (tag == \"Do\") return ordinal(date.getDate());\nif (tag == \"dddd\") return days[date.getDay()];\n});\n};\nThe interface of ordinal is a single function, whereas date-names exports an\nobject containing multiple things\u2014days and months are arrays of names. De-\nstructuring is very convenient when creating bindings for imported interfaces.\n166\nThe module adds its interface function to exports so that modules that\ndepend on it get access to it. We could use the module like this:",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_396",
    "text": "166\nThe module adds its interface function to exports so that modules that\ndepend on it get access to it. We could use the module like this:\nconst {formatDate} = require(\"./format-date.js\");\nconsole.log(formatDate(new Date(2017, 9, 13),\n\"dddd the Do\"));\n// \u2192Friday the 13th\nCommonJS is implemented with a module loader that, when loading a module,\nwraps its code in a function (giving it its own local scope) and passes the\nrequire and exports bindings to that function as arguments.\nIf we assume we have access to a readFile function that reads a file by name\nand gives us its content, we can define a simplified form of require like this:\nfunction require(name) {\nif (!(name in require.cache)) {\nlet code = readFile(name);\nlet exports = require.cache[name] = {};\nlet wrapper = Function(\"require, exports\", code);\nwrapper(require, exports);\n}\nreturn require.cache[name];\n}\nrequire.cache = Object.create(null);\nFunction is a built-in JavaScript function that takes a list of arguments (as a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_397",
    "text": "wrapper(require, exports);\n}\nreturn require.cache[name];\n}\nrequire.cache = Object.create(null);\nFunction is a built-in JavaScript function that takes a list of arguments (as a\ncomma-separated string) and a string containing the function body and returns\na function value with those arguments and that body.\nThis is an interest-\ning concept\u2014it allows a program to create new pieces of program from string\ndata\u2014but also a dangerous one, since if someone can trick your program into\nputting a string they provide into Function, they can make the program do\nanything they want.\nStandard JavaScript provides no such function as readFile, but different\nJavaScript environments, such as the browser and Node.js, provide their own\nways of accessing files. The example just pretends that readFile exists.\nTo avoid loading the same module multiple times, require keeps a store\n(cache) of already loaded modules. When called, it first checks whether the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_398",
    "text": "To avoid loading the same module multiple times, require keeps a store\n(cache) of already loaded modules. When called, it first checks whether the\nrequested module has been loaded and, if not, loads it. This involves reading\nthe module\u2019s code, wrapping it in a function, and calling it.\nBy defining require and exports as parameters for the generated wrapper\nfunction (and passing the appropriate values when calling it), the loader makes\nsure that these bindings are available in the module\u2019s scope.\n167\nAn important difference between this system and ES modules is that ES mod-\nule imports happen before a module\u2019s script starts running, whereas require is\na normal function, invoked when the module is already running. Unlike import\ndeclarations, require calls can appear inside functions, and the name of the\ndependency can be any expression that evaluates to a string, whereas import\nallows only plain quoted strings.\nThe transition of the JavaScript community from CommonJS style to ES",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_399",
    "text": "dependency can be any expression that evaluates to a string, whereas import\nallows only plain quoted strings.\nThe transition of the JavaScript community from CommonJS style to ES\nmodules has been a slow and somewhat rough one. Fortunately we are now at\na point where most of the popular packages on NPM provide their code as ES\nmodules, and Node.js allows ES modules to import from CommonJS modules.\nWhile CommonJS code is still something you will run across, there is no real\nreason to write new programs in this style anymore.\nBuilding and bundling\nMany JavaScript packages aren\u2019t technically written in JavaScript. Language\nextensions such as TypeScript, the type checking dialect mentioned in Chapter\n8, are widely used. People also often start using planned new language features\nlong before they have been added to the platforms that actually run JavaScript.\nTo make this possible, they compile their code, translating it from their cho-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_400",
    "text": "long before they have been added to the platforms that actually run JavaScript.\nTo make this possible, they compile their code, translating it from their cho-\nsen JavaScript dialect to plain old JavaScript\u2014or even to a past version of\nJavaScript\u2014so that browsers can run it.\nIncluding a modular program that consists of 200 different files in a web\npage produces its own problems. If fetching a single file over the network takes\n50 milliseconds, loading the whole program takes 10 seconds, or maybe half\nthat if you can load several files simultaneously. That\u2019s a lot of wasted time.\nBecause fetching a single big file tends to be faster than fetching a lot of tiny\nones, web programmers have started using tools that combine their programs\n(which they painstakingly split into modules) into a single big file before they\npublish it to the web. Such tools are called bundlers.\nAnd we can go further.\nApart from the number of files, the size of the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_401",
    "text": "publish it to the web. Such tools are called bundlers.\nAnd we can go further.\nApart from the number of files, the size of the\nfiles also determines how fast they can be transferred over the network. Thus,\nthe JavaScript community has invented minifiers. These are tools that take\na JavaScript program and make it smaller by automatically removing com-\nments and whitespace, renaming bindings, and replacing pieces of code with\nequivalent code that take up less space.\nIt is not uncommon for the code that you find in an NPM package or that\nruns on a web page to have gone through multiple stages of transformation\u2014\nconverting from modern JavaScript to historic JavaScript, combining the mod-\n168\nules into a single file, and minifying the code. We won\u2019t go into the details of\nthese tools in this book, since there are many of them, and which one is popu-\nlar changes regularly. Just be aware that such things exist, and look them up\nwhen you need them.\nModule design",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_402",
    "text": "these tools in this book, since there are many of them, and which one is popu-\nlar changes regularly. Just be aware that such things exist, and look them up\nwhen you need them.\nModule design\nStructuring programs is one of the subtler aspects of programming. Any non-\ntrivial piece of functionality can be organized in various ways.\nGood program design is subjective\u2014there are trade-offs involved, and mat-\nters of taste. The best way to learn the value of well-structured design is to\nread or work on a lot of programs and notice what works and what doesn\u2019t.\nDon\u2019t assume that a painful mess is \u201cjust the way it is\u201d. You can improve the\nstructure of almost everything by putting more thought into it.\nOne aspect of module design is ease of use. If you are designing something\nthat is intended to be used by multiple people\u2014or even by yourself, in three\nmonths when you no longer remember the specifics of what you did\u2014it is\nhelpful if your interface is simple and predictable.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_403",
    "text": "that is intended to be used by multiple people\u2014or even by yourself, in three\nmonths when you no longer remember the specifics of what you did\u2014it is\nhelpful if your interface is simple and predictable.\nThat may mean following existing conventions. A good example is the ini\npackage. This module imitates the standard JSON object by providing parse\nand stringify (to write an INI file) functions, and, like JSON, converts between\nstrings and plain objects. The interface is small and familiar, and after you\u2019ve\nworked with it once, you\u2019re likely to remember how to use it.\nEven if there\u2019s no standard function or widely used package to imitate, you\ncan keep your modules predictable by using simple data structures and doing\na single, focused thing. Many of the INI-file parsing modules on NPM provide\na function that directly reads such a file from the hard disk and parses it,\nfor example. This makes it impossible to use such modules in the browser,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_404",
    "text": "a function that directly reads such a file from the hard disk and parses it,\nfor example. This makes it impossible to use such modules in the browser,\nwhere we don\u2019t have direct filesystem access, and adds complexity that would\nhave been better addressed by composing the module with some file-reading\nfunction.\nThis points to another helpful aspect of module design\u2014the ease with which\nsomething can be composed with other code. Focused modules that compute\nvalues are applicable in a wider range of programs than bigger modules that\nperform complicated actions with side effects. An INI file reader that insists on\nreading the file from disk is useless in a scenario where the file\u2019s content comes\nfrom some other source.\nRelatedly, stateful objects are sometimes useful or even necessary, but if\nsomething can be done with a function, use a function. Several of the INI file\n169\nreaders on NPM provide an interface style that requires you to first create an",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_405",
    "text": "something can be done with a function, use a function. Several of the INI file\n169\nreaders on NPM provide an interface style that requires you to first create an\nobject, then load the file into your object, and finally use specialized methods\nto get at the results.\nThis type of thing is common in the object-oriented\ntradition, and it\u2019s terrible. Instead of making a single function call and moving\non, you have to perform the ritual of moving your object through its various\nstates. And because the data is now wrapped in a specialized object type, all\ncode that interacts with it has to know about that type, creating unnecessary\ninterdependencies.\nOften, defining new data structures can\u2019t be avoided\u2014only a few basic ones\nare provided by the language standard, and many types of data have to be\nmore complex than an array or a map. But when an array su\ufb00ices, use an\narray.\nAn example of a slightly more complex data structure is the graph from",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_406",
    "text": "more complex than an array or a map. But when an array su\ufb00ices, use an\narray.\nAn example of a slightly more complex data structure is the graph from\nChapter 7. There is no single obvious way to represent a graph in JavaScript.\nIn that chapter, we used an object whose properties hold arrays of strings\u2014the\nother nodes reachable from that node.\nThere are several different pathfinding packages on NPM, but none of them\nuses this graph format. They usually allow the graph\u2019s edges to have a weight,\nwhich is the cost or distance associated with it. That isn\u2019t possible in our\nrepresentation.\nFor example, there\u2019s the dijkstrajs package. A well-known approach to\npathfinding, quite similar to our findRoute function, is called Dijkstra\u2019s algo-\nrithm, after Edsger Dijkstra, who first wrote it down. The js su\ufb00ix is often\nadded to package names to indicate the fact that they are written in JavaScript.\nThis dijkstrajs package uses a graph format similar to ours, but instead of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_407",
    "text": "added to package names to indicate the fact that they are written in JavaScript.\nThis dijkstrajs package uses a graph format similar to ours, but instead of\narrays, it uses objects whose property values are numbers\u2014the weights of the\nedges.\nIf we wanted to use that package, we\u2019d have to make sure that our graph\nwas stored in the format it expects. All edges get the same weight, since our\nsimplified model treats each road as having the same cost (one turn).\nconst {find_path} = require(\"dijkstrajs\");\nlet graph = {};\nfor (let node of Object.keys(roadGraph)) {\nlet edges = graph[node] = {};\nfor (let dest of roadGraph[node]) {\nedges[dest] = 1;\n}\n}\n170\nconsole.log(find_path(graph, \"Post Office\", \"Cabin\"));\n// \u2192[\"Post Office\", \"Alice's House\", \"Cabin\"]\nThis can be a barrier to composition\u2014when various packages are using different\ndata structures to describe similar things, combining them is di\ufb00icult. There-\nfore, if you want to design for composability, find out what data structures",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_408",
    "text": "data structures to describe similar things, combining them is di\ufb00icult. There-\nfore, if you want to design for composability, find out what data structures\nother people are using and, when possible, follow their example.\nDesigning a fitting module structure for a program can be di\ufb00icult. In the\nphase where you are still exploring the problem, trying different things to see\nwhat works, you might want to not worry about it too much, since keeping\neverything organized can be a big distraction. Once you have something that\nfeels solid, that\u2019s a good time to take a step back and organize it.\nSummary\nModules provide structure to bigger programs by separating the code into pieces\nwith clear interfaces and dependencies. The interface is the part of the module\nthat\u2019s visible to other modules, and the dependencies are the other modules it\nmakes use of.\nBecause JavaScript historically did not provide a module system, the Com-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_409",
    "text": "that\u2019s visible to other modules, and the dependencies are the other modules it\nmakes use of.\nBecause JavaScript historically did not provide a module system, the Com-\nmonJS system was built on top of it. Then at some point it did get a built-in\nsystem, which now coexists uneasily with the CommonJS system.\nA package is a chunk of code that can be distributed on its own. NPM is a\nrepository of JavaScript packages. You can download all kinds of useful (and\nuseless) packages from it.\nExercises\nA modular robot\nThese are the bindings that the project from Chapter 7 creates:\nroads\nbuildGraph\nroadGraph\nVillageState\nrunRobot\nrandomPick\nrandomRobot\nmailRoute\nrouteRobot\nfindRoute\n171\ngoalOrientedRobot\nIf you were to write that project as a modular program, what modules would\nyou create? Which module would depend on which other module, and what\nwould their interfaces look like?\nWhich pieces are likely to be available prewritten on NPM? Would you prefer\nto use an NPM package or write them yourself?",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_410",
    "text": "would their interfaces look like?\nWhich pieces are likely to be available prewritten on NPM? Would you prefer\nto use an NPM package or write them yourself?\nRoads module\nWrite an ES module based on the example from Chapter 7 that contains\nthe array of roads and exports the graph data structure representing them\nas roadGraph.\nIt depends on a module ./graph.js that exports a function\nbuildGraph, used to build the graph. This function expects an array of two-\nelement arrays (the start and end points of the roads).\nCircular dependencies\nA circular dependency is a situation where module A depends on B, and B\nalso, directly or indirectly, depends on A. Many module systems simply forbid\nthis because whichever order you choose for loading such modules, you cannot\nmake sure that each module\u2019s dependencies have been loaded before it runs.\nCommonJS modules allow a limited form of cyclic dependencies. As long as\nthe modules don\u2019t access each other\u2019s interface until after they finish loading,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_411",
    "text": "CommonJS modules allow a limited form of cyclic dependencies. As long as\nthe modules don\u2019t access each other\u2019s interface until after they finish loading,\ncyclic dependencies are okay.\nThe require function given earlier in this chapter supports this type of de-\npendency cycle. Can you see how it handles cycles?\n172\n\u201cWho can wait quietly while the mud settles?\nWho can remain still until the moment of action?\u201d\n\u2014Laozi, Tao Te Ching\nChapter 11\nAsynchronous Programming\nThe central part of a computer, the part that carries out the individual steps\nthat make up our programs, is called the processor. The programs we have\nseen so far will keep the processor busy until they have finished their work.\nThe speed at which something like a loop that manipulates numbers can be\nexecuted depends pretty much entirely on the speed of the computer\u2019s processor\nand memory.\nBut many programs interact with things outside of the processor. For ex-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_412",
    "text": "executed depends pretty much entirely on the speed of the computer\u2019s processor\nand memory.\nBut many programs interact with things outside of the processor. For ex-\nample, they may communicate over a computer network or request data from\nthe hard disk\u2014which is a lot slower than getting it from memory.\nWhen such a thing is happening, it would be a shame to let the processor\nsit idle\u2014there might be some other work it could do in the meantime.\nIn\npart, this is handled by your operating system, which will switch the processor\nbetween multiple running programs. But that doesn\u2019t help when we want a\nsingle program to be able to make progress while it is waiting for a network\nrequest.\nAsynchronicity\nIn a synchronous programming model, things happen one at a time. When you\ncall a function that performs a long-running action, it returns only when the\naction has finished and it can return the result. This stops your program for\nthe time the action takes.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_413",
    "text": "call a function that performs a long-running action, it returns only when the\naction has finished and it can return the result. This stops your program for\nthe time the action takes.\nAn asynchronous model allows multiple things to happen at the same time.\nWhen you start an action, your program continues to run. When the action\nfinishes, the program is informed and gets access to the result (for example,\nthe data read from disk).\nWe can compare synchronous and asynchronous programming using a small\nexample: a program that makes two requests over the network and then com-\nbines the results.\nIn a synchronous environment, where the request function returns only after\n173\nit has done its work, the easiest way to perform this task is to make the requests\none after the other. This has the drawback that the second request will be\nstarted only when the first has finished. The total time taken will be at least\nthe sum of the two response times.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_414",
    "text": "one after the other. This has the drawback that the second request will be\nstarted only when the first has finished. The total time taken will be at least\nthe sum of the two response times.\nThe solution to this problem, in a synchronous system, is to start additional\nthreads of control. A thread is another running program whose execution may\nbe interleaved with other programs by the operating system\u2014since most mod-\nern computers contain multiple processors, multiple threads may even run at\nthe same time, on different processors. A second thread could start the second\nrequest, and then both threads wait for their results to come back, after which\nthey resynchronize to combine their results.\nIn the following diagram, the thick lines represent time the program spends\nrunning normally, and the thin lines represent time spent waiting for the net-\nwork. In the synchronous model, the time taken by the network is part of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_415",
    "text": "running normally, and the thin lines represent time spent waiting for the net-\nwork. In the synchronous model, the time taken by the network is part of\nthe timeline for a given thread of control. In the asynchronous model, start-\ning a network action allows the program to continue running while the network\ncommunication happens alongside it, notifying the program when it is finished.\nsynchronous, single thread of control\nsynchronous, two threads of control\nasynchronous\nAnother way to describe the difference is that waiting for actions to finish is\nimplicit in the synchronous model, while it is explicit\u2014under our control\u2014in\nthe asynchronous one.\nAsynchronicity cuts both ways. It makes expressing programs that do not\nfit the straight-line model of control easier, but it can also make expressing\nprograms that do follow a straight line more awkward. We\u2019ll see some ways to\nreduce this awkwardness later in the chapter.\nBoth prominent JavaScript programming platforms\u2014browsers and Node.js\u2014",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_416",
    "text": "programs that do follow a straight line more awkward. We\u2019ll see some ways to\nreduce this awkwardness later in the chapter.\nBoth prominent JavaScript programming platforms\u2014browsers and Node.js\u2014\nmake operations that might take a while asynchronous, rather than relying on\nthreads. Since programming with threads is notoriously hard (understanding\nwhat a program does is much more di\ufb00icult when it\u2019s doing multiple things at\nonce), this is generally considered a good thing.\n174\nCallbacks\nOne approach to asynchronous programming is to make functions that need\nto wait for something take an extra argument, a callback function. The asyn-\nchronous function starts a process, sets things up so that the callback function\nis called when the process finishes, and then returns.\nAs an example, the setTimeout function, available both in Node.js and in\nbrowsers, waits a given number of milliseconds and then calls a function.\nsetTimeout(() => console.log(\"Tick\"), 500);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_417",
    "text": "As an example, the setTimeout function, available both in Node.js and in\nbrowsers, waits a given number of milliseconds and then calls a function.\nsetTimeout(() => console.log(\"Tick\"), 500);\nWaiting is not generally important work, but it can be very useful when you\nneed to arrange for something to happen at a certain time or check whether\nsome action is taking longer than expected.\nAnother example of a common asynchronous operation is reading a file from\na device\u2019s storage. Imagine you have a function readTextFile that reads a file\u2019s\ncontent as a string and passes it to a callback function.\nreadTextFile(\"shopping_list.txt\", content => {\nconsole.log(`Shopping List:\\n${content}`);\n});\n// \u2192Shopping List:\n// \u2192Peanut butter\n// \u2192Bananas\nThe readTextFile function is not part of standard JavaScript. We will see how\nto read files in the browser and in Node.js in later chapters.\nPerforming multiple asynchronous actions in a row using callbacks means",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_418",
    "text": "to read files in the browser and in Node.js in later chapters.\nPerforming multiple asynchronous actions in a row using callbacks means\nthat you have to keep passing new functions to handle the continuation of the\ncomputation after the actions. An asynchronous function that compares two\nfiles and produces a boolean indicating whether their content is the same might\nlook like this:\nfunction compareFiles(fileA, fileB, callback) {\nreadTextFile(fileA, contentA => {\nreadTextFile(fileB, contentB => {\ncallback(contentA == contentB);\n});\n});\n}\nThis style of programming is workable, but the indentation level increases with\neach asynchronous action because you end up in another function. Doing more\ncomplicated things, such as wrapping asynchronous actions in a loop, can get\n175\nawkward.\nIn a way, asynchronicity is contagious. Any function that calls a function\nthat works asynchronously must itself be asynchronous, using a callback or",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_419",
    "text": "175\nawkward.\nIn a way, asynchronicity is contagious. Any function that calls a function\nthat works asynchronously must itself be asynchronous, using a callback or\nsimilar mechanism to deliver its result. Calling a callback is somewhat more\ninvolved and error prone than simply returning a value, so needing to structure\nlarge parts of your program that way is not great.\nPromises\nA slightly different way to build an asynchronous program is to have asyn-\nchronous functions return an object that represents its (future) result instead\nof passing around callback functions. This way, such functions actually return\nsomething meaningful, and the shape of the program more closely resembles\nthat of synchronous programs.\nThis is what the standard class Promise is for. A promise is a receipt repre-\nsenting a value that may not be available yet. It provides a then method that\nallows you to register a function that should be called when the action for which",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_420",
    "text": "senting a value that may not be available yet. It provides a then method that\nallows you to register a function that should be called when the action for which\nit is waiting finishes. When the promise is resolved, meaning its value becomes\navailable, such functions (there can be multiple) are called with the result value.\nIt is possible to call then on a promise that has already resolved\u2014your function\nwill still be called.\nThe easiest way to create a promise is by calling Promise.resolve. This\nfunction ensures that the value you give it is wrapped in a promise. If it\u2019s\nalready a promise, it is simply returned. Otherwise, you get a new promise\nthat immediately resolves with your value as its result.\nlet fifteen = Promise.resolve(15);\nfifteen.then(value => console.log(`Got ${value}`));\n// \u2192Got 15\nTo create a promise that does not immediately resolve, you can use Promise\nas a constructor. It has a somewhat odd interface: the constructor expects a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_421",
    "text": "// \u2192Got 15\nTo create a promise that does not immediately resolve, you can use Promise\nas a constructor. It has a somewhat odd interface: the constructor expects a\nfunction as its argument, which it immediately calls, passing it a function that\nit can use to resolve the promise.\nFor example, this is how you could create a promise-based interface for the\nreadTextFile function:\nfunction textFile(filename) {\nreturn new Promise(resolve => {\nreadTextFile(filename, text => resolve(text));\n});\n}\n176\ntextFile(\"plans.txt\").then(console.log);\nNote how, in contrast to callback-style functions, this asynchronous function\nreturns a meaningful value\u2014a promise to give you the contents of the file at\nsome point in the future.\nA useful thing about the then method is that it itself returns another promise.\nThis one resolves to the value returned by the callback function or, if that\nreturned value is a promise, to the value that promise resolves to. Thus, you",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_422",
    "text": "This one resolves to the value returned by the callback function or, if that\nreturned value is a promise, to the value that promise resolves to. Thus, you\ncan \u201cchain\u201d multiple calls to then together to set up a sequence of asynchronous\nactions.\nThis function, which reads a file full of filenames and returns the content of\na random file in that list, shows this kind of asynchronous promise pipeline:\nfunction randomFile(listFile) {\nreturn textFile(listFile)\n.then(content => content.trim().split(\"\\n\"))\n.then(ls => ls[Math.floor(Math.random() * ls.length)])\n.then(filename => textFile(filename));\n}\nThe function returns the result of this chain of then calls. The initial promise\nfetches the list of files as a string. The first then call transforms that string\ninto an array of lines, producing a new promise. The second then call picks a\nrandom line from that, producing a third promise that yields a single filename.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_423",
    "text": "into an array of lines, producing a new promise. The second then call picks a\nrandom line from that, producing a third promise that yields a single filename.\nThe final then call reads this file, so the result of the function as a whole is a\npromise that returns the content of a random file.\nIn this code, the functions used in the first two then calls return a regular\nvalue that will immediately be passed into the promise returned by then when\nthe function returns. The last then call returns a promise (textFile(filename\n)), making it an actual asynchronous step.\nIt would also have been possible to perform all these steps inside a single\nthen callback, since only the last step is actually asynchronous. But the kind\nof then wrappers that only do some synchronous data transformation are often\nuseful, such as when you want to return a promise that produces a processed\nversion of some asynchronous result.\nfunction jsonFile(filename) {\nreturn textFile(filename).then(JSON.parse);\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_424",
    "text": "useful, such as when you want to return a promise that produces a processed\nversion of some asynchronous result.\nfunction jsonFile(filename) {\nreturn textFile(filename).then(JSON.parse);\n}\njsonFile(\"package.json\").then(console.log);\n177\nGenerally, it is useful to think of a promise as a device that lets code ignore\nthe question of when a value is going to arrive. A normal value has to actually\nexist before we can reference it. A promised value is a value that might already\nbe there or might appear at some point in the future. Computations defined\nin terms of promises, by wiring them together with then calls, are executed\nasynchronously as their inputs become available.\nFailure\nRegular JavaScript computations can fail by throwing an exception. Asyn-\nchronous computations often need something like that.\nA network request\nmay fail, a file may not exist, or some code that is part of the asynchronous\ncomputation may throw an exception.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_425",
    "text": "chronous computations often need something like that.\nA network request\nmay fail, a file may not exist, or some code that is part of the asynchronous\ncomputation may throw an exception.\nOne of the most pressing problems with the callback style of asynchronous\nprogramming is that it makes it extremely di\ufb00icult to ensure failures are prop-\nerly reported to the callbacks.\nA common convention is to use the first argument to the callback to indicate\nthat the action failed, and the second to pass the value produced by the action\nwhen it was successful.\nsomeAsyncFunction((error, value) => {\nif (error) handleError(error);\nelse processValue(value);\n});\nSuch callback functions must always check whether they received an exception\nand make sure that any problems they cause, including exceptions thrown by\nfunctions they call, are caught and given to the right function.\nPromises make this easier. They can be either resolved (the action finished",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_426",
    "text": "functions they call, are caught and given to the right function.\nPromises make this easier. They can be either resolved (the action finished\nsuccessfully) or rejected (it failed). Resolve handlers (as registered with then)\nare called only when the action is successful, and rejections are propagated to\nthe new promise returned by then. When a handler throws an exception, this\nautomatically causes the promise produced by its then call to be rejected. If\nany element in a chain of asynchronous actions fails, the outcome of the whole\nchain is marked as rejected, and no success handlers are called beyond the point\nwhere it failed.\nMuch like resolving a promise provides a value, rejecting one also provides\na value, usually called the reason of the rejection. When an exception in a\nhandler function causes the rejection, the exception value is used as the reason.\nSimilarly, when a handler returns a promise that is rejected, that rejection flows",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_427",
    "text": "handler function causes the rejection, the exception value is used as the reason.\nSimilarly, when a handler returns a promise that is rejected, that rejection flows\ninto the next promise. There\u2019s a Promise.reject function that creates a new,\n178\nimmediately rejected promise.\nTo explicitly handle such rejections, promises have a catch method that\nregisters a handler to be called when the promise is rejected, similar to how\nthen handlers handle normal resolution. It\u2019s also very much like then in that\nit returns a new promise, which resolves to the original promise\u2019s value when\nthat resolves normally and to the result of the catch handler otherwise. If a\ncatch handler throws an error, the new promise is also rejected.\nAs a shorthand, then also accepts a rejection handler as a second argu-\nment, so you can install both types of handlers in a single method call: .then\n(acceptHandler, rejectHandler).\nA function passed to the Promise constructor receives a second argument,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_428",
    "text": "ment, so you can install both types of handlers in a single method call: .then\n(acceptHandler, rejectHandler).\nA function passed to the Promise constructor receives a second argument,\nalongside the resolve function, which it can use to reject the new promise.\nWhen our readTextFile function encounters a problem, it passes the error\nto its callback function as a second argument. Our textFile wrapper should\nactually check that argument so that a failure causes the promise it returns to\nbe rejected.\nfunction textFile(filename) {\nreturn new Promise((resolve, reject) => {\nreadTextFile(filename, (text, error) => {\nif (error) reject(error);\nelse resolve(text);\n});\n});\n}\nThe chains of promise values created by calls to then and catch thus form\na pipeline through which asynchronous values or failures move.\nSince such\nchains are created by registering handlers, each link has a success handler or a\nrejection handler (or both) associated with it. Handlers that don\u2019t match the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_429",
    "text": "Since such\nchains are created by registering handlers, each link has a success handler or a\nrejection handler (or both) associated with it. Handlers that don\u2019t match the\ntype of outcome (success or failure) are ignored. Handlers that do match are\ncalled, and their outcome determines what kind of value comes next\u2014success\nwhen they return a non-promise value, rejection when they throw an exception,\nand the outcome of the promise when they return a promise.\nnew Promise((_, reject) => reject(new Error(\"Fail\")))\n.then(value => console.log(\"Handler 1:\", value))\n.catch(reason => {\nconsole.log(\"Caught failure \" + reason);\nreturn \"nothing\";\n})\n.then(value => console.log(\"Handler 2:\", value));\n// \u2192Caught failure Error: Fail\n179\n// \u2192Handler 2: nothing\nThe first then handler function isn\u2019t called because at that point of the pipeline\nthe promise holds a rejection. The catch handler handles that rejection and\nreturns a value, which is given to the second then handler function.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_430",
    "text": "the promise holds a rejection. The catch handler handles that rejection and\nreturns a value, which is given to the second then handler function.\nMuch like an uncaught exception is handled by the environment, JavaScript\nenvironments can detect when a promise rejection isn\u2019t handled and will report\nthis as an error.\nCarla\nIt\u2019s a sunny day in Berlin. The runway of the old, decommissioned airport is\nteeming with cyclists and inline skaters. In the grass near a garbage container,\na flock of crows noisily mills about, trying to convince a group of tourists to\npart with their sandwiches.\nOne of the crows stands out\u2014a large scruffy female with a few white feathers\nin her right wing. She is baiting people with a skill and confidence that suggest\nshe\u2019s been doing this for a long time. When an elderly man is distracted by\nthe antics of another crow, she casually swoops in, snatches his half-eaten bun\nfrom his hand, and sails away.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_431",
    "text": "she\u2019s been doing this for a long time. When an elderly man is distracted by\nthe antics of another crow, she casually swoops in, snatches his half-eaten bun\nfrom his hand, and sails away.\nContrary to the rest of the group, who look like they are happy to spend the\nday goofing around here, the large crow looks purposeful. Carrying her loot,\nshe flies straight toward the roof of the hangar building, disappearing into an\nair vent.\nInside the building, you can hear an odd tapping sound\u2014soft, but persistent.\nIt comes from a narrow space under the roof of an unfinished stairwell. The\ncrow is sitting there, surrounded by her stolen snacks, half a dozen smartphones\n(several of which are turned on), and a mess of cables. She rapidly taps the\nscreen of one of the phones with her beak. Words are appearing on it. If you\ndidn\u2019t know better, you\u2019d think she was typing.\nThis crow is known to her peers as \u201cc\u0101\u0101w-kr\u00f6\u201d. But since those sounds are",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_432",
    "text": "screen of one of the phones with her beak. Words are appearing on it. If you\ndidn\u2019t know better, you\u2019d think she was typing.\nThis crow is known to her peers as \u201cc\u0101\u0101w-kr\u00f6\u201d. But since those sounds are\npoorly suited for human vocal chords, we\u2019ll refer to her as Carla.\nCarla is a somewhat peculiar crow.\nIn her youth, she was fascinated by\nhuman language, eavesdropping on people until she had a good grasp of what\nthey were saying. Later in life, her interest shifted to human technology, and\nshe started stealing phones to study them.\nHer current project is learning\nto program. The text she is typing in her hidden lab is, in fact, a piece of\nasynchronous JavaScript code.\n180\nBreaking In\nCarla loves the internet. Annoyingly, the phone she is working on is about to\nrun out of prepaid data. The building has a wireless network, but it requires a\ncode to access.\nFortunately, the wireless routers in the building are 20 years old and poorly",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_433",
    "text": "run out of prepaid data. The building has a wireless network, but it requires a\ncode to access.\nFortunately, the wireless routers in the building are 20 years old and poorly\nsecured. Doing some research, Carla finds out that the network authentication\nmechanism has a flaw she can use. When joining the network, a device must\nsend along the correct six-digit passcode. The access point will reply with a\nsuccess or failure message depending on whether the right code is provided.\nHowever, when sending a partial code (say, only three digits), the response\nis different based on whether those digits are the correct start of the code or\nnot. Sending incorrect numbers immediately returns a failure message. When\nsending the correct ones, the access point waits for more digits.\nThis makes it possible to greatly speed up the guessing of the number. Carla\ncan find the first digit by trying each number in turn, until she finds one that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_434",
    "text": "This makes it possible to greatly speed up the guessing of the number. Carla\ncan find the first digit by trying each number in turn, until she finds one that\ndoesn\u2019t immediately return failure. Having one digit, she can find the second\ndigit in the same way, and so on, until she knows the entire passcode.\nAssume Carla has a joinWifi function. Given the network name and the\npasscode (as a string), the function tries to join the network, returning a\npromise that resolves if successful and rejects if the authentication failed. The\nfirst thing she needs is a way to wrap a promise so that it automatically rejects\nafter it takes too much time, to allow the program to quickly move on if the\naccess point doesn\u2019t respond.\nfunction withTimeout(promise, time) {\nreturn new Promise((resolve, reject) => {\npromise.then(resolve, reject);\nsetTimeout(() => reject(\"Timed out\"), time);\n});\n}\nThis makes use of the fact that a promise can be resolved or rejected only once.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_435",
    "text": "promise.then(resolve, reject);\nsetTimeout(() => reject(\"Timed out\"), time);\n});\n}\nThis makes use of the fact that a promise can be resolved or rejected only once.\nIf the promise given as its argument resolves or rejects first, that result will be\nthe result of the promise returned by withTimeout. If, on the other hand, the\nsetTimeout fires first, rejecting the promise, any further resolve or reject calls\nare ignored.\nTo find the whole passcode, the program needs to repeatedly look for the\nnext digit by trying each digit. If authentication succeeds, we know we have\nfound what we are looking for. If it immediately fails, we know that digit was\nwrong and must try the next digit. If the request times out, we have found\n181\nanother correct digit and must continue by adding another digit.\nBecause you cannot wait for a promise inside a for loop, Carla uses a recur-\nsive function to drive this process. On each call, this function gets the code as",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_436",
    "text": "Because you cannot wait for a promise inside a for loop, Carla uses a recur-\nsive function to drive this process. On each call, this function gets the code as\nwe know it so far, as well as the next digit to try. Depending on what happens,\nit may return a finished code or call through to itself, to either start cracking\nthe next position in the code or to try again with another digit.\nfunction crackPasscode(networkID) {\nfunction nextDigit(code, digit) {\nlet newCode = code + digit;\nreturn withTimeout(joinWifi(networkID, newCode), 50)\n.then(() => newCode)\n.catch(failure => {\nif (failure == \"Timed out\") {\nreturn nextDigit(newCode, 0);\n} else if (digit < 9) {\nreturn nextDigit(code, digit + 1);\n} else {\nthrow failure;\n}\n});\n}\nreturn nextDigit(\"\", 0);\n}\nThe access point tends to respond to bad authentication requests in about 20\nmilliseconds, so to be safe, this function waits for 50 milliseconds before timing\nout a request.\ncrackPasscode(\"HANGAR 2\").then(console.log);\n// \u2192555555",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_437",
    "text": "milliseconds, so to be safe, this function waits for 50 milliseconds before timing\nout a request.\ncrackPasscode(\"HANGAR 2\").then(console.log);\n// \u2192555555\nCarla tilts her head and sighs. This would have been more satisfying if the\ncode had been a bit harder to guess.\nAsync functions\nEven with promises, this kind of asynchronous code is annoying to write.\nPromises often need to be tied together in verbose, arbitrary-looking ways.\nTo create an asynchronous loop, Carla was forced to introduce a recursive\nfunction.\nThe thing the cracking function actually does is completely linear\u2014it always\nwaits for the previous action to complete before starting the next one. In a\n182\nsynchronous programming model, it\u2019d be more straightforward to express.\nThe good news is that JavaScript allows you to write pseudosynchronous\ncode to describe asynchronous computation. An async function implicitly re-\nturns a promise and can, in its body, await other promises in a way that looks\nsynchronous.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_438",
    "text": "code to describe asynchronous computation. An async function implicitly re-\nturns a promise and can, in its body, await other promises in a way that looks\nsynchronous.\nWe can rewrite crackPasscode like this:\nasync function crackPasscode(networkID) {\nfor (let code = \"\";;) {\nfor (let digit = 0;; digit++) {\nlet newCode = code + digit;\ntry {\nawait withTimeout(joinWifi(networkID, newCode), 50);\nreturn newCode;\n} catch (failure) {\nif (failure == \"Timed out\") {\ncode = newCode;\nbreak;\n} else if (digit == 9) {\nthrow failure;\n}\n}\n}\n}\n}\nThis version more clearly shows the double loop structure of the function (the\ninner loop tries digit 0 to 9 and the outer loop adds digits to the passcode).\nAn async function is marked by the word async before the function keyword.\nMethods can also be made async by writing async before their name. When\nsuch a function or method is called, it returns a promise.\nAs soon as the\nfunction returns something, that promise is resolved. If the body throws an",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_439",
    "text": "such a function or method is called, it returns a promise.\nAs soon as the\nfunction returns something, that promise is resolved. If the body throws an\nexception, the promise is rejected.\nInside an async function, the word await can be put in front of an expression\nto wait for a promise to resolve and only then continue the execution of the\nfunction. If the promise rejects, an exception is raised at the point of the await.\nSuch a function no longer runs from start to completion in one go like a\nregular JavaScript function. Instead, it can be frozen at any point that has an\nawait and can be resumed at a later time.\nFor most asynchronous code, this notation is more convenient than directly\nusing promises. You do still need an understanding of promises, since in many\ncases you\u2019ll still interact with them directly. But when wiring them together,\nasync functions are generally more pleasant to write than chains of then calls.\n183\nGenerators",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_440",
    "text": "cases you\u2019ll still interact with them directly. But when wiring them together,\nasync functions are generally more pleasant to write than chains of then calls.\n183\nGenerators\nThis ability of functions to be paused and then resumed again is not exclusive\nto async functions. JavaScript also has a feature called generator functions.\nThese are similar, but without the promises.\nWhen you define a function with function* (placing an asterisk after the\nword function), it becomes a generator. When you call a generator, it returns\nan iterator, which we already saw in Chapter 6.\nfunction* powers(n) {\nfor (let current = n;; current *= n) {\nyield current;\n}\n}\nfor (let power of powers(3)) {\nif (power > 50) break;\nconsole.log(power);\n}\n// \u21923\n// \u21929\n// \u219227\nInitially, when you call powers, the function is frozen at its start. Every time\nyou call next on the iterator, the function runs until it hits a yield expression,\nwhich pauses it and causes the yielded value to become the next value produced",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_441",
    "text": "you call next on the iterator, the function runs until it hits a yield expression,\nwhich pauses it and causes the yielded value to become the next value produced\nby the iterator. When the function returns (the one in the example never does),\nthe iterator is done.\nWriting iterators is often much easier when you use generator functions. The\niterator for the Group class (from the exercise in Chapter 6) can be written with\nthis generator:\nGroup.prototype[Symbol.iterator] = function*() {\nfor (let i = 0; i < this.members.length; i++) {\nyield this.members[i];\n}\n};\nThere\u2019s no longer a need to create an object to hold the iteration state\u2014\ngenerators automatically save their local state every time they yield.\nSuch yield expressions may occur only directly in the generator function\nitself and not in an inner function you define inside of it. The state a generator\nsaves, when yielding, is only its local environment and the position where it\nyielded.\n184",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_442",
    "text": "itself and not in an inner function you define inside of it. The state a generator\nsaves, when yielding, is only its local environment and the position where it\nyielded.\n184\nAn async function is a special type of generator. It produces a promise when\ncalled, which is resolved when it returns (finishes) and rejected when it throws\nan exception. Whenever it yields (awaits) a promise, the result of that promise\n(value or thrown exception) is the result of the await expression.\nA Corvid Art Project\nOne morning, Carla wakes up to unfamiliar noise from the tarmac outside of\nher hangar. Hopping onto the edge of the roof, she sees the humans are setting\nup for something. There\u2019s a lot of electric cabling, a stage, and some kind of\nbig black wall being built up.\nBeing a curious crow, Carla takes a closer look at the wall. It appears to\nconsist of a number of large glass-fronted devices wired up to cables. On the\nback, the devices say \u201cLedTec SIG-5030\u201d.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_443",
    "text": "Being a curious crow, Carla takes a closer look at the wall. It appears to\nconsist of a number of large glass-fronted devices wired up to cables. On the\nback, the devices say \u201cLedTec SIG-5030\u201d.\nA quick internet search turns up a user manual for these devices.\nThey\nappear to be tra\ufb00ic signs, with a programmable matrix of amber LED lights.\nThe intent of the humans is probably to display some kind of information on\nthem during their event. Interestingly, the screens can be programmed over\na wireless network.\nCould it be they are connected to the building\u2019s local\nnetwork?\nEach device on a network gets an IP address, which other devices can use\nto send it messages. We talk more about that in Chapter 13. Carla notices\nthat her own phones all get addresses like 10.0.0.20 or 10.0.0.33. It might be\nworth trying to send messages to all such addresses and see if any one of them\nresponds to the interface described in the manual for the signs.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_444",
    "text": "worth trying to send messages to all such addresses and see if any one of them\nresponds to the interface described in the manual for the signs.\nChapter 18 shows how to make real requests on real networks. In this chap-\nter, we\u2019ll use a simplified dummy function called request for network communi-\ncation. This function takes two arguments\u2014a network address and a message,\nwhich may be anything that can be sent as JSON\u2014and returns a promise that\neither resolves to a response from the machine at the given address, or rejects\nif there was a problem.\nAccording to the manual, you can change what is displayed on a SIG-5030\nsign by sending it a message with content like {\"command\": \"display\", \"data\n\": [0, 0, 3, \u2026]}, where data holds one number per LED dot, providing its\nbrightness\u20140 means off, 3 means maximum brightness. Each sign is 50 lights\nwide and 30 lights high, so an update command should send 1,500 numbers.\nThis code sends a display update message to all addresses on the local net-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_445",
    "text": "wide and 30 lights high, so an update command should send 1,500 numbers.\nThis code sends a display update message to all addresses on the local net-\nwork, to see what sticks. Each of the numbers in an IP address can go from 0\nto 255. In the data it sends, it activates a number of lights corresponding to\n185\nthe network address\u2019s last number.\nfor (let addr = 1; addr < 256; addr++) {\nlet data = [];\nfor (let n = 0; n < 1500; n++) {\ndata.push(n < addr ? 3 : 0);\n}\nlet ip = `10.0.0.${addr}`;\nrequest(ip, {command: \"display\", data})\n.then(() => console.log(`Request to ${ip} accepted`))\n.catch(() => {});\n}\nSince most of these addresses won\u2019t exist or will not accept such messages, the\ncatch call makes sure network errors don\u2019t crash the program. The requests\nare all sent out immediately, without waiting for other requests to finish, in\norder to not waste time when some of the machines don\u2019t answer.\nHaving fired off her network scan, Carla heads back outside to see the result.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_446",
    "text": "order to not waste time when some of the machines don\u2019t answer.\nHaving fired off her network scan, Carla heads back outside to see the result.\nTo her delight, all of the screens are now showing a stripe of light in their upper-\nleft corners. They are on the local network, and they do accept commands.\nShe quickly notes the numbers shown on each screen. There are nine screens,\narranged three high and three wide. They have the following network addresses:\nconst screenAddresses = [\n\"10.0.0.44\", \"10.0.0.45\", \"10.0.0.41\",\n\"10.0.0.31\", \"10.0.0.40\", \"10.0.0.42\",\n\"10.0.0.48\", \"10.0.0.47\", \"10.0.0.46\"\n];\nNow this opens up possibilities for all kinds of shenanigans. She could show\n\u201ccrows rule, humans drool\u201d on the wall in giant letters. But that feels a bit\ncrude. Instead, she plans to show a video of a flying crow covering all of the\nscreens at night.\nCarla finds a fitting video clip, in which a second and a half of footage can",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_447",
    "text": "crude. Instead, she plans to show a video of a flying crow covering all of the\nscreens at night.\nCarla finds a fitting video clip, in which a second and a half of footage can\nbe repeated to create a looping video showing a crow\u2019s wingbeat. To fit the\nnine screens (each of which can show 50\u00d730 pixels), Carla cuts and resizes the\nvideos to get a series of 150\u00d790 images, 10 per second. Those are then each\ncut into nine rectangles, and processed so that the dark spots on the video\n(where the crow is) show a bright light, and the light spots (no crow) are left\ndark, which should create the effect of an amber crow flying against a black\nbackground.\nShe has set up the clipImages variable to hold an array of frames, where\neach frame is represented with an array of nine sets of pixels\u2014one for each\n186\nscreen\u2014in the format that the signs expect.\nTo display a single frame of the video, Carla needs to send a request to all",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_448",
    "text": "each frame is represented with an array of nine sets of pixels\u2014one for each\n186\nscreen\u2014in the format that the signs expect.\nTo display a single frame of the video, Carla needs to send a request to all\nthe screens at once. But she also needs to wait for the result of these requests,\nboth in order to not start sending the next frame before the current one has\nbeen properly sent and in order to notice when requests are failing.\nPromise has a static method all that can be used to convert an array of\npromises into a single promise that resolves to an array of results. This provides\na convenient way to have some asynchronous actions happen alongside each\nother, wait for them all to finish, and then do something with their results (or\nat least wait for them to make sure they don\u2019t fail).\nfunction displayFrame(frame) {\nreturn Promise.all(frame.map((data, i) => {\nreturn request(screenAddresses[i], {\ncommand: \"display\",\ndata\n});\n}));\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_449",
    "text": "function displayFrame(frame) {\nreturn Promise.all(frame.map((data, i) => {\nreturn request(screenAddresses[i], {\ncommand: \"display\",\ndata\n});\n}));\n}\nThis maps over the images in frame (which is an array of display data arrays)\nto create an array of request promises. It then returns a promise that combines\nall of those.\nIn order to be able to stop a playing video, the process is wrapped in a\nclass. This class has an asynchronous play method that returns a promise that\nresolves only when the playback is stopped again via the stop method.\nfunction wait(time) {\nreturn new Promise(accept => setTimeout(accept, time));\n}\nclass VideoPlayer {\nconstructor(frames, frameTime) {\nthis.frames = frames;\nthis.frameTime = frameTime;\nthis.stopped = true;\n}\nasync play() {\nthis.stopped = false;\nfor (let i = 0; !this.stopped; i++) {\nlet nextFrame = wait(this.frameTime);\nawait displayFrame(this.frames[i % this.frames.length]);\nawait nextFrame;\n187\n}\n}\nstop() {\nthis.stopped = true;\n}\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_450",
    "text": "for (let i = 0; !this.stopped; i++) {\nlet nextFrame = wait(this.frameTime);\nawait displayFrame(this.frames[i % this.frames.length]);\nawait nextFrame;\n187\n}\n}\nstop() {\nthis.stopped = true;\n}\n}\nThe wait function wraps setTimeout in a promise that resolves after the given\nnumber of milliseconds. This is useful for controlling the speed of the playback.\nlet video = new VideoPlayer(clipImages, 100);\nvideo.play().catch(e => {\nconsole.log(\"Playback failed: \" + e);\n});\nsetTimeout(() => video.stop(), 15000);\nFor the entire week that the screen wall stands, every evening, when it is dark,\na huge glowing orange bird mysteriously appears on it.\nThe event loop\nAn asynchronous program starts by running its main script, which will often\nset up callbacks to be called later. That main script, as well as the callbacks,\nrun to completion in one piece, uninterrupted. But between them, the program\nmay sit idle, waiting for something to happen.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_451",
    "text": "run to completion in one piece, uninterrupted. But between them, the program\nmay sit idle, waiting for something to happen.\nSo callbacks are not directly called by the code that scheduled them. If I\ncall setTimeout from within a function, that function will have returned by the\ntime the callback function is called. And when the callback returns, control\ndoes not go back to the function that scheduled it.\nAsynchronous behavior happens on its own empty function call stack. This\nis one of the reasons that, without promises, managing exceptions across asyn-\nchronous code is so hard. Since each callback starts with a mostly empty stack,\nyour catch handlers won\u2019t be on the stack when they throw an exception.\ntry {\nsetTimeout(() => {\nthrow new Error(\"Woosh\");\n}, 20);\n} catch (e) {\n// This will not run\nconsole.log(\"Caught\", e);\n}\n188\nNo matter how closely together events\u2014such as timeouts or incoming requests\u2014\nhappen, a JavaScript environment will run only one program at a time. You",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_452",
    "text": "console.log(\"Caught\", e);\n}\n188\nNo matter how closely together events\u2014such as timeouts or incoming requests\u2014\nhappen, a JavaScript environment will run only one program at a time. You\ncan think of this as it running a big loop around your program, called the event\nloop. When there\u2019s nothing to be done, that loop is paused. But as events come\nin, they are added to a queue, and their code is executed one after the other.\nBecause no two things run at the same time, slow-running code can delay the\nhandling of other events.\nThis example sets a timeout but then dallies until after the timeout\u2019s in-\ntended point of time, causing the timeout to be late.\nlet start = Date.now();\nsetTimeout(() => {\nconsole.log(\"Timeout ran at\", Date.now() - start);\n}, 20);\nwhile (Date.now() < start + 50) {}\nconsole.log(\"Wasted time until\", Date.now() - start);\n// \u2192Wasted time until 50\n// \u2192Timeout ran at 55\nPromises always resolve or reject as a new event. Even if a promise is already",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_453",
    "text": "console.log(\"Wasted time until\", Date.now() - start);\n// \u2192Wasted time until 50\n// \u2192Timeout ran at 55\nPromises always resolve or reject as a new event. Even if a promise is already\nresolved, waiting for it will cause your callback to run after the current script\nfinishes, rather than right away.\nPromise.resolve(\"Done\").then(console.log);\nconsole.log(\"Me first!\");\n// \u2192Me first!\n// \u2192Done\nIn later chapters we\u2019ll see various other types of events that run on the event\nloop.\nAsynchronous bugs\nWhen your program runs synchronously, in a single go, there are no state\nchanges happening except those that the program itself makes.\nFor asyn-\nchronous programs this is different\u2014they may have gaps in their execution\nduring which other code can run.\nLet\u2019s look at an example. This is a function that tries to report the size of\neach file in an array of files, making sure to read them all at the same time\nrather than in sequence.\nasync function fileSizes(files) {\nlet list = \"\";\n189",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_454",
    "text": "each file in an array of files, making sure to read them all at the same time\nrather than in sequence.\nasync function fileSizes(files) {\nlet list = \"\";\n189\nawait Promise.all(files.map(async fileName => {\nlist += fileName + \": \" +\n(await textFile(fileName)).length + \"\\n\";\n}));\nreturn list;\n}\nThe async fileName => part shows how arrow functions can also be made async\nby putting the word async in front of them.\nThe code doesn\u2019t immediately look suspicious... it maps the async arrow\nfunction over the array of names, creating an array of promises, and then uses\nPromise.all to wait for all of these before returning the list they build up.\nBut this program is entirely broken. It\u2019ll always return only a single line of\noutput, listing the file that took the longest to read.\nCan you work out why?\nThe problem lies in the += operator, which takes the current value of list\nat the time the statement starts executing and then, when the await finishes,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_455",
    "text": "Can you work out why?\nThe problem lies in the += operator, which takes the current value of list\nat the time the statement starts executing and then, when the await finishes,\nsets the list binding to be that value plus the added string.\nBut between the time the statement starts executing and the time it finishes,\nthere\u2019s an asynchronous gap. The map expression runs before anything has been\nadded to the list, so each of the += operators starts from an empty string and\nends up, when its storage retrieval finishes, setting list to the result of adding\nits line to the empty string.\nThis could have easily been avoided by returning the lines from the mapped\npromises and calling join on the result of Promise.all, instead of building up\nthe list by changing a binding. As usual, computing new values is less error\nprone than changing existing values.\nasync function fileSizes(files) {\nlet lines = files.map(async fileName => {\nreturn fileName + \": \" +\n(await textFile(fileName)).length;\n});",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_456",
    "text": "prone than changing existing values.\nasync function fileSizes(files) {\nlet lines = files.map(async fileName => {\nreturn fileName + \": \" +\n(await textFile(fileName)).length;\n});\nreturn (await Promise.all(lines)).join(\"\\n\");\n}\nMistakes like this are easy to make, especially when using await, and you should\nbe aware of where the gaps in your code occur. An advantage of JavaScript\u2019s\nexplicit asynchronicity (whether through callbacks, promises, or await) is that\nspotting these gaps is relatively easy.\n190\nSummary\nAsynchronous programming makes it possible to express waiting for long-\nrunning actions without freezing the whole program. JavaScript environments\ntypically implement this style of programming using callbacks, functions that\nare called when the actions complete. An event loop schedules such callbacks\nto be called when appropriate, one after the other, so that their execution does\nnot overlap.\nProgramming asynchronously is made easier by promises, objects that rep-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_457",
    "text": "to be called when appropriate, one after the other, so that their execution does\nnot overlap.\nProgramming asynchronously is made easier by promises, objects that rep-\nresent actions that might complete in the future, and async functions, which\nallow you to write an asynchronous program as if it were synchronous.\nExercises\nQuiet Times\nThere\u2019s a security camera near Carla\u2019s lab that\u2019s activated by a motion sensor.\nIt is connected to the network and starts sending out a video stream when it\nis active. Because she\u2019d rather not be discovered, Carla has set up a system\nthat notices this kind of wireless network tra\ufb00ic and turns on a light in her lair\nwhenever there is activity outside, so she knows when to keep quiet.\nShe\u2019s also been logging the times at which the camera is tripped for a while\nand wants to use this information to visualize which times, in an average week,\ntend to be quiet and which tend to be busy. The log is stored in files holding",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_458",
    "text": "and wants to use this information to visualize which times, in an average week,\ntend to be quiet and which tend to be busy. The log is stored in files holding\none time stamp number (as returned by Date.now()) per line.\n1695709940692\n1695701068331\n1695701189163\nThe \"camera_logs.txt\" file holds a list of logfiles.\nWrite an asynchronous\nfunction activityTable(day) that for a given day of the week returns an array\nof 24 numbers, one for each hour of the day, that hold the number of camera\nnetwork tra\ufb00ic observations seen in that hour of the day. Days are identified by\nnumber using the system used by Date.getDay, where Sunday is 0 and Saturday\nis 6.\nThe activityGraph function, provided by the sandbox, summarizes such a\ntable into a string.\nTo read the files, use the textFile function defined earlier\u2014given a filename,\nit returns a promise that resolves to the file\u2019s content. Remember that new\nDate(timestamp) creates a Date object for that time, which has getDay and\n191",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_459",
    "text": "it returns a promise that resolves to the file\u2019s content. Remember that new\nDate(timestamp) creates a Date object for that time, which has getDay and\n191\ngetHours methods returning the day of the week and the hour of the day.\nBoth types of files\u2014the list of logfiles and the logfiles themselves\u2014have each\npiece of data on its own line, separated by newline (\"\\n\") characters.\nReal Promises\nRewrite the function from the previous exercise without async/await, using\nplain Promise methods.\nIn this style, using Promise.all will be more convenient than trying to model\na loop over the logfiles. In the async function, just using await in a loop is\nsimpler. If reading a file takes some time, which of these two approaches will\ntake the least time to run?\nIf one of the files listed in the file list has a typo, and reading it fails, how\ndoes that failure end up in the Promise object that your function returns?\nBuilding Promise.all",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_460",
    "text": "If one of the files listed in the file list has a typo, and reading it fails, how\ndoes that failure end up in the Promise object that your function returns?\nBuilding Promise.all\nAs we saw, given an array of promises, Promise.all returns a promise that\nwaits for all of the promises in the array to finish. It then succeeds, yielding\nan array of result values. If a promise in the array fails, the promise returned\nby all fails too, passing on the failure reason from the failing promise.\nImplement something like this yourself as a regular function called Promise_all\n.\nRemember that after a promise has succeeded or failed, it can\u2019t succeed or\nfail again, and further calls to the functions that resolve it are ignored. This\ncan simplify the way you handle a failure of your promise.\n192\n\u201cThe evaluator, which determines the meaning of expressions in a\nprogramming language, is just another program.\u201d\n\u2014Hal Abelson and Gerald Sussman, Structure and Interpretation of\nComputer Programs\nChapter 12",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_461",
    "text": "programming language, is just another program.\u201d\n\u2014Hal Abelson and Gerald Sussman, Structure and Interpretation of\nComputer Programs\nChapter 12\nProject: A Programming Language\nBuilding your own programming language is surprisingly easy (as long as you\ndo not aim too high) and very enlightening.\nThe main thing I want to show in this chapter is that there\u2019s no magic\ninvolved in building a programming language. I\u2019ve often felt that some human\ninventions were so immensely clever and complicated that I\u2019d never be able to\nunderstand them. But with a little reading and experimenting, they often turn\nout to be quite mundane.\nWe will build a programming language called Egg. It will be a tiny, simple\nlanguage\u2014but one that is powerful enough to express any computation you\ncan think of. It will allow simple abstraction based on functions.\nParsing\nThe most immediately visible part of a programming language is its syntax, or",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_462",
    "text": "can think of. It will allow simple abstraction based on functions.\nParsing\nThe most immediately visible part of a programming language is its syntax, or\nnotation. A parser is a program that reads a piece of text and produces a data\nstructure that reflects the structure of the program contained in that text. If\nthe text does not form a valid program, the parser should point out the error.\nOur language will have a simple and uniform syntax. Everything in Egg is an\nexpression. An expression can be the name of a binding, a number, a string, or\nan application. Applications are used for function calls but also for constructs\nsuch as if or while.\nTo keep the parser simple, strings in Egg do not support anything like back-\nslash escapes. A string is simply a sequence of characters that are not double\nquotes, wrapped in double quotes. A number is a sequence of digits. Binding\nnames can consist of any character that is not whitespace and that does not\nhave a special meaning in the syntax.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_463",
    "text": "quotes, wrapped in double quotes. A number is a sequence of digits. Binding\nnames can consist of any character that is not whitespace and that does not\nhave a special meaning in the syntax.\nApplications are written the way they are in JavaScript, by putting paren-\ntheses after an expression and having any number of arguments between those\nparentheses, separated by commas.\ndo(define(x, 10),\n193\nif(>(x, 5),\nprint(\"large\"),\nprint(\"small\")))\nThe uniformity of the Egg language means that things that are operators in\nJavaScript (such as >) are normal bindings in this language, applied just like\nother functions. Since the syntax has no concept of a block, we need a do\nconstruct to represent doing multiple things in sequence.\nThe data structure that the parser will use to describe a program consists\nof expression objects, each of which has a type property indicating the kind of\nexpression it is and other properties to describe its content.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_464",
    "text": "of expression objects, each of which has a type property indicating the kind of\nexpression it is and other properties to describe its content.\nExpressions of type \"value\" represent literal strings or numbers. Their value\nproperty contains the string or number value that they represent. Expressions\nof type \"word\" are used for identifiers (names). Such objects have a name prop-\nerty that holds the identifier\u2019s name as a string. Finally, \"apply\" expressions\nrepresent applications. They have an operator property that refers to the ex-\npression that is being applied, as well as an args property that holds an array\nof argument expressions.\nThe >(x, 5) part of the previous program would be represented like this:\n{\ntype: \"apply\",\noperator: {type: \"word\", name: \">\"},\nargs: [\n{type: \"word\", name: \"x\"},\n{type: \"value\", value: 5}\n]\n}\nSuch a data structure is called a syntax tree. If you imagine the objects as\ndots and the links between them as lines between those dots, as shown in the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_465",
    "text": "{type: \"value\", value: 5}\n]\n}\nSuch a data structure is called a syntax tree. If you imagine the objects as\ndots and the links between them as lines between those dots, as shown in the\nfollowing diagram, the structure has a treelike shape. The fact that expressions\ncontain other expressions, which in turn might contain more expressions, is\nsimilar to the way tree branches split and split again.\n194\ndo\nde\ufb01ne\nx\n10\nif\n>\nx\n5\nprint\n\"large\"\nprint\n\"small\"\nContrast this to the parser we wrote for the configuration file format in\nChapter 9, which had a simple structure: it split the input into lines and\nhandled those lines one at a time. There were only a few simple forms that a\nline was allowed to have.\nHere we must find a different approach. Expressions are not separated into\nlines, and they have a recursive structure.\nApplication expressions contain\nother expressions.\nFortunately, this problem can be solved very well by writing a parser function",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_466",
    "text": "lines, and they have a recursive structure.\nApplication expressions contain\nother expressions.\nFortunately, this problem can be solved very well by writing a parser function\nthat is recursive in a way that reflects the recursive nature of the language.\nWe define a function parseExpression that takes a string as input. It returns\nan object containing the data structure for the expression at the start of the\nstring, along with the part of the string left after parsing this expression. When\nparsing subexpressions (the argument to an application, for example), this\nfunction can be called again, yielding the argument expression as well as the\ntext that remains. This text may in turn contain more arguments or may be\nthe closing parenthesis that ends the list of arguments.\nThis is the first part of the parser:\nfunction parseExpression(program) {\nprogram = skipSpace(program);\nlet match, expr;\nif (match = /^\"([^\"]*)\"/.exec(program)) {\nexpr = {type: \"value\", value: match[1]};",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_467",
    "text": "function parseExpression(program) {\nprogram = skipSpace(program);\nlet match, expr;\nif (match = /^\"([^\"]*)\"/.exec(program)) {\nexpr = {type: \"value\", value: match[1]};\n} else if (match = /^\\d+\\b/.exec(program)) {\nexpr = {type: \"value\", value: Number(match[0])};\n} else if (match = /^[^\\s(),#\"]+/.exec(program)) {\nexpr = {type: \"word\", name: match[0]};\n} else {\n195\nthrow new SyntaxError(\"Unexpected syntax: \" + program);\n}\nreturn parseApply(expr, program.slice(match[0].length));\n}\nfunction skipSpace(string) {\nlet first = string.search(/\\S/);\nif (first == -1) return \"\";\nreturn string.slice(first);\n}\nBecause Egg, like JavaScript, allows any amount of whitespace between its\nelements, we have to repeatedly cut the whitespace off the start of the program\nstring. The skipSpace function helps with this.\nAfter skipping any leading space, parseExpression uses three regular expres-\nsions to spot the three atomic elements that Egg supports: strings, numbers,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_468",
    "text": "After skipping any leading space, parseExpression uses three regular expres-\nsions to spot the three atomic elements that Egg supports: strings, numbers,\nand words. The parser constructs a different kind of data structure depending\non which expression matches. If the input does not match one of these three\nforms, it is not a valid expression, and the parser throws an error. We use\nthe SyntaxError constructor here. This is an exception class defined by the\nstandard, like Error, but more specific.\nWe then cut off the part that was matched from the program string and pass\nthat, along with the object for the expression, to parseApply, which checks\nwhether the expression is an application. If so, it parses a parenthesized list of\narguments.\nfunction parseApply(expr, program) {\nprogram = skipSpace(program);\nif (program[0] != \"(\") {\nreturn {expr: expr, rest: program};\n}\nprogram = skipSpace(program.slice(1));\nexpr = {type: \"apply\", operator: expr, args: []};\nwhile (program[0] != \")\") {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_469",
    "text": "if (program[0] != \"(\") {\nreturn {expr: expr, rest: program};\n}\nprogram = skipSpace(program.slice(1));\nexpr = {type: \"apply\", operator: expr, args: []};\nwhile (program[0] != \")\") {\nlet arg = parseExpression(program);\nexpr.args.push(arg.expr);\nprogram = skipSpace(arg.rest);\nif (program[0] == \",\") {\nprogram = skipSpace(program.slice(1));\n} else if (program[0] != \")\") {\nthrow new SyntaxError(\"Expected ',' or ')'\");\n}\n196\n}\nreturn parseApply(expr, program.slice(1));\n}\nIf the next character in the program is not an opening parenthesis, this is not\nan application, and parseApply returns the expression it was given. Otherwise,\nit skips the opening parenthesis and creates the syntax tree object for this\napplication expression. It then recursively calls parseExpression to parse each\nargument until a closing parenthesis is found. The recursion is indirect, through\nparseApply and parseExpression calling each other.\nBecause an application expression can itself be applied (such as in multiplier",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_470",
    "text": "parseApply and parseExpression calling each other.\nBecause an application expression can itself be applied (such as in multiplier\n(2)(1)), parseApply must, after it has parsed an application, call itself again\nto check whether another pair of parentheses follows.\nThis is all we need to parse Egg. We wrap it in a convenient parse func-\ntion that verifies that it has reached the end of the input string after parsing\nthe expression (an Egg program is a single expression), and that gives us the\nprogram\u2019s data structure.\nfunction parse(program) {\nlet {expr, rest} = parseExpression(program);\nif (skipSpace(rest).length > 0) {\nthrow new SyntaxError(\"Unexpected text after program\");\n}\nreturn expr;\n}\nconsole.log(parse(\"+(a, 10)\"));\n// \u2192{type: \"apply\",\n//\noperator: {type: \"word\", name: \"+\"},\n//\nargs: [{type: \"word\", name: \"a\"},\n//\n{type: \"value\", value: 10}]}\nIt works! It doesn\u2019t give us very helpful information when it fails and doesn\u2019t",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_471",
    "text": "//\noperator: {type: \"word\", name: \"+\"},\n//\nargs: [{type: \"word\", name: \"a\"},\n//\n{type: \"value\", value: 10}]}\nIt works! It doesn\u2019t give us very helpful information when it fails and doesn\u2019t\nstore the line and column on which each expression starts, which might be\nhelpful when reporting errors later, but it\u2019s good enough for our purposes.\nThe evaluator\nWhat can we do with the syntax tree for a program? Run it, of course! And\nthat is what the evaluator does. You give it a syntax tree and a scope object\nthat associates names with values, and it will evaluate the expression that the\ntree represents and return the value that this produces.\n197\nconst specialForms = Object.create(null);\nfunction evaluate(expr, scope) {\nif (expr.type == \"value\") {\nreturn expr.value;\n} else if (expr.type == \"word\") {\nif (expr.name in scope) {\nreturn scope[expr.name];\n} else {\nthrow new ReferenceError(\n`Undefined binding: ${expr.name}`);\n}\n} else if (expr.type == \"apply\") {\nlet {operator, args} = expr;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_472",
    "text": "if (expr.name in scope) {\nreturn scope[expr.name];\n} else {\nthrow new ReferenceError(\n`Undefined binding: ${expr.name}`);\n}\n} else if (expr.type == \"apply\") {\nlet {operator, args} = expr;\nif (operator.type == \"word\" &&\noperator.name in specialForms) {\nreturn specialForms[operator.name](expr.args, scope);\n} else {\nlet op = evaluate(operator, scope);\nif (typeof op == \"function\") {\nreturn op(...args.map(arg => evaluate(arg, scope)));\n} else {\nthrow new TypeError(\"Applying a non-function.\");\n}\n}\n}\n}\nThe evaluator has code for each of the expression types. A literal value ex-\npression produces its value. (For example, the expression 100 evaluates to the\nnumber 100.) For a binding, we must check whether it is actually defined in\nthe scope and, if it is, fetch the binding\u2019s value.\nApplications are more involved. If they are a special form, like if, we do\nnot evaluate anything\u2014we just and pass the argument expressions, along with",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_473",
    "text": "Applications are more involved. If they are a special form, like if, we do\nnot evaluate anything\u2014we just and pass the argument expressions, along with\nthe scope, to the function that handles this form. If it is a normal call, we\nevaluate the operator, verify that it is a function, and call it with the evaluated\narguments.\nWe use plain JavaScript function values to represent Egg\u2019s function values.\nWe will come back to this later, when the special form fun is defined.\nThe recursive structure of evaluate resembles the structure of the parser,\nand both mirror the structure of the language itself. It would also be possible\nto combine the parser and the evaluator into one function and evaluate during\nparsing, but splitting them up this way makes the program clearer and more\nflexible.\n198\nThis is really all that\u2019s needed to interpret Egg. It\u2019s that simple. But without\ndefining a few special forms and adding some useful values to the environment,\nyou can\u2019t do much with this language yet.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_474",
    "text": "defining a few special forms and adding some useful values to the environment,\nyou can\u2019t do much with this language yet.\nSpecial forms\nThe specialForms object is used to define special syntax in Egg. It associates\nwords with functions that evaluate such forms. It is currently empty. Let\u2019s add\nif.\nspecialForms.if = (args, scope) => {\nif (args.length != 3) {\nthrow new SyntaxError(\"Wrong number of args to if\");\n} else if (evaluate(args[0], scope) !== false) {\nreturn evaluate(args[1], scope);\n} else {\nreturn evaluate(args[2], scope);\n}\n};\nEgg\u2019s if construct expects exactly three arguments. It will evaluate the first,\nand if the result isn\u2019t the value false, it will evaluate the second. Otherwise,\nthe third gets evaluated. This if form is more similar to JavaScript\u2019s ternary\n?: operator than to JavaScript\u2019s if. It is an expression, not a statement, and\nit produces a value\u2014namely, the result of the second or third argument.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_475",
    "text": "?: operator than to JavaScript\u2019s if. It is an expression, not a statement, and\nit produces a value\u2014namely, the result of the second or third argument.\nEgg also differs from JavaScript in how it handles the condition value to if.\nIt will treat only the value false as false, not things like zero or the empty\nstring.\nThe reason we need to represent if as a special form rather than a regular\nfunction is that all arguments to functions are evaluated before the function is\ncalled, whereas if should evaluate only either its second or its third argument,\ndepending on the value of the first.\nThe while form is similar.\nspecialForms.while = (args, scope) => {\nif (args.length != 2) {\nthrow new SyntaxError(\"Wrong number of args to while\");\n}\nwhile (evaluate(args[0], scope) !== false) {\nevaluate(args[1], scope);\n}\n// Since undefined does not exist in Egg, we return false,\n199\n// for lack of a meaningful result\nreturn false;\n};",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_476",
    "text": "}\nwhile (evaluate(args[0], scope) !== false) {\nevaluate(args[1], scope);\n}\n// Since undefined does not exist in Egg, we return false,\n199\n// for lack of a meaningful result\nreturn false;\n};\nAnother basic building block is do, which executes all its arguments from top\nto bottom. Its value is the value produced by the last argument.\nspecialForms.do = (args, scope) => {\nlet value = false;\nfor (let arg of args) {\nvalue = evaluate(arg, scope);\n}\nreturn value;\n};\nTo be able to create bindings and give them new values, we also create a\nform called define. It expects a word as its first argument and an expression\nproducing the value to assign to that word as its second argument.\nSince\ndefine, like everything, is an expression, it must return a value. We\u2019ll make it\nreturn the value that was assigned (just like JavaScript\u2019s = operator).\nspecialForms.define = (args, scope) => {\nif (args.length != 2 || args[0].type != \"word\") {\nthrow new SyntaxError(\"Incorrect use of define\");\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_477",
    "text": "specialForms.define = (args, scope) => {\nif (args.length != 2 || args[0].type != \"word\") {\nthrow new SyntaxError(\"Incorrect use of define\");\n}\nlet value = evaluate(args[1], scope);\nscope[args[0].name] = value;\nreturn value;\n};\nThe environment\nThe scope accepted by evaluate is an object with properties whose names\ncorrespond to binding names and whose values correspond to the values those\nbindings are bound to. Let\u2019s define an object to represent the global scope.\nTo be able to use the if construct we just defined, we must have access to\nBoolean values. Since there are only two Boolean values, we do not need special\nsyntax for them. We simply bind two names to the values true and false and\nuse them.\nconst topScope = Object.create(null);\ntopScope.true = true;\ntopScope.false = false;\n200\nWe can now evaluate a simple expression that negates a Boolean value.\nlet prog = parse(`if(true, false, true)`);\nconsole.log(evaluate(prog, topScope));\n// \u2192false",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_478",
    "text": "topScope.false = false;\n200\nWe can now evaluate a simple expression that negates a Boolean value.\nlet prog = parse(`if(true, false, true)`);\nconsole.log(evaluate(prog, topScope));\n// \u2192false\nTo supply basic arithmetic and comparison operators, we will also add some\nfunction values to the scope. In the interest of keeping the code short, we\u2019ll\nuse Function to synthesize a bunch of operator functions in a loop instead of\ndefining them individually.\nfor (let op of [\"+\", \"-\", \"*\", \"/\", \"==\", \"<\", \">\"]) {\ntopScope[op] = Function(\"a, b\", `return a ${op} b;`);\n}\nIt is also useful to have a way to output values, so we\u2019ll wrap console.log in a\nfunction and call it print.\ntopScope.print = value => {\nconsole.log(value);\nreturn value;\n};\nThat gives us enough elementary tools to write simple programs. The following\nfunction provides a convenient way to parse a program and run it in a fresh\nscope:\nfunction run(program) {\nreturn evaluate(parse(program), Object.create(topScope));\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_479",
    "text": "function provides a convenient way to parse a program and run it in a fresh\nscope:\nfunction run(program) {\nreturn evaluate(parse(program), Object.create(topScope));\n}\nWe\u2019ll use object prototype chains to represent nested scopes so that the program\ncan add bindings to its local scope without changing the top-level scope.\nrun(`\ndo(define(total, 0),\ndefine(count, 1),\nwhile(<(count, 11),\ndo(define(total, +(total, count)),\ndefine(count, +(count, 1)))),\nprint(total))\n`);\n// \u219255\nThis is the program we\u2019ve seen several times before that computes the sum of\nthe numbers 1 to 10, expressed in Egg. It is clearly uglier than the equivalent\nJavaScript program\u2014but not bad for a language implemented in fewer than\n201\n150 lines of code.\nFunctions\nA programming language without functions is a poor programming language\nindeed. Fortunately, it isn\u2019t hard to add a fun construct, which treats its last\nargument as the function\u2019s body and uses all arguments before that as the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_480",
    "text": "indeed. Fortunately, it isn\u2019t hard to add a fun construct, which treats its last\nargument as the function\u2019s body and uses all arguments before that as the\nnames of the function\u2019s parameters.\nspecialForms.fun = (args, scope) => {\nif (!args.length) {\nthrow new SyntaxError(\"Functions need a body\");\n}\nlet body = args[args.length - 1];\nlet params = args.slice(0, args.length - 1).map(expr => {\nif (expr.type != \"word\") {\nthrow new SyntaxError(\"Parameter names must be words\");\n}\nreturn expr.name;\n});\nreturn function(...args) {\nif (args.length != params.length) {\nthrow new TypeError(\"Wrong number of arguments\");\n}\nlet localScope = Object.create(scope);\nfor (let i = 0; i < args.length; i++) {\nlocalScope[params[i]] = args[i];\n}\nreturn evaluate(body, localScope);\n};\n};\nFunctions in Egg get their own local scope. The function produced by the fun\nform creates this local scope and adds the argument bindings to it. It then\nevaluates the function body in this scope and returns the result.\nrun(`",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_481",
    "text": "form creates this local scope and adds the argument bindings to it. It then\nevaluates the function body in this scope and returns the result.\nrun(`\ndo(define(plusOne, fun(a, +(a, 1))),\nprint(plusOne(10)))\n`);\n// \u219211\nrun(`\ndo(define(pow, fun(base, exp,\n202\nif(==(exp, 0),\n1,\n*(base, pow(base, -(exp, 1)))))),\nprint(pow(2, 10)))\n`);\n// \u21921024\nCompilation\nWhat we have built is an interpreter. During evaluation, it acts directly on the\nrepresentation of the program produced by the parser.\nCompilation is the process of adding another step between the parsing and\nthe running of a program, which transforms the program into something that\ncan be evaluated more e\ufb00iciently by doing as much work as possible in advance.\nFor example, in well-designed languages it is obvious, for each use of a binding,\nwhich binding is being referred to, without actually running the program. This\ncan be used to avoid looking up the binding by name every time it is accessed,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_482",
    "text": "which binding is being referred to, without actually running the program. This\ncan be used to avoid looking up the binding by name every time it is accessed,\ninstead directly fetching it from some predetermined memory location.\nTraditionally, compilation involves converting the program to machine code,\nthe raw format that a computer\u2019s processor can execute.\nBut any process\nthat converts a program to a different representation can be thought of as\ncompilation.\nIt would be possible to write an alternative evaluation strategy for Egg,\none that first converts the program to a JavaScript program, uses Function to\ninvoke the JavaScript compiler on it, and runs the result. When done right,\nthis would make Egg run very fast while still being quite simple to implement.\nIf you are interested in this topic and willing to spend some time on it, I\nencourage you to try to implement such a compiler as an exercise.\nCheating\nWhen we defined if and while, you probably noticed that they were more",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_483",
    "text": "encourage you to try to implement such a compiler as an exercise.\nCheating\nWhen we defined if and while, you probably noticed that they were more\nor less trivial wrappers around JavaScript\u2019s own if and while. Similarly, the\nvalues in Egg are just regular old JavaScript values. Bridging the gap to a more\nprimitive system, such as the machine code the processor understands, takes\nmore effort\u2014but the way it works resembles what we are doing here.\nThough the toy language in this chapter doesn\u2019t do anything that couldn\u2019t\nbe done better in JavaScript, there are situations where writing small languages\nhelps get real work done.\n203\nSuch a language does not have to resemble a typical programming language.\nIf JavaScript didn\u2019t come equipped with regular expressions, for example, you\ncould write your own parser and evaluator for regular expressions.\nOr imagine you are building a program that makes it possible to quickly\ncreate parsers by providing a logical description of the language they need",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_484",
    "text": "Or imagine you are building a program that makes it possible to quickly\ncreate parsers by providing a logical description of the language they need\nto parse. You could define a specific notation for that, and a compiler that\ncompiles it to a parser program.\nexpr = number | string | name | application\nnumber = digit+\nname = letter+\nstring = '\"' (! '\"')* '\"'\napplication = expr '(' (expr (',' expr)*)? ')'\nThis is what is usually called a domain-specific language, a language tailored to\nexpress a narrow domain of knowledge. Such a language can be more expressive\nthan a general-purpose language because it is designed to describe exactly the\nthings that need to be described in its domain and nothing else.\nExercises\nArrays\nAdd support for arrays to Egg by adding the following three functions to the\ntop scope: array(...values) to construct an array containing the argument\nvalues, length(array) to get an array\u2019s length, and element(array, n) to fetch\nthe nth element from an array.\nClosure",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_485",
    "text": "top scope: array(...values) to construct an array containing the argument\nvalues, length(array) to get an array\u2019s length, and element(array, n) to fetch\nthe nth element from an array.\nClosure\nThe way we have defined fun allows functions in Egg to reference the surround-\ning scope, allowing the function\u2019s body to use local values that were visible at\nthe time the function was defined, just like JavaScript functions do.\nThe following program illustrates this: function f returns a function that\nadds its argument to f\u2019s argument, meaning that it needs access to the local\nscope inside f to be able to use binding a.\nrun(`\ndo(define(f, fun(a, fun(b, +(a, b)))),\n204\nprint(f(4)(5)))\n`);\n// \u21929\nGo back to the definition of the fun form and explain which mechanism causes\nthis to work.\nComments\nIt would be nice if we could write comments in Egg. For example, whenever\nwe find a hash sign (#), we could treat the rest of the line as a comment and\nignore it, similar to // in JavaScript.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_486",
    "text": "Comments\nIt would be nice if we could write comments in Egg. For example, whenever\nwe find a hash sign (#), we could treat the rest of the line as a comment and\nignore it, similar to // in JavaScript.\nWe do not have to make any big changes to the parser to support this. We\ncan simply change skipSpace to skip comments as if they are whitespace so that\nall the points where skipSpace is called will now also skip comments. Make\nthis change.\nFixing scope\nCurrently, the only way to assign a binding a value is define. This construct\nacts as a way both to define new bindings and to give existing ones a new value.\nThis ambiguity causes a problem. When you try to give a nonlocal binding\na new value, you will end up defining a local one with the same name instead.\nSome languages work like this by design, but I\u2019ve always found it an awkward\nway to handle scope.\nAdd a special form set, similar to define, which gives a binding a new value,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_487",
    "text": "Some languages work like this by design, but I\u2019ve always found it an awkward\nway to handle scope.\nAdd a special form set, similar to define, which gives a binding a new value,\nupdating the binding in an outer scope if it doesn\u2019t already exist in the inner\nscope. If the binding is not defined at all, throw a ReferenceError (another\nstandard error type).\nThe technique of representing scopes as simple objects, which has made\nthings convenient so far, will get in your way a little at this point. You might\nwant to use the Object.getPrototypeOf function, which returns the prototype\nof an object. Also remember that you can use Object.hasOwn to find out if a\ngiven object has a property.\n205\n\u201cThe dream behind the web is of a common information space in\nwhich we communicate by sharing information. Its universality is\nessential: the fact that a hypertext link can point to anything, be it\npersonal, local or global, be it draft or highly polished.\u201d",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_488",
    "text": "which we communicate by sharing information. Its universality is\nessential: the fact that a hypertext link can point to anything, be it\npersonal, local or global, be it draft or highly polished.\u201d\n\u2014Tim Berners-Lee, The World Wide Web: A Very Short Personal\nPistory\nChapter 13\nJavaScript and the Browser\nThe next chapters of this book will discuss web browsers. Without browsers,\nthere would be no JavaScript\u2014or if there were, no one would ever have paid\nany attention to it.\nWeb technology has been decentralized from the start, not just technically\nbut also in terms of the way it evolved. Various browser vendors have added\nnew functionality in ad hoc and sometimes poorly thought-out ways, which\nwere then\u2014sometimes\u2014adopted by others, and finally set down in standards.\nThis is both a blessing and a curse. On the one hand, it is empowering to\nnot have a central party control a system but have it be improved by various",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_489",
    "text": "This is both a blessing and a curse. On the one hand, it is empowering to\nnot have a central party control a system but have it be improved by various\nparties working in loose collaboration (or occasionally, open hostility). On the\nother hand, the haphazard way in which the web was developed means that\nthe resulting system is not exactly a shining example of internal consistency.\nSome parts of it are downright confusing and badly designed.\nNetworks and the Internet\nComputer networks have been around since the 1950s. If you put cables be-\ntween two or more computers and allow them to send data back and forth\nthrough these cables, you can do all kinds of wonderful things.\nIf connecting two machines in the same building allows us to do wonderful\nthings, connecting machines all over the planet should be even better. The\ntechnology to start implementing this vision was developed in the 1980s, and\nthe resulting network is called the internet. It has lived up to its promise.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_490",
    "text": "technology to start implementing this vision was developed in the 1980s, and\nthe resulting network is called the internet. It has lived up to its promise.\nA computer can use this network to shoot bits at another computer. For\nany effective communication to arise out of this bit-shooting, the computers on\nboth ends must know what the bits are supposed to represent. The meaning\nof any given sequence of bits depends entirely on the kind of thing that it is\ntrying to express and on the encoding mechanism used.\nA network protocol describes a style of communication over a network. There\nare protocols for sending email, for fetching email, for sharing files, and even\n206\nfor controlling computers that happen to be infected by malicious software.\nThe HyperText Transfer Protocol (HTTP) is a protocol for retrieving named\nresources (chunks of information, such as web pages or pictures). It specifies\nthat the side making the request should start with a line like this, naming the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_491",
    "text": "resources (chunks of information, such as web pages or pictures). It specifies\nthat the side making the request should start with a line like this, naming the\nresource and the version of the protocol that it is trying to use:\nGET /index.html HTTP/1.1\nThere are many more rules about the way the requester can include more infor-\nmation in the request and the way the other side, which returns the resource,\npackages up its content. We\u2019ll look at HTTP in a little more detail in Chapter\n18.\nMost protocols are built on top of other protocols. HTTP treats the network\nas a streamlike device into which you can put bits and have them arrive at the\ncorrect destination in the correct order. Providing those guarantees on top of\nthe primitive data-sending that the network gives you is already a rather tricky\nproblem.\nThe Transmission Control Protocol (TCP) is a protocol that addresses this\nproblem. All internet-connected devices \u201cspeak\u201d it, and most communication",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_492",
    "text": "problem.\nThe Transmission Control Protocol (TCP) is a protocol that addresses this\nproblem. All internet-connected devices \u201cspeak\u201d it, and most communication\non the internet is built on top of it.\nA TCP connection works as follows: one computer must be waiting, or\nlistening, for other computers to start talking to it. To be able to listen for\ndifferent kinds of communication at the same time on a single machine, each\nlistener has a number (called a port) associated with it. Most protocols specify\nwhich port should be used by default. For example, when we want to send\nan email using the SMTP protocol, the machine through which we send it is\nexpected to be listening on port 25.\nAnother computer can then establish a connection by connecting to the tar-\nget machine using the correct port number.\nIf the target machine can be\nreached and is listening on that port, the connection is successfully created.\nThe listening computer is called the server, and the connecting computer is",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_493",
    "text": "If the target machine can be\nreached and is listening on that port, the connection is successfully created.\nThe listening computer is called the server, and the connecting computer is\ncalled the client.\nSuch a connection acts as a two-way pipe through which bits can flow\u2014the\nmachines on both ends can put data into it. Once the bits are successfully\ntransmitted, they can be read out again by the machine on the other side.\nThis is a convenient model. You could say that TCP provides an abstraction\nof the network.\n207\nThe Web\nThe World Wide Web (not to be confused with the internet as a whole) is a\nset of protocols and formats that allow us to visit web pages in a browser. The\nword Web refers to the fact that such pages can easily link to each other, thus\nconnecting into a huge mesh that users can move through.\nTo become part of the web, all you need to do is connect a machine to the\ninternet and have it listen on port 80 with the HTTP protocol so that other",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_494",
    "text": "To become part of the web, all you need to do is connect a machine to the\ninternet and have it listen on port 80 with the HTTP protocol so that other\ncomputers can ask it for documents.\nEach document on the web is named by a uniform resource locator (URL),\nwhich looks something like this:\nhttp://eloquentjavascript.net/13_browser.html\n|\n|\n|\n|\nprotocol\nserver\npath\nThe first part tells us that this URL uses the HTTP protocol (as opposed to,\nfor example, encrypted HTTP, which would be https://). Then comes the part\nthat identifies which server we are requesting the document from. Last is a\npath string that identifies the document (or resource) we are interested in.\nMachines connected to the internet get an IP address, a number that can be\nused to send messages to that machine, and looks something like 149.210.142.219\nor 2001:4860:4860::8888. Since lists of more or less random numbers are hard\nto remember and awkward to type, you can instead register a domain name",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_495",
    "text": "or 2001:4860:4860::8888. Since lists of more or less random numbers are hard\nto remember and awkward to type, you can instead register a domain name\nfor an address or set of addresses. I registered eloquentjavascript.net to point\nat the IP address of a machine I control and can thus use that domain name\nto serve web pages.\nIf you type this URL into your browser\u2019s address bar, the browser will try\nto retrieve and display the document at that URL. First, your browser has to\nfind out what address eloquentjavascript.net refers to. Then, using the HTTP\nprotocol, it will make a connection to the server at that address and ask for the\nresource /13_browser.html. If all goes well, the server sends back a document,\nwhich your browser then displays on your screen.\nHTML\nHTML, which stands for HyperText Markup Language, is the document format\nused for web pages. An HTML document contains text, as well as tags that\ngive structure to the text, describing things such as links, paragraphs, and",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_496",
    "text": "used for web pages. An HTML document contains text, as well as tags that\ngive structure to the text, describing things such as links, paragraphs, and\nheadings.\nA short HTML document might look like this:\n208\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>My home page</title>\n</head>\n<body>\n<h1>My home page</h1>\n<p>Hello, I am Marijn and this is my home page.</p>\n<p>I also wrote a book! Read it\n<a href=\"http://eloquentjavascript.net\">here</a>.</p>\n</body>\n</html>\nThis is what such a document would look like in the browser:\nThe tags, wrapped in angle brackets (< and >, the symbols for less than and\ngreater than), provide information about the structure of the document. The\nother text is just plain text.\nThe document starts with <!doctype html>, which tells the browser to in-\nterpret the page as modern HTML, as opposed to obsolete styles used in the\npast.\nHTML documents have a head and a body. The head contains information",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_497",
    "text": "terpret the page as modern HTML, as opposed to obsolete styles used in the\npast.\nHTML documents have a head and a body. The head contains information\nabout the document, and the body contains the document itself. In this case,\nthe head declares that the title of this document is \u201cMy home page\u201d and that it\nuses the UTF-8 encoding, which is a way to encode Unicode text as binary data.\nThe document\u2019s body contains a heading (<h1>, meaning \u201cheading 1\u201d\u2014<h2> to\n<h6> produce subheadings) and two paragraphs (<p>).\nTags come in several forms. An element, such as the body, a paragraph, or a\nlink, is started by an opening tag like <p> and ended by a closing tag like </p>.\nSome opening tags, such as the one for the link (<a>), contain extra information\nin the form of name=\"value\" pairs. These are called attributes. In this case,\nthe destination of the link is indicated with href=\"http://eloquentjavascript\n.net\", where href stands for \u201chypertext reference\u201d.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_498",
    "text": "the destination of the link is indicated with href=\"http://eloquentjavascript\n.net\", where href stands for \u201chypertext reference\u201d.\nSome kinds of tags do not enclose anything and thus do not need to be closed.\nThe metadata tag <meta charset=\"utf-8\"> is an example of this.\nTo be able to include angle brackets in the text of a document even though\n209\nthey have a special meaning in HTML, yet another form of special notation\nhas to be introduced. A plain opening angle bracket is written as &lt; (\u201cless\nthan\u201d), and a closing bracket is written as &gt; (\u201cgreater than\u201d). In HTML, an\nampersand (&) character followed by a name or character code and a semicolon\n(;) is called an entity and will be replaced by the character it encodes.\nThis is analogous to the way backslashes are used in JavaScript strings. Since\nthis mechanism gives ampersand characters a special meaning too, they need\nto be escaped as &amp;. Inside attribute values, which are wrapped in double",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_499",
    "text": "this mechanism gives ampersand characters a special meaning too, they need\nto be escaped as &amp;. Inside attribute values, which are wrapped in double\nquotes, &quot; can be used to insert a literal quote character.\nHTML is parsed in a remarkably error-tolerant way. When tags that should\nbe there are missing, the browser automatically adds them. The way this is\ndone has been standardized, and you can rely on all modern browsers to do it\nin the same way.\nThe following document will be treated just like the one shown previously:\n<!doctype html>\n<meta charset=utf-8>\n<title>My home page</title>\n<h1>My home page</h1>\n<p>Hello, I am Marijn and this is my home page.\n<p>I also wrote a book! Read it\n<a href=http://eloquentjavascript.net>here</a>.\nThe <html>, <head>, and <body> tags are completely gone. The browser knows\nthat <meta> and <title> belong in the head and that <h1> means the body has\nstarted. Furthermore, I am no longer explicitly closing the paragraphs, since",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_500",
    "text": "that <meta> and <title> belong in the head and that <h1> means the body has\nstarted. Furthermore, I am no longer explicitly closing the paragraphs, since\nopening a new paragraph or ending the document will close them implicitly.\nThe quotes around the attribute values are also gone.\nThis book will usually omit the <html>, <head>, and <body> tags from exam-\nples to keep them short and free of clutter. I will close tags and include quotes\naround attributes, though.\nI will also usually omit the doctype and charset declaration. Don\u2019t take\nthis as encouragement to drop these from HTML documents. Browsers will\noften do ridiculous things when you forget them. Consider the doctype and\nthe charset metadata to be implicitly present in examples, even when they are\nnot actually shown in the text.\n210\nHTML and JavaScript\nIn the context of this book, the most important HTML tag is <script>, which\nallows us to include a piece of JavaScript in a document.\n<h1>Testing alert</h1>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_501",
    "text": "210\nHTML and JavaScript\nIn the context of this book, the most important HTML tag is <script>, which\nallows us to include a piece of JavaScript in a document.\n<h1>Testing alert</h1>\n<script>alert(\"hello!\");</script>\nSuch a script will run as soon as its <script> tag is encountered while the\nbrowser reads the HTML. This page will pop up a dialog when opened\u2014the\nalert function resembles prompt, in that it pops up a little window, but only\nshows a message without asking for input.\nIncluding large programs directly in HTML documents is often impractical.\nThe <script> tag can be given an src attribute to fetch a script file (a text file\ncontaining a JavaScript program) from a URL.\n<h1>Testing alert</h1>\n<script src=\"code/hello.js\"></script>\nThe code/hello.js file included here contains the same program\u2014alert(\"hello\n!\"). When an HTML page references other URLs as part of itself, such as an\nimage file or a script, web browsers will retrieve them immediately and include\nthem in the page.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_502",
    "text": "!\"). When an HTML page references other URLs as part of itself, such as an\nimage file or a script, web browsers will retrieve them immediately and include\nthem in the page.\nA script tag must always be closed with </script>, even if it refers to a\nscript file and doesn\u2019t contain any code. If you forget this, the rest of the page\nwill be interpreted as part of the script.\nYou can load ES modules (see Chapter 10) in the browser by giving your\nscript tag a type=\"module\" attribute. Such modules can depend on other mod-\nules by using URLs relative to themselves as module names in import declara-\ntions.\nSome attributes can also contain a JavaScript program. The <button> tag\n(which shows up as a button) supports an onclick attribute. The attribute\u2019s\nvalue will be run whenever the button is clicked.\n<button onclick=\"alert('Boom!');\">DO NOT PRESS</button>\nNote that I had to use single quotes for the string in the onclick attribute",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_503",
    "text": "value will be run whenever the button is clicked.\n<button onclick=\"alert('Boom!');\">DO NOT PRESS</button>\nNote that I had to use single quotes for the string in the onclick attribute\nbecause double quotes are already used to quote the whole attribute. I could\nalso have used &quot; to escape the inner quotes.\n211\nIn the sandbox\nRunning programs downloaded from the internet is potentially dangerous. You\ndon\u2019t know much about the people behind most sites you visit, and they do not\nnecessarily mean well. Running programs by malicious actors is how you get\nyour computer infected by viruses, your data stolen, and your accounts hacked.\nYet the attraction of the web is that you can browse it without necessarily\ntrusting all the pages you visit. This is why browsers severely limit the things\na JavaScript program may do: it can\u2019t look at the files on your computer or\nmodify anything not related to the web page it was embedded in.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_504",
    "text": "a JavaScript program may do: it can\u2019t look at the files on your computer or\nmodify anything not related to the web page it was embedded in.\nIsolating a programming environment in this way is called sandboxing, the\nidea being that the program is harmlessly playing in a sandbox. But you should\nimagine this particular kind of sandbox as having a cage of thick steel bars over\nit so that the programs playing in it can\u2019t actually get out.\nThe hard part of sandboxing is allowing programs enough room to be useful\nwhile restricting them from doing anything dangerous. Lots of useful func-\ntionality, such as communicating with other servers or reading the content of\nthe copy-paste clipboard, can also be used for problematic, privacy-invading\npurposes.\nEvery now and then, someone comes up with a new way to circumvent the\nlimitations of a browser and do something harmful, ranging from leaking minor\nprivate information to taking over the whole machine on which the browser is",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_505",
    "text": "limitations of a browser and do something harmful, ranging from leaking minor\nprivate information to taking over the whole machine on which the browser is\nrunning. The browser developers respond by fixing the hole, and all is well\nagain\u2014until the next problem is discovered, and hopefully publicized rather\nthan secretly exploited by some government agency or criminal organization.\nCompatibility and the browser wars\nIn the early stages of the web, a browser called Mosaic dominated the mar-\nket. After a few years, the balance shifted to Netscape, which was, in turn,\nlargely supplanted by Microsoft\u2019s Internet Explorer.\nAt any point where a\nsingle browser was dominant, that browser\u2019s vendor would feel entitled to uni-\nlaterally invent new features for the web. Since most users used the most pop-\nular browser, websites would simply start using those features\u2014never mind the\nother browsers.\nThis was the dark age of compatibility, often called the browser wars. Web",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_506",
    "text": "ular browser, websites would simply start using those features\u2014never mind the\nother browsers.\nThis was the dark age of compatibility, often called the browser wars. Web\ndevelopers were left with not one unified web but two or three incompatible\nplatforms. To make things worse, the browsers in use around 2003 were all full\nof bugs, and of course the bugs were different for each browser. Life was hard\n212\nfor people writing web pages.\nMozilla Firefox, a not-for-profit offshoot of Netscape, challenged Internet\nExplorer\u2019s position in the late 2000s. Because Microsoft was not particularly\ninterested in staying competitive at the time, Firefox took a lot of market share\naway from it. Around the same time, Google introduced its Chrome browser\nand Apple\u2019s Safari browser gained popularity, leading to a situation where there\nwere four major players, rather than one.\nThe new players had a more serious attitude toward standards and better",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_507",
    "text": "and Apple\u2019s Safari browser gained popularity, leading to a situation where there\nwere four major players, rather than one.\nThe new players had a more serious attitude toward standards and better\nengineering practices, giving us less incompatibility and fewer bugs. Microsoft,\nseeing its market share crumble, came around and adopted these attitudes in\nits Edge browser, which replaced Internet Explorer. If you are starting to learn\nweb development today, consider yourself lucky.\nThe latest versions of the\nmajor browsers behave quite uniformly and have relatively few bugs.\nUnfortunately, with Firefox\u2019s market share getting ever smaller, and Edge\nbecoming just a wrapper around Chrome\u2019s core in 2018, this uniformity might\nonce again take the form of a single vendor\u2014Google, this time\u2014having enough\ncontrol over the browser market to push its idea of what the web should look\nlike onto the rest of the world.\nFor what it is worth, this long chain of historical events and accidents has",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_508",
    "text": "control over the browser market to push its idea of what the web should look\nlike onto the rest of the world.\nFor what it is worth, this long chain of historical events and accidents has\nproduced the web platform that we have today. In the next chapters, we are\ngoing to write programs for it.\n213\n\u201cToo bad! Same old story! Once you\u2019ve finished building your house\nyou notice you\u2019ve accidentally learned something that you really\nshould have known\u2014before you started.\u201d\n\u2014Friedrich Nietzsche, Beyond Good and Evil\nChapter 14\nThe Document Object Model\nWhen you open a web page, your browser retrieves the page\u2019s HTML text and\nparses it, much like our parser from Chapter 12 parsed programs. The browser\nbuilds up a model of the document\u2019s structure and uses this model to draw the\npage on the screen.\nThis representation of the document is one of the toys that a JavaScript\nprogram has available in its sandbox. It is a data structure that you can read",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_509",
    "text": "page on the screen.\nThis representation of the document is one of the toys that a JavaScript\nprogram has available in its sandbox. It is a data structure that you can read\nor modify. It acts as a live data structure: when it\u2019s modified, the page on the\nscreen is updated to reflect the changes.\nDocument structure\nYou can imagine an HTML document as a nested set of boxes. Tags such as\n<body> and </body> enclose other tags, which in turn contain other tags or\ntext. Here\u2019s the example document from the previous chapter:\n<!doctype html>\n<html>\n<head>\n<title>My home page</title>\n</head>\n<body>\n<h1>My home page</h1>\n<p>Hello, I am Marijn and this is my home page.</p>\n<p>I also wrote a book! Read it\n<a href=\"http://eloquentjavascript.net\">here</a>.</p>\n</body>\n</html>\nThis page has the following structure:\n214\nhere\na\n.\nI also wrote a book! Read it\np\nHello, I am Marijn and this is...\np\nMy home page\nh1\nbody\nMy home page\ntitle\nhead\nhtml",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_510",
    "text": "</body>\n</html>\nThis page has the following structure:\n214\nhere\na\n.\nI also wrote a book! Read it\np\nHello, I am Marijn and this is...\np\nMy home page\nh1\nbody\nMy home page\ntitle\nhead\nhtml\nThe data structure the browser uses to represent the document follows this\nshape. For each box, there is an object, which we can interact with to find\nout things such as what HTML tag it represents and which boxes and text it\ncontains. This representation is called the Document Object Model, or DOM\nfor short.\nThe global binding document gives us access to these objects. Its documentElement\nproperty refers to the object representing the <html> tag. Since every HTML\ndocument has a head and a body, it also has head and body properties pointing\nat those elements.\nTrees\nThink back to the syntax trees from Chapter 12 for a moment. Their structures\nare strikingly similar to the structure of a browser\u2019s document. Each node may\nrefer to other nodes, children, which in turn may have their own children. This",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_511",
    "text": "are strikingly similar to the structure of a browser\u2019s document. Each node may\nrefer to other nodes, children, which in turn may have their own children. This\nshape is typical of nested structures, where elements can contain subelements\nthat are similar to themselves.\nWe call a data structure a tree when it has a branching structure, no cycles\n(a node may not contain itself, directly or indirectly), and a single, well-defined\nroot. In the case of the DOM, document.documentElement serves as the root.\nTrees come up a lot in computer science. In addition to representing recur-\nsive structures such as HTML documents or programs, they are often used to\nmaintain sorted sets of data because elements can usually be found or inserted\nmore e\ufb00iciently in a tree than in a flat array.\n215\nA typical tree has different kinds of nodes. The syntax tree for the Egg\nlanguage had identifiers, values, and application nodes.\nApplication nodes",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_512",
    "text": "more e\ufb00iciently in a tree than in a flat array.\n215\nA typical tree has different kinds of nodes. The syntax tree for the Egg\nlanguage had identifiers, values, and application nodes.\nApplication nodes\nmay have children, whereas identifiers and values are leaves, or nodes without\nchildren.\nThe same goes for the DOM. Nodes for elements, which represent HTML\ntags, determine the structure of the document. These can have child nodes.\nAn example of such a node is document.body. Some of these children can be\nleaf nodes, such as pieces of text or comment nodes.\nEach DOM node object has a nodeType property, which contains a code\n(number) that identifies the type of node. Elements have code 1, which is also\ndefined as the constant property Node.ELEMENT_NODE. Text nodes, representing\na section of text in the document, get code 3 (Node.TEXT_NODE). Comments\nhave code 8 (Node.COMMENT_NODE).\nAnother way to visualize our document tree is as follows:\nhtml\nhead\ntitle\nMy home page\nbody\nh1\nMy home page\np",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_513",
    "text": "have code 8 (Node.COMMENT_NODE).\nAnother way to visualize our document tree is as follows:\nhtml\nhead\ntitle\nMy home page\nbody\nh1\nMy home page\np\nHello! I am...\np\nI also wrote...\nhere\na\n.\nThe leaves are text nodes, and the arrows indicate parent-child relationships\nbetween nodes.\nThe standard\nUsing cryptic numeric codes to represent node types is not a very JavaScript-\nlike thing to do. Later in this chapter, we\u2019ll see that other parts of the DOM\ninterface also feel cumbersome and alien. This is because the DOM interface\nwasn\u2019t designed for JavaScript alone. Rather, it tries to be a language-neutral\ninterface that can be used in other systems as well\u2014not just for HTML but\nalso for XML, which is a generic data format with an HTML-like syntax.\nThis is unfortunate. Standards are often useful. But in this case, the advan-\ntage (cross-language consistency) isn\u2019t all that compelling. Having an interface\nthat is properly integrated with the language you\u2019re using will save you more",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_514",
    "text": "tage (cross-language consistency) isn\u2019t all that compelling. Having an interface\nthat is properly integrated with the language you\u2019re using will save you more\ntime than having a familiar interface across languages.\n216\nAs an example of this poor integration, consider the childNodes property\nthat element nodes in the DOM have. This property holds an array-like object\nwith a length property and properties labeled by numbers to access the child\nnodes. But it is an instance of the NodeList type, not a real array, so it does\nnot have methods such as slice and map.\nThen there are issues that are simply caused by poor design. For exam-\nple, there is no way to create a new node and immediately add children or\nattributes to it. Instead, you have to first create it and then add the children\nand attributes one by one, using side effects. Code that interacts heavily with\nthe DOM tends to get long, repetitive, and ugly.\nBut these flaws aren\u2019t fatal. Since JavaScript allows us to create our own",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_515",
    "text": "the DOM tends to get long, repetitive, and ugly.\nBut these flaws aren\u2019t fatal. Since JavaScript allows us to create our own\nabstractions, it is possible to design improved ways to express the operations\nwe are performing. Many libraries intended for browser programming come\nwith such tools.\nMoving through the tree\nDOM nodes contain a wealth of links to other nearby nodes. The following\ndiagram illustrates these:\nI also wrote a book! ...\np\nHello, I am Marijn...\np\nMy home page\nh1\nbody\n0\n1\n2\nchildNodes\nfirstChild\nlastChild\npreviousSibling\nnextSibling\nparentNode\nAlthough the diagram shows only one link of each type, every node has a\nparentNode property that points to the node it is part of, if any. Likewise,\nevery element node (node type 1) has a childNodes property that points to an\narray-like object holding its children.\nIn theory, you could move anywhere in the tree using just these parent and\nchild links. But JavaScript also gives you access to a number of additional",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_516",
    "text": "array-like object holding its children.\nIn theory, you could move anywhere in the tree using just these parent and\nchild links. But JavaScript also gives you access to a number of additional\nconvenience links. The firstChild and lastChild properties point to the first\nand last child elements or have the value null for nodes without children.\nSimilarly, previousSibling and nextSibling point to adjacent nodes, which\n217\nare nodes with the same parent that appear immediately before or after the\nnode itself. For a first child, previousSibling will be null, and for a last child,\nnextSibling will be null.\nThere\u2019s also the children property, which is like childNodes but contains\nonly element (type 1) children, not other types of child nodes. This can be\nuseful when you aren\u2019t interested in text nodes.\nWhen dealing with a nested data structure like this one, recursive functions\nare often useful. The following function scans a document for text nodes con-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_517",
    "text": "When dealing with a nested data structure like this one, recursive functions\nare often useful. The following function scans a document for text nodes con-\ntaining a given string and returns true when it has found one:\nfunction talksAbout(node, string) {\nif (node.nodeType == Node.ELEMENT_NODE) {\nfor (let child of node.childNodes) {\nif (talksAbout(child, string)) {\nreturn true;\n}\n}\nreturn false;\n} else if (node.nodeType == Node.TEXT_NODE) {\nreturn node.nodeValue.indexOf(string) > -1;\n}\n}\nconsole.log(talksAbout(document.body, \"book\"));\n// \u2192true\nThe nodeValue property of a text node holds the string of text that it represents.\nFinding elements\nNavigating these links among parents, children, and siblings is often useful.\nBut if we want to find a specific node in the document, reaching it by start-\ning at document.body and following a fixed path of properties is a bad idea.\nDoing so bakes assumptions into our program about the precise structure of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_518",
    "text": "ing at document.body and following a fixed path of properties is a bad idea.\nDoing so bakes assumptions into our program about the precise structure of\nthe document\u2014a structure you might want to change later. Another compli-\ncating factor is that text nodes are created even for the whitespace between\nnodes. The example document\u2019s <body> tag has not just three children (<h1>\nand two <p> elements), but seven: those three, plus the spaces before, after,\nand between them.\nIf we want to get the href attribute of the link in that document, we don\u2019t\nwant to say something like \u201cGet the second child of the sixth child of the\ndocument body\u201d.\nIt\u2019d be better if we could say \u201cGet the first link in the\n218\ndocument\u201d. And we can.\nlet link = document.body.getElementsByTagName(\"a\")[0];\nconsole.log(link.href);\nAll element nodes have a getElementsByTagName method, which collects all ele-\nments with the given tag name that are descendants (direct or indirect children)",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_519",
    "text": "console.log(link.href);\nAll element nodes have a getElementsByTagName method, which collects all ele-\nments with the given tag name that are descendants (direct or indirect children)\nof that node and returns them as an array-like object.\nTo find a specific single node, you can give it an id attribute and use document\n.getElementById instead.\n<p>My ostrich Gertrude:</p>\n<p><img id=\"gertrude\" src=\"img/ostrich.png\"></p>\n<script>\nlet ostrich = document.getElementById(\"gertrude\");\nconsole.log(ostrich.src);\n</script>\nA third, similar method is getElementsByClassName, which, like getElementsByTagName\n, searches through the contents of an element node and retrieves all elements\nthat have the given string in their class attribute.\nChanging the document\nAlmost everything about the DOM data structure can be changed. The shape\nof the document tree can be modified by changing parent-child relationships.\nNodes have a remove method to remove them from their current parent node.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_520",
    "text": "of the document tree can be modified by changing parent-child relationships.\nNodes have a remove method to remove them from their current parent node.\nTo add a child node to an element node, we can use appendChild, which puts\nit at the end of the list of children, or insertBefore, which inserts the node\ngiven as the first argument before the node given as the second argument.\n<p>One</p>\n<p>Two</p>\n<p>Three</p>\n<script>\nlet paragraphs = document.body.getElementsByTagName(\"p\");\ndocument.body.insertBefore(paragraphs[2], paragraphs[0]);\n</script>\nA node can exist in the document in only one place. Thus, inserting para-\ngraph Three in front of paragraph One will first remove it from the end of the\ndocument and then insert it at the front, resulting in Three/One/Two. All\n219\noperations that insert a node somewhere will, as a side effect, cause it to be\nremoved from its current position (if it has one).\nThe replaceChild method is used to replace a child node with another one.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_521",
    "text": "removed from its current position (if it has one).\nThe replaceChild method is used to replace a child node with another one.\nIt takes as arguments two nodes: a new node and the node to be replaced. The\nreplaced node must be a child of the element the method is called on. Note\nthat both replaceChild and insertBefore expect the new node as their first\nargument.\nCreating nodes\nSay we want to write a script that replaces all images (<img> tags) in the doc-\nument with the text held in their alt attributes, which specifies an alternative\ntextual representation of the image. This involves not only removing the images\nbut also adding a new text node to replace them.\n<p>The <img src=\"img/cat.png\" alt=\"Cat\"> in the\n<img src=\"img/hat.png\" alt=\"Hat\">.</p>\n<p><button onclick=\"replaceImages()\">Replace</button></p>\n<script>\nfunction replaceImages() {\nlet images = document.body.getElementsByTagName(\"img\");\nfor (let i = images.length - 1; i >= 0; i--) {\nlet image = images[i];\nif (image.alt) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_522",
    "text": "<script>\nfunction replaceImages() {\nlet images = document.body.getElementsByTagName(\"img\");\nfor (let i = images.length - 1; i >= 0; i--) {\nlet image = images[i];\nif (image.alt) {\nlet text = document.createTextNode(image.alt);\nimage.parentNode.replaceChild(text, image);\n}\n}\n}\n</script>\nGiven a string, createTextNode gives us a text node that we can insert into the\ndocument to make it show up on the screen.\nThe loop that goes over the images starts at the end of the list. This is nec-\nessary because the node list returned by a method like getElementsByTagName\n(or a property like childNodes) is live. That is, it is updated as the document\nchanges. If we started from the front, removing the first image would cause the\nlist to lose its first element so that the second time the loop repeats, where i\nis 1, it would stop because the length of the collection is now also 1.\nIf you want a solid collection of nodes, as opposed to a live one, you can\n220",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_523",
    "text": "is 1, it would stop because the length of the collection is now also 1.\nIf you want a solid collection of nodes, as opposed to a live one, you can\n220\nconvert the collection to a real array by calling Array.from.\nlet arrayish = {0: \"one\", 1: \"two\", length: 2};\nlet array = Array.from(arrayish);\nconsole.log(array.map(s => s.toUpperCase()));\n// \u2192[\"ONE\", \"TWO\"]\nTo create element nodes, you can use the document.createElement method.\nThis method takes a tag name and returns a new empty node of the given\ntype.\nThe following example defines a utility elt, which creates an element node\nand treats the rest of its arguments as children to that node. This function is\nthen used to add an attribution to a quote.\n<blockquote id=\"quote\">\nNo book can ever be finished. While working on it we learn\njust enough to find it immature the moment we turn away\nfrom it.\n</blockquote>\n<script>\nfunction elt(type, ...children) {\nlet node = document.createElement(type);\nfor (let child of children) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_524",
    "text": "just enough to find it immature the moment we turn away\nfrom it.\n</blockquote>\n<script>\nfunction elt(type, ...children) {\nlet node = document.createElement(type);\nfor (let child of children) {\nif (typeof child != \"string\") node.appendChild(child);\nelse node.appendChild(document.createTextNode(child));\n}\nreturn node;\n}\ndocument.getElementById(\"quote\").appendChild(\nelt(\"footer\", \"\u2014\",\nelt(\"strong\", \"Karl Popper\"),\n\", preface to the second edition of \",\nelt(\"em\", \"The Open Society and Its Enemies\"),\n\", 1950\"));\n</script>\nThis is what the resulting document looks like:\n221\nAttributes\nSome element attributes, such as href for links, can be accessed through a\nproperty of the same name on the element\u2019s DOM object. This is the case for\nmost commonly used standard attributes.\nHTML allows you to set any attribute you want on nodes.\nThis can be\nuseful because it allows you to store extra information in a document. To read",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_525",
    "text": "most commonly used standard attributes.\nHTML allows you to set any attribute you want on nodes.\nThis can be\nuseful because it allows you to store extra information in a document. To read\nor change custom attributes, which aren\u2019t available as regular object properties,\nyou have to use the getAttribute and setAttribute methods.\n<p data-classified=\"secret\">The launch code is 00000000.</p>\n<p data-classified=\"unclassified\">I have two feet.</p>\n<script>\nlet paras = document.body.getElementsByTagName(\"p\");\nfor (let para of Array.from(paras)) {\nif (para.getAttribute(\"data-classified\") == \"secret\") {\npara.remove();\n}\n}\n</script>\nIt is recommended to prefix the names of such made-up attributes with data-\nto ensure they do not conflict with any other attributes.\nThere is a commonly used attribute, class, which is a keyword in the\nJavaScript language. For historical reasons\u2014some old JavaScript implementa-\ntions could not handle property names that matched keywords\u2014the property",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_526",
    "text": "JavaScript language. For historical reasons\u2014some old JavaScript implementa-\ntions could not handle property names that matched keywords\u2014the property\nused to access this attribute is called className. You can also access it under\nits real name, \"class\", with the getAttribute and setAttribute methods.\nLayout\nYou may have noticed that different types of elements are laid out differently.\nSome, such as paragraphs (<p>) or headings (<h1>), take up the whole width\nof the document and are rendered on separate lines. These are called block\nelements. Others, such as links (<a>) or the <strong> element, are rendered\non the same line with their surrounding text. Such elements are called inline\nelements.\nFor any given document, browsers are able to compute a layout, which gives\neach element a size and position based on its type and content. This layout is\nthen used to actually draw the document.\nThe size and position of an element can be accessed from JavaScript. The\n222",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_527",
    "text": "each element a size and position based on its type and content. This layout is\nthen used to actually draw the document.\nThe size and position of an element can be accessed from JavaScript. The\n222\noffsetWidth and offsetHeight properties give you the space the element takes\nup in pixels.\nA pixel is the basic unit of measurement in the browser.\nIt\ntraditionally corresponds to the smallest dot that the screen can draw, but on\nmodern displays, which can draw very small dots, that may no longer be the\ncase, and a browser pixel may span multiple display dots.\nSimilarly, clientWidth and clientHeight give you the size of the space inside\nthe element, ignoring border width.\n<p style=\"border: 3px solid red\">\nI'm boxed in\n</p>\n<script>\nlet para = document.body.getElementsByTagName(\"p\")[0];\nconsole.log(\"clientHeight:\", para.clientHeight);\n// \u219219\nconsole.log(\"offsetHeight:\", para.offsetHeight);\n// \u219225\n</script>\nGiving a paragraph a border causes a rectangle to be drawn around it.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_528",
    "text": "console.log(\"clientHeight:\", para.clientHeight);\n// \u219219\nconsole.log(\"offsetHeight:\", para.offsetHeight);\n// \u219225\n</script>\nGiving a paragraph a border causes a rectangle to be drawn around it.\nThe most effective way to find the precise position of an element on the\nscreen is the getBoundingClientRect method. It returns an object with top,\nbottom, left, and right properties, indicating the pixel positions of the sides of\nthe element relative to the upper left of the screen. If you want pixel positions\nrelative to the whole document, you must add the current scroll position, which\nyou can find in the pageXOffset and pageYOffset bindings.\nLaying out a document can be quite a lot of work. In the interest of speed,\nbrowser engines do not immediately re-layout a document every time you\nchange it but wait as long as they can before doing so. When a JavaScript\nprogram that changed the document finishes running, the browser will have to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_529",
    "text": "change it but wait as long as they can before doing so. When a JavaScript\nprogram that changed the document finishes running, the browser will have to\ncompute a new layout to draw the changed document to the screen. When a\nprogram asks for the position or size of something by reading properties such\nas offsetHeight or calling getBoundingClientRect, providing that information\nalso requires computing a layout.\nA program that repeatedly alternates between reading DOM layout infor-\nmation and changing the DOM forces a lot of layout computations to happen\nand will consequently run very slowly. The following code is an example of\nthis. It contains two different programs that build up a line of X characters\n2,000 pixels wide and measures the time each one takes.\n223\n<p><span id=\"one\"></span></p>\n<p><span id=\"two\"></span></p>\n<script>\nfunction time(name, action) {\nlet start = Date.now(); // Current time in milliseconds\naction();\nconsole.log(name, \"took\", Date.now() - start, \"ms\");\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_530",
    "text": "<p><span id=\"two\"></span></p>\n<script>\nfunction time(name, action) {\nlet start = Date.now(); // Current time in milliseconds\naction();\nconsole.log(name, \"took\", Date.now() - start, \"ms\");\n}\ntime(\"naive\", () => {\nlet target = document.getElementById(\"one\");\nwhile (target.offsetWidth < 2000) {\ntarget.appendChild(document.createTextNode(\"X\"));\n}\n});\n// \u2192naive took 32 ms\ntime(\"clever\", function() {\nlet target = document.getElementById(\"two\");\ntarget.appendChild(document.createTextNode(\"XXXXX\"));\nlet total = Math.ceil(2000 / (target.offsetWidth / 5));\ntarget.firstChild.nodeValue = \"X\".repeat(total);\n});\n// \u2192clever took 1 ms\n</script>\nStyling\nWe have seen that different HTML elements are drawn differently. Some are\ndisplayed as blocks, others inline. Some add styling\u2014<strong> makes its con-\ntent bold, and <a> makes it blue and underlines it.\nThe way an <img> tag shows an image or an <a> tag causes a link to be fol-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_531",
    "text": "tent bold, and <a> makes it blue and underlines it.\nThe way an <img> tag shows an image or an <a> tag causes a link to be fol-\nlowed when it is clicked is strongly tied to the element type. But we can change\nthe styling associated with an element, such as the text color or underline. Here\nis an example that uses the style property:\n<p><a href=\".\">Normal link</a></p>\n<p><a href=\".\" style=\"color: green\">Green link</a></p>\nThe second link will be green instead of the default link color:\n224\nA style attribute may contain one or more declarations, which are a property\n(such as color) followed by a colon and a value (such as green). When there\nis more than one declaration, they must be separated by semicolons, as in\n\"color: red; border: none\".\nA lot of aspects of the document can be influenced by styling. For example,\nthe display property controls whether an element is displayed as a block or an\ninline element.\nThis text is displayed <strong>inline</strong>,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_532",
    "text": "the display property controls whether an element is displayed as a block or an\ninline element.\nThis text is displayed <strong>inline</strong>,\n<strong style=\"display: block\">as a block</strong>, and\n<strong style=\"display: none\">not at all</strong>.\nThe block tag will end up on its own line, since block elements are not displayed\ninline with the text around them. The last tag is not displayed at all\u2014display\n: none prevents an element from showing up on the screen.\nThis is a way\nto hide elements. It is often preferable to removing them from the document\nentirely because it makes it easy to reveal them again later.\nJavaScript code can directly manipulate the style of an element through the\nelement\u2019s style property. This property holds an object that has properties for\nall possible style properties. The values of these properties are strings, which\nwe can write to in order to change a particular aspect of the element\u2019s style.\n<p id=\"para\" style=\"color: purple\">\nNice text\n</p>\n<script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_533",
    "text": "we can write to in order to change a particular aspect of the element\u2019s style.\n<p id=\"para\" style=\"color: purple\">\nNice text\n</p>\n<script>\nlet para = document.getElementById(\"para\");\nconsole.log(para.style.color);\npara.style.color = \"magenta\";\n</script>\nSome style property names contain hyphens, such as font-family. Because\nsuch property names are awkward to work with in JavaScript (you\u2019d have to\nsay style[\"font-family\"]), the property names in the style object for such\nproperties have their hyphens removed and the letters after them capitalized\n225\n(style.fontFamily).\nCascading styles\nThe styling system for HTML is called CSS, for Cascading Style Sheets. A style\nsheet is a set of rules for how to style elements in a document. It can be given\ninside a <style> tag.\n<style>\nstrong {\nfont-style: italic;\ncolor: gray;\n}\n</style>\n<p>Now <strong>strong text</strong> is italic and gray.</p>\nThe cascading in the name refers to the fact that multiple such rules are com-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_534",
    "text": "<style>\nstrong {\nfont-style: italic;\ncolor: gray;\n}\n</style>\n<p>Now <strong>strong text</strong> is italic and gray.</p>\nThe cascading in the name refers to the fact that multiple such rules are com-\nbined to produce the final style for an element. In the example, the default\nstyling for <strong> tags, which gives them font-weight: bold, is overlaid by\nthe rule in the <style> tag, which adds font-style and color.\nWhen multiple rules define a value for the same property, the most recently\nread rule gets a higher precedence and wins. For example, if the rule in the\n<style> tag included font-weight: normal, contradicting the default font-\nweight rule, the text would be normal, not bold. Styles in a style attribute\napplied directly to the node have the highest precedence and always win.\nIt is possible to target things other than tag names in CSS rules. A rule for\n.abc applies to all elements with \"abc\" in their class attribute. A rule for #xyz",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_535",
    "text": "It is possible to target things other than tag names in CSS rules. A rule for\n.abc applies to all elements with \"abc\" in their class attribute. A rule for #xyz\napplies to the element with an id attribute of \"xyz\" (which should be unique\nwithin the document).\n.subtle {\ncolor: gray;\nfont-size: 80%;\n}\n#header {\nbackground: blue;\ncolor: white;\n}\n/* p elements with id main and with classes a and b */\np#main.a.b {\nmargin-bottom: 20px;\n}\n226\nThe precedence rule favoring the most recently defined rule applies only when\nthe rules have the same specificity. A rule\u2019s specificity is a measure of how\nprecisely it describes matching elements, determined by the number and kind\n(tag, class, or ID) of element aspects it requires. For example, a rule that\ntargets p.a is more specific than rules that target p or just .a and would thus\ntake precedence over them.\nThe notation p > a \u2026{} applies the given styles to all <a> tags that are direct",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_536",
    "text": "targets p.a is more specific than rules that target p or just .a and would thus\ntake precedence over them.\nThe notation p > a \u2026{} applies the given styles to all <a> tags that are direct\nchildren of <p> tags. Similarly, p a \u2026{} applies to all <a> tags inside <p> tags,\nwhether they are direct or indirect children.\nQuery selectors\nWe won\u2019t be using style sheets very much in this book. Understanding them is\nhelpful when programming in the browser, but they are complicated enough to\nwarrant a separate book. The main reason I introduced selector syntax\u2014the\nnotation used in style sheets to determine which elements a set of styles apply\nto\u2014is that we can use this same mini-language as an effective way to find DOM\nelements.\nThe querySelectorAll method, which is defined both on the document object\nand on element nodes, takes a selector string and returns a NodeList containing\nall the elements that it matches.\n<p>And if you go chasing\n<span class=\"animal\">rabbits</span></p>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_537",
    "text": "and on element nodes, takes a selector string and returns a NodeList containing\nall the elements that it matches.\n<p>And if you go chasing\n<span class=\"animal\">rabbits</span></p>\n<p>And you know you're going to fall</p>\n<p>Tell 'em a <span class=\"character\">hookah smoking\n<span class=\"animal\">caterpillar</span></span></p>\n<p>Has given you the call</p>\n<script>\nfunction count(selector) {\nreturn document.querySelectorAll(selector).length;\n}\nconsole.log(count(\"p\"));\n// All <p> elements\n// \u21924\nconsole.log(count(\".animal\"));\n// Class animal\n// \u21922\nconsole.log(count(\"p .animal\"));\n// Animal inside of <p>\n// \u21922\nconsole.log(count(\"p > .animal\")); // Direct child of <p>\n// \u21921\n</script>\n227\nUnlike methods such as getElementsByTagName, the object returned by querySelectorAll\nis not live. It won\u2019t change when you change the document. It is still not a\nreal array, though, so you need to call Array.from if you want to treat it like\none.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_538",
    "text": "is not live. It won\u2019t change when you change the document. It is still not a\nreal array, though, so you need to call Array.from if you want to treat it like\none.\nThe querySelector method (without the All part) works in a similar way.\nThis one is useful if you want a specific single element. It will return only the\nfirst matching element, or null when no element matches.\nPositioning and animating\nThe position style property influences layout in a powerful way.\nIt has a\ndefault value of static, meaning the element sits in its normal place in the\ndocument. When it is set to relative, the element still takes up space in the\ndocument, but now the top and left style properties can be used to move it\nrelative to that normal place. When position is set to absolute, the element is\nremoved from the normal document flow\u2014that is, it no longer takes up space\nand may overlap with other elements. Its top and left properties can be used",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_539",
    "text": "removed from the normal document flow\u2014that is, it no longer takes up space\nand may overlap with other elements. Its top and left properties can be used\nto absolutely position it relative to the upper-left corner of the nearest enclosing\nelement whose position property isn\u2019t static, or relative to the document if\nno such enclosing element exists.\nWe can use this to create an animation. The following document displays a\npicture of a cat that moves around in an ellipse:\n<p style=\"text-align: center\">\n<img src=\"img/cat.png\" style=\"position: relative\">\n</p>\n<script>\nlet cat = document.querySelector(\"img\");\nlet angle = Math.PI / 2;\nfunction animate(time, lastTime) {\nif (lastTime != null) {\nangle += (time - lastTime) * 0.001;\n}\ncat.style.top = (Math.sin(angle) * 20) + \"px\";\ncat.style.left = (Math.cos(angle) * 200) + \"px\";\nrequestAnimationFrame(newTime => animate(newTime, time));\n}\nrequestAnimationFrame(animate);\n</script>\nThe gray arrow shows the path along which the image moves.\n228",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_540",
    "text": "requestAnimationFrame(newTime => animate(newTime, time));\n}\nrequestAnimationFrame(animate);\n</script>\nThe gray arrow shows the path along which the image moves.\n228\nOur picture is centered on the page and given a position of relative. We\u2019ll\nrepeatedly update that picture\u2019s top and left styles to move it.\nThe script uses requestAnimationFrame to schedule the animate function to\nrun whenever the browser is ready to repaint the screen. The animate function\nitself again calls requestAnimationFrame to schedule the next update. When\nthe browser window (or tab) is active, this will cause updates to happen at a\nrate of about 60 per second, which tends to produce a good-looking animation.\nIf we just updated the DOM in a loop, the page would freeze, and nothing\nwould show up on the screen. Browsers do not update their display while a\nJavaScript program is running, nor do they allow any interaction with the page.\nThis is why we need requestAnimationFrame\u2014it lets the browser know that we",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_541",
    "text": "JavaScript program is running, nor do they allow any interaction with the page.\nThis is why we need requestAnimationFrame\u2014it lets the browser know that we\nare done for now, and it can go ahead and do the things that browsers do, such\nas updating the screen and responding to user actions.\nThe animation function is passed the current time as an argument. To ensure\nthat the motion of the cat per millisecond is stable, it bases the speed at which\nthe angle changes on the difference between the current time and the last time\nthe function ran. If it just moved the angle by a fixed amount per step, the\nmotion would stutter when, for example, another heavy task running on the\nsame computer prevented the function from running for a fraction of a second.\nMoving in circles is done using the trigonometry functions Math.cos and\nMath.sin. For those who aren\u2019t familiar with these, I\u2019ll briefly introduce them,\nsince we will occasionally use them in this book.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_542",
    "text": "Math.sin. For those who aren\u2019t familiar with these, I\u2019ll briefly introduce them,\nsince we will occasionally use them in this book.\nMath.cos and Math.sin are useful for finding points that lie on a circle around\npoint (0, 0) with a radius of 1. Both functions interpret their argument as the\nposition on this circle, with 0 denoting the point on the far right of the circle,\ngoing clockwise until 2\u03c0 (about 6.28) has taken us around the whole circle.\nMath.cos tells you the x-coordinate of the point that corresponds to the given\nposition, and Math.sin yields the y-coordinate. Positions (or angles) greater\nthan 2\u03c0 or less than 0 are valid\u2014the rotation repeats so that a+2\u03c0 refers to\nthe same angle as a.\nThis unit for measuring angles is called radians\u2014a full circle is 2\u03c0 radians,\nsimilar to how it is 360 degrees when measuring in degrees. The constant \u03c0 is\navailable as Math.PI in JavaScript.\n229\ncos(\u00bc\u03c0)\nsin(\u00bc\u03c0)\ncos(-\u2154\u03c0)\nsin(-\u2154\u03c0)\nsin(-\u2154\u03c0)",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_543",
    "text": "similar to how it is 360 degrees when measuring in degrees. The constant \u03c0 is\navailable as Math.PI in JavaScript.\n229\ncos(\u00bc\u03c0)\nsin(\u00bc\u03c0)\ncos(-\u2154\u03c0)\nsin(-\u2154\u03c0)\nsin(-\u2154\u03c0)\nThe cat animation code keeps a counter, angle, for the current angle of the\nanimation and increments it every time the animate function is called. It can\nthen use this angle to compute the current position of the image element. The\ntop style is computed with Math.sin and multiplied by 20, which is the vertical\nradius of our ellipse. The left style is based on Math.cos and multiplied by\n200 so that the ellipse is much wider than it is high.\nNote that styles usually need units. In this case, we have to append \"px\"\nto the number to tell the browser that we are counting in pixels (as opposed\nto centimeters, \u201cems\u201d, or other units). This is easy to forget. Using numbers\nwithout units will result in your style being ignored\u2014unless the number is 0,\nwhich always means the same thing, regardless of its unit.\nSummary",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_544",
    "text": "without units will result in your style being ignored\u2014unless the number is 0,\nwhich always means the same thing, regardless of its unit.\nSummary\nJavaScript programs may inspect and interfere with the document that the\nbrowser is displaying through a data structure called the DOM. This data\nstructure represents the browser\u2019s model of the document, and a JavaScript\nprogram can modify it to change the visible document.\nThe DOM is organized like a tree, where elements are arranged hierarchically\naccording to the structure of the document. The objects representing elements\nhave properties such as parentNode and childNodes, which can be used to\nnavigate through this tree.\nThe way a document is displayed can be influenced by styling, both by at-\ntaching styles to nodes directly and by defining rules that match certain nodes.\nThere are many different style properties, such as color or display. JavaScript\ncode can manipulate an element\u2019s style directly through its style property.\nExercises",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_545",
    "text": "There are many different style properties, such as color or display. JavaScript\ncode can manipulate an element\u2019s style directly through its style property.\nExercises\nBuild a table\nAn HTML table is built with the following tag structure:\n230\n<table>\n<tr>\n<th>name</th>\n<th>height</th>\n<th>place</th>\n</tr>\n<tr>\n<td>Kilimanjaro</td>\n<td>5895</td>\n<td>Tanzania</td>\n</tr>\n</table>\nFor each row, the <table> tag contains a <tr> tag. Inside of these <tr> tags,\nwe can put cell elements: either heading cells (<th>) or regular cells (<td>).\nGiven a dataset of mountains, an array of objects with name, height, and\nplace properties, generate the DOM structure for a table that enumerates the\nobjects. It has one column per key and one row per object, plus a header row\nwith <th> elements at the top, listing the column names.\nWrite this so that the columns are automatically derived from the objects,\nby taking the property names of the first object in the data.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_546",
    "text": "with <th> elements at the top, listing the column names.\nWrite this so that the columns are automatically derived from the objects,\nby taking the property names of the first object in the data.\nShow the resulting table in the document by appending it to the element\nthat has an id attribute of \"mountains\".\nOnce you have this working, right-align cells that contain number values by\nsetting their style.textAlign property to \"right\".\nElements by tag name\nThe document.getElementsByTagName method returns all child elements with a\ngiven tag name. Implement your own version of this as a function that takes a\nnode and a string (the tag name) as arguments and returns an array containing\nall descendant element nodes with the given tag name. Your function should go\nthrough the document itself. It may not use a method like querySelectorAll\nto do the work.\nTo find the tag name of an element, use its nodeName property. But note",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_547",
    "text": "through the document itself. It may not use a method like querySelectorAll\nto do the work.\nTo find the tag name of an element, use its nodeName property. But note\nthat this will return the tag name in all uppercase. Use the toLowerCase or\ntoUpperCase string methods to compensate for this.\nThe cat's hat\nExtend the cat animation defined earlier so that both the cat and his hat\n(<img src=\"img/hat.png\">) orbit at opposite sides of the ellipse.\n231\nOr make the hat circle around the cat. Or alter the animation in some other\ninteresting way.\nTo make positioning multiple objects easier, you\u2019ll probably want to switch\nto absolute positioning. This means that top and left are counted relative to\nthe upper left of the document. To avoid using negative coordinates, which\nwould cause the image to move outside of the visible page, you can add a fixed\nnumber of pixels to the position values.\n232\n\u201cYou have power over your mind\u2014not outside events. Realize this,\nand you will find strength.\u201d",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_548",
    "text": "number of pixels to the position values.\n232\n\u201cYou have power over your mind\u2014not outside events. Realize this,\nand you will find strength.\u201d\n\u2014Marcus Aurelius, Meditations\nChapter 15\nHandling Events\nSome programs work with direct user input, such as mouse and keyboard ac-\ntions. That kind of input isn\u2019t available ahead of time, as a well-organized\ndata structure\u2014it comes in piece by piece, in real time, and the program must\nrespond to it as it happens.\nEvent handlers\nImagine an interface where the only way to find out whether a key on the\nkeyboard is being pressed is to read the current state of that key. To be able\nto react to keypresses, you would have to constantly read the key\u2019s state to\ncatch it before it is released again. It would be dangerous to perform other\ntime-intensive computations, since you might miss a keypress.\nSome primitive machines handle input like this. A step up from this is for\nthe hardware or operating system to notice the keypress and put it in a queue.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_549",
    "text": "Some primitive machines handle input like this. A step up from this is for\nthe hardware or operating system to notice the keypress and put it in a queue.\nA program can then periodically check the queue for new events and react to\nwhat it finds there.\nOf course, the program has to remember to look at the queue, and to do it\noften because any time between the key being pressed and the program noticing\nthe event will cause the software to feel unresponsive. This approach is called\npolling. Most programmers prefer to avoid it.\nA better mechanism is for the system to actively notify the code when an\nevent occurs. Browsers do this by allowing us to register functions as handlers\nfor specific events.\n<p>Click this document to activate the handler.</p>\n<script>\nwindow.addEventListener(\"click\", () => {\nconsole.log(\"You knocked?\");\n});\n</script>\n233\nThe window binding refers to a built-in object provided by the browser. It repre-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_550",
    "text": "<script>\nwindow.addEventListener(\"click\", () => {\nconsole.log(\"You knocked?\");\n});\n</script>\n233\nThe window binding refers to a built-in object provided by the browser. It repre-\nsents the browser window that contains the document. Calling its addEventListener\nmethod registers the second argument to be called whenever the event de-\nscribed by its first argument occurs.\nEvents and DOM nodes\nEach browser event handler is registered in a context. In the previous example,\nwe called addEventListener on the window object to register a handler for the\nwhole window. Such a method can also be found on DOM elements and some\nother types of objects. Event listeners are called only when the event happens\nin the context of the object on which they are registered.\n<button>Click me</button>\n<p>No handler here.</p>\n<script>\nlet button = document.querySelector(\"button\");\nbutton.addEventListener(\"click\", () => {\nconsole.log(\"Button clicked.\");\n});\n</script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_551",
    "text": "<button>Click me</button>\n<p>No handler here.</p>\n<script>\nlet button = document.querySelector(\"button\");\nbutton.addEventListener(\"click\", () => {\nconsole.log(\"Button clicked.\");\n});\n</script>\nThat example attaches a handler to the button node. Clicks on the button\ncause that handler to run, but clicks on the rest of the document do not.\nGiving a node an onclick attribute has a similar effect. This works for most\ntypes of events\u2014you can attach a handler through the attribute whose name\nis the event name with on in front of it.\nBut a node can have only one onclick attribute, so you can register only\none handler per node that way. The addEventListener method allows you to\nadd any number of handlers meaning it\u2019s safe to add handlers even if there is\nalready another handler on the element.\nThe removeEventListener method, called with arguments similar to addEventListener\n, removes a handler.\n<button>Act-once button</button>\n<script>\nlet button = document.querySelector(\"button\");",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_552",
    "text": "The removeEventListener method, called with arguments similar to addEventListener\n, removes a handler.\n<button>Act-once button</button>\n<script>\nlet button = document.querySelector(\"button\");\nfunction once() {\nconsole.log(\"Done.\");\nbutton.removeEventListener(\"click\", once);\n}\nbutton.addEventListener(\"click\", once);\n</script>\n234\nThe function given to removeEventListener has to be the same function value\ngiven to addEventListener. When you need to unregister a handler, you\u2019ll want\nto give the handler function a name (once, in the example) to be able to pass\nthe same function value to both methods.\nEvent objects\nThough we have ignored it so far, event handler functions are passed an ar-\ngument: the event object. This object holds additional information about the\nevent. For example, if we want to know which mouse button was pressed, we\ncan look at the event object\u2019s button property.\n<button>Click me any way you want</button>\n<script>\nlet button = document.querySelector(\"button\");",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_553",
    "text": "can look at the event object\u2019s button property.\n<button>Click me any way you want</button>\n<script>\nlet button = document.querySelector(\"button\");\nbutton.addEventListener(\"mousedown\", event => {\nif (event.button == 0) {\nconsole.log(\"Left button\");\n} else if (event.button == 1) {\nconsole.log(\"Middle button\");\n} else if (event.button == 2) {\nconsole.log(\"Right button\");\n}\n});\n</script>\nThe information stored in an event object differs per type of event. (We\u2019ll\ndiscuss different types later in the chapter.) The object\u2019s type property always\nholds a string identifying the event (such as \"click\" or \"mousedown\").\nPropagation\nFor most event types, handlers registered on nodes with children will also re-\nceive events that happen in the children. If a button inside a paragraph is\nclicked, event handlers on the paragraph will also see the click event.\nBut if both the paragraph and the button have a handler, the more specific",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_554",
    "text": "clicked, event handlers on the paragraph will also see the click event.\nBut if both the paragraph and the button have a handler, the more specific\nhandler\u2014the one on the button\u2014gets to go first. The event is said to propagate\noutward from the node where it happened to that node\u2019s parent node and on\nto the root of the document. Finally, after all handlers registered on a specific\nnode have had their turn, handlers registered on the whole window get a chance\nto respond to the event.\n235\nAt any point, an event handler can call the stopPropagation method on the\nevent object to prevent handlers further up from receiving the event. This can\nbe useful when, for example, you have a button inside another clickable element\nand you don\u2019t want clicks on the button to activate the outer element\u2019s click\nbehavior.\nThe following example registers \"mousedown\" handlers on both a button and\nthe paragraph around it. When clicked with the right mouse button, the han-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_555",
    "text": "behavior.\nThe following example registers \"mousedown\" handlers on both a button and\nthe paragraph around it. When clicked with the right mouse button, the han-\ndler for the button calls stopPropagation, which will prevent the handler on\nthe paragraph from running. When the button is clicked with another mouse\nbutton, both handlers will run.\n<p>A paragraph with a <button>button</button>.</p>\n<script>\nlet para = document.querySelector(\"p\");\nlet button = document.querySelector(\"button\");\npara.addEventListener(\"mousedown\", () => {\nconsole.log(\"Handler for paragraph.\");\n});\nbutton.addEventListener(\"mousedown\", event => {\nconsole.log(\"Handler for button.\");\nif (event.button == 2) event.stopPropagation();\n});\n</script>\nMost event objects have a target property that refers to the node where they\noriginated. You can use this property to ensure that you\u2019re not accidentally\nhandling something that propagated up from a node you do not want to handle.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_556",
    "text": "originated. You can use this property to ensure that you\u2019re not accidentally\nhandling something that propagated up from a node you do not want to handle.\nIt is also possible to use the target property to cast a wide net for a specific\ntype of event. For example, if you have a node containing a long list of buttons,\nit may be more convenient to register a single click handler on the outer node\nand have it use the target property to figure out whether a button was clicked,\nrather than registering individual handlers on all of the buttons.\n<button>A</button>\n<button>B</button>\n<button>C</button>\n<script>\ndocument.body.addEventListener(\"click\", event => {\nif (event.target.nodeName == \"BUTTON\") {\nconsole.log(\"Clicked\", event.target.textContent);\n}\n});\n</script>\n236\nDefault actions\nMany events have a default action. If you click a link, you will be taken to\nthe link\u2019s target. If you press the down arrow, the browser will scroll the page",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_557",
    "text": "}\n});\n</script>\n236\nDefault actions\nMany events have a default action. If you click a link, you will be taken to\nthe link\u2019s target. If you press the down arrow, the browser will scroll the page\ndown. If you right-click, you\u2019ll get a context menu. And so on.\nFor most types of events, the JavaScript event handlers are called before the\ndefault behavior takes place. If the handler doesn\u2019t want this normal behavior\nto happen, typically because it has already taken care of handling the event, it\ncan call the preventDefault method on the event object.\nThis can be used to implement your own keyboard shortcuts or context\nmenu. It can also be used to obnoxiously interfere with the behavior that users\nexpect. For example, here is a link that cannot be followed:\n<a href=\"https://developer.mozilla.org/\">MDN</a>\n<script>\nlet link = document.querySelector(\"a\");\nlink.addEventListener(\"click\", event => {\nconsole.log(\"Nope.\");\nevent.preventDefault();\n});\n</script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_558",
    "text": "<a href=\"https://developer.mozilla.org/\">MDN</a>\n<script>\nlet link = document.querySelector(\"a\");\nlink.addEventListener(\"click\", event => {\nconsole.log(\"Nope.\");\nevent.preventDefault();\n});\n</script>\nTry not to do such things without a really good reason. It\u2019ll be unpleasant for\npeople who use your page when expected behavior is broken.\nDepending on the browser, some events can\u2019t be intercepted at all.\nOn\nChrome, for example, the keyboard shortcut to close the current tab (ctrl-W\nor command-W) cannot be handled by JavaScript.\nKey events\nWhen a key on the keyboard is pressed, your browser fires a \"keydown\" event.\nWhen it is released, you get a \"keyup\" event.\n<p>This page turns violet when you hold the V key.</p>\n<script>\nwindow.addEventListener(\"keydown\", event => {\nif (event.key == \"v\") {\ndocument.body.style.background = \"violet\";\n}\n});\nwindow.addEventListener(\"keyup\", event => {\nif (event.key == \"v\") {\ndocument.body.style.background = \"\";\n237\n}\n});\n</script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_559",
    "text": "if (event.key == \"v\") {\ndocument.body.style.background = \"violet\";\n}\n});\nwindow.addEventListener(\"keyup\", event => {\nif (event.key == \"v\") {\ndocument.body.style.background = \"\";\n237\n}\n});\n</script>\nDespite its name, \"keydown\" fires not only when the key is physically pushed\ndown. When a key is pressed and held, the event fires again every time the\nkey repeats. Sometimes you have to be careful about this. For example, if you\nadd a button to the DOM when a key is pressed and remove it again when the\nkey is released, you might accidentally add hundreds of buttons when the key\nis held down longer.\nThe previous example looks at the key property of the event object to see\nwhich key the event is about. This property holds a string that, for most keys,\ncorresponds to the thing that pressing that key would type. For special keys\nsuch as enter, it holds a string that names the key (\"Enter\", in this case).\nIf you hold shift while pressing a key, that might also influence the name of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_560",
    "text": "such as enter, it holds a string that names the key (\"Enter\", in this case).\nIf you hold shift while pressing a key, that might also influence the name of\nthe key\u2014\"v\" becomes \"V\", and \"1\" may become \"!\", if that is what pressing\nshift-1 produces on your keyboard.\nModifier keys such as shift, ctrl, alt, and meta (command on Mac)\ngenerate key events just like normal keys. When looking for key combinations,\nyou can also find out whether these keys are held down by looking at the\nshiftKey, ctrlKey, altKey, and metaKey properties of keyboard and mouse\nevents.\n<p>Press Control-Space to continue.</p>\n<script>\nwindow.addEventListener(\"keydown\", event => {\nif (event.key == \" \" && event.ctrlKey) {\nconsole.log(\"Continuing!\");\n}\n});\n</script>\nThe DOM node where a key event originates depends on the element that has\nfocus when the key is pressed. Most nodes cannot have focus unless you give\nthem a tabindex attribute, but things like links, buttons, and form fields can.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_561",
    "text": "focus when the key is pressed. Most nodes cannot have focus unless you give\nthem a tabindex attribute, but things like links, buttons, and form fields can.\nWe\u2019ll come back to form fields in Chapter 18. When nothing in particular has\nfocus, document.body acts as the target node of key events.\nWhen the user is typing text, using key events to figure out what is being\ntyped is problematic. Some platforms, most notably the virtual keyboard on\nAndroid phones, don\u2019t fire key events. But even when you have an old-fashioned\nkeyboard, some types of text input don\u2019t match keypresses in a straightforward\nway, such as input method editor (IME) software used by people whose scripts\n238\ndon\u2019t fit on a keyboard, where multiple keystrokes are combined to create\ncharacters.\nTo notice when something was typed, elements that you can type into, such\nas the <input> and <textarea> tags, fire \"input\" events whenever the user\nchanges their content. To get the actual content that was typed, it is best to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_562",
    "text": "as the <input> and <textarea> tags, fire \"input\" events whenever the user\nchanges their content. To get the actual content that was typed, it is best to\ndirectly read it from the focused field, which we discuss in Chapter 18.\nPointer events\nThere are currently two widely used ways to point at things on a screen: mice\n(including devices that act like mice, such as touchpads and trackballs) and\ntouchscreens. These produce different kinds of events.\nMouse clicks\nPressing a mouse button causes a number of events to fire. The \"mousedown\"\nand \"mouseup\" events are similar to \"keydown\" and \"keyup\" and fire when the\nbutton is pressed and released. These happen on the DOM nodes that are\nimmediately below the mouse pointer when the event occurs.\nAfter the \"mouseup\" event, a \"click\" event fires on the most specific node\nthat contained both the press and the release of the button. For example, if I\npress down the mouse button on one paragraph and then move the pointer to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_563",
    "text": "that contained both the press and the release of the button. For example, if I\npress down the mouse button on one paragraph and then move the pointer to\nanother paragraph and release the button, the \"click\" event will happen on\nthe element that contains both those paragraphs.\nIf two clicks happen close together, a \"dblclick\" (double-click) event also\nfires, after the second click event.\nTo get precise information about the place where a mouse event happened,\nyou can look at its clientX and clientY properties, which contain the event\u2019s\ncoordinates (in pixels) relative to the upper-left corner of the window, or pageX\nand pageY, which are relative to the upper-left corner of the whole document\n(which may be different when the window has been scrolled).\nThe following program implements a primitive drawing application. Every\ntime you click the document, it adds a dot under your mouse pointer.\n<style>\nbody {\nheight: 200px;\nbackground: beige;\n}\n.dot {\nheight: 8px; width: 8px;\n239",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_564",
    "text": "time you click the document, it adds a dot under your mouse pointer.\n<style>\nbody {\nheight: 200px;\nbackground: beige;\n}\n.dot {\nheight: 8px; width: 8px;\n239\nborder-radius: 4px; /* rounds corners */\nbackground: teal;\nposition: absolute;\n}\n</style>\n<script>\nwindow.addEventListener(\"click\", event => {\nlet dot = document.createElement(\"div\");\ndot.className = \"dot\";\ndot.style.left = (event.pageX - 4) + \"px\";\ndot.style.top = (event.pageY - 4) + \"px\";\ndocument.body.appendChild(dot);\n});\n</script>\nWe\u2019ll create a less primitive drawing application in Chapter 19.\nMouse motion\nEvery time the mouse pointer moves, a \"mousemove\" event fires. This event can\nbe used to track the position of the mouse. A common situation in which this\nis useful is when implementing some form of mouse-dragging functionality.\nAs an example, the following program displays a bar and sets up event han-\ndlers so that dragging to the left or right on this bar makes it narrower or\nwider:\n<p>Drag the bar to change its width:</p>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_565",
    "text": "As an example, the following program displays a bar and sets up event han-\ndlers so that dragging to the left or right on this bar makes it narrower or\nwider:\n<p>Drag the bar to change its width:</p>\n<div style=\"background: orange; width: 60px; height: 20px\">\n</div>\n<script>\nlet lastX; // Tracks the last observed mouse X position\nlet bar = document.querySelector(\"div\");\nbar.addEventListener(\"mousedown\", event => {\nif (event.button == 0) {\nlastX = event.clientX;\nwindow.addEventListener(\"mousemove\", moved);\nevent.preventDefault(); // Prevent selection\n}\n});\nfunction moved(event) {\nif (event.buttons == 0) {\nwindow.removeEventListener(\"mousemove\", moved);\n} else {\nlet dist = event.clientX - lastX;\n240\nlet newWidth = Math.max(10, bar.offsetWidth + dist);\nbar.style.width = newWidth + \"px\";\nlastX = event.clientX;\n}\n}\n</script>\nThe resulting page looks like this:\nNote that the \"mousemove\" handler is registered on the whole window. Even",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_566",
    "text": "bar.style.width = newWidth + \"px\";\nlastX = event.clientX;\n}\n}\n</script>\nThe resulting page looks like this:\nNote that the \"mousemove\" handler is registered on the whole window. Even\nif the mouse goes outside of the bar during resizing, as long as the button is\nheld, we still want to update its size.\nWe must stop resizing the bar when the mouse button is released. For that,\nwe can use the buttons property (note the plural), which tells us about the\nbuttons that are currently held down. When it is 0, no buttons are down.\nWhen buttons are held, the value of the buttons property is the sum of the\ncodes for those buttons\u2014the left button has code 1, the right button 2, and\nthe middle one 4. With the left and right buttons held, for example, the value\nof buttons will be 3.\nNote that the order of these codes is different from the one used by button,\nwhere the middle button came before the right one. As mentioned, consistency\nisn\u2019t a strong point of the browser\u2019s programming interface.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_567",
    "text": "where the middle button came before the right one. As mentioned, consistency\nisn\u2019t a strong point of the browser\u2019s programming interface.\nTouch events\nThe style of graphical browser that we use was designed with mouse interfaces\nin mind, at a time where touchscreens were rare. To make the web \u201cwork\u201d on\nearly touchscreen phones, browsers for those devices pretended, to a certain\nextent, that touch events were mouse events. If you tap your screen, you\u2019ll get\n\"mousedown\", \"mouseup\", and \"click\" events.\nBut this illusion isn\u2019t very robust. A touchscreen doesn\u2019t work like a mouse:\nit doesn\u2019t have multiple buttons, you can\u2019t track the finger when it isn\u2019t on the\nscreen (to simulate \"mousemove\"), and it allows multiple fingers to be on the\nscreen at the same time.\nMouse events cover touch interaction only in straightforward cases\u2014if you\nadd a \"click\" handler to a button, touch users will still be able to use it. But\nsomething like the resizeable bar in the previous example does not work on a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_568",
    "text": "add a \"click\" handler to a button, touch users will still be able to use it. But\nsomething like the resizeable bar in the previous example does not work on a\ntouchscreen.\n241\nThere are specific event types fired by touch interaction. When a finger starts\ntouching the screen, you get a \"touchstart\" event. When it is moved while\ntouching, \"touchmove\" events fire. Finally, when it stops touching the screen,\nyou\u2019ll see a \"touchend\" event.\nBecause many touchscreens can detect multiple fingers at the same time,\nthese events don\u2019t have a single set of coordinates associated with them. Rather,\ntheir event objects have a touches property, which holds an array-like object of\npoints, each of which has its own clientX, clientY, pageX, and pageY properties.\nYou could do something like this to show red circles around every touching\nfinger:\n<style>\ndot { position: absolute; display: block;\nborder: 2px solid red; border-radius: 50px;\nheight: 100px; width: 100px; }\n</style>\n<p>Touch this page</p>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_569",
    "text": "finger:\n<style>\ndot { position: absolute; display: block;\nborder: 2px solid red; border-radius: 50px;\nheight: 100px; width: 100px; }\n</style>\n<p>Touch this page</p>\n<script>\nfunction update(event) {\nfor (let dot; dot = document.querySelector(\"dot\");) {\ndot.remove();\n}\nfor (let i = 0; i < event.touches.length; i++) {\nlet {pageX, pageY} = event.touches[i];\nlet dot = document.createElement(\"dot\");\ndot.style.left = (pageX - 50) + \"px\";\ndot.style.top = (pageY - 50) + \"px\";\ndocument.body.appendChild(dot);\n}\n}\nwindow.addEventListener(\"touchstart\", update);\nwindow.addEventListener(\"touchmove\", update);\nwindow.addEventListener(\"touchend\", update);\n</script>\nYou\u2019ll often want to call preventDefault in touch event handlers to override the\nbrowser\u2019s default behavior (which may include scrolling the page on swiping)\nand to prevent the mouse events from being fired, for which you may also have\na handler.\n242\nScroll events",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_570",
    "text": "browser\u2019s default behavior (which may include scrolling the page on swiping)\nand to prevent the mouse events from being fired, for which you may also have\na handler.\n242\nScroll events\nWhenever an element is scrolled, a \"scroll\" event is fired on it. This has var-\nious uses, such as knowing what the user is currently looking at (for disabling\noff-screen animations or sending spy reports to your evil headquarters) or show-\ning some indication of progress (by highlighting part of a table of contents or\nshowing a page number).\nThe following example draws a progress bar above the document and updates\nit to fill up as you scroll down:\n<style>\n#progress {\nborder-bottom: 2px solid blue;\nwidth: 0;\nposition: fixed;\ntop: 0; left: 0;\n}\n</style>\n<div id=\"progress\"></div>\n<script>\n// Create some content\ndocument.body.appendChild(document.createTextNode(\n\"supercalifragilisticexpialidocious \".repeat(1000)));\nlet bar = document.querySelector(\"#progress\");\nwindow.addEventListener(\"scroll\", () => {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_571",
    "text": "document.body.appendChild(document.createTextNode(\n\"supercalifragilisticexpialidocious \".repeat(1000)));\nlet bar = document.querySelector(\"#progress\");\nwindow.addEventListener(\"scroll\", () => {\nlet max = document.body.scrollHeight - innerHeight;\nbar.style.width = `${(pageYOffset / max) * 100}%`;\n});\n</script>\nGiving an element a position of fixed acts much like an absolute position but\nalso prevents it from scrolling along with the rest of the document. The effect\nis to make our progress bar stay at the top. Its width is changed to indicate the\ncurrent progress. We use %, rather than px, as a unit when setting the width\nso that the element is sized relative to the page width.\nThe global innerHeight binding gives us the height of the window, which we\nmust subtract from the total scrollable height\u2014you can\u2019t keep scrolling when\nyou hit the bottom of the document. There\u2019s also an innerWidth for the window\nwidth. By dividing pageYOffset, the current scroll position, by the maximum",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_572",
    "text": "you hit the bottom of the document. There\u2019s also an innerWidth for the window\nwidth. By dividing pageYOffset, the current scroll position, by the maximum\nscroll position and multiplying by 100, we get the percentage for the progress\nbar.\nCalling preventDefault on a scroll event does not prevent the scrolling from\n243\nhappening. In fact, the event handler is called only after the scrolling takes\nplace.\nFocus events\nWhen an element gains focus, the browser fires a \"focus\" event on it. When\nit loses focus, the element gets a \"blur\" event.\nUnlike the events discussed earlier, these two events do not propagate. A\nhandler on a parent element is not notified when a child element gains or loses\nfocus.\nThe following example displays help text for the text field that currently has\nfocus:\n<p>Name: <input type=\"text\" data-help=\"Your full name\"></p>\n<p>Age: <input type=\"text\" data-help=\"Your age in years\"></p>\n<p id=\"help\"></p>\n<script>\nlet help = document.querySelector(\"#help\");",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_573",
    "text": "focus:\n<p>Name: <input type=\"text\" data-help=\"Your full name\"></p>\n<p>Age: <input type=\"text\" data-help=\"Your age in years\"></p>\n<p id=\"help\"></p>\n<script>\nlet help = document.querySelector(\"#help\");\nlet fields = document.querySelectorAll(\"input\");\nfor (let field of Array.from(fields)) {\nfield.addEventListener(\"focus\", event => {\nlet text = event.target.getAttribute(\"data-help\");\nhelp.textContent = text;\n});\nfield.addEventListener(\"blur\", event => {\nhelp.textContent = \"\";\n});\n}\n</script>\nThis screenshot shows the help text for the age field:\nThe window object will receive \"focus\" and \"blur\" events when the user\nmoves from or to the browser tab or window in which the document is shown.\n244\nLoad event\nWhen a page finishes loading, the \"load\" event fires on the window and the\ndocument body objects. This is often used to schedule initialization actions that\nrequire the whole document to have been built. Remember that the content of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_574",
    "text": "document body objects. This is often used to schedule initialization actions that\nrequire the whole document to have been built. Remember that the content of\n<script> tags is run immediately when the tag is encountered. This may be\ntoo soon, for example when the script needs to do something with parts of the\ndocument that appear after the <script> tag.\nElements such as images and script tags that load an external file also have\na \"load\" event that indicates the files they reference were loaded. Like the\nfocus-related events, loading events do not propagate.\nWhen you close page or navigate away from it (for example, by following a\nlink), a \"beforeunload\" event fires. The main use of this event is to prevent the\nuser from accidentally losing work by closing a document. If you prevent the\ndefault behavior on this event and set the returnValue property on the event\nobject to a string, the browser will show the user a dialog asking if they really",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_575",
    "text": "default behavior on this event and set the returnValue property on the event\nobject to a string, the browser will show the user a dialog asking if they really\nwant to leave the page. That dialog might include your string, but because\nsome malicious sites try to use these dialogs to confuse people into staying on\ntheir page to look at dodgy weight-loss ads, most browsers no longer display\nthem.\nEvents and the event loop\nIn the context of the event loop, as discussed in Chapter 11, browser event\nhandlers behave like other asynchronous notifications.\nThey are scheduled\nwhen the event occurs but must wait for other scripts that are running to\nfinish before they get a chance to run.\nThe fact that events can be processed only when nothing else is running\nmeans that if the event loop is tied up with other work, any interaction with\nthe page (which happens through events) will be delayed until there\u2019s time to\nprocess it. So if you schedule too much work, either with long-running event",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_576",
    "text": "the page (which happens through events) will be delayed until there\u2019s time to\nprocess it. So if you schedule too much work, either with long-running event\nhandlers or with lots of short-running ones, the page will become slow and\ncumbersome to use.\nFor cases where you really do want to do some time-consuming thing in the\nbackground without freezing the page, browsers provide something called web\nworkers. A worker is a JavaScript process that runs alongside the main script,\non its own timeline.\nImagine that squaring a number is a heavy, long-running computation that\nwe want to perform in a separate thread. We could write a file called code/\n245\nsquareworker.js that responds to messages by computing a square and sending\na message back.\naddEventListener(\"message\", event => {\npostMessage(event.data * event.data);\n});\nTo avoid the problems of having multiple threads touching the same data, work-\ners do not share their global scope or any other data with the main script\u2019s",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_577",
    "text": "postMessage(event.data * event.data);\n});\nTo avoid the problems of having multiple threads touching the same data, work-\ners do not share their global scope or any other data with the main script\u2019s\nenvironment. Instead, you have to communicate with them by sending mes-\nsages back and forth.\nThis code spawns a worker running that script, sends it a few messages, and\noutputs the responses.\nlet squareWorker = new Worker(\"code/squareworker.js\");\nsquareWorker.addEventListener(\"message\", event => {\nconsole.log(\"The worker responded:\", event.data);\n});\nsquareWorker.postMessage(10);\nsquareWorker.postMessage(24);\nThe postMessage function sends a message, which will cause a \"message\" event\nto fire in the receiver. The script that created the worker sends and receives\nmessages through the Worker object, whereas the worker talks to the script that\ncreated it by sending and listening directly on its global scope. Only values",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_578",
    "text": "messages through the Worker object, whereas the worker talks to the script that\ncreated it by sending and listening directly on its global scope. Only values\nthat can be represented as JSON can be sent as messages\u2014the other side will\nreceive a copy of them, rather than the value itself.\nTimers\nThe setTimeout function we saw in Chapter 11 schedules another function to\nbe called later, after a given number of milliseconds. Sometimes you need to\ncancel a function you have scheduled. You can do this by storing the value\nreturned by setTimeout and calling clearTimeout on it.\nlet bombTimer = setTimeout(() => {\nconsole.log(\"BOOM!\");\n}, 500);\nif (Math.random() < 0.5) { // 50% chance\nconsole.log(\"Defused.\");\nclearTimeout(bombTimer);\n}\n246\nThe cancelAnimationFrame function works in the same way as clearTimeout.\nCalling it on a value returned by requestAnimationFrame will cancel that frame\n(assuming it hasn\u2019t already been called).",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_579",
    "text": "}\n246\nThe cancelAnimationFrame function works in the same way as clearTimeout.\nCalling it on a value returned by requestAnimationFrame will cancel that frame\n(assuming it hasn\u2019t already been called).\nA similar set of functions, setInterval and clearInterval, are used to set\ntimers that should repeat every X milliseconds.\nlet ticks = 0;\nlet clock = setInterval(() => {\nconsole.log(\"tick\", ticks++);\nif (ticks == 10) {\nclearInterval(clock);\nconsole.log(\"stop.\");\n}\n}, 200);\nDebouncing\nSome types of events have the potential to fire rapidly many times in a row,\nsuch as the \"mousemove\" and \"scroll\" events. When handling such events, you\nmust be careful not to do anything too time-consuming or your handler will\ntake up so much time that interaction with the document starts to feel slow.\nIf you do need to do something nontrivial in such a handler, you can use\nsetTimeout to make sure you are not doing it too often. This is usually called",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_580",
    "text": "If you do need to do something nontrivial in such a handler, you can use\nsetTimeout to make sure you are not doing it too often. This is usually called\ndebouncing the event. There are several slightly different approaches to this.\nFor example, suppose we want to react when the user has typed something,\nbut we don\u2019t want to do it immediately for every input event. When they are\ntyping quickly, we just want to wait until a pause occurs. Instead of imme-\ndiately performing an action in the event handler, we set a timeout. We also\nclear the previous timeout (if any) so that when events occur close together\n(closer than our timeout delay), the timeout from the previous event will be\ncanceled.\n<textarea>Type something here...</textarea>\n<script>\nlet textarea = document.querySelector(\"textarea\");\nlet timeout;\ntextarea.addEventListener(\"input\", () => {\nclearTimeout(timeout);\ntimeout = setTimeout(() => console.log(\"Typed!\"), 500);\n});\n</script>\n247",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_581",
    "text": "let timeout;\ntextarea.addEventListener(\"input\", () => {\nclearTimeout(timeout);\ntimeout = setTimeout(() => console.log(\"Typed!\"), 500);\n});\n</script>\n247\nGiving an undefined value to clearTimeout or calling it on a timeout that has\nalready fired has no effect. Thus, we don\u2019t have to be careful about when to\ncall it, and we simply do so for every event.\nWe can use a slightly different pattern if we want to space responses so that\nthey\u2019re separated by at least a certain length of time but want to fire them\nduring a series of events, not just afterward.\nFor example, we might want\nto respond to \"mousemove\" events by showing the current coordinates of the\nmouse, but only every 250 milliseconds.\n<script>\nlet scheduled = null;\nwindow.addEventListener(\"mousemove\", event => {\nif (!scheduled) {\nsetTimeout(() => {\ndocument.body.textContent =\n`Mouse at ${scheduled.pageX}, ${scheduled.pageY}`;\nscheduled = null;\n}, 250);\n}\nscheduled = event;\n});\n</script>\nSummary",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_582",
    "text": "if (!scheduled) {\nsetTimeout(() => {\ndocument.body.textContent =\n`Mouse at ${scheduled.pageX}, ${scheduled.pageY}`;\nscheduled = null;\n}, 250);\n}\nscheduled = event;\n});\n</script>\nSummary\nEvent handlers make it possible to detect and react to events happening in our\nweb page. The addEventListener method is used to register such a handler.\nEach event has a type (\"keydown\", \"focus\", and so on) that identifies it.\nMost events are called on a specific DOM element and then propagate to that\nelement\u2019s ancestors, allowing handlers associated with those elements to handle\nthem.\nWhen an event handler is called, it\u2019s passed an event object with additional\ninformation about the event. This object also has methods that allow us to\nstop further propagation (stopPropagation) and prevent the browser\u2019s default\nhandling of the event (preventDefault).\nPressing a key fires \"keydown\" and \"keyup\" events. Pressing a mouse button\nfires \"mousedown\", \"mouseup\", and \"click\" events.\nMoving the mouse fires",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_583",
    "text": "handling of the event (preventDefault).\nPressing a key fires \"keydown\" and \"keyup\" events. Pressing a mouse button\nfires \"mousedown\", \"mouseup\", and \"click\" events.\nMoving the mouse fires\n\"mousemove\" events.\nTouchscreen interaction will result in \"touchstart\", \"\ntouchmove\", and \"touchend\" events.\nScrolling can be detected with the \"scroll\" event, and focus changes can\nbe detected with the \"focus\" and \"blur\" events. When the document finishes\n248\nloading, a \"load\" event fires on the window.\nExercises\nBalloon\nWrite a page that displays a balloon (using the balloon emoji, \ud83c\udf88). When you\npress the up arrow, it should inflate (grow) 10 percent. When you press the\ndown arrow, it should deflate (shrink) 10 percent.\nYou can control the size of text (emoji are text) by setting the font-size\nCSS property (style.fontSize) on its parent element. Remember to include a\nunit in the value\u2014for example, pixels (10px).\nThe key names of the arrow keys are \"ArrowUp\" and \"ArrowDown\". Make sure",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_584",
    "text": "CSS property (style.fontSize) on its parent element. Remember to include a\nunit in the value\u2014for example, pixels (10px).\nThe key names of the arrow keys are \"ArrowUp\" and \"ArrowDown\". Make sure\nthe keys change only the balloon, without scrolling the page.\nOnce you have that working, add a feature where if you blow up the balloon\npast a certain size, it \u201cexplodes\u201d.\nIn this case, exploding means that it is\nreplaced with an \ud83d\udca5emoji, and the event handler is removed (so that you can\u2019t\ninflate or deflate the explosion).\nMouse trail\nIn JavaScript\u2019s early days, which was the high time of gaudy home pages with\nlots of animated images, people came up with some truly inspiring ways to\nuse the language. One of these was the mouse trail\u2014a series of elements that\nwould follow the mouse pointer as you moved it across the page.\nIn this exercise, I want you to implement a mouse trail.\nUse absolutely\npositioned <div> elements with a fixed size and background color (refer to the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_585",
    "text": "In this exercise, I want you to implement a mouse trail.\nUse absolutely\npositioned <div> elements with a fixed size and background color (refer to the\ncode in the \u201cMouse Clicks\u201d section for an example). Create a bunch of these\nelements and, when the mouse moves, display them in the wake of the mouse\npointer.\nThere are various possible approaches here.\nYou can make your trail as\nsimple or as complex as you want. A simple solution to start with is to keep\na fixed number of trail elements and cycle through them, moving the next one\nto the mouse\u2019s current position every time a \"mousemove\" event occurs.\nTabs\nTabbed panels are common in user interfaces. They allow you to select an\ninterface panel by choosing from a number of tabs \u201csticking out\u201d above an\nelement.\n249\nImplement a simple tabbed interface. Write a function, asTabs, that takes a\nDOM node and creates a tabbed interface showing the child elements of that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_586",
    "text": "element.\n249\nImplement a simple tabbed interface. Write a function, asTabs, that takes a\nDOM node and creates a tabbed interface showing the child elements of that\nnode. It should insert a list of <button> elements at the top of the node, one for\neach child element, containing text retrieved from the data-tabname attribute\nof the child. All but one of the original children should be hidden (given a\ndisplay style of none). The currently visible node can be selected by clicking\nthe buttons.\nWhen that works, extend it to style the button for the currently selected tab\ndifferently so that it is obvious which tab is selected.\n250\n\u201cAll reality is a game.\u201d\n\u2014Iain Banks, The Player of Games\nChapter 16\nProject: A Platform Game\nMuch of my initial fascination with computers, like that of many nerdy kids,\nhad to do with computer games. I was drawn into the tiny simulated worlds\nthat I could manipulate and in which stories (sort of) unfolded\u2014more, I sup-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_587",
    "text": "had to do with computer games. I was drawn into the tiny simulated worlds\nthat I could manipulate and in which stories (sort of) unfolded\u2014more, I sup-\npose, because of the way I projected my imagination into them than because\nof the possibilities they actually offered.\nI don\u2019t wish a career in game programming on anyone. As with the music\nindustry, the discrepancy between the number of eager young people wanting\nto work in it and the actual demand for such people creates a rather unhealthy\nenvironment. But writing games for fun is amusing.\nThis chapter will walk through the implementation of a small platform game.\nPlatform games (or \u201cjump and run\u201d games) are games that expect the player\nto move a figure through a world, which is usually two-dimensional and viewed\nfrom the side, while jumping over and onto things.\nThe game\nOur game will be roughly based on Dark Blue (www.lessmilk.com/games/10) by\nThomas Palef. I chose that game because it is both entertaining and minimalist",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_588",
    "text": "The game\nOur game will be roughly based on Dark Blue (www.lessmilk.com/games/10) by\nThomas Palef. I chose that game because it is both entertaining and minimalist\nand because it can be built without too much code. It looks like this:\nThe dark box represents the player, whose task is to collect the yellow boxes\n251\n(coins) while avoiding the red stuff (lava). A level is completed when all coins\nhave been collected.\nThe player can walk around with the left and right arrow keys and can jump\nwith the up arrow. Jumping is this game character\u2019s specialty. It can reach\nseveral times its own height and can change direction in midair. This may not\nbe entirely realistic, but it helps give the player the feeling of being in direct\ncontrol of the on-screen avatar.\nThe game consists of a static background, laid out like a grid, with the moving\nelements overlaid on that background. Each field on the grid is either empty,\nsolid, or lava. The moving elements are the player, coins, and certain pieces",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_589",
    "text": "elements overlaid on that background. Each field on the grid is either empty,\nsolid, or lava. The moving elements are the player, coins, and certain pieces\nof lava. The positions of these elements are not constrained to the grid\u2014their\ncoordinates may be fractional, allowing smooth motion.\nThe technology\nWe will use the browser DOM to display the game, and we\u2019ll read user input\nby handling key events.\nThe screen- and keyboard-related code is only a small part of the work we\nneed to do to build this game. Since everything looks like colored boxes, draw-\ning is uncomplicated: we create DOM elements and use styling to give them a\nbackground color, size, and position.\nWe can represent the background as a table, since it is an unchanging grid of\nsquares. The free-moving elements can be overlaid using absolutely positioned\nelements.\nIn games and other programs that should animate graphics and respond\nto user input without noticeable delay, e\ufb00iciency is important. Although the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_590",
    "text": "elements.\nIn games and other programs that should animate graphics and respond\nto user input without noticeable delay, e\ufb00iciency is important. Although the\nDOM was not originally designed for high-performance graphics, it is actually\nbetter at this than you would expect. You saw some animations in Chapter\n14. On a modern machine, a simple game like this performs well, even if we\ndon\u2019t worry about optimization very much.\nIn the next chapter, we will explore another browser technology, the <canvas>\ntag, which provides a more traditional way to draw graphics, working in terms\nof shapes and pixels rather than DOM elements.\nLevels\nWe\u2019ll want a human-readable, human-editable way to specify levels. Since it\nis okay for everything to start out on a grid, we could use big strings in which\n252\neach character represents an element\u2014either a part of the background grid or\na moving element.\nThe plan for a small level might look like this:\nlet simpleLevelPlan = `\n......................",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_591",
    "text": "252\neach character represents an element\u2014either a part of the background grid or\na moving element.\nThe plan for a small level might look like this:\nlet simpleLevelPlan = `\n......................\n..#................#..\n..#..............=.#..\n..#.........o.o....#..\n..#.@......#####...#..\n..#####............#..\n......#++++++++++++#..\n......##############..\n......................`;\nPeriods are empty space, hash (#) characters are walls, and plus signs are lava.\nThe player\u2019s starting position is the at sign (@). Every O character is a coin,\nand the equal sign (=) at the top is a block of lava that moves back and forth\nhorizontally.\nWe\u2019ll support two additional kinds of moving lava: the pipe character (|)\ncreates vertically moving blobs, and v indicates dripping lava\u2014vertically mov-\ning lava that doesn\u2019t bounce back and forth but only moves down, jumping\nback to its start position when it hits the floor.\nA whole game consists of multiple levels that the player must complete. A",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_592",
    "text": "ing lava that doesn\u2019t bounce back and forth but only moves down, jumping\nback to its start position when it hits the floor.\nA whole game consists of multiple levels that the player must complete. A\nlevel is completed when all coins have been collected. If the player touches\nlava, the current level is restored to its starting position, and the player may\ntry again.\nReading a level\nThe following class stores a level object. Its argument should be the string that\ndefines the level.\nclass Level {\nconstructor(plan) {\nlet rows = plan.trim().split(\"\\n\").map(l => [...l]);\nthis.height = rows.length;\nthis.width = rows[0].length;\nthis.startActors = [];\nthis.rows = rows.map((row, y) => {\nreturn row.map((ch, x) => {\nlet type = levelChars[ch];\n253\nif (typeof type != \"string\") {\nlet pos = new Vec(x, y);\nthis.startActors.push(type.create(pos, ch));\ntype = \"empty\";\n}\nreturn type;\n});\n});\n}\n}\nThe trim method is used to remove whitespace at the start and end of the plan",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_593",
    "text": "let pos = new Vec(x, y);\nthis.startActors.push(type.create(pos, ch));\ntype = \"empty\";\n}\nreturn type;\n});\n});\n}\n}\nThe trim method is used to remove whitespace at the start and end of the plan\nstring. This allows our example plan to start with a newline so that all lines are\ndirectly below each other. The remaining string is split on newline characters,\nand each line is spread into an array, producing arrays of characters.\nSo rows holds an array of arrays of characters, the rows of the plan. We can\nderive the level\u2019s width and height from these. But we must still separate the\nmoving elements from the background grid. We\u2019ll call moving elements actors.\nThey\u2019ll be stored in an array of objects. The background will be an array of\narrays of strings, holding field types such as \"empty\", \"wall\", or \"lava\".\nTo create these arrays, we map over the rows and then over their content.\nRemember that map passes the array index as a second argument to the mapping",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_594",
    "text": "To create these arrays, we map over the rows and then over their content.\nRemember that map passes the array index as a second argument to the mapping\nfunction, which tells us the x- and y-coordinates of a given character. Positions\nin the game will be stored as pairs of coordinates, with the upper left being 0,0\nand each background square being 1 unit high and wide.\nTo interpret the characters in the plan, the Level constructor uses the\nlevelChars object, which, for each character used in the level descriptions,\nholds a string if it is a background type, and a class if it produces an actor.\nWhen type is an actor class, its static create method is used to create an ob-\nject, which is added to startActors, and the mapping function returns \"empty\"\nfor this background square.\nThe position of the actor is stored as a Vec object. This is a two-dimensional\nvector, an object with x and y properties, as seen in the exercises of Chapter 6.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_595",
    "text": "for this background square.\nThe position of the actor is stored as a Vec object. This is a two-dimensional\nvector, an object with x and y properties, as seen in the exercises of Chapter 6.\nAs the game runs, actors will end up in different places or even disappear\nentirely (as coins do when collected). We\u2019ll use a State class to track the state\nof a running game.\nclass State {\nconstructor(level, actors, status) {\nthis.level = level;\nthis.actors = actors;\nthis.status = status;\n254\n}\nstatic start(level) {\nreturn new State(level, level.startActors, \"playing\");\n}\nget player() {\nreturn this.actors.find(a => a.type == \"player\");\n}\n}\nThe status property will switch to \"lost\" or \"won\" when the game has ended.\nThis is again a persistent data structure\u2014updating the game state creates a\nnew state and leaves the old one intact.\nActors\nActor objects represent the current position and state of a given moving element\n(player, coin, or mobile lava) in our game. All actor objects conform to the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_596",
    "text": "Actors\nActor objects represent the current position and state of a given moving element\n(player, coin, or mobile lava) in our game. All actor objects conform to the\nsame interface. They have size and pos properties holding the size and the\ncoordinates of the upper-left corner of the rectangle representing this actor,\nand an update method.\nThis update method is used to compute their new state and position after a\ngiven time step. It simulates the thing the actor does\u2014moving in response to\nthe arrow keys for the player and bouncing back and forth for the lava\u2014and\nreturns a new, updated actor object.\nA type property contains a string that identifies the type of the actor\u2014\"\nplayer\", \"coin\", or \"lava\". This is useful when drawing the game\u2014the look\nof the rectangle drawn for an actor is based on its type.\nActor classes have a static create method that is used by the Level con-\nstructor to create an actor from a character in the level plan. It is given the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_597",
    "text": "Actor classes have a static create method that is used by the Level con-\nstructor to create an actor from a character in the level plan. It is given the\ncoordinates of the character and the character itself, which is necessary because\nthe Lava class handles several different characters.\nThis is the Vec class that we\u2019ll use for our two-dimensional values, such as\nthe position and size of actors.\nclass Vec {\nconstructor(x, y) {\nthis.x = x; this.y = y;\n}\nplus(other) {\nreturn new Vec(this.x + other.x, this.y + other.y);\n255\n}\ntimes(factor) {\nreturn new Vec(this.x * factor, this.y * factor);\n}\n}\nThe times method scales a vector by a given number. It will be useful when we\nneed to multiply a speed vector by a time interval to get the distance traveled\nduring that time.\nThe different types of actors get their own classes, since their behavior is\nvery different. Let\u2019s define these classes. We\u2019ll get to their update methods\nlater.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_598",
    "text": "during that time.\nThe different types of actors get their own classes, since their behavior is\nvery different. Let\u2019s define these classes. We\u2019ll get to their update methods\nlater.\nThe player class has a speed property that stores its current speed to simulate\nmomentum and gravity.\nclass Player {\nconstructor(pos, speed) {\nthis.pos = pos;\nthis.speed = speed;\n}\nget type() { return \"player\"; }\nstatic create(pos) {\nreturn new Player(pos.plus(new Vec(0, -0.5)),\nnew Vec(0, 0));\n}\n}\nPlayer.prototype.size = new Vec(0.8, 1.5);\nBecause a player is one-and-a-half squares high, its initial position is set to be\nhalf a square above the position where the @ character appeared. This way, its\nbottom aligns with the bottom of the square where it appeared.\nThe size property is the same for all instances of Player, so we store it on\nthe prototype rather than on the instances themselves. We could have used\na getter like type, but that would create and return a new Vec object every",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_599",
    "text": "the prototype rather than on the instances themselves. We could have used\na getter like type, but that would create and return a new Vec object every\ntime the property is read, which would be wasteful. (Strings, being immutable,\ndon\u2019t have to be re-created every time they are evaluated.)\nWhen constructing a Lava actor, we need to initialize the object differently\ndepending on the character it is based on. Dynamic lava moves along at its\ncurrent speed until it hits an obstacle. At that point, if it has a reset property,\nit will jump back to its start position (dripping). If it does not, it will invert\n256\nits speed and continue in the other direction (bouncing).\nThe create method looks at the character that the Level constructor passes\nand creates the appropriate lava actor.\nclass Lava {\nconstructor(pos, speed, reset) {\nthis.pos = pos;\nthis.speed = speed;\nthis.reset = reset;\n}\nget type() { return \"lava\"; }\nstatic create(pos, ch) {\nif (ch == \"=\") {\nreturn new Lava(pos, new Vec(2, 0));",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_600",
    "text": "constructor(pos, speed, reset) {\nthis.pos = pos;\nthis.speed = speed;\nthis.reset = reset;\n}\nget type() { return \"lava\"; }\nstatic create(pos, ch) {\nif (ch == \"=\") {\nreturn new Lava(pos, new Vec(2, 0));\n} else if (ch == \"|\") {\nreturn new Lava(pos, new Vec(0, 2));\n} else if (ch == \"v\") {\nreturn new Lava(pos, new Vec(0, 3), pos);\n}\n}\n}\nLava.prototype.size = new Vec(1, 1);\nCoin actors are relatively simple. They mostly just sit in their place. But to\nliven up the game a little, they are given a \u201cwobble\u201d, a slight vertical back-\nand-forth motion. To track this, a coin object stores a base position as well\nas a wobble property that tracks the phase of the bouncing motion. Together,\nthese determine the coin\u2019s actual position (stored in the pos property).\nclass Coin {\nconstructor(pos, basePos, wobble) {\nthis.pos = pos;\nthis.basePos = basePos;\nthis.wobble = wobble;\n}\nget type() { return \"coin\"; }\nstatic create(pos) {\nlet basePos = pos.plus(new Vec(0.2, 0.1));\nreturn new Coin(basePos, basePos,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_601",
    "text": "this.pos = pos;\nthis.basePos = basePos;\nthis.wobble = wobble;\n}\nget type() { return \"coin\"; }\nstatic create(pos) {\nlet basePos = pos.plus(new Vec(0.2, 0.1));\nreturn new Coin(basePos, basePos,\nMath.random() * Math.PI * 2);\n257\n}\n}\nCoin.prototype.size = new Vec(0.6, 0.6);\nIn Chapter 14, we saw that Math.sin gives us the y-coordinate of a point on a\ncircle. That coordinate goes back and forth in a smooth waveform as we move\nalong the circle, which makes the sine function useful for modeling a wavy\nmotion.\nTo avoid a situation where all coins move up and down synchronously, the\nstarting phase of each coin is randomized. The period of Math.sin\u2019s wave, the\nwidth of a wave it produces, is 2\u03c0. We multiply the value returned by Math\n.random by that number to give the coin a random starting position on the\nwave.\nWe can now define the levelChars object that maps plan characters to either\nbackground grid types or actor classes.\nconst levelChars = {\n\".\": \"empty\", \"#\": \"wall\", \"+\": \"lava\",",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_602",
    "text": "wave.\nWe can now define the levelChars object that maps plan characters to either\nbackground grid types or actor classes.\nconst levelChars = {\n\".\": \"empty\", \"#\": \"wall\", \"+\": \"lava\",\n\"@\": Player, \"o\": Coin,\n\"=\": Lava, \"|\": Lava, \"v\": Lava\n};\nThat gives us all the parts needed to create a Level instance.\nlet simpleLevel = new Level(simpleLevelPlan);\nconsole.log(`${simpleLevel.width} by ${simpleLevel.height}`);\n// \u219222 by 9\nThe task ahead is to display such levels on the screen and to model time and\nmotion inside them.\nDrawing\nIn the next chapter, we\u2019ll display the same game in a different way. To make\nthat possible, we put the drawing logic behind an interface and pass it to the\ngame as an argument. That way, we can use the same game program with\ndifferent new display modules.\nA game display object draws a given level and state. We pass its constructor\nto the game to allow it to be replaced. The display class we define in this",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_603",
    "text": "different new display modules.\nA game display object draws a given level and state. We pass its constructor\nto the game to allow it to be replaced. The display class we define in this\nchapter is called DOMDisplay because it uses DOM elements to show the level.\nWe\u2019ll be using a style sheet to set the actual colors and other fixed properties\nof the elements that make up the game. It would also be possible to directly\n258\nassign to the elements\u2019 style property when we create them, but that would\nproduce more verbose programs.\nThe following helper function provides a succinct way to create an element\nand give it some attributes and child nodes:\nfunction elt(name, attrs, ...children) {\nlet dom = document.createElement(name);\nfor (let attr of Object.keys(attrs)) {\ndom.setAttribute(attr, attrs[attr]);\n}\nfor (let child of children) {\ndom.appendChild(child);\n}\nreturn dom;\n}\nA display is created by giving it a parent element to which it should append\nitself and a level object.\nclass DOMDisplay {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_604",
    "text": "}\nfor (let child of children) {\ndom.appendChild(child);\n}\nreturn dom;\n}\nA display is created by giving it a parent element to which it should append\nitself and a level object.\nclass DOMDisplay {\nconstructor(parent, level) {\nthis.dom = elt(\"div\", {class: \"game\"}, drawGrid(level));\nthis.actorLayer = null;\nparent.appendChild(this.dom);\n}\nclear() { this.dom.remove(); }\n}\nThe level\u2019s background grid, which never changes, is drawn once. Actors are\nredrawn every time the display is updated with a given state. The actorLayer\nproperty will be used to track the element that holds the actors so that they\ncan be easily removed and replaced.\nOur coordinates and sizes are tracked in grid units, where a size or distance\nof 1 means one grid block. When setting pixel sizes, we will have to scale these\ncoordinates up\u2014everything in the game would be ridiculously small at a single\npixel per square. The scale constant gives the number of pixels that a single\nunit takes up on the screen.\nconst scale = 20;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_605",
    "text": "pixel per square. The scale constant gives the number of pixels that a single\nunit takes up on the screen.\nconst scale = 20;\nfunction drawGrid(level) {\nreturn elt(\"table\", {\nclass: \"background\",\nstyle: `width: ${level.width * scale}px`\n259\n}, ...level.rows.map(row =>\nelt(\"tr\", {style: `height: ${scale}px`},\n...row.map(type => elt(\"td\", {class: type})))\n));\n}\nThe <table> element\u2019s form nicely corresponds to the structure of the rows\nproperty of the level\u2014each row of the grid is turned into a table row (<tr>\nelement). The strings in the grid are used as class names for the table cell\n(<td>) elements. The code uses the spread (triple dot) operator to pass arrays\nof child nodes to elt as separate arguments.\nThe following CSS makes the table look like the background we want:\n.background\n{ background: rgb(52, 166, 251);\ntable-layout: fixed;\nborder-spacing: 0;\n}\n.background td { padding: 0;\n}\n.lava\n{ background: rgb(255, 100, 100); }\n.wall\n{ background: white;\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_606",
    "text": ".background\n{ background: rgb(52, 166, 251);\ntable-layout: fixed;\nborder-spacing: 0;\n}\n.background td { padding: 0;\n}\n.lava\n{ background: rgb(255, 100, 100); }\n.wall\n{ background: white;\n}\nSome of these (table-layout, border-spacing, and padding) are used to sup-\npress unwanted default behavior. We don\u2019t want the layout of the table to\ndepend upon the contents of its cells, and we don\u2019t want space between the\ntable cells or padding inside them.\nThe background rule sets the background color. CSS allows colors to be spec-\nified both as words (white) or with a format such as rgb(R, G, B), where the\nred, green, and blue components of the color are separated into three numbers\nfrom 0 to 255. In rgb(52, 166, 251), the red component is 52, green is 166,\nand blue is 251. Since the blue component is the largest, the resulting color\nwill be bluish. In the .lava rule, the first number (red) is the largest.\nWe draw each actor by creating a DOM element for it and setting that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_607",
    "text": "will be bluish. In the .lava rule, the first number (red) is the largest.\nWe draw each actor by creating a DOM element for it and setting that\nelement\u2019s position and size based on the actor\u2019s properties. The values must\nbe multiplied by scale to go from game units to pixels.\nfunction drawActors(actors) {\nreturn elt(\"div\", {}, ...actors.map(actor => {\nlet rect = elt(\"div\", {class: `actor ${actor.type}`});\nrect.style.width = `${actor.size.x * scale}px`;\nrect.style.height = `${actor.size.y * scale}px`;\nrect.style.left = `${actor.pos.x * scale}px`;\nrect.style.top = `${actor.pos.y * scale}px`;\nreturn rect;\n}));\n}\n260\nTo give an element more than one class, we separate the class names by spaces.\nIn the following CSS code, the actor class gives the actors their absolute posi-\ntion. Their type name is used as an extra class to give them a color. We don\u2019t\nhave to define the lava class again because we\u2019re reusing the class for the lava\ngrid squares we defined earlier.\n.actor",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_608",
    "text": "tion. Their type name is used as an extra class to give them a color. We don\u2019t\nhave to define the lava class again because we\u2019re reusing the class for the lava\ngrid squares we defined earlier.\n.actor\n{ position: absolute;\n}\n.coin\n{ background: rgb(241, 229, 89); }\n.player { background: rgb(64, 64, 64);\n}\nThe syncState method is used to make the display show a given state. It first\nremoves the old actor graphics, if any, and then redraws the actors in their new\npositions. It may be tempting to try to reuse the DOM elements for actors, but\nto make that work, we would need a lot of additional bookkeeping to associate\nactors with DOM elements and to make sure we remove elements when their\nactors vanish. Since there will typically be only a handful of actors in the game,\nredrawing all of them is not expensive.\nDOMDisplay.prototype.syncState = function(state) {\nif (this.actorLayer) this.actorLayer.remove();\nthis.actorLayer = drawActors(state.actors);\nthis.dom.appendChild(this.actorLayer);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_609",
    "text": "DOMDisplay.prototype.syncState = function(state) {\nif (this.actorLayer) this.actorLayer.remove();\nthis.actorLayer = drawActors(state.actors);\nthis.dom.appendChild(this.actorLayer);\nthis.dom.className = `game ${state.status}`;\nthis.scrollPlayerIntoView(state);\n};\nBy adding the level\u2019s current status as a class name to the wrapper, we can\nstyle the player actor slightly differently when the game is won or lost by adding\na CSS rule that takes effect only when the player has an ancestor element with\na given class.\n.lost .player {\nbackground: rgb(160, 64, 64);\n}\n.won .player {\nbox-shadow: -4px -7px 8px white, 4px -7px 8px white;\n}\nAfter touching lava, the player turns dark red, suggesting scorching. When the\nlast coin has been collected, we add two blurred white shadows\u2014one to the\nupper left and one to the upper right\u2014to create a white halo effect.\nWe can\u2019t assume that the level always fits in the viewport, the element into\nwhich we draw the game.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_610",
    "text": "upper left and one to the upper right\u2014to create a white halo effect.\nWe can\u2019t assume that the level always fits in the viewport, the element into\nwhich we draw the game.\nThat is why we need the scrollPlayerIntoView\ncall: it ensures that if the level is protruding outside the viewport, we scroll\n261\nthat viewport to make sure the player is near its center. The following CSS\ngives the game\u2019s wrapping DOM element a maximum size and ensures that\nanything that sticks out of the element\u2019s box is not visible. We also give it a\nrelative position so that the actors inside it are positioned relative to the level\u2019s\nupper-left corner.\n.game {\noverflow: hidden;\nmax-width: 600px;\nmax-height: 450px;\nposition: relative;\n}\nIn the scrollPlayerIntoView method, we find the player\u2019s position and update\nthe wrapping element\u2019s scroll position. We change the scroll position by manip-\nulating that element\u2019s scrollLeft and scrollTop properties when the player is\ntoo close to the edge.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_611",
    "text": "the wrapping element\u2019s scroll position. We change the scroll position by manip-\nulating that element\u2019s scrollLeft and scrollTop properties when the player is\ntoo close to the edge.\nDOMDisplay.prototype.scrollPlayerIntoView = function(state) {\nlet width = this.dom.clientWidth;\nlet height = this.dom.clientHeight;\nlet margin = width / 3;\n// The viewport\nlet left = this.dom.scrollLeft, right = left + width;\nlet top = this.dom.scrollTop, bottom = top + height;\nlet player = state.player;\nlet center = player.pos.plus(player.size.times(0.5))\n.times(scale);\nif (center.x < left + margin) {\nthis.dom.scrollLeft = center.x - margin;\n} else if (center.x > right - margin) {\nthis.dom.scrollLeft = center.x + margin - width;\n}\nif (center.y < top + margin) {\nthis.dom.scrollTop = center.y - margin;\n} else if (center.y > bottom - margin) {\nthis.dom.scrollTop = center.y + margin - height;\n}\n};\nThe way the player\u2019s center is found shows how the methods on our Vec type",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_612",
    "text": "} else if (center.y > bottom - margin) {\nthis.dom.scrollTop = center.y + margin - height;\n}\n};\nThe way the player\u2019s center is found shows how the methods on our Vec type\nallow computations with objects to be written in a relatively readable way. To\n262\nfind the actor\u2019s center, we add its position (its upper-left corner) and half its\nsize. That is the center in level coordinates, but we need it in pixel coordinates,\nso we then multiply the resulting vector by our display scale.\nNext, a series of checks verifies that the player position isn\u2019t outside of the\nallowed range. Note that sometimes this will set nonsense scroll coordinates\nthat are below zero or beyond the element\u2019s scrollable area. This is okay\u2014the\nDOM will constrain them to acceptable values. Setting scrollLeft to -10 will\ncause it to become 0.\nWhile it would have been slightly simpler to always try to scroll the player\nto the center of the viewport, this creates a rather jarring effect. As you are",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_613",
    "text": "cause it to become 0.\nWhile it would have been slightly simpler to always try to scroll the player\nto the center of the viewport, this creates a rather jarring effect. As you are\njumping, the view will constantly shift up and down. It\u2019s more pleasant to\nhave a \u201cneutral\u201d area in the middle of the screen where you can move around\nwithout causing any scrolling.\nWe are now able to display our tiny level.\n<link rel=\"stylesheet\" href=\"css/game.css\">\n<script>\nlet simpleLevel = new Level(simpleLevelPlan);\nlet display = new DOMDisplay(document.body, simpleLevel);\ndisplay.syncState(State.start(simpleLevel));\n</script>\nThe <link> tag, when used with rel=\"stylesheet\", is a way to load a CSS\nfile into a page. The file game.css contains the styles necessary for our game.\nMotion and collision\nNow we\u2019re at the point where we can start adding motion. The basic approach\ntaken by most games like this is to split time into small steps and, for each step,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_614",
    "text": "Motion and collision\nNow we\u2019re at the point where we can start adding motion. The basic approach\ntaken by most games like this is to split time into small steps and, for each step,\nmove the actors by a distance corresponding to their speed multiplied by the\nsize of the time step. We\u2019ll measure time in seconds, so speeds are expressed\nin units per second.\nMoving things is easy. The di\ufb00icult part is dealing with the interactions\n263\nbetween the elements. When the player hits a wall or floor, they should not\nsimply move through it. The game must notice when a given motion causes\nan object to hit another object and respond accordingly. For walls, the motion\nmust be stopped. When hitting a coin, that coin must be collected. When\ntouching lava, the game should be lost.\nSolving this for the general case is a major task. You can find libraries, usu-\nally called physics engines, that simulate interaction between physical objects",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_615",
    "text": "touching lava, the game should be lost.\nSolving this for the general case is a major task. You can find libraries, usu-\nally called physics engines, that simulate interaction between physical objects\nin two or three dimensions. We\u2019ll take a more modest approach in this chapter,\nhandling only collisions between rectangular objects and handling them in a\nrather simplistic way.\nBefore moving the player or a block of lava, we test whether the motion would\ntake it inside of a wall. If it does, we simply cancel the motion altogether. The\nresponse to such a collision depends on the type of actor\u2014the player will stop,\nwhereas a lava block will bounce back.\nThis approach requires our time steps to be rather small, since it will cause\nmotion to stop before the objects actually touch. If the time steps (and thus\nthe motion steps) are too big, the player would end up hovering a noticeable\ndistance above the ground. Another approach, arguably better but more com-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_616",
    "text": "the motion steps) are too big, the player would end up hovering a noticeable\ndistance above the ground. Another approach, arguably better but more com-\nplicated, would be to find the exact collision spot and move there. We will take\nthe simple approach and hide its problems by ensuring the animation proceeds\nin small steps.\nThis method tells us whether a rectangle (specified by a position and a size)\ntouches a grid element of the given type.\nLevel.prototype.touches = function(pos, size, type) {\nlet xStart = Math.floor(pos.x);\nlet xEnd = Math.ceil(pos.x + size.x);\nlet yStart = Math.floor(pos.y);\nlet yEnd = Math.ceil(pos.y + size.y);\nfor (let y = yStart; y < yEnd; y++) {\nfor (let x = xStart; x < xEnd; x++) {\nlet isOutside = x < 0 || x >= this.width ||\ny < 0 || y >= this.height;\nlet here = isOutside ? \"wall\" : this.rows[y][x];\nif (here == type) return true;\n}\n}\nreturn false;\n};\nThe method computes the set of grid squares that the body overlaps with\n264",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_617",
    "text": "let here = isOutside ? \"wall\" : this.rows[y][x];\nif (here == type) return true;\n}\n}\nreturn false;\n};\nThe method computes the set of grid squares that the body overlaps with\n264\nby using Math.floor and Math.ceil on its coordinates. Remember that grid\nsquares are 1 by 1 units in size. By rounding the sides of a box up and down,\nwe get the range of background squares that the box touches.\nWe loop over the block of grid squares found by rounding the coordinates\nand return true when a matching square is found. Squares outside of the level\nare always treated as \"wall\" to ensure that the player can\u2019t leave the world\nand that we won\u2019t accidentally try to read outside of the bounds of our rows\narray.\nThe state update method uses touches to figure out whether the player is\ntouching lava.\nState.prototype.update = function(time, keys) {\nlet actors = this.actors\n.map(actor => actor.update(time, this, keys));\nlet newState = new State(this.level, actors, this.status);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_618",
    "text": "touching lava.\nState.prototype.update = function(time, keys) {\nlet actors = this.actors\n.map(actor => actor.update(time, this, keys));\nlet newState = new State(this.level, actors, this.status);\nif (newState.status != \"playing\") return newState;\nlet player = newState.player;\nif (this.level.touches(player.pos, player.size, \"lava\")) {\nreturn new State(this.level, actors, \"lost\");\n}\nfor (let actor of actors) {\nif (actor != player && overlap(actor, player)) {\nnewState = actor.collide(newState);\n}\n}\nreturn newState;\n};\nThe method is passed a time step and a data structure that tells it which keys\nare being held down. The first thing it does is call the update method on all\nactors, producing an array of updated actors. The actors also get the time\nstep, the keys, and the state so that they can base their update on those. Only\nthe player will actually read keys, since that\u2019s the only actor that\u2019s controlled\nby the keyboard.\n265",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_619",
    "text": "step, the keys, and the state so that they can base their update on those. Only\nthe player will actually read keys, since that\u2019s the only actor that\u2019s controlled\nby the keyboard.\n265\nIf the game is already over, no further processing has to be done (the game\ncan\u2019t be won after being lost, or vice versa).\nOtherwise, the method tests\nwhether the player is touching background lava. If so, the game is lost and\nwe\u2019re done. Finally, if the game really is still going on, it sees whether any\nother actors overlap the player.\nOverlap between actors is detected with the overlap function. It takes two\nactor objects and returns true when they touch\u2014which is the case when they\noverlap both along the x-axis and along the y-axis.\nfunction overlap(actor1, actor2) {\nreturn actor1.pos.x + actor1.size.x > actor2.pos.x &&\nactor1.pos.x < actor2.pos.x + actor2.size.x &&\nactor1.pos.y + actor1.size.y > actor2.pos.y &&\nactor1.pos.y < actor2.pos.y + actor2.size.y;\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_620",
    "text": "return actor1.pos.x + actor1.size.x > actor2.pos.x &&\nactor1.pos.x < actor2.pos.x + actor2.size.x &&\nactor1.pos.y + actor1.size.y > actor2.pos.y &&\nactor1.pos.y < actor2.pos.y + actor2.size.y;\n}\nIf any actor does overlap, its collide method gets a chance to update the state.\nTouching a lava actor sets the game status to \"lost\". Coins vanish when you\ntouch them and set the status to \"won\" when they are the last coin of the level.\nLava.prototype.collide = function(state) {\nreturn new State(state.level, state.actors, \"lost\");\n};\nCoin.prototype.collide = function(state) {\nlet filtered = state.actors.filter(a => a != this);\nlet status = state.status;\nif (!filtered.some(a => a.type == \"coin\")) status = \"won\";\nreturn new State(state.level, filtered, status);\n};\nActor updates\nActor objects\u2019 update methods take as arguments the time step, the state ob-\nject, and a keys object.\nThe one for the Lava actor type ignores the keys\nobject.\nLava.prototype.update = function(time, state) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_621",
    "text": "ject, and a keys object.\nThe one for the Lava actor type ignores the keys\nobject.\nLava.prototype.update = function(time, state) {\nlet newPos = this.pos.plus(this.speed.times(time));\nif (!state.level.touches(newPos, this.size, \"wall\")) {\nreturn new Lava(newPos, this.speed, this.reset);\n} else if (this.reset) {\nreturn new Lava(this.reset, this.speed, this.reset);\n266\n} else {\nreturn new Lava(this.pos, this.speed.times(-1));\n}\n};\nThis update method computes a new position by adding the product of the time\nstep and the current speed to its old position. If no obstacle blocks that new\nposition, it moves there. If there is an obstacle, the behavior depends on the\ntype of the lava block\u2014dripping lava has a reset position, to which it jumps\nback when it hits something. Bouncing lava inverts its speed by multiplying it\nby -1 so that it starts moving in the opposite direction.\nCoins use their update method to wobble. They ignore collisions with the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_622",
    "text": "by -1 so that it starts moving in the opposite direction.\nCoins use their update method to wobble. They ignore collisions with the\ngrid, since they are simply wobbling around inside of their own square.\nconst wobbleSpeed = 8, wobbleDist = 0.07;\nCoin.prototype.update = function(time) {\nlet wobble = this.wobble + time * wobbleSpeed;\nlet wobblePos = Math.sin(wobble) * wobbleDist;\nreturn new Coin(this.basePos.plus(new Vec(0, wobblePos)),\nthis.basePos, wobble);\n};\nThe wobble property is incremented to track time and then used as an argument\nto Math.sin to find the new position on the wave. The coin\u2019s current position\nis then computed from its base position and an offset based on this wave.\nThat leaves the player itself. Player motion is handled separately per axis\nbecause hitting the floor should not prevent horizontal motion, and hitting a\nwall should not stop falling or jumping motion.\nconst playerXSpeed = 7;\nconst gravity = 30;\nconst jumpSpeed = 17;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_623",
    "text": "because hitting the floor should not prevent horizontal motion, and hitting a\nwall should not stop falling or jumping motion.\nconst playerXSpeed = 7;\nconst gravity = 30;\nconst jumpSpeed = 17;\nPlayer.prototype.update = function(time, state, keys) {\nlet xSpeed = 0;\nif (keys.ArrowLeft) xSpeed -= playerXSpeed;\nif (keys.ArrowRight) xSpeed += playerXSpeed;\nlet pos = this.pos;\nlet movedX = pos.plus(new Vec(xSpeed * time, 0));\nif (!state.level.touches(movedX, this.size, \"wall\")) {\npos = movedX;\n}\nlet ySpeed = this.speed.y + time * gravity;\n267\nlet movedY = pos.plus(new Vec(0, ySpeed * time));\nif (!state.level.touches(movedY, this.size, \"wall\")) {\npos = movedY;\n} else if (keys.ArrowUp && ySpeed > 0) {\nySpeed = -jumpSpeed;\n} else {\nySpeed = 0;\n}\nreturn new Player(pos, new Vec(xSpeed, ySpeed));\n};\nThe horizontal motion is computed based on the state of the left and right\narrow keys. When there\u2019s no wall blocking the new position created by this",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_624",
    "text": "};\nThe horizontal motion is computed based on the state of the left and right\narrow keys. When there\u2019s no wall blocking the new position created by this\nmotion, it is used. Otherwise, the old position is kept.\nVertical motion works in a similar way but has to simulate jumping and\ngravity. The player\u2019s vertical speed (ySpeed) is first accelerated to account for\ngravity.\nWe check for walls again. If we don\u2019t hit any, the new position is used. If\nthere is a wall, there are two possible outcomes. When the up arrow is pressed\nand we are moving down (meaning the thing we hit is below us), the speed is\nset to a relatively large, negative value. This causes the player to jump. If that\nis not the case, the player simply bumped into something, and the speed is set\nto zero.\nThe gravity strength, jumping speed, and other constants in the game were\ndetermined by simply trying out some numbers and seeing which ones felt right.\nYou can try experimenting with them.\nTracking keys",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_625",
    "text": "determined by simply trying out some numbers and seeing which ones felt right.\nYou can try experimenting with them.\nTracking keys\nFor a game like this, we do not want keys to take effect once per keypress.\nRather, we want their effect (moving the player figure) to stay active as long\nas they are held.\nWe need to set up a key handler that stores the current state of the left,\nright, and up arrow keys. We will also want to call preventDefault for those\nkeys so that they don\u2019t end up scrolling the page.\nThe following function, when given an array of key names, will return an\nobject that tracks the current position of those keys. It registers event handlers\nfor \"keydown\" and \"keyup\" events and, when the key code in the event is present\nin the set of codes that it is tracking, updates the object.\nfunction trackKeys(keys) {\nlet down = Object.create(null);\n268\nfunction track(event) {\nif (keys.includes(event.key)) {\ndown[event.key] = event.type == \"keydown\";\nevent.preventDefault();\n}\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_626",
    "text": "function trackKeys(keys) {\nlet down = Object.create(null);\n268\nfunction track(event) {\nif (keys.includes(event.key)) {\ndown[event.key] = event.type == \"keydown\";\nevent.preventDefault();\n}\n}\nwindow.addEventListener(\"keydown\", track);\nwindow.addEventListener(\"keyup\", track);\nreturn down;\n}\nconst arrowKeys =\ntrackKeys([\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\"]);\nThe same handler function is used for both event types. It looks at the event\nobject\u2019s type property to determine whether the key state should be updated\nto true (\"keydown\") or false (\"keyup\").\nRunning the game\nThe requestAnimationFrame function, which we saw in Chapter 14, provides\na good way to animate a game. But its interface is quite primitive\u2014using it\nrequires us to track the time at which our function was called the last time\naround and call requestAnimationFrame again after every frame.\nLet\u2019s define a helper function that wraps all that in a convenient interface",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_627",
    "text": "around and call requestAnimationFrame again after every frame.\nLet\u2019s define a helper function that wraps all that in a convenient interface\nand allows us to simply call runAnimation, giving it a function that expects\na time difference as an argument and draws a single frame. When the frame\nfunction returns the value false, the animation stops.\nfunction runAnimation(frameFunc) {\nlet lastTime = null;\nfunction frame(time) {\nif (lastTime != null) {\nlet timeStep = Math.min(time - lastTime, 100) / 1000;\nif (frameFunc(timeStep) === false) return;\n}\nlastTime = time;\nrequestAnimationFrame(frame);\n}\nrequestAnimationFrame(frame);\n}\nI have set a maximum frame step of 100 milliseconds (one-tenth of a second).\nWhen the browser tab or window with our page is hidden, requestAnimationFrame\n269\ncalls will be suspended until the tab or window is shown again. In this case,\nthe difference between lastTime and time will be the entire time in which the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_628",
    "text": "269\ncalls will be suspended until the tab or window is shown again. In this case,\nthe difference between lastTime and time will be the entire time in which the\npage was hidden. Advancing the game by that much in a single step would\nlook silly and might cause weird side effects, such as the player falling through\nthe floor.\nThe function also converts the time steps to seconds, which are an easier\nquantity to think about than milliseconds.\nThe runLevel function takes a Level object and a display constructor and\nreturns a promise. It displays the level (in document.body) and lets the user\nplay through it. When the level is finished (lost or won), runLevel waits one\nmore second (to let the user see what happens) and then clears the display,\nstops the animation, and resolves the promise to the game\u2019s end status.\nfunction runLevel(level, Display) {\nlet display = new Display(document.body, level);\nlet state = State.start(level);\nlet ending = 1;\nreturn new Promise(resolve => {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_629",
    "text": "function runLevel(level, Display) {\nlet display = new Display(document.body, level);\nlet state = State.start(level);\nlet ending = 1;\nreturn new Promise(resolve => {\nrunAnimation(time => {\nstate = state.update(time, arrowKeys);\ndisplay.syncState(state);\nif (state.status == \"playing\") {\nreturn true;\n} else if (ending > 0) {\nending -= time;\nreturn true;\n} else {\ndisplay.clear();\nresolve(state.status);\nreturn false;\n}\n});\n});\n}\nA game is a sequence of levels. Whenever the player dies, the current level\nis restarted. When a level is completed, we move on to the next level. This\ncan be expressed by the following function, which takes an array of level plans\n(strings) and a display constructor:\nasync function runGame(plans, Display) {\nfor (let level = 0; level < plans.length;) {\nlet status = await runLevel(new Level(plans[level]),\nDisplay);\n270\nif (status == \"won\") level++;\n}\nconsole.log(\"You've won!\");\n}\nBecause we made runLevel return a promise, runGame can be written using an",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_630",
    "text": "Display);\n270\nif (status == \"won\") level++;\n}\nconsole.log(\"You've won!\");\n}\nBecause we made runLevel return a promise, runGame can be written using an\nasync function, as shown in Chapter 11. It returns another promise, which\nresolves when the player finishes the game.\nThere is a set of level plans available in the GAME_LEVELS binding in this\nchapter\u2019s sandbox (https://eloquentjavascript.net/code#16). This page feeds\nthem to runGame, starting an actual game.\n<link rel=\"stylesheet\" href=\"css/game.css\">\n<body>\n<script>\nrunGame(GAME_LEVELS, DOMDisplay);\n</script>\n</body>\nExercises\nGame over\nIt\u2019s traditional for platform games to have the player start with a limited num-\nber of lives and subtract one life each time they die. When the player is out of\nlives, the game restarts from the beginning.\nAdjust runGame to implement lives. Have the player start with three. Output\nthe current number of lives (using console.log) every time a level starts.\nPausing the game",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_631",
    "text": "Adjust runGame to implement lives. Have the player start with three. Output\nthe current number of lives (using console.log) every time a level starts.\nPausing the game\nMake it possible to pause (suspend) and unpause the game by pressing esc.\nYou can do this by changing the runLevel function to set up a keyboard event\nhandler that interrupts or resumes the animation whenever esc is hit.\nThe runAnimation interface may not look like it is suitable for this at first\nglance, but it is if you rearrange the way runLevel calls it.\nWhen you have that working, there\u2019s something else you can try. The way\nwe\u2019ve been registering keyboard event handlers is somewhat problematic. The\narrowKeys object is currently a global binding, and its event handlers are kept\naround even when no game is running. You could say they leak out of our\nsystem. Extend trackKeys to provide a way to unregister its handlers, then\n271\nchange runLevel to register its handlers when it starts and unregister them",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_632",
    "text": "system. Extend trackKeys to provide a way to unregister its handlers, then\n271\nchange runLevel to register its handlers when it starts and unregister them\nagain when it is finished.\nA monster\nIt is traditional for platform games to have enemies that you can defeat by\njumping on top of them. This exercise asks you to add such an actor type to\nthe game.\nWe\u2019ll call this actor a monster. Monsters move only horizontally. You can\nmake them move in the direction of the player, bounce back and forth like\nhorizontal lava, or have any other movement pattern you want.\nThe class\ndoesn\u2019t have to handle falling, but it should make sure the monster doesn\u2019t\nwalk through walls.\nWhen a monster touches the player, the effect depends on whether the player\nis jumping on top of them or not.\nYou can approximate this by checking\nwhether the player\u2019s bottom is near the monster\u2019s top. If this is the case, the\nmonster disappears. If not, the game is lost.\n272\n\u201cDrawing is deception.\u201d",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_633",
    "text": "You can approximate this by checking\nwhether the player\u2019s bottom is near the monster\u2019s top. If this is the case, the\nmonster disappears. If not, the game is lost.\n272\n\u201cDrawing is deception.\u201d\n\u2014M.C. Escher, cited by Bruno Ernst in The Magic Mirror of M.C.\nEscher\nChapter 17\nDrawing on Canvas\nBrowsers give us several ways to display graphics. The simplest way is to use\nstyles to position and color regular DOM elements. This can get us quite far,\nas the game in the previous chapter showed. By adding partially transparent\nbackground images to the nodes, we can make them look exactly the way we\nwant. It is even possible to rotate or skew nodes with the transform style.\nBut we\u2019d be using the DOM for something that it wasn\u2019t originally designed\nfor. Some tasks, such as drawing a line between arbitrary points, are extremely\nawkward to do with regular HTML elements.\nThere are two alternatives. The first is DOM based but utilizes Scalable",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_634",
    "text": "for. Some tasks, such as drawing a line between arbitrary points, are extremely\nawkward to do with regular HTML elements.\nThere are two alternatives. The first is DOM based but utilizes Scalable\nVector Graphics (SVG) rather than HTML. Think of SVG as a document-\nmarkup dialect that focuses on shapes rather than text. You can embed an\nSVG document directly in an HTML document or include it with an <img> tag.\nThe second alternative is called a canvas. A canvas is a single DOM element\nthat encapsulates a picture. It provides a programming interface for drawing\nshapes onto the space taken up by the node. The main difference between a\ncanvas and an SVG picture is that in SVG the original description of the shapes\nis preserved so that they can be moved or resized at any time. A canvas, on\nthe other hand, converts the shapes to pixels (colored dots on a raster) as soon\nas they are drawn and does not remember what these pixels represent. The",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_635",
    "text": "the other hand, converts the shapes to pixels (colored dots on a raster) as soon\nas they are drawn and does not remember what these pixels represent. The\nonly way to move a shape on a canvas is to clear the canvas (or the part of the\ncanvas around the shape) and redraw it with the shape in a new position.\nSVG\nThis book won\u2019t go into SVG in detail, but I\u2019ll briefly explain how it works. At\nthe end of the chapter, I\u2019ll come back to the trade-offs that you must consider\nwhen deciding which drawing mechanism is appropriate for a given application.\nThis is an HTML document with a simple SVG picture in it:\n<p>Normal HTML here.</p>\n<svg xmlns=\"http://www.w3.org/2000/svg\">\n273\n<circle r=\"50\" cx=\"50\" cy=\"50\" fill=\"red\"/>\n<rect x=\"120\" y=\"5\" width=\"90\" height=\"90\"\nstroke=\"blue\" fill=\"none\"/>\n</svg>\nThe xmlns attribute changes an element (and its children) to a different XML\nnamespace. This namespace, identified by a URL, specifies the dialect that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_636",
    "text": "stroke=\"blue\" fill=\"none\"/>\n</svg>\nThe xmlns attribute changes an element (and its children) to a different XML\nnamespace. This namespace, identified by a URL, specifies the dialect that\nwe are currently speaking. The <circle> and <rect> tags, which do not exist\nin HTML, do have a meaning in SVG\u2014they draw shapes using the style and\nposition specified by their attributes.\nThe document is displayed like this:\nThese tags create DOM elements, just like HTML tags, that scripts can\ninteract with. For example, this changes the <circle> element to be colored\ncyan instead:\nlet circle = document.querySelector(\"circle\");\ncircle.setAttribute(\"fill\", \"cyan\");\nThe canvas element\nCanvas graphics can be drawn onto a <canvas> element. You can give such an\nelement width and height attributes to determine its size in pixels.\nA new canvas is empty, meaning it is entirely transparent and thus shows up\nas empty space in the document.\nThe <canvas> tag is intended to allow different styles of drawing. To get",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_637",
    "text": "A new canvas is empty, meaning it is entirely transparent and thus shows up\nas empty space in the document.\nThe <canvas> tag is intended to allow different styles of drawing. To get\naccess to an actual drawing interface, we first need to create a context, an\nobject whose methods provide the drawing interface. There are currently three\nwidely supported drawing styles: \"2d\" for two-dimensional graphics, \"webgl\"\nfor three-dimensional graphics through the OpenGL interface, and \"webgpu\", a\nmore modern and flexible alternative to WebGL.\nThis book won\u2019t discuss WebGL or WebGPU\u2014we\u2019ll stick to two dimensions.\nBut if you are interested in three-dimensional graphics, I do encourage you to\nlook into WebGPU. It provides a direct interface to graphics hardware and\nallows you to render even complicated scenes e\ufb00iciently, using JavaScript.\n274\nYou create a context with the getContext method on the <canvas> DOM\nelement.\n<p>Before canvas.</p>\n<canvas width=\"120\" height=\"60\"></canvas>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_638",
    "text": "274\nYou create a context with the getContext method on the <canvas> DOM\nelement.\n<p>Before canvas.</p>\n<canvas width=\"120\" height=\"60\"></canvas>\n<p>After canvas.</p>\n<script>\nlet canvas = document.querySelector(\"canvas\");\nlet context = canvas.getContext(\"2d\");\ncontext.fillStyle = \"red\";\ncontext.fillRect(10, 10, 100, 50);\n</script>\nAfter creating the context object, the example draws a red rectangle that is\n100 pixels wide and 50 pixels high, with its upper-left corner at coordinates\n(10, 10).\nJust like in HTML (and SVG), the coordinate system that the canvas uses\nputs (0, 0) at the upper-left corner, and the positive y-axis goes down from\nthere. This means (10, 10) is 10 pixels below and to the right of the upper-left\ncorner.\nLines and surfaces\nIn the canvas interface, a shape can be filled, meaning its area is given a certain\ncolor or pattern, or it can be stroked, which means a line is drawn along its\nedge. SVG uses the same terminology.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_639",
    "text": "In the canvas interface, a shape can be filled, meaning its area is given a certain\ncolor or pattern, or it can be stroked, which means a line is drawn along its\nedge. SVG uses the same terminology.\nThe fillRect method fills a rectangle. It takes first the x- and y-coordinates\nof the rectangle\u2019s upper-left corner, then its width, and then its height.\nA\nsimilar method called strokeRect draws the outline of a rectangle.\nNeither method takes any further parameters. The color of the fill, thickness\nof the stroke, and so on, are not determined by an argument to the method, as\nyou might reasonably expect, but rather by properties of the context object.\nThe fillStyle property controls the way shapes are filled. It can be set to\na string that specifies a color, using the color notation used by CSS.\n275\nThe strokeStyle property works similarly but determines the color used for\na stroked line. The width of that line is determined by the lineWidth property,\nwhich may contain any positive number.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_640",
    "text": "275\nThe strokeStyle property works similarly but determines the color used for\na stroked line. The width of that line is determined by the lineWidth property,\nwhich may contain any positive number.\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.strokeStyle = \"blue\";\ncx.strokeRect(5, 5, 50, 50);\ncx.lineWidth = 5;\ncx.strokeRect(135, 5, 50, 50);\n</script>\nThis code draws two blue squares, using a thicker line for the second one.\nWhen no width or height attribute is specified, as in the example, a canvas\nelement gets a default width of 300 pixels and height of 150 pixels.\nPaths\nA path is a sequence of lines. The 2D canvas interface takes a peculiar approach\nto describing such a path. It is done entirely through side effects. Paths are\nnot values that can be stored and passed around. Instead, if you want to do\nsomething with a path, you make a sequence of method calls to describe its\nshape.\n<canvas></canvas>\n<script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_641",
    "text": "not values that can be stored and passed around. Instead, if you want to do\nsomething with a path, you make a sequence of method calls to describe its\nshape.\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\nfor (let y = 10; y < 100; y += 10) {\ncx.moveTo(10, y);\ncx.lineTo(90, y);\n}\ncx.stroke();\n</script>\nThis example creates a path with a number of horizontal line segments and\nthen strokes it using the stroke method. Each segment created with lineTo\nstarts at the path\u2019s current position. That position is usually the end of the\n276\nlast segment, unless moveTo was called. In that case, the next segment would\nstart at the position passed to moveTo.\nThe path described by the previous program looks like this:\nWhen filling a path (using the fill method), each shape is filled separately.\nA path can contain multiple shapes\u2014each moveTo motion starts a new one.\nBut the path needs to be closed (meaning its start and end are in the same",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_642",
    "text": "A path can contain multiple shapes\u2014each moveTo motion starts a new one.\nBut the path needs to be closed (meaning its start and end are in the same\nposition) before it can be filled. If the path is not already closed, a line is added\nfrom its end to its start, and the shape enclosed by the completed path is filled.\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\ncx.moveTo(50, 10);\ncx.lineTo(10, 70);\ncx.lineTo(90, 70);\ncx.fill();\n</script>\nThis example draws a filled triangle. Note that only two of the triangle\u2019s sides\nare explicitly drawn. The third, from the lower-right corner back to the top, is\nimplied and wouldn\u2019t be there if you stroked the path.\nYou could also use the closePath method to explicitly close a path by adding\nan actual line segment back to the path\u2019s start. This segment is drawn when\nstroking the path.\nCurves\nA path may also contain curved lines. These are unfortunately a bit more\ninvolved to draw.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_643",
    "text": "an actual line segment back to the path\u2019s start. This segment is drawn when\nstroking the path.\nCurves\nA path may also contain curved lines. These are unfortunately a bit more\ninvolved to draw.\nThe quadraticCurveTo method draws a curve to a given point. To determine\nthe curvature of the line, the method is given a control point as well as a\n277\ndestination point. Imagine this control point as attracting the line, giving it\nits curve. The line won\u2019t go through the control point, but its direction at the\nstart and end points will be such that a straight line in that direction would\npoint toward the control point. The following example illustrates this:\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\ncx.moveTo(10, 90);\n// control=(60, 10) goal=(90, 90)\ncx.quadraticCurveTo(60, 10, 90, 90);\ncx.lineTo(60, 10);\ncx.closePath();\ncx.stroke();\n</script>\nIt produces a path that looks like this:",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_644",
    "text": "cx.moveTo(10, 90);\n// control=(60, 10) goal=(90, 90)\ncx.quadraticCurveTo(60, 10, 90, 90);\ncx.lineTo(60, 10);\ncx.closePath();\ncx.stroke();\n</script>\nIt produces a path that looks like this:\nWe draw a quadratic curve from the left to the right, with (60, 10) as the\ncontrol point, and then draw two line segments going through that control\npoint and back to the start of the line. The result somewhat resembles a Star\nTrek insignia. You can see the effect of the control point: the lines leaving\nthe lower corners start off in the direction of the control point and then curve\ntoward their target.\nThe bezierCurveTo method draws a similar kind of curve. Instead of a single\ncontrol point, this method has two\u2014one for each of the line\u2019s end points. Here\nis a similar sketch to illustrate the behavior of such a curve:\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\ncx.moveTo(10, 90);\n// control1=(10, 10) control2=(90, 10) goal=(50, 90)",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_645",
    "text": "<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\ncx.moveTo(10, 90);\n// control1=(10, 10) control2=(90, 10) goal=(50, 90)\ncx.bezierCurveTo(10, 10, 90, 10, 50, 90);\ncx.lineTo(90, 10);\ncx.lineTo(10, 10);\ncx.closePath();\n278\ncx.stroke();\n</script>\nThe two control points specify the direction at both ends of the curve. The\nfarther they are away from their corresponding point, the more the curve will\n\u201cbulge\u201d in that direction.\nSuch curves can be hard to work with\u2014it\u2019s not always clear how to find the\ncontrol points that provide the shape you are looking for. Sometimes you can\ncompute them, and sometimes you\u2019ll just have to find a suitable value by trial\nand error.\nThe arc method is a way to draw a line that curves along the edge of a circle.\nIt takes a pair of coordinates for the arc\u2019s center, a radius, and then a start\nangle and end angle.\nThose last two parameters make it possible to draw only part of the circle.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_646",
    "text": "It takes a pair of coordinates for the arc\u2019s center, a radius, and then a start\nangle and end angle.\nThose last two parameters make it possible to draw only part of the circle.\nThe angles are measured in radians, not degrees. This means a full circle has\nan angle of 2\u03c0, or 2 * Math.PI, which is about 6.28. The angle starts counting\nat the point to the right of the circle\u2019s center and goes clockwise from there.\nYou can use a start of 0 and an end bigger than 2\u03c0 (say, 7) to draw a full circle.\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.beginPath();\n// center=(50, 50) radius=40 angle=0 to 7\ncx.arc(50, 50, 40, 0, 7);\n// center=(150, 50) radius=40 angle=0 to \u03c0\u00bd\ncx.arc(150, 50, 40, 0, 0.5 * Math.PI);\ncx.stroke();\n</script>\nThe resulting picture contains a line from the right of the full circle (first call\nto arc) to the right of the quarter-circle (second call).\n279\nLike other path-drawing methods, a line drawn with arc is connected to the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_647",
    "text": "to arc) to the right of the quarter-circle (second call).\n279\nLike other path-drawing methods, a line drawn with arc is connected to the\nprevious path segment.You can call moveTo or start a new path to avoid this.\nDrawing a pie chart\nImagine you\u2019ve just taken a job at EconomiCorp, Inc. Your first assignment is\nto draw a pie chart of its customer satisfaction survey results.\nThe results binding contains an array of objects that represent the survey\nresponses.\nconst results = [\n{name: \"Satisfied\", count: 1043, color: \"lightblue\"},\n{name: \"Neutral\", count: 563, color: \"lightgreen\"},\n{name: \"Unsatisfied\", count: 510, color: \"pink\"},\n{name: \"No comment\", count: 175, color: \"silver\"}\n];\nTo draw a pie chart, we draw a number of pie slices, each made up of an arc\nand a pair of lines to the center of that arc. We can compute the angle taken\nup by each arc by dividing a full circle (2\u03c0) by the total number of responses\nand then multiplying that number (the angle per response) by the number of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_648",
    "text": "up by each arc by dividing a full circle (2\u03c0) by the total number of responses\nand then multiplying that number (the angle per response) by the number of\npeople who picked a given choice.\n<canvas width=\"200\" height=\"200\"></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet total = results\n.reduce((sum, {count}) => sum + count, 0);\n// Start at the top\nlet currentAngle = -0.5 * Math.PI;\nfor (let result of results) {\nlet sliceAngle = (result.count / total) * 2 * Math.PI;\ncx.beginPath();\n// center=100,100, radius=100\n// from current angle, clockwise by slice's angle\ncx.arc(100, 100, 100,\ncurrentAngle, currentAngle + sliceAngle);\ncurrentAngle += sliceAngle;\ncx.lineTo(100, 100);\ncx.fillStyle = result.color;\ncx.fill();\n}\n</script>\n280\nThis draws the following chart:\nBut a chart that doesn\u2019t tell us what the slices mean isn\u2019t very helpful. We\nneed a way to draw text to the canvas.\nText\nA 2D canvas drawing context provides the methods fillText and strokeText.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_649",
    "text": "But a chart that doesn\u2019t tell us what the slices mean isn\u2019t very helpful. We\nneed a way to draw text to the canvas.\nText\nA 2D canvas drawing context provides the methods fillText and strokeText.\nThe latter can be useful for outlining letters, but usually fillText is what you\nneed. It will fill the outline of the given text with the current fillStyle.\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.font = \"28px Georgia\";\ncx.fillStyle = \"fuchsia\";\ncx.fillText(\"I can draw text, too!\", 10, 50);\n</script>\nYou can specify the size, style, and font of the text with the font property.\nThis example just gives a font size and family name. It is also possible to add\nitalic or bold to the start of the string to select a style.\nThe last two arguments to fillText and strokeText provide the position at\nwhich the font is drawn. By default, they indicate the position of the start\nof the text\u2019s alphabetic baseline, which is the line that letters \u201cstand\u201d on, not",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_650",
    "text": "which the font is drawn. By default, they indicate the position of the start\nof the text\u2019s alphabetic baseline, which is the line that letters \u201cstand\u201d on, not\ncounting hanging parts in letters such as j or p. You can change the horizontal\nposition by setting the textAlign property to \"end\" or \"center\" and the vertical\nposition by setting textBaseline to \"top\", \"middle\", or \"bottom\".\nWe\u2019ll come back to our pie chart, and the problem of labeling the slices, in\nthe exercises at the end of the chapter.\n281\nImages\nIn computer graphics, a distinction is often made between vector graphics and\nbitmap graphics. The first is what we have been doing so far in this chapter\u2014\nspecifying a picture by giving a logical description of shapes. Bitmap graphics,\non the other hand, don\u2019t specify actual shapes but rather work with pixel data\n(rasters of colored dots).\nThe drawImage method allows us to draw pixel data onto a canvas. This",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_651",
    "text": "on the other hand, don\u2019t specify actual shapes but rather work with pixel data\n(rasters of colored dots).\nThe drawImage method allows us to draw pixel data onto a canvas. This\npixel data can originate from an <img> element or from another canvas. The\nfollowing example creates a detached <img> element and loads an image file\ninto it. But the method cannot immediately start drawing from this picture\nbecause the browser may not have loaded it yet. To deal with this, we register\na \"load\" event handler and do the drawing after the image has loaded.\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet img = document.createElement(\"img\");\nimg.src = \"img/hat.png\";\nimg.addEventListener(\"load\", () => {\nfor (let x = 10; x < 200; x += 30) {\ncx.drawImage(img, x, 10);\n}\n});\n</script>\nBy default, drawImage will draw the image at its original size. You can also\ngive it two additional arguments to specify the width and height of the drawn",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_652",
    "text": "cx.drawImage(img, x, 10);\n}\n});\n</script>\nBy default, drawImage will draw the image at its original size. You can also\ngive it two additional arguments to specify the width and height of the drawn\nimage, when those aren\u2019t the same as the origin image.\nWhen drawImage is given nine arguments, it can be used to draw only a frag-\nment of an image. The second through fifth arguments indicate the rectangle\n(x, y, width, and height) in the source image that should be copied, and the\nsixth to ninth arguments give the rectangle (on the canvas) into which it should\nbe copied.\nThis can be used to pack multiple sprites (image elements) into a single\nimage file and then draw only the part you need. For example, this picture\ncontains a game character in multiple poses:\nBy alternating which pose we draw, we can show an animation that looks\nlike a walking character.\n282\nTo animate a picture on a canvas, the clearRect method is useful. It resem-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_653",
    "text": "By alternating which pose we draw, we can show an animation that looks\nlike a walking character.\n282\nTo animate a picture on a canvas, the clearRect method is useful. It resem-\nbles fillRect, but instead of coloring the rectangle, it makes it transparent,\nremoving the previously drawn pixels.\nWe know that each sprite, each subpicture, is 24 pixels wide and 30 pixels\nhigh. The following code loads the image and then sets up an interval (repeated\ntimer) to draw the next frame:\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet img = document.createElement(\"img\");\nimg.src = \"img/player.png\";\nlet spriteW = 24, spriteH = 30;\nimg.addEventListener(\"load\", () => {\nlet cycle = 0;\nsetInterval(() => {\ncx.clearRect(0, 0, spriteW, spriteH);\ncx.drawImage(img,\n// source rectangle\ncycle * spriteW, 0, spriteW, spriteH,\n// destination rectangle\n0,\n0, spriteW, spriteH);\ncycle = (cycle + 1) % 8;\n}, 120);\n});\n</script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_654",
    "text": "cx.drawImage(img,\n// source rectangle\ncycle * spriteW, 0, spriteW, spriteH,\n// destination rectangle\n0,\n0, spriteW, spriteH);\ncycle = (cycle + 1) % 8;\n}, 120);\n});\n</script>\nThe cycle binding tracks our position in the animation. For each frame, it is\nincremented and then clipped back to the 0 to 7 range by using the remainder\noperator. This binding is then used to compute the x-coordinate that the sprite\nfor the current pose has in the picture.\nTransformation\nWhat if we want our character to walk to the left instead of to the right? We\ncould draw another set of sprites, of course. But we could also instruct the\ncanvas to draw the picture the other way round.\nCalling the scale method will cause anything drawn after it to be scaled.\nThis method takes two parameters, one to set a horizontal scale and one to set\na vertical scale.\n<canvas></canvas>\n<script>\n283\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.scale(3, .5);\ncx.beginPath();\ncx.arc(50, 50, 40, 0, 7);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_655",
    "text": "a vertical scale.\n<canvas></canvas>\n<script>\n283\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\ncx.scale(3, .5);\ncx.beginPath();\ncx.arc(50, 50, 40, 0, 7);\ncx.lineWidth = 3;\ncx.stroke();\n</script>\nBecause of the call to scale, the circle is drawn three times as wide and half\nas high.\nScaling will cause everything about the drawn image, including the line\nwidth, to be stretched out or squeezed together as specified.\nScaling by a\nnegative amount will flip the picture around. The flipping happens around\npoint (0, 0), which means it will also flip the direction of the coordinate sys-\ntem. When a horizontal scaling of -1 is applied, a shape drawn at x position\n100 will end up at what used to be position -100.\nTo turn a picture around, we can\u2019t simply add cx.scale(-1, 1) before the\ncall to drawImage. That would move our picture outside of the canvas, where it\nwon\u2019t be visible. We could adjust the coordinates given to drawImage to com-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_656",
    "text": "call to drawImage. That would move our picture outside of the canvas, where it\nwon\u2019t be visible. We could adjust the coordinates given to drawImage to com-\npensate for this by drawing the image at x position -50 instead of 0. Another\nsolution, which doesn\u2019t require the code doing the drawing to know about the\nscale change, is to adjust the axis around which the scaling happens.\nThere are several other methods besides scale that influence the coordinate\nsystem for a canvas. You can rotate subsequently drawn shapes with the rotate\nmethod and move them with the translate method.\nThe interesting\u2014and\nconfusing\u2014thing is that these transformations stack, meaning that each one\nhappens relative to the previous transformations.\nIf we translate by 10 horizontal pixels twice, everything will be drawn 20\npixels to the right. If we first move the center of the coordinate system to\n(50, 50) and then rotate by 20 degrees (about 0.1\u03c0 radians), that rotation will\nhappen around point (50, 50).",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_657",
    "text": "pixels to the right. If we first move the center of the coordinate system to\n(50, 50) and then rotate by 20 degrees (about 0.1\u03c0 radians), that rotation will\nhappen around point (50, 50).\ntranslate(50, 50)\nrotate(0.1*Math.PI)\nrotate(0.1*Math.PI)\ntranslate(50, 50)\n284\nBut if we first rotate by 20 degrees and then translate by (50, 50), the\ntranslation will happen in the rotated coordinate system and thus produce a\ndifferent orientation. The order in which transformations are applied matters.\nTo flip a picture around the vertical line at a given x position, we can do the\nfollowing:\nfunction flipHorizontally(context, around) {\ncontext.translate(around, 0);\ncontext.scale(-1, 1);\ncontext.translate(-around, 0);\n}\nWe move the y-axis to where we want our mirror to be, apply the mirroring,\nand finally move the y-axis back to its proper place in the mirrored universe.\nThe following picture explains why this works:\nmirror\n1\n2\n3\n4",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_658",
    "text": "and finally move the y-axis back to its proper place in the mirrored universe.\nThe following picture explains why this works:\nmirror\n1\n2\n3\n4\nThis shows the coordinate systems before and after mirroring across the\ncentral line. The triangles are numbered to illustrate each step. If we draw a\ntriangle at a positive x position, it would, by default, be in the place where\ntriangle 1 is. A call to flipHorizontally first does a translation to the right,\nwhich gets us to triangle 2. It then scales, flipping the triangle over to position\n3. This is not where it should be, if it were mirrored in the given line. The\nsecond translate call fixes this\u2014it \u201ccancels\u201d the initial translation and makes\ntriangle 4 appear exactly where it should.\nWe can now draw a mirrored character at position (100, 0) by flipping the\nworld around the character\u2019s vertical center.\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet img = document.createElement(\"img\");",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_659",
    "text": "world around the character\u2019s vertical center.\n<canvas></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nlet img = document.createElement(\"img\");\nimg.src = \"img/player.png\";\nlet spriteW = 24, spriteH = 30;\nimg.addEventListener(\"load\", () => {\nflipHorizontally(cx, 100 + spriteW / 2);\n285\ncx.drawImage(img, 0, 0, spriteW, spriteH,\n100, 0, spriteW, spriteH);\n});\n</script>\nStoring and clearing transformations\nTransformations stick around.\nEverything else we draw after drawing that\nmirrored character would also be mirrored. That might be inconvenient.\nIt is possible to save the current transformation, do some drawing and trans-\nforming, and then restore the old transformation. This is usually the proper\nthing to do for a function that needs to temporarily transform the coordinate\nsystem. First, we save whatever transformation the code that called the func-\ntion was using. Then the function does its thing, adding more transformations",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_660",
    "text": "system. First, we save whatever transformation the code that called the func-\ntion was using. Then the function does its thing, adding more transformations\non top of the current transformation. Finally, we revert to the transformation\nwe started with.\nThe save and restore methods on the 2D canvas context do this transfor-\nmation management. They conceptually keep a stack of transformation states.\nWhen you call save, the current state is pushed onto the stack, and when you\ncall restore, the state on top of the stack is taken off and used as the context\u2019s\ncurrent transformation. You can also call resetTransform to fully reset the\ntransformation.\nThe branch function in the following example illustrates what you can do\nwith a function that changes the transformation and then calls a function (in\nthis case itself), which continues drawing with the given transformation.\nThis function draws a treelike shape by drawing a line, moving the center",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_661",
    "text": "this case itself), which continues drawing with the given transformation.\nThis function draws a treelike shape by drawing a line, moving the center\nof the coordinate system to the end of the line, and calling itself twice\u2014first\nrotated to the left and then rotated to the right. Every call reduces the length\nof the branch drawn, and the recursion stops when the length drops below 8.\n<canvas width=\"600\" height=\"300\"></canvas>\n<script>\nlet cx = document.querySelector(\"canvas\").getContext(\"2d\");\nfunction branch(length, angle, scale) {\ncx.fillRect(0, 0, 1, length);\nif (length < 8) return;\ncx.save();\ncx.translate(0, length);\ncx.rotate(-angle);\nbranch(length * scale, angle, scale);\ncx.rotate(2 * angle);\n286\nbranch(length * scale, angle, scale);\ncx.restore();\n}\ncx.translate(300, 0);\nbranch(60, 0.5, 0.8);\n</script>\nThe result is a simple fractal.\nIf the calls to save and restore were not there, the second recursive call to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_662",
    "text": "cx.restore();\n}\ncx.translate(300, 0);\nbranch(60, 0.5, 0.8);\n</script>\nThe result is a simple fractal.\nIf the calls to save and restore were not there, the second recursive call to\nbranch would end up with the position and rotation created by the first call.\nIt would be connected not to the current branch but rather to the innermost,\nrightmost branch drawn by the first call. The resulting shape might also be\ninteresting, but it is definitely not a tree.\nBack to the game\nWe now know enough about canvas drawing to start working on a canvas-based\ndisplay system for the game from the previous chapter. The new display will\nno longer be showing just colored boxes. Instead, we\u2019ll use drawImage to draw\npictures that represent the game\u2019s elements.\nWe define another display object type called CanvasDisplay, supporting the\nsame interface as DOMDisplay from Chapter 16\u2014namely, the methods syncState\nand clear.\nThis object keeps a little more information than DOMDisplay. Rather than",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_663",
    "text": "same interface as DOMDisplay from Chapter 16\u2014namely, the methods syncState\nand clear.\nThis object keeps a little more information than DOMDisplay. Rather than\nusing the scroll position of its DOM element, it tracks its own viewport, which\ntells us which part of the level we are currently looking at. Finally, it keeps\na flipPlayer property so that even when the player is standing still, it keeps\nfacing the direction in which it last moved.\nclass CanvasDisplay {\nconstructor(parent, level) {\nthis.canvas = document.createElement(\"canvas\");\nthis.canvas.width = Math.min(600, level.width * scale);\n287\nthis.canvas.height = Math.min(450, level.height * scale);\nparent.appendChild(this.canvas);\nthis.cx = this.canvas.getContext(\"2d\");\nthis.flipPlayer = false;\nthis.viewport = {\nleft: 0,\ntop: 0,\nwidth: this.canvas.width / scale,\nheight: this.canvas.height / scale\n};\n}\nclear() {\nthis.canvas.remove();\n}\n}\nThe syncState method first computes a new viewport and then draws the game",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_664",
    "text": "top: 0,\nwidth: this.canvas.width / scale,\nheight: this.canvas.height / scale\n};\n}\nclear() {\nthis.canvas.remove();\n}\n}\nThe syncState method first computes a new viewport and then draws the game\nscene at the appropriate position.\nCanvasDisplay.prototype.syncState = function(state) {\nthis.updateViewport(state);\nthis.clearDisplay(state.status);\nthis.drawBackground(state.level);\nthis.drawActors(state.actors);\n};\nContrary to DOMDisplay, this display style does have to redraw the background\non every update. Because shapes on a canvas are just pixels, after we draw\nthem there is no good way to move them (or remove them). The only way to\nupdate the canvas display is to clear it and redraw the scene. We may also\nhave scrolled, which requires the background to be in a different position.\nThe updateViewport method is similar to DOMDisplay\u2019s scrollPlayerIntoView\nmethod. It checks whether the player is too close to the edge of the screen\nand moves the viewport when this is the case.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_665",
    "text": "The updateViewport method is similar to DOMDisplay\u2019s scrollPlayerIntoView\nmethod. It checks whether the player is too close to the edge of the screen\nand moves the viewport when this is the case.\nCanvasDisplay.prototype.updateViewport = function(state) {\nlet view = this.viewport, margin = view.width / 3;\nlet player = state.player;\nlet center = player.pos.plus(player.size.times(0.5));\nif (center.x < view.left + margin) {\nview.left = Math.max(center.x - margin, 0);\n288\n} else if (center.x > view.left + view.width - margin) {\nview.left = Math.min(center.x + margin - view.width,\nstate.level.width - view.width);\n}\nif (center.y < view.top + margin) {\nview.top = Math.max(center.y - margin, 0);\n} else if (center.y > view.top + view.height - margin) {\nview.top = Math.min(center.y + margin - view.height,\nstate.level.height - view.height);\n}\n};\nThe calls to Math.max and Math.min ensure that the viewport does not end up\nshowing space outside of the level.\nMath.max(x, 0) makes sure the resulting",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_666",
    "text": "state.level.height - view.height);\n}\n};\nThe calls to Math.max and Math.min ensure that the viewport does not end up\nshowing space outside of the level.\nMath.max(x, 0) makes sure the resulting\nnumber is not less than zero. Math.min similarly guarantees that a value stays\nbelow a given bound.\nWhen clearing the display, we\u2019ll use a slightly different color depending on\nwhether the game is won (brighter) or lost (darker).\nCanvasDisplay.prototype.clearDisplay = function(status) {\nif (status == \"won\") {\nthis.cx.fillStyle = \"rgb(68, 191, 255)\";\n} else if (status == \"lost\") {\nthis.cx.fillStyle = \"rgb(44, 136, 214)\";\n} else {\nthis.cx.fillStyle = \"rgb(52, 166, 251)\";\n}\nthis.cx.fillRect(0, 0,\nthis.canvas.width, this.canvas.height);\n};\nTo draw the background, we run through the tiles that are visible in the current\nviewport, using the same trick used in the touches method from the previous\nchapter.\nlet otherSprites = document.createElement(\"img\");\notherSprites.src = \"img/sprites.png\";",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_667",
    "text": "viewport, using the same trick used in the touches method from the previous\nchapter.\nlet otherSprites = document.createElement(\"img\");\notherSprites.src = \"img/sprites.png\";\nCanvasDisplay.prototype.drawBackground = function(level) {\nlet {left, top, width, height} = this.viewport;\nlet xStart = Math.floor(left);\nlet xEnd = Math.ceil(left + width);\nlet yStart = Math.floor(top);\nlet yEnd = Math.ceil(top + height);\n289\nfor (let y = yStart; y < yEnd; y++) {\nfor (let x = xStart; x < xEnd; x++) {\nlet tile = level.rows[y][x];\nif (tile == \"empty\") continue;\nlet screenX = (x - left) * scale;\nlet screenY = (y - top) * scale;\nlet tileX = tile == \"lava\" ? scale : 0;\nthis.cx.drawImage(otherSprites,\ntileX,\n0, scale, scale,\nscreenX, screenY, scale, scale);\n}\n}\n};\nTiles that are not empty are drawn with drawImage. The otherSprites image\ncontains the pictures used for elements other than the player. It contains, from\nleft to right, the wall tile, the lava tile, and the sprite for a coin.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_668",
    "text": "contains the pictures used for elements other than the player. It contains, from\nleft to right, the wall tile, the lava tile, and the sprite for a coin.\nBackground tiles are 20 by 20 pixels, since we\u2019ll use the same scale as in\nDOMDisplay. Thus, the offset for lava tiles is 20 (the value of the scale binding),\nand the offset for walls is 0.\nWe don\u2019t bother waiting for the sprite image to load. Calling drawImage with\nan image that hasn\u2019t been loaded yet will simply do nothing. Thus, we might\nfail to draw the game properly for the first few frames while the image is still\nloading, but that isn\u2019t a serious problem. Since we keep updating the screen,\nthe correct scene will appear as soon as the loading finishes.\nThe walking character shown earlier will be used to represent the player. The\ncode that draws it needs to pick the right sprite and direction based on the\nplayer\u2019s current motion. The first eight sprites contain a walking animation.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_669",
    "text": "code that draws it needs to pick the right sprite and direction based on the\nplayer\u2019s current motion. The first eight sprites contain a walking animation.\nWhen the player is moving along a floor, we cycle through them based on the\ncurrent time. We want to switch frames every 60 milliseconds, so the time is\ndivided by 60 first. When the player is standing still, we draw the ninth sprite.\nDuring jumps, which are recognized by the fact that the vertical speed is not\nzero, we use the tenth, rightmost sprite.\nBecause the sprites are slightly wider than the player object\u201424 instead of\n16 pixels to allow some space for feet and arms\u2014the method has to adjust the\nx-coordinate and width by a given amount (playerXOverlap).\nlet playerSprites = document.createElement(\"img\");\nplayerSprites.src = \"img/player.png\";\nconst playerXOverlap = 4;\n290\nCanvasDisplay.prototype.drawPlayer = function(player, x, y,\nwidth, height){\nwidth += playerXOverlap * 2;\nx -= playerXOverlap;\nif (player.speed.x != 0) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_670",
    "text": "const playerXOverlap = 4;\n290\nCanvasDisplay.prototype.drawPlayer = function(player, x, y,\nwidth, height){\nwidth += playerXOverlap * 2;\nx -= playerXOverlap;\nif (player.speed.x != 0) {\nthis.flipPlayer = player.speed.x < 0;\n}\nlet tile = 8;\nif (player.speed.y != 0) {\ntile = 9;\n} else if (player.speed.x != 0) {\ntile = Math.floor(Date.now() / 60) % 8;\n}\nthis.cx.save();\nif (this.flipPlayer) {\nflipHorizontally(this.cx, x + width / 2);\n}\nlet tileX = tile * width;\nthis.cx.drawImage(playerSprites, tileX, 0, width, height,\nx,\ny, width, height);\nthis.cx.restore();\n};\nThe drawPlayer method is called by drawActors, which is responsible for draw-\ning all the actors in the game.\nCanvasDisplay.prototype.drawActors = function(actors) {\nfor (let actor of actors) {\nlet width = actor.size.x * scale;\nlet height = actor.size.y * scale;\nlet x = (actor.pos.x - this.viewport.left) * scale;\nlet y = (actor.pos.y - this.viewport.top) * scale;\nif (actor.type == \"player\") {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_671",
    "text": "let height = actor.size.y * scale;\nlet x = (actor.pos.x - this.viewport.left) * scale;\nlet y = (actor.pos.y - this.viewport.top) * scale;\nif (actor.type == \"player\") {\nthis.drawPlayer(actor, x, y, width, height);\n} else {\nlet tileX = (actor.type == \"coin\" ? 2 : 1) * scale;\nthis.cx.drawImage(otherSprites,\ntileX, 0, width, height,\nx,\ny, width, height);\n}\n}\n};\n291\nWhen drawing something that is not the player, we look at its type to find the\noffset of the correct sprite. The lava tile is found at offset 20, and the coin\nsprite is found at 40 (two times scale).\nWe have to subtract the viewport\u2019s position when computing the actor\u2019s\nposition, since (0, 0) on our canvas corresponds to the top left of the viewport,\nnot the top left of the level. We could also have used translate for this. Either\nway works.\nThat concludes the new display system. The resulting game looks something\nlike this:\nChoosing a graphics interface\nWhen you need to generate graphics in the browser, you can choose between",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_672",
    "text": "way works.\nThat concludes the new display system. The resulting game looks something\nlike this:\nChoosing a graphics interface\nWhen you need to generate graphics in the browser, you can choose between\nplain HTML, SVG, and canvas. There is no single best approach that works in\nall situations. Each option has strengths and weaknesses.\nPlain HTML has the advantage of being simple. It also integrates well with\ntext. Both SVG and canvas allow you to draw text, but they won\u2019t help you\nposition that text or wrap it when it takes up more than one line.\nIn an\nHTML-based picture, it is much easier to include blocks of text.\nSVG can be used to produce crisp graphics that look good at any zoom\nlevel. Unlike HTML, it is designed for drawing and is thus more suitable for\nthat purpose.\nBoth SVG and HTML build up a data structure (the DOM) that represents\nyour picture. This makes it possible to modify elements after they are drawn.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_673",
    "text": "that purpose.\nBoth SVG and HTML build up a data structure (the DOM) that represents\nyour picture. This makes it possible to modify elements after they are drawn.\nIf you need to repeatedly change a small part of a big picture in response to\nwhat the user is doing or as part of an animation, doing it in a canvas can be\nneedlessly expensive. The DOM also allows us to register mouse event handlers\non every element in the picture (even on shapes drawn with SVG). You can\u2019t\ndo that with canvas.\n292\nBut canvas\u2019s pixel-oriented approach can be an advantage when drawing\na huge number of tiny elements. The fact that it does not build up a data\nstructure but only repeatedly draws onto the same pixel surface gives canvas\na lower cost per shape. There are also effects that are only practical with a\ncanvas element, such as rendering a scene one pixel at a time (for example,\nusing a ray tracer) or postprocessing an image with JavaScript (blurring or\ndistorting it).",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_674",
    "text": "canvas element, such as rendering a scene one pixel at a time (for example,\nusing a ray tracer) or postprocessing an image with JavaScript (blurring or\ndistorting it).\nIn some cases, you may want to combine several of these techniques. For\nexample, you might draw a graph with SVG or canvas but show textual infor-\nmation by positioning an HTML element on top of the picture.\nFor nondemanding applications, it really doesn\u2019t matter much which inter-\nface you choose. The display we built for our game in this chapter could have\nbeen implemented using any of these three graphics technologies, since it does\nnot need to draw text, handle mouse interaction, or work with an extraordi-\nnarily large number of elements.\nSummary\nIn this chapter we discussed techniques for drawing graphics in the browser,\nfocusing on the <canvas> element.\nA canvas node represents an area in a document that our program may draw\non. This drawing is done through a drawing context object, created with the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_675",
    "text": "focusing on the <canvas> element.\nA canvas node represents an area in a document that our program may draw\non. This drawing is done through a drawing context object, created with the\ngetContext method.\nThe 2D drawing interface allows us to fill and stroke various shapes. The con-\ntext\u2019s fillStyle property determines how shapes are filled. The strokeStyle\nand lineWidth properties control the way lines are drawn.\nRectangles and pieces of text can be drawn with a single method call. The\nfillRect and strokeRect methods draw rectangles, and the fillText and\nstrokeText methods draw text. To create custom shapes, we must first build\nup a path.\nCalling beginPath starts a new path. A number of other methods add lines\nand curves to the current path. For example, lineTo can add a straight line.\nWhen a path is finished, it can be filled with the fill method or stroked with\nthe stroke method.\nMoving pixels from an image or another canvas onto our canvas is done with",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_676",
    "text": "When a path is finished, it can be filled with the fill method or stroked with\nthe stroke method.\nMoving pixels from an image or another canvas onto our canvas is done with\nthe drawImage method. By default, this method draws the whole source image,\nbut by giving it more parameters, you can copy a specific area of the image.\nWe used this for our game by copying individual poses of the game character\nout of an image that contained many such poses.\n293\nTransformations allow you to draw a shape in multiple orientations. A 2D\ndrawing context has a current transformation that can be changed with the\ntranslate, scale, and rotate methods. These will affect all subsequent draw-\ning operations. A transformation state can be saved with the save method and\nrestored with the restore method.\nWhen showing an animation on a canvas, the clearRect method can be used\nto clear part of the canvas before redrawing it.\nExercises\nShapes\nWrite a program that draws the following shapes on a canvas:",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_677",
    "text": "When showing an animation on a canvas, the clearRect method can be used\nto clear part of the canvas before redrawing it.\nExercises\nShapes\nWrite a program that draws the following shapes on a canvas:\n1. A trapezoid (a rectangle that is wider on one side)\n2. A red diamond (a rectangle rotated 45 degrees or \u00bc\u03c0 radians)\n3. A zigzagging line\n4. A spiral made up of 100 straight line segments\n5. A yellow star\nWhen drawing the last two shapes, you may want to refer to the explanation\nof Math.cos and Math.sin in Chapter 14, which describes how to get coordinates\non a circle using these functions.\nI recommend creating a function for each shape.\nPass the position, and\noptionally other properties such as the size or the number of points, as param-\neters. The alternative, which is to hardcode numbers all over your code, tends\nto make the code needlessly hard to read and modify.\nThe pie chart\nEarlier in the chapter, we saw an example program that drew a pie chart.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_678",
    "text": "to make the code needlessly hard to read and modify.\nThe pie chart\nEarlier in the chapter, we saw an example program that drew a pie chart.\nModify this program so that the name of each category is shown next to the\nslice that represents it. Try to find a pleasing-looking way to automatically\n294\nposition this text that would work for other datasets as well. You may assume\nthat categories are big enough to leave enough room for their labels.\nYou might need Math.sin and Math.cos again, which are described in Chapter\n14.\nA bouncing ball\nUse the requestAnimationFrame technique that we saw in Chapter 14 and Chap-\nter 16 to draw a box with a bouncing ball in it. The ball moves at a constant\nspeed and bounces off the box\u2019s sides when it hits them.\nPrecomputed mirroring\nOne unfortunate thing about transformations is that they slow down the draw-\ning of bitmaps. The position and size of each pixel have to be transformed,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_679",
    "text": "Precomputed mirroring\nOne unfortunate thing about transformations is that they slow down the draw-\ning of bitmaps. The position and size of each pixel have to be transformed,\nand though it is possible that browsers will get cleverer about transformation\nin the future, they currently cause a measurable increase in the time it takes\nto draw a bitmap.\nIn a game like ours, where we are drawing only a single transformed sprite,\nthis is a nonissue. But imagine that we need to draw hundreds of characters\nor thousands of rotating particles from an explosion.\nThink of a way to draw an inverted character without loading additional\nimage files and without having to make transformed drawImage calls every\nframe.\n295\n\u201cWhat was often di\ufb00icult for people to understand about the design\nwas that there was nothing else beyond URLs, HTTP and HTML.\nThere was no central computer \u2018controlling\u2019 the web, no single\nnetwork on which these protocols worked, not even an organisation",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_680",
    "text": "was that there was nothing else beyond URLs, HTTP and HTML.\nThere was no central computer \u2018controlling\u2019 the web, no single\nnetwork on which these protocols worked, not even an organisation\nanywhere that \u2018ran\u2019 the Web. The Web was not a physical \u2018thing\u2019\nthat existed in a certain \u2018place\u2019. It was a \u2018space\u2019 in which\ninformation could exist.\u201d\n\u2014Tim Berners-Lee\nChapter 18\nHTTP and Forms\nThe Hypertext Transfer Protocol, introduced in Chapter 13, is the mechanism\nthrough which data is requested and provided on the World Wide Web. This\nchapter describes the protocol in more detail and explains the way browser\nJavaScript has access to it.\nThe protocol\nIf you type eloquentjavascript.net/18_http.html in your browser\u2019s address bar,\nthe browser first looks up the address of the server associated with eloquent-\njavascript.net and tries to open a TCP connection to it on port 80, the default\nport for HTTP tra\ufb00ic. If the server exists and accepts the connection, the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_681",
    "text": "javascript.net and tries to open a TCP connection to it on port 80, the default\nport for HTTP tra\ufb00ic. If the server exists and accepts the connection, the\nbrowser might send something like this:\nGET /18_http.html HTTP/1.1\nHost: eloquentjavascript.net\nUser-Agent: Your browser's name\nThen the server responds, through that same connection.\nHTTP/1.1 200 OK\nContent-Length: 87320\nContent-Type: text/html\nLast-Modified: Fri, 13 Oct 2023 10:05:41 GMT\n<!doctype html>\n... the rest of the document\nThe browser takes the part of the response after the blank line, its body (not\nto be confused with the HTML <body> tag), and displays it as an HTML\ndocument.\nThe information sent by the client is called the request. It starts with this\nline:\nGET /18_http.html HTTP/1.1\n296\nThe first word is the method of the request. GET means that we want to get the\nspecified resource. Other common methods are DELETE to delete a resource, PUT",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_682",
    "text": "line:\nGET /18_http.html HTTP/1.1\n296\nThe first word is the method of the request. GET means that we want to get the\nspecified resource. Other common methods are DELETE to delete a resource, PUT\nto create or replace it, and POST to send information to it. Note that the server\nis not obliged to carry out every request it gets. If you walk up to a random\nwebsite and tell it to DELETE its main page, it\u2019ll probably refuse.\nThe part after the method name is the path of the resource the request\napplies to. In the simplest case, a resource is simply a file on the server, but\nthe protocol doesn\u2019t require it to be. A resource may be anything that can be\ntransferred as if it is a file. Many servers generate the responses they produce\non the fly. For example, if you open https://github.com/marijnh, the server\nlooks in its database for a user named \u201cmarijnh\u201d, and if it finds one, it will\ngenerate a profile page for that user.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_683",
    "text": "on the fly. For example, if you open https://github.com/marijnh, the server\nlooks in its database for a user named \u201cmarijnh\u201d, and if it finds one, it will\ngenerate a profile page for that user.\nAfter the resource path, the first line of the request mentions HTTP/1.1 to\nindicate the version of the HTTP protocol it is using.\nIn practice, many sites use HTTP version 2, which supports the same con-\ncepts as version 1.1 but is a lot more complicated so that it can be faster.\nBrowsers will automatically switch to the appropriate protocol version when\ntalking to a given server, and the outcome of a request is the same regardless of\nwhich version is used. Because version 1.1 is more straightforward and easier\nto play around with, we\u2019ll use that to illustrate the protocol.\nThe server\u2019s response will start with a version as well, followed by the status\nof the response, first as a three-digit status code and then as a human-readable\nstring.\nHTTP/1.1 200 OK",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_684",
    "text": "The server\u2019s response will start with a version as well, followed by the status\nof the response, first as a three-digit status code and then as a human-readable\nstring.\nHTTP/1.1 200 OK\nStatus codes starting with a 2 indicate that the request succeeded.\nCodes\nstarting with 4 mean there was something wrong with the request. The most\nfamous HTTP status code is probably 404, which means that the resource\ncould not be found. Codes that start with 5 mean an error happened on the\nserver and the request is not to blame.\nThe first line of a request or response may be followed by any number of\nheaders. These are lines in the form name: value that specify extra informa-\ntion about the request or response. These headers were part of the example\nresponse:\nContent-Length: 87320\nContent-Type: text/html\nLast-Modified: Fri, 13 Oct 2023 10:05:41 GMT\nThis tells us the size and type of the response document. In this case, it is an\nHTML document of 87,320 bytes. It also tells us when that document was last",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_685",
    "text": "This tells us the size and type of the response document. In this case, it is an\nHTML document of 87,320 bytes. It also tells us when that document was last\n297\nmodified.\nThe client and server are free to decide what headers to include in their\nrequests or responses. But some of them are necessary for things to work. For\nexample, without a Content-Type header in the response, the browser won\u2019t\nknow how to display the document.\nAfter the headers, both requests and responses may include a blank line\nfollowed by a body, which contains the actual document being sent. GET and\nDELETE requests don\u2019t send along any data, but PUT and POST requests do. Some\nresponse types, such as error responses, also don\u2019t require a body.\nBrowsers and HTTP\nAs we saw, a browser will make a request when we enter a URL in its address\nbar. When the resulting HTML page references other files, such as images and\nJavaScript files, it will retrieve those as well.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_686",
    "text": "bar. When the resulting HTML page references other files, such as images and\nJavaScript files, it will retrieve those as well.\nA moderately complicated website can easily include anywhere from 10 to\n200 resources. To be able to fetch those quickly, browsers will make several GET\nrequests simultaneously, rather than waiting for the responses one at a time.\nHTML pages may include forms, which allow the user to fill out information\nand send it to the server. This is an example of a form:\n<form method=\"GET\" action=\"example/message.html\">\n<p>Name: <input type=\"text\" name=\"name\"></p>\n<p>Message:<br><textarea name=\"message\"></textarea></p>\n<p><button type=\"submit\">Send</button></p>\n</form>\nThis code describes a form with two fields: a small one asking for a name and a\nlarger one to write a message in. When you click the Send button, the form is\nsubmitted, meaning that the content of its field is packed into an HTTP request\nand the browser navigates to the result of that request.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_687",
    "text": "submitted, meaning that the content of its field is packed into an HTTP request\nand the browser navigates to the result of that request.\nWhen the <form> element\u2019s method attribute is GET (or is omitted), the in-\nformation in the form is added to the end of the action URL as a query string.\nThe browser might make a request to this URL:\nGET /example/message.html?name=Jean&message=Yes%3F HTTP/1.1\nThe question mark indicates the end of the path part of the URL and the start\nof the query. It is followed by pairs of names and values, corresponding to the\nname attribute on the form field elements and the content of those elements,\nrespectively. An ampersand character (&) is used to separate the pairs.\n298\nThe actual message encoded in the URL is \u201cYes?\u201d but the question mark is\nreplaced by a strange code. Some characters in query strings must be escaped.\nThe question mark, represented as %3F, is one of those. There seems to be",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_688",
    "text": "replaced by a strange code. Some characters in query strings must be escaped.\nThe question mark, represented as %3F, is one of those. There seems to be\nan unwritten rule that every format needs its own way of escaping characters.\nThis one, called URL encoding, uses a percent sign followed by two hexadecimal\n(base 16) digits that encode the character code. In this case, 3F, which is 63\nin decimal notation, is the code of a question mark character.\nJavaScript\nprovides the encodeURIComponent and decodeURIComponent functions to encode\nand decode this format.\nconsole.log(encodeURIComponent(\"Yes?\"));\n// \u2192Yes%3F\nconsole.log(decodeURIComponent(\"Yes%3F\"));\n// \u2192Yes?\nIf we change the method attribute of the HTML form in the example we saw\nearlier to POST, the HTTP request made to submit the form will use the POST\nmethod and put the query string in the body of the request rather than adding\nit to the URL.\nPOST /example/message.html HTTP/1.1\nContent-length: 24",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_689",
    "text": "method and put the query string in the body of the request rather than adding\nit to the URL.\nPOST /example/message.html HTTP/1.1\nContent-length: 24\nContent-type: application/x-www-form-urlencoded\nname=Jean&message=Yes%3F\nGET requests should be used for requests that do not have side effects but\nsimply ask for information. Requests that change something on the server,\nfor example creating a new account or posting a message, should be expressed\nwith other methods, such as POST. Client-side software such as a browser knows\nthat it shouldn\u2019t blindly make POST requests but will often implicitly make GET\nrequests\u2014to prefetch a resource it believes the user will soon need, for example.\nWe\u2019ll come back to forms and how to interact with them from JavaScript\nlater in the chapter.\nFetch\nThe interface through which browser JavaScript can make HTTP requests is\ncalled fetch.\nfetch(\"example/data.txt\").then(response => {\nconsole.log(response.status);\n// \u2192200\n299",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_690",
    "text": "Fetch\nThe interface through which browser JavaScript can make HTTP requests is\ncalled fetch.\nfetch(\"example/data.txt\").then(response => {\nconsole.log(response.status);\n// \u2192200\n299\nconsole.log(response.headers.get(\"Content-Type\"));\n// \u2192text/plain\n});\nCalling fetch returns a promise that resolves to a Response object holding infor-\nmation about the server\u2019s response, such as its status code and its headers. The\nheaders are wrapped in a Map-like object that treats its keys (the header names)\nas case insensitive because header names are not supposed to be case sensitive.\nThis means headers.get(\"Content-Type\") and headers.get(\"content-TYPE\")\nwill return the same value.\nNote that the promise returned by fetch resolves successfully even if the\nserver responded with an error code. It can also be rejected if there is a network\nerror or if the server to which that the request is addressed can\u2019t be found.\nThe first argument to fetch is the URL that should be requested. When",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_691",
    "text": "error or if the server to which that the request is addressed can\u2019t be found.\nThe first argument to fetch is the URL that should be requested. When\nthat URL doesn\u2019t start with a protocol name (such as http:), it is treated as\nrelative, which means it is interpreted relative to the current document. When\nit starts with a slash (/), it replaces the current path, which is the part after\nthe server name. When it does not, the part of the current path up to and\nincluding its last slash character is put in front of the relative URL.\nTo get at the actual content of a response, you can use its text method.\nBecause the initial promise is resolved as soon as the response\u2019s headers have\nbeen received and because reading the response body might take a while longer,\nthis again returns a promise.\nfetch(\"example/data.txt\")\n.then(resp => resp.text())\n.then(text => console.log(text));\n// \u2192This is the content of data.txt\nA similar method, called json, returns a promise that resolves to the value you",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_692",
    "text": ".then(resp => resp.text())\n.then(text => console.log(text));\n// \u2192This is the content of data.txt\nA similar method, called json, returns a promise that resolves to the value you\nget when parsing the body as JSON or rejects if it\u2019s not valid JSON.\nBy default, fetch uses the GET method to make its request and does not\ninclude a request body. You can configure it differently by passing an object\nwith extra options as a second argument. For example, this request tries to\ndelete example/data.txt:\nfetch(\"example/data.txt\", {method: \"DELETE\"}).then(resp => {\nconsole.log(resp.status);\n// \u2192405\n});\nThe 405 status code means \u201cmethod not allowed\u201d, an HTTP server\u2019s way of\nsaying \u201cI\u2019m afraid I can\u2019t do that\u201d.\n300\nTo add a request body for a PUT or POST request, you can include a body\noption. To set headers, there\u2019s the headers option. For example, this request\nincludes a Range header, which instructs the server to return only part of a\ndocument.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_693",
    "text": "option. To set headers, there\u2019s the headers option. For example, this request\nincludes a Range header, which instructs the server to return only part of a\ndocument.\nfetch(\"example/data.txt\", {headers: {Range: \"bytes=8-19\"}})\n.then(resp => resp.text())\n.then(console.log);\n// \u2192the content\nThe browser will automatically add some request headers, such as \u201cHost\u201d and\nthose needed for the server to figure out the size of the body. But adding your\nown headers is often useful to include things such as authentication information\nor to tell the server which file format you\u2019d like to receive.\nHTTP sandboxing\nMaking HTTP requests in web page scripts once again raises concerns about\nsecurity. The person who controls the script might not have the same interests\nas the person on whose computer it is running. More specifically, if I visit\nthemafia.org, I do not want its scripts to be able to make a request to my-\nbank.com, using identifying information from my browser, with instructions to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_694",
    "text": "themafia.org, I do not want its scripts to be able to make a request to my-\nbank.com, using identifying information from my browser, with instructions to\ntransfer away all my money.\nFor this reason, browsers protect us by disallowing scripts to make HTTP\nrequests to other domains (names such as themafia.org and mybank.com).\nThis can be an annoying problem when building systems that want to ac-\ncess several domains for legitimate reasons. Fortunately, servers can include a\nheader like this in their response to explicitly indicate to the browser that it is\nokay for the request to come from another domain:\nAccess-Control-Allow-Origin: *\nAppreciating HTTP\nWhen building a system that requires communication between a JavaScript\nprogram running in the browser (client-side) and a program on a server (server-\nside), there are several different ways to model this communication.\nA commonly used model is that of remote procedure calls. In this model,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_695",
    "text": "side), there are several different ways to model this communication.\nA commonly used model is that of remote procedure calls. In this model,\ncommunication follows the patterns of normal function calls, except that the\nfunction is actually running on another machine. Calling it involves making a\n301\nrequest to the server that includes the function\u2019s name and arguments. The\nresponse to that request contains the returned value.\nWhen thinking in terms of remote procedure calls, HTTP is just a vehicle for\ncommunication, and you will most likely write an abstraction layer that hides\nit entirely.\nAnother approach is to build your communication around the concept of\nresources and HTTP methods. Instead of a remote procedure called addUser,\nyou use a PUT request to /users/larry. Instead of encoding that user\u2019s prop-\nerties in function arguments, you define a JSON document format (or use an\nexisting format) that represents a user. The body of the PUT request to create",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_696",
    "text": "erties in function arguments, you define a JSON document format (or use an\nexisting format) that represents a user. The body of the PUT request to create\na new resource is then such a document. A resource is fetched by making a\nGET request to the resource\u2019s URL (for example, /users/larry), which again\nreturns the document representing the resource.\nThis second approach makes it easier to use some of the features that HTTP\nprovides, such as support for caching resources (keeping a copy of a resource on\nthe client for fast access). The concepts used in HTTP, which are well designed,\ncan provide a helpful set of principles to design your server interface around.\nSecurity and HTTPS\nData traveling over the internet tends to follow a long, dangerous road. To\nget to its destination, it must hop through anything from coffee shop Wi-Fi\nhotspots to networks controlled by various companies and states. At any point\nalong its route, it may be inspected or even modified.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_697",
    "text": "hotspots to networks controlled by various companies and states. At any point\nalong its route, it may be inspected or even modified.\nIf it is important that something remain secret, such as the password to\nyour email account, or that it arrive at its destination unmodified, such as the\naccount number you transfer money to via your bank\u2019s website, plain HTTP\nis not good enough.\nThe secure HTTP protocol, used for URLs starting with https://, wraps\nHTTP tra\ufb00ic in a way that makes it harder to read and tamper with. Before\nexchanging data, the client verifies that the server is who it claims to be by\nasking it to prove that it has a cryptographic certificate issued by a certificate\nauthority that the browser recognizes. Next, all data going over the connection\nis encrypted in a way that should prevent eavesdropping and tampering.\nThus, when it works right, HTTPS prevents other people from impersonating\nthe website you are trying to talk to and from snooping on your communication.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_698",
    "text": "Thus, when it works right, HTTPS prevents other people from impersonating\nthe website you are trying to talk to and from snooping on your communication.\nIt\u2019s not perfect, and there have been various incidents where HTTPS failed\nbecause of forged or stolen certificates and broken software, but it is a lot safer\nthan plain HTTP.\n302\nForm fields\nForms were originally designed for the pre-JavaScript web to allow websites to\nsend user-submitted information in an HTTP request. This design assumes\nthat interaction with the server always happens by navigating to a new page.\nHowever, the form elements are part of the DOM, like the rest of the page,\nand the DOM elements that represent form fields support a number of proper-\nties and events that are not present on other elements. These make it possible\nto inspect and control such input fields with JavaScript programs and do things\nsuch as adding new functionality to a form or using forms and fields as building\nblocks in a JavaScript application.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_699",
    "text": "to inspect and control such input fields with JavaScript programs and do things\nsuch as adding new functionality to a form or using forms and fields as building\nblocks in a JavaScript application.\nA web form consists of any number of input fields grouped in a <form>\ntag. HTML allows several different styles of fields, ranging from simple on/off\ncheckboxes to drop-down menus and fields for text input. This book won\u2019t try\nto comprehensively discuss all field types, but we\u2019ll start with a rough overview.\nA lot of field types use the <input> tag. This tag\u2019s type attribute is used to\nselect the field\u2019s style. These are some commonly used <input> types:\ntext\nA single-line text field\npassword\nSame as text but hides the text that is typed\ncheckbox\nAn on/off switch\ncolor\nA color\ndate\nA calendar date\nradio\n(Part of) a multiple-choice field\nfile\nAllows the user to choose a file from their computer\nForm fields do not necessarily have to appear in a <form> tag. You can put",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_700",
    "text": "date\nA calendar date\nradio\n(Part of) a multiple-choice field\nfile\nAllows the user to choose a file from their computer\nForm fields do not necessarily have to appear in a <form> tag. You can put\nthem anywhere in a page. Such form-less fields cannot be submitted (only a\nform as a whole can), but when responding to input with JavaScript, we often\ndon\u2019t want to submit our fields normally anyway.\n<p><input type=\"text\" value=\"abc\"> (text)</p>\n<p><input type=\"password\" value=\"abc\"> (password)</p>\n<p><input type=\"checkbox\" checked> (checkbox)</p>\n<p><input type=\"color\" value=\"orange\"> (color)</p>\n<p><input type=\"date\" value=\"2023-10-13\"> (date)</p>\n<p><input type=\"radio\" value=\"A\" name=\"choice\">\n<input type=\"radio\" value=\"B\" name=\"choice\" checked>\n<input type=\"radio\" value=\"C\" name=\"choice\"> (radio)</p>\n<p><input type=\"file\"> (file)</p>\nThe fields created with this HTML code look like this:\n303\nThe JavaScript interface for such elements differs with the type of the ele-\nment.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_701",
    "text": "<p><input type=\"file\"> (file)</p>\nThe fields created with this HTML code look like this:\n303\nThe JavaScript interface for such elements differs with the type of the ele-\nment.\nMultiline text fields have their own tag, <textarea>, mostly because using\nan attribute to specify a multiline starting value would be awkward. The <\ntextarea> tag requires a matching </textarea> closing tag and uses the text\nbetween those two, instead of the value attribute, as starting text.\n<textarea>\none\ntwo\nthree\n</textarea>\nFinally, the <select> tag is used to create a field that allows the user to select\nfrom a number of predefined options.\n<select>\n<option>Pancakes</option>\n<option>Pudding</option>\n<option>Ice cream</option>\n</select>\nSuch a field looks like this:\nWhenever the value of a form field changes, it will fire a \"change\" event.\nFocus\nUnlike most elements in HTML documents, form fields can get keyboard focus.\nWhen clicked, moved to with tab, or activated in some other way, they become",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_702",
    "text": "Focus\nUnlike most elements in HTML documents, form fields can get keyboard focus.\nWhen clicked, moved to with tab, or activated in some other way, they become\nthe currently active element and the recipient of keyboard input.\nThus, you can type into a text field only when it is focused. Other fields\nrespond differently to keyboard events. For example, a <select> menu tries to\n304\nmove to the option that contains the text the user typed and responds to the\narrow keys by moving its selection up and down.\nWe can control focus from JavaScript with the focus and blur methods. The\nfirst moves focus to the DOM element it is called on, and the second removes\nfocus. The value in document.activeElement corresponds to the currently fo-\ncused element.\n<input type=\"text\">\n<script>\ndocument.querySelector(\"input\").focus();\nconsole.log(document.activeElement.tagName);\n// \u2192INPUT\ndocument.querySelector(\"input\").blur();\nconsole.log(document.activeElement.tagName);\n// \u2192BODY\n</script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_703",
    "text": "document.querySelector(\"input\").focus();\nconsole.log(document.activeElement.tagName);\n// \u2192INPUT\ndocument.querySelector(\"input\").blur();\nconsole.log(document.activeElement.tagName);\n// \u2192BODY\n</script>\nFor some pages, the user is expected to want to interact with a form field\nimmediately. JavaScript can be used to focus this field when the document is\nloaded, but HTML also provides the autofocus attribute, which produces the\nsame effect while letting the browser know what we are trying to achieve. This\ngives the browser the option to disable the behavior when it is not appropriate,\nsuch as when the user has put the focus on something else.\nBrowsers allow the user to move the focus through the document by pressing\ntab to move to the next focusable element, and shift-tab to move back to\nthe previous element. By default, elements are visited in the order in which\nthey appear in the document. It is possible to use the tabindex attribute to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_704",
    "text": "the previous element. By default, elements are visited in the order in which\nthey appear in the document. It is possible to use the tabindex attribute to\nchange this order. The following example document will let the focus jump\nfrom the text input to the OK button, rather than going through the help link\nfirst:\n<input type=\"text\" tabindex=1> <a href=\".\">(help)</a>\n<button onclick=\"console.log('ok')\" tabindex=2>OK</button>\nBy default, most types of HTML elements cannot be focused. You can add a\ntabindex attribute to any element to make it focusable. A tabindex of 0 makes\nan element focusable without affecting the focus order.\nDisabled fields\nAll form fields can be disabled through their disabled attribute. It is an at-\ntribute that can be specified without value\u2014the fact that it is present at all\n305\ndisables the element.\n<button>I'm all right</button>\n<button disabled>I'm out</button>\nDisabled fields cannot be focused or changed, and browsers make them look\ngray and faded.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_705",
    "text": "305\ndisables the element.\n<button>I'm all right</button>\n<button disabled>I'm out</button>\nDisabled fields cannot be focused or changed, and browsers make them look\ngray and faded.\nWhen a program is in the process of handling an action caused by some\nbutton or other control that might require communication with the server and\nthus take a while, it can be a good idea to disable the control until the action\nfinishes. That way, when the user gets impatient and clicks it again, they don\u2019t\naccidentally repeat their action.\nThe form as a whole\nWhen a field is contained in a <form> element, its DOM element will have a\nform property linking back to the form\u2019s DOM element. The <form> element,\nin turn, has a property called elements that contains an array-like collection\nof the fields inside it.\nThe name attribute of a form field determines the way its value will be identi-\nfied when the form is submitted. It can also be used as a property name when",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_706",
    "text": "of the fields inside it.\nThe name attribute of a form field determines the way its value will be identi-\nfied when the form is submitted. It can also be used as a property name when\naccessing the form\u2019s elements property, which acts both as an array-like object\n(accessible by number) and a map (accessible by name).\n<form action=\"example/submit.html\">\nName: <input type=\"text\" name=\"name\"><br>\nPassword: <input type=\"password\" name=\"password\"><br>\n<button type=\"submit\">Log in</button>\n</form>\n<script>\nlet form = document.querySelector(\"form\");\nconsole.log(form.elements[1].type);\n// \u2192password\nconsole.log(form.elements.password.type);\n// \u2192password\nconsole.log(form.elements.name.form == form);\n// \u2192true\n</script>\nA button with a type attribute of submit will, when pressed, cause the form\nto be submitted. Pressing enter when a form field is focused has the same\n306\neffect.\nSubmitting a form normally means that the browser navigates to the page",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_707",
    "text": "to be submitted. Pressing enter when a form field is focused has the same\n306\neffect.\nSubmitting a form normally means that the browser navigates to the page\nindicated by the form\u2019s action attribute, using either a GET or a POST request.\nBut before that happens, a \"submit\" event is fired. You can handle this event\nwith JavaScript and prevent this default behavior by calling preventDefault\non the event object.\n<form>\nValue: <input type=\"text\" name=\"value\">\n<button type=\"submit\">Save</button>\n</form>\n<script>\nlet form = document.querySelector(\"form\");\nform.addEventListener(\"submit\", event => {\nconsole.log(\"Saving value\", form.elements.value.value);\nevent.preventDefault();\n});\n</script>\nIntercepting \"submit\" events in JavaScript has various uses. We can write code\nto verify that the values the user entered make sense and immediately show an\nerror message instead of submitting the form. Or we can disable the regular",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_708",
    "text": "to verify that the values the user entered make sense and immediately show an\nerror message instead of submitting the form. Or we can disable the regular\nway of submitting the form entirely, as in the example, and have our program\nhandle the input, possibly using fetch to send it to a server without reloading\nthe page.\nText fields\nFields created by <textarea> tags, or <input> tags with a type of text or\npassword, share a common interface. Their DOM elements have a value prop-\nerty that holds their current content as a string value. Setting this property to\nanother string changes the field\u2019s content.\nThe selectionStart and selectionEnd properties of text fields give us infor-\nmation about the cursor and selection in the text. When nothing is selected,\nthese two properties hold the same number, indicating the position of the cur-\nsor. For example, 0 indicates the start of the text, and 10 indicates the cursor",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_709",
    "text": "these two properties hold the same number, indicating the position of the cur-\nsor. For example, 0 indicates the start of the text, and 10 indicates the cursor\nis after the 10th character. When part of the field is selected, the two properties\nwill differ, giving us the start and end of the selected text. Like value, these\nproperties may also be written to.\nImagine you are writing an article about Khasekhemwy, last pharaoh of the\nSecond Dynasty, but have some trouble spelling his name. The following code\nwires up a <textarea> tag with an event handler that, when you press F2,\n307\ninserts the string \u201cKhasekhemwy\u201d for you.\n<textarea></textarea>\n<script>\nlet textarea = document.querySelector(\"textarea\");\ntextarea.addEventListener(\"keydown\", event => {\nif (event.key == \"F2\") {\nreplaceSelection(textarea, \"Khasekhemwy\");\nevent.preventDefault();\n}\n});\nfunction replaceSelection(field, word) {\nlet from = field.selectionStart, to = field.selectionEnd;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_710",
    "text": "if (event.key == \"F2\") {\nreplaceSelection(textarea, \"Khasekhemwy\");\nevent.preventDefault();\n}\n});\nfunction replaceSelection(field, word) {\nlet from = field.selectionStart, to = field.selectionEnd;\nfield.value = field.value.slice(0, from) + word +\nfield.value.slice(to);\n// Put the cursor after the word\nfield.selectionStart = from + word.length;\nfield.selectionEnd = from + word.length;\n}\n</script>\nThe replaceSelection function replaces the currently selected part of a text\nfield\u2019s content with the given word and then moves the cursor after that word\nso that the user can continue typing.\nThe \"change\" event for a text field does not fire every time something is\ntyped. Rather, it fires when the field loses focus after its content was changed.\nTo respond immediately to changes in a text field, you should register a handler\nfor the \"input\" event instead, which fires every time the user types a character,\ndeletes text, or otherwise manipulates the field\u2019s content.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_711",
    "text": "for the \"input\" event instead, which fires every time the user types a character,\ndeletes text, or otherwise manipulates the field\u2019s content.\nThe following example shows a text field and a counter displaying the current\nlength of the text in the field:\n<input type=\"text\"> length: <span id=\"length\">0</span>\n<script>\nlet text = document.querySelector(\"input\");\nlet output = document.querySelector(\"#length\");\ntext.addEventListener(\"input\", () => {\noutput.textContent = text.value.length;\n});\n</script>\n308\nCheckboxes and radio buttons\nA checkbox field is a binary toggle.\nIts value can be extracted or changed\nthrough its checked property, which holds a Boolean value.\n<label>\n<input type=\"checkbox\" id=\"purple\"> Make this page purple\n</label>\n<script>\nlet checkbox = document.querySelector(\"#purple\");\ncheckbox.addEventListener(\"change\", () => {\ndocument.body.style.background =\ncheckbox.checked ? \"mediumpurple\" : \"\";\n});\n</script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_712",
    "text": "</label>\n<script>\nlet checkbox = document.querySelector(\"#purple\");\ncheckbox.addEventListener(\"change\", () => {\ndocument.body.style.background =\ncheckbox.checked ? \"mediumpurple\" : \"\";\n});\n</script>\nThe <label> tag associates a piece of document with an input field. Clicking\nanywhere on the label will activate the field, which focuses it and toggles its\nvalue when it is a checkbox or radio button.\nA radio button is similar to a checkbox, but it\u2019s implicitly linked to other\nradio buttons with the same name attribute so that only one of them can be\nactive at any time.\nColor:\n<label>\n<input type=\"radio\" name=\"color\" value=\"orange\"> Orange\n</label>\n<label>\n<input type=\"radio\" name=\"color\" value=\"lightgreen\"> Green\n</label>\n<label>\n<input type=\"radio\" name=\"color\" value=\"lightblue\"> Blue\n</label>\n<script>\nlet buttons = document.querySelectorAll(\"[name=color]\");\nfor (let button of Array.from(buttons)) {\nbutton.addEventListener(\"change\", () => {\ndocument.body.style.background = button.value;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_713",
    "text": "<script>\nlet buttons = document.querySelectorAll(\"[name=color]\");\nfor (let button of Array.from(buttons)) {\nbutton.addEventListener(\"change\", () => {\ndocument.body.style.background = button.value;\n});\n}\n</script>\nThe square brackets in the CSS query given to querySelectorAll are used to\nmatch attributes. It selects elements whose name attribute is \"color\".\n309\nSelect fields\nSelect fields are conceptually similar to radio buttons\u2014they also allow the user\nto choose from a set of options. But where a radio button puts the layout of\nthe options under our control, the appearance of a <select> tag is determined\nby the browser.\nSelect fields also have a variant more akin to a list of checkboxes rather\nthan radio boxes.\nWhen given the multiple attribute, a <select> tag will\nallow the user to select any number of options, rather than just a single option.\nWhereas a regular select field is drawn as a drop-down control, which shows the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_714",
    "text": "allow the user to select any number of options, rather than just a single option.\nWhereas a regular select field is drawn as a drop-down control, which shows the\ninactive options only when you open it, a field with multiple enabled shows\nmultiple options at the same time, allowing the user to enable or disable them\nindividually.\nEach <option> tag has a value.\nThis value can be defined with a value\nattribute. When that is not given, the text inside the option will count as its\nvalue. The value property of a <select> element reflects the currently selected\noption. For a multiple field, though, this property doesn\u2019t mean much, since\nit will give the value of only one of the currently selected options.\nThe <option> tags for a <select> field can be accessed as an array-like ob-\nject through the field\u2019s options property. Each option has a property called\nselected, which indicates whether that option is currently selected. The prop-\nerty can also be written to select or deselect an option.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_715",
    "text": "selected, which indicates whether that option is currently selected. The prop-\nerty can also be written to select or deselect an option.\nThis example extracts the selected values from a multiple select field and\nuses them to compose a binary number from individual bits. Hold ctrl (or\ncommand on a Mac) to select multiple options.\n<select multiple>\n<option value=\"1\">0001</option>\n<option value=\"2\">0010</option>\n<option value=\"4\">0100</option>\n<option value=\"8\">1000</option>\n</select> = <span id=\"output\">0</span>\n<script>\nlet select = document.querySelector(\"select\");\nlet output = document.querySelector(\"#output\");\nselect.addEventListener(\"change\", () => {\nlet number = 0;\nfor (let option of Array.from(select.options)) {\nif (option.selected) {\nnumber += Number(option.value);\n}\n}\n310\noutput.textContent = number;\n});\n</script>\nFile fields\nFile fields were originally designed as a way to upload files from the user\u2019s\nmachine through a form. In modern browsers, they also provide a way to read",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_716",
    "text": "});\n</script>\nFile fields\nFile fields were originally designed as a way to upload files from the user\u2019s\nmachine through a form. In modern browsers, they also provide a way to read\nsuch files from JavaScript programs. The field acts as a kind of gatekeeper.\nThe script cannot simply start reading private files from the user\u2019s computer,\nbut if the user selects a file in such a field, the browser interprets that action\nto mean that the script may read the file.\nA file field usually looks like a button labeled with something like \u201cchoose\nfile\u201d or \u201cbrowse\u201d, with information about the chosen file next to it.\n<input type=\"file\">\n<script>\nlet input = document.querySelector(\"input\");\ninput.addEventListener(\"change\", () => {\nif (input.files.length > 0) {\nlet file = input.files[0];\nconsole.log(\"You chose\", file.name);\nif (file.type) console.log(\"It has type\", file.type);\n}\n});\n</script>\nThe files property of a file field element is an array-like object (once again,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_717",
    "text": "console.log(\"You chose\", file.name);\nif (file.type) console.log(\"It has type\", file.type);\n}\n});\n</script>\nThe files property of a file field element is an array-like object (once again,\nnot a real array) containing the files chosen in the field. It is initially empty.\nThe reason there isn\u2019t simply a file property is that file fields also support a\nmultiple attribute, which makes it possible to select multiple files at the same\ntime.\nThe objects in files have properties such as name (the filename), size (the\nfile\u2019s size in bytes, which are chunks of 8 bits), and type (the media type of the\nfile, such as text/plain or image/jpeg).\nWhat it does not have is a property that contains the content of the file.\nGetting at that is a little more involved. Since reading a file from disk can take\ntime, the interface is asynchronous to avoid freezing the window.\n<input type=\"file\" multiple>\n<script>\nlet input = document.querySelector(\"input\");\n311\ninput.addEventListener(\"change\", () => {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_718",
    "text": "time, the interface is asynchronous to avoid freezing the window.\n<input type=\"file\" multiple>\n<script>\nlet input = document.querySelector(\"input\");\n311\ninput.addEventListener(\"change\", () => {\nfor (let file of Array.from(input.files)) {\nlet reader = new FileReader();\nreader.addEventListener(\"load\", () => {\nconsole.log(\"File\", file.name, \"starts with\",\nreader.result.slice(0, 20));\n});\nreader.readAsText(file);\n}\n});\n</script>\nReading a file is done by creating a FileReader object, registering a \"load\"\nevent handler for it, and calling its readAsText method, giving it the file we\nwant to read. Once loading finishes, the reader\u2019s result property contains the\nfile\u2019s content.\nFileReaders also fire an \"error\" event when reading the file fails for any\nreason. The error object itself will end up in the reader\u2019s error property. This\ninterface was designed before promises became part of the language. You could\nwrap it in a promise like this:\nfunction readFileText(file) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_719",
    "text": "interface was designed before promises became part of the language. You could\nwrap it in a promise like this:\nfunction readFileText(file) {\nreturn new Promise((resolve, reject) => {\nlet reader = new FileReader();\nreader.addEventListener(\n\"load\", () => resolve(reader.result));\nreader.addEventListener(\n\"error\", () => reject(reader.error));\nreader.readAsText(file);\n});\n}\nStoring data client-side\nSimple HTML pages with a bit of JavaScript can be a great format for \u201cmini\napplications\u201d\u2014small helper programs that automate basic tasks. By connect-\ning a few form fields with event handlers, you can do anything from converting\nbetween centimeters and inches to computing passwords from a master pass-\nword and a website name.\nWhen such an application needs to remember something between sessions,\nyou cannot use JavaScript bindings\u2014those are thrown away every time the\npage is closed. You could set up a server, connect it to the internet, and have\n312",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_720",
    "text": "you cannot use JavaScript bindings\u2014those are thrown away every time the\npage is closed. You could set up a server, connect it to the internet, and have\n312\nyour application store something there (we\u2019ll see how to do that in Chapter\n20). But that\u2019s a lot of extra work and complexity. Sometimes it\u2019s enough to\njust keep the data in the browser.\nThe localStorage object can be used to store data in a way that survives\npage reloads. This object allows you to file string values under names.\nlocalStorage.setItem(\"username\", \"marijn\");\nconsole.log(localStorage.getItem(\"username\"));\n// \u2192marijn\nlocalStorage.removeItem(\"username\");\nA value in localStorage sticks around until it is overwritten or is removed with\nremoveItem, or the user clears their local data.\nSites from different domains get different storage compartments. That means\ndata stored in localStorage by a given website can, in principle, be read (and\noverwritten) only by scripts on that same site.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_721",
    "text": "data stored in localStorage by a given website can, in principle, be read (and\noverwritten) only by scripts on that same site.\nBrowsers do enforce a limit on the size of the data a site can store in\nlocalStorage. That restriction, along with the fact that filling up people\u2019s\nhard drives with junk is not really profitable, prevents the feature from eating\nup too much space.\nThe following code implements a crude note-taking application. It keeps a\nset of named notes and allows the user to edit notes and create new ones.\nNotes: <select></select> <button>Add</button><br>\n<textarea style=\"width: 100%\"></textarea>\n<script>\nlet list = document.querySelector(\"select\");\nlet note = document.querySelector(\"textarea\");\nlet state;\nfunction setState(newState) {\nlist.textContent = \"\";\nfor (let name of Object.keys(newState.notes)) {\nlet option = document.createElement(\"option\");\noption.textContent = name;\nif (newState.selected == name) option.selected = true;\nlist.appendChild(option);\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_722",
    "text": "let option = document.createElement(\"option\");\noption.textContent = name;\nif (newState.selected == name) option.selected = true;\nlist.appendChild(option);\n}\nnote.value = newState.notes[newState.selected];\nlocalStorage.setItem(\"Notes\", JSON.stringify(newState));\nstate = newState;\n}\n313\nsetState(JSON.parse(localStorage.getItem(\"Notes\")) ?? {\nnotes: {\"shopping list\": \"Carrots\\nRaisins\"},\nselected: \"shopping list\"\n});\nlist.addEventListener(\"change\", () => {\nsetState({notes: state.notes, selected: list.value});\n});\nnote.addEventListener(\"change\", () => {\nlet {selected} = state;\nsetState({\nnotes: {...state.notes, [selected]: note.value},\nselected\n});\n});\ndocument.querySelector(\"button\")\n.addEventListener(\"click\", () => {\nlet name = prompt(\"Note name\");\nif (name) setState({\nnotes: {...state.notes, [name]: \"\"},\nselected: name\n});\n});\n</script>\nThe script gets its starting state from the \"Notes\" value stored in localStorage",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_723",
    "text": "if (name) setState({\nnotes: {...state.notes, [name]: \"\"},\nselected: name\n});\n});\n</script>\nThe script gets its starting state from the \"Notes\" value stored in localStorage\nor, if that\u2019s missing, creates an example state that has only a shopping list in it.\nReading a field that does not exist from localStorage will yield null. Passing\nnull to JSON.parse will make it parse the string \"null\" and return null. Thus,\nthe ?? operator can be used to provide a default value in a situation like this.\nThe setState method makes sure the DOM is showing a given state and\nstores the new state to localStorage.\nEvent handlers call this function to\nmove to a new state.\nThe ... syntax in the example is used to create a new object that is a clone\nof the old state.notes, but with one property added or overwritten. It uses\nspread syntax to first add the properties from the old object and then set a new\nproperty. The square brackets notation in the object literal is used to create a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_724",
    "text": "spread syntax to first add the properties from the old object and then set a new\nproperty. The square brackets notation in the object literal is used to create a\nproperty whose name is based on some dynamic value.\nThere is another object, similar to localStorage, called sessionStorage. The\ndifference between the two is that the content of sessionStorage is forgotten at\nthe end of each session, which for most browsers means whenever the browser\nis closed.\n314\nSummary\nIn this chapter, we discussed how the HTTP protocol works. A client sends\na request, which contains a method (usually GET) and a path that identifies a\nresource. The server then decides what to do with the request and responds\nwith a status code and a response body. Both requests and responses may\ncontain headers that provide additional information.\nThe interface through which browser JavaScript can make HTTP requests is\ncalled fetch. Making a request looks like this:",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_725",
    "text": "contain headers that provide additional information.\nThe interface through which browser JavaScript can make HTTP requests is\ncalled fetch. Making a request looks like this:\nfetch(\"/18_http.html\").then(r => r.text()).then(text => {\nconsole.log(`The page starts with ${text.slice(0, 15)}`);\n});\nBrowsers make GET requests to fetch the resources needed to display a web\npage. A page may also contain forms, which allow information entered by the\nuser to be sent as a request for a new page when the form is submitted.\nHTML can represent various types of form fields, such as text fields, check-\nboxes, multiple-choice fields, and file pickers. Such fields can be inspected and\nmanipulated with JavaScript.\nThey fire the \"change\" event when changed,\nfire the \"input\" event when text is typed, and receive keyboard events when\nthey have keyboard focus. Properties like value (for text and select fields) or\nchecked (for checkboxes and radio buttons) are used to read or set the field\u2019s\ncontent.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_726",
    "text": "they have keyboard focus. Properties like value (for text and select fields) or\nchecked (for checkboxes and radio buttons) are used to read or set the field\u2019s\ncontent.\nWhen a form is submitted, a \"submit\" event is fired on it. A JavaScript\nhandler can call preventDefault on that event to disable the browser\u2019s default\nbehavior. Form field elements may also occur outside of a form tag.\nWhen the user has selected a file from their local filesystem in a file picker\nfield, the FileReader interface can be used to access the content of this file from\na JavaScript program.\nThe localStorage and sessionStorage objects can be used to save informa-\ntion in a way that survives page reloads. The first object saves the data forever\n(or until the user decides to clear it), and the second saves it until the browser\nis closed.\nExercises\nContent negotiation\nOne of the things HTTP can do is called content negotiation.\nThe Accept\nrequest header is used to tell the server what type of document the client",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_727",
    "text": "is closed.\nExercises\nContent negotiation\nOne of the things HTTP can do is called content negotiation.\nThe Accept\nrequest header is used to tell the server what type of document the client\n315\nwould like to get. Many servers ignore this header, but when a server knows of\nvarious ways to encode a resource, it can look at this header and send the one\nthat the client prefers.\nThe URL https://eloquentjavascript.net/author is configured to respond with\neither plaintext, HTML, or JSON, depending on what the client asks for. These\nformats are identified by the standardized media types text/plain, text/html,\nand application/json.\nSend requests to fetch all three formats of this resource. Use the headers\nproperty in the options object passed to fetch to set the header named Accept\nto the desired media type.\nFinally, try asking for the media type application/rainbows+unicorns and\nsee which status code that produces.\nA JavaScript workbench",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_728",
    "text": "to the desired media type.\nFinally, try asking for the media type application/rainbows+unicorns and\nsee which status code that produces.\nA JavaScript workbench\nBuild an interface that allows users to type and run pieces of JavaScript code.\nPut a button next to a <textarea> field that, when pressed, uses the Function\nconstructor we saw in Chapter 10 to wrap the text in a function and call it.\nConvert the return value of the function, or any error it raises, to a string and\ndisplay it below the text field.\nConway's Game of Life\nConway\u2019s Game of Life is a simple simulation that creates artificial \u201clife\u201d on\na grid, each cell of which is either alive or not. In each generation (turn), the\nfollowing rules are applied:\n\u2022 Any live cell with fewer than two or more than three live neighbors dies.\n\u2022 Any live cell with two or three live neighbors lives on to the next gener-\nation.\n\u2022 Any dead cell with exactly three live neighbors becomes a live cell.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_729",
    "text": "\u2022 Any live cell with two or three live neighbors lives on to the next gener-\nation.\n\u2022 Any dead cell with exactly three live neighbors becomes a live cell.\nA neighbor is defined as any adjacent cell, including diagonally adjacent ones.\nNote that these rules are applied to the whole grid at once, not one square at\na time. That means the counting of neighbors is based on the situation at the\nstart of the generation, and changes happening to neighbor cells during this\ngeneration should not influence the new state of a given cell.\nImplement this game using whichever data structure you find appropriate.\nUse Math.random to populate the grid with a random pattern initially. Display\n316\nit as a grid of checkbox fields, with a button next to it to advance to the next\ngeneration. When the user checks or unchecks the checkboxes, their changes\nshould be included when computing the next generation.\n317\n\u201cI look at the many colors before me. I look at my blank canvas.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_730",
    "text": "generation. When the user checks or unchecks the checkboxes, their changes\nshould be included when computing the next generation.\n317\n\u201cI look at the many colors before me. I look at my blank canvas.\nThen, I try to apply colors like words that shape poems, like notes\nthat shape music.\u201d\n\u2014Joan Mir\u00f3\nChapter 19\nProject: A Pixel Art Editor\nThe material from the previous chapters gives you all the elements you need\nto build a basic web application. In this chapter, we will do just that.\nOur application will be a pixel-drawing program that allows you to modify a\npicture pixel by pixel by manipulating a zoomed-in view of it, shown as a grid\nof colored squares. You can use the program to open image files, scribble on\nthem with your mouse or other pointer device, and save them. This is what it\nwill look like:\nPainting on a computer is great. You don\u2019t need to worry about materials,\nskill, or talent. You just start smearing and see where you end up.\nComponents",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_731",
    "text": "will look like:\nPainting on a computer is great. You don\u2019t need to worry about materials,\nskill, or talent. You just start smearing and see where you end up.\nComponents\nThe interface for the application shows a big <canvas> element on top, with a\nnumber of form fields below it. The user draws on the picture by selecting a\ntool from a <select> field and then clicking, touching, or dragging across the\ncanvas. There are tools for drawing single pixels or rectangles, for filling an\narea, and for picking a color from the picture.\nWe will structure the editor interface as a number of components, objects that\nare responsible for a piece of the DOM and that may contain other components\ninside them.\nThe state of the application consists of the current picture, the selected\ntool, and the selected color. We\u2019ll set things up so that the state lives in a\n318\nsingle value and the interface components always base the way they look on\nthe current state.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_732",
    "text": "tool, and the selected color. We\u2019ll set things up so that the state lives in a\n318\nsingle value and the interface components always base the way they look on\nthe current state.\nTo see why this is important, let\u2019s consider the alternative\u2014distributing\npieces of state throughout the interface. Up to a certain point, this is easier to\nprogram. We can just put in a color field and read its value when we need to\nknow the current color.\nBut then we add the color picker\u2014a tool that lets you click the picture to\nselect the color of a given pixel. To keep the color field showing the correct\ncolor, that tool would have to know that the color field exists and update it\nwhenever it picks a new color. If you ever add another place that makes the\ncolor visible (maybe the mouse cursor could show it), you have to update your\ncolor-changing code to keep that synchronized as well.\nIn effect, this creates a problem where each part of the interface needs to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_733",
    "text": "color-changing code to keep that synchronized as well.\nIn effect, this creates a problem where each part of the interface needs to\nknow about all other parts, which is not very modular. For small applications\nlike the one in this chapter, that may not be a problem. For bigger projects, it\ncan turn into a real nightmare.\nTo avoid this nightmare on principle, we\u2019re going to be strict about data flow.\nThere is a state, and the interface is drawn based on that state. An interface\ncomponent may respond to user actions by updating the state, at which point\nthe components get a chance to synchronize themselves with this new state.\nIn practice, each component is set up so that when it is given a new state, it\nalso notifies its child components, insofar as those need to be updated. Setting\nthis up is a bit of a hassle. Making this more convenient is the main selling\npoint of many browser programming libraries. But for a small application like\nthis, we can do it without such infrastructure.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_734",
    "text": "point of many browser programming libraries. But for a small application like\nthis, we can do it without such infrastructure.\nUpdates to the state are represented as objects, which we\u2019ll call actions.\nComponents may create such actions and dispatch them\u2014give them to a central\nstate management function. That function computes the next state, after which\nthe interface components update themselves to this new state.\nWe\u2019re taking the messy task of running a user interface and applying struc-\nture to it. Though the DOM-related pieces are still full of side effects, they\nare held up by a conceptually simple backbone: the state update cycle. The\nstate determines what the DOM looks like, and the only way DOM events can\nchange the state is by dispatching actions to the state.\nThere are many variants of this approach, each with its own benefits and\nproblems, but their central idea is the same: state changes should go through\na single well-defined channel, not happen all over the place.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_735",
    "text": "problems, but their central idea is the same: state changes should go through\na single well-defined channel, not happen all over the place.\nOur components will be classes conforming to an interface. Their constructor\nis given a state\u2014which may be the whole application state or some smaller\nvalue if it doesn\u2019t need access to everything\u2014and uses that to build up a dom\n319\nproperty. This is the DOM element that represents the component. Most\nconstructors will also take some other values that won\u2019t change over time, such\nas the function they can use to dispatch an action.\nEach component has a syncState method that is used to synchronize it to\na new state value. The method takes one argument, the state, which is of the\nsame type as the first argument to its constructor.\nThe state\nThe application state will be an object with picture, tool, and color prop-\nerties. The picture is itself an object that stores the width, height, and pixel",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_736",
    "text": "The state\nThe application state will be an object with picture, tool, and color prop-\nerties. The picture is itself an object that stores the width, height, and pixel\ncontent of the picture. The pixels are stored in a single array, row by row, from\ntop to bottom.\nclass Picture {\nconstructor(width, height, pixels) {\nthis.width = width;\nthis.height = height;\nthis.pixels = pixels;\n}\nstatic empty(width, height, color) {\nlet pixels = new Array(width * height).fill(color);\nreturn new Picture(width, height, pixels);\n}\npixel(x, y) {\nreturn this.pixels[x + y * this.width];\n}\ndraw(pixels) {\nlet copy = this.pixels.slice();\nfor (let {x, y, color} of pixels) {\ncopy[x + y * this.width] = color;\n}\nreturn new Picture(this.width, this.height, copy);\n}\n}\nWe want to be able to treat a picture as an immutable value, for reasons we\u2019ll\nget back to later in the chapter.\nBut we also sometimes need to update a\nwhole bunch of pixels at a time. To be able to do that, the class has a draw",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_737",
    "text": "get back to later in the chapter.\nBut we also sometimes need to update a\nwhole bunch of pixels at a time. To be able to do that, the class has a draw\nmethod that expects an array of updated pixels\u2014objects with x, y, and color\nproperties\u2014and creates a new picture with those pixels overwritten.\nThis\nmethod uses slice without arguments to copy the entire pixel array\u2014the start\nof the slice defaults to 0, and the end defaults to the array\u2019s length.\n320\nThe empty method uses two pieces of array functionality that we haven\u2019t seen\nbefore. The Array constructor can be called with a number to create an empty\narray of the given length. The fill method can then be used to fill this array\nwith a given value. These are used to create an array in which all pixels have\nthe same color.\nColors are stored as strings containing traditional CSS color codes made up\nof a hash sign (#) followed by six hexadecimal (base-16) digits\u2014two for the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_738",
    "text": "the same color.\nColors are stored as strings containing traditional CSS color codes made up\nof a hash sign (#) followed by six hexadecimal (base-16) digits\u2014two for the\nred component, two for the green component, and two for the blue component.\nThis is a somewhat cryptic and inconvenient way to write colors, but it is the\nformat the HTML color input field uses, and it can be used in the fillStyle\nproperty of a canvas drawing context, so for the ways we\u2019ll use colors in this\nprogram, it is practical enough.\nBlack, where all components are zero, is written \"#000000\", and bright pink\nlooks like \"#ff00ff\", where the red and blue components have the maximum\nvalue of 255, written ff in hexadecimal digits (which use a to f to represent\ndigits 10 to 15).\nWe\u2019ll allow the interface to dispatch actions as objects whose properties\noverwrite the properties of the previous state. The color field, when the user\nchanges it, could dispatch an object like {color: field.value}, from which",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_739",
    "text": "overwrite the properties of the previous state. The color field, when the user\nchanges it, could dispatch an object like {color: field.value}, from which\nthis update function can compute a new state.\nfunction updateState(state, action) {\nreturn {...state, ...action};\n}\nThis pattern, in which object spread is used to first add the properties an\nexisting object and then override some of those, is common in JavaScript code\nthat uses immutable objects.\nDOM building\nOne of the main things that interface components do is create DOM structure.\nWe again don\u2019t want to directly use the verbose DOM methods for that, so\nhere\u2019s a slightly expanded version of the elt function:\nfunction elt(type, props, ...children) {\nlet dom = document.createElement(type);\nif (props) Object.assign(dom, props);\nfor (let child of children) {\nif (typeof child != \"string\") dom.appendChild(child);\nelse dom.appendChild(document.createTextNode(child));\n}\n321\nreturn dom;\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_740",
    "text": "if (props) Object.assign(dom, props);\nfor (let child of children) {\nif (typeof child != \"string\") dom.appendChild(child);\nelse dom.appendChild(document.createTextNode(child));\n}\n321\nreturn dom;\n}\nThe main difference between this version and the one we used in Chapter 16 is\nthat it assigns properties to DOM nodes, not attributes. This means we can\u2019t\nuse it to set arbitrary attributes, but we can use it to set properties whose\nvalue isn\u2019t a string, such as onclick, which can be set to a function to register\na click event handler.\nThis allows this convenient style for registering event handlers:\n<body>\n<script>\ndocument.body.appendChild(elt(\"button\", {\nonclick: () => console.log(\"click\")\n}, \"The button\"));\n</script>\n</body>\nThe canvas\nThe first component we\u2019ll define is the part of the interface that displays the\npicture as a grid of colored boxes. This component is responsible for two things:\nshowing a picture and communicating pointer events on that picture to the rest",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_741",
    "text": "picture as a grid of colored boxes. This component is responsible for two things:\nshowing a picture and communicating pointer events on that picture to the rest\nof the application.\nTherefore, we can define it as a component that only knows about the current\npicture, not the whole application state.\nBecause it doesn\u2019t know how the\napplication as a whole works, it cannot directly dispatch actions.\nRather,\nwhen responding to pointer events, it calls a callback function provided by the\ncode that created it, which will handle the application-specific parts.\nconst scale = 10;\nclass PictureCanvas {\nconstructor(picture, pointerDown) {\nthis.dom = elt(\"canvas\", {\nonmousedown: event => this.mouse(event, pointerDown),\nontouchstart: event => this.touch(event, pointerDown)\n});\nthis.syncState(picture);\n}\nsyncState(picture) {\nif (this.picture == picture) return;\nthis.picture = picture;\n322\ndrawPicture(this.picture, this.dom, scale);\n}\n}",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_742",
    "text": "});\nthis.syncState(picture);\n}\nsyncState(picture) {\nif (this.picture == picture) return;\nthis.picture = picture;\n322\ndrawPicture(this.picture, this.dom, scale);\n}\n}\nWe draw each pixel as a 10-by-10 square, as determined by the scale constant.\nTo avoid unnecessary work, the component keeps track of its current picture\nand does a redraw only when syncState is given a new picture.\nThe actual drawing function sets the size of the canvas based on the scale\nand picture size and fills it with a series of squares, one for each pixel.\nfunction drawPicture(picture, canvas, scale) {\ncanvas.width = picture.width * scale;\ncanvas.height = picture.height * scale;\nlet cx = canvas.getContext(\"2d\");\nfor (let y = 0; y < picture.height; y++) {\nfor (let x = 0; x < picture.width; x++) {\ncx.fillStyle = picture.pixel(x, y);\ncx.fillRect(x * scale, y * scale, scale, scale);\n}\n}\n}\nWhen the left mouse button is pressed while the mouse is over the picture can-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_743",
    "text": "cx.fillStyle = picture.pixel(x, y);\ncx.fillRect(x * scale, y * scale, scale, scale);\n}\n}\n}\nWhen the left mouse button is pressed while the mouse is over the picture can-\nvas, the component calls the pointerDown callback, giving it the position of the\npixel that was clicked\u2014in picture coordinates. This will be used to implement\nmouse interaction with the picture. The callback may return another callback\nfunction to be notified when the pointer is moved to a different pixel while the\nbutton is held down.\nPictureCanvas.prototype.mouse = function(downEvent, onDown) {\nif (downEvent.button != 0) return;\nlet pos = pointerPosition(downEvent, this.dom);\nlet onMove = onDown(pos);\nif (!onMove) return;\nlet move = moveEvent => {\nif (moveEvent.buttons == 0) {\nthis.dom.removeEventListener(\"mousemove\", move);\n} else {\nlet newPos = pointerPosition(moveEvent, this.dom);\nif (newPos.x == pos.x && newPos.y == pos.y) return;\npos = newPos;\nonMove(newPos);\n}\n};\n323",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_744",
    "text": "this.dom.removeEventListener(\"mousemove\", move);\n} else {\nlet newPos = pointerPosition(moveEvent, this.dom);\nif (newPos.x == pos.x && newPos.y == pos.y) return;\npos = newPos;\nonMove(newPos);\n}\n};\n323\nthis.dom.addEventListener(\"mousemove\", move);\n};\nfunction pointerPosition(pos, domNode) {\nlet rect = domNode.getBoundingClientRect();\nreturn {x: Math.floor((pos.clientX - rect.left) / scale),\ny: Math.floor((pos.clientY - rect.top) / scale)};\n}\nSince we know the size of the pixels and we can use getBoundingClientRect to\nfind the position of the canvas on the screen, it is possible to go from mouse\nevent coordinates (clientX and clientY) to picture coordinates.\nThese are\nalways rounded down so that they refer to a specific pixel.\nWith touch events, we have to do something similar, but using different\nevents and making sure we call preventDefault on the \"touchstart\" event to\nprevent panning.\nPictureCanvas.prototype.touch = function(startEvent,\nonDown) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_745",
    "text": "events and making sure we call preventDefault on the \"touchstart\" event to\nprevent panning.\nPictureCanvas.prototype.touch = function(startEvent,\nonDown) {\nlet pos = pointerPosition(startEvent.touches[0], this.dom);\nlet onMove = onDown(pos);\nstartEvent.preventDefault();\nif (!onMove) return;\nlet move = moveEvent => {\nlet newPos = pointerPosition(moveEvent.touches[0],\nthis.dom);\nif (newPos.x == pos.x && newPos.y == pos.y) return;\npos = newPos;\nonMove(newPos);\n};\nlet end = () => {\nthis.dom.removeEventListener(\"touchmove\", move);\nthis.dom.removeEventListener(\"touchend\", end);\n};\nthis.dom.addEventListener(\"touchmove\", move);\nthis.dom.addEventListener(\"touchend\", end);\n};\nFor touch events, clientX and clientY aren\u2019t available directly on the event\nobject, but we can use the coordinates of the first touch object in the touches\nproperty.\n324\nThe application\nTo make it possible to build the application piece by piece, we\u2019ll implement the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_746",
    "text": "object, but we can use the coordinates of the first touch object in the touches\nproperty.\n324\nThe application\nTo make it possible to build the application piece by piece, we\u2019ll implement the\nmain component as a shell around a picture canvas and a dynamic set of tools\nand controls that we pass to its constructor.\nThe controls are the interface elements that appear below the picture. They\u2019ll\nbe provided as an array of component constructors.\nThe tools do things like drawing pixels or filling in an area. The application\nshows the set of available tools as a <select> field. The currently selected\ntool determines what happens when the user interacts with the picture with a\npointer device. The set of available tools is provided as an object that maps\nthe names that appear in the drop-down field to functions that implement the\ntools. Such functions get a picture position, a current application state, and\na dispatch function as arguments. They may return a move handler function",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_747",
    "text": "tools. Such functions get a picture position, a current application state, and\na dispatch function as arguments. They may return a move handler function\nthat gets called with a new position and a current state when the pointer moves\nto a different pixel.\nclass PixelEditor {\nconstructor(state, config) {\nlet {tools, controls, dispatch} = config;\nthis.state = state;\nthis.canvas = new PictureCanvas(state.picture, pos => {\nlet tool = tools[this.state.tool];\nlet onMove = tool(pos, this.state, dispatch);\nif (onMove) return pos => onMove(pos, this.state);\n});\nthis.controls = controls.map(\nControl => new Control(state, config));\nthis.dom = elt(\"div\", {}, this.canvas.dom, elt(\"br\"),\n...this.controls.reduce(\n(a, c) => a.concat(\" \", c.dom), []));\n}\nsyncState(state) {\nthis.state = state;\nthis.canvas.syncState(state.picture);\nfor (let ctrl of this.controls) ctrl.syncState(state);\n}\n}\nThe pointer handler given to PictureCanvas calls the currently selected tool",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_748",
    "text": "this.state = state;\nthis.canvas.syncState(state.picture);\nfor (let ctrl of this.controls) ctrl.syncState(state);\n}\n}\nThe pointer handler given to PictureCanvas calls the currently selected tool\nwith the appropriate arguments and, if that returns a move handler, adapts it\nto also receive the state.\n325\nAll controls are constructed and stored in this.controls so that they can\nbe updated when the application state changes. The call to reduce introduces\nspaces between the controls\u2019 DOM elements. That way, they don\u2019t look so\npressed together.\nThe first control is the tool selection menu. It creates a <select> element\nwith an option for each tool and sets up a \"change\" event handler that updates\nthe application state when the user selects a different tool.\nclass ToolSelect {\nconstructor(state, {tools, dispatch}) {\nthis.select = elt(\"select\", {\nonchange: () => dispatch({tool: this.select.value})\n}, ...Object.keys(tools).map(name => elt(\"option\", {\nselected: name == state.tool\n}, name)));",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_749",
    "text": "this.select = elt(\"select\", {\nonchange: () => dispatch({tool: this.select.value})\n}, ...Object.keys(tools).map(name => elt(\"option\", {\nselected: name == state.tool\n}, name)));\nthis.dom = elt(\"label\", null, \"\ud83d\udd8cTool: \", this.select);\n}\nsyncState(state) { this.select.value = state.tool; }\n}\nBy wrapping the label text and the field in a <label> element, we tell the\nbrowser that the label belongs to that field so that you can, for example, click\nthe label to focus the field.\nWe also need to be able to change the color, so let\u2019s add a control for that.\nAn HTML <input> element with a type attribute of color gives us a form\nfield that is specialized for selecting colors. Such a field\u2019s value is always a\nCSS color code in \"#RRGGBB\" format (red, green, and blue components, two\ndigits per color). The browser will show a color picker interface when the user\ninteracts with it.\nDepending on the browser, the color picker might look like this:\n326",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_750",
    "text": "digits per color). The browser will show a color picker interface when the user\ninteracts with it.\nDepending on the browser, the color picker might look like this:\n326\nThis control creates such a field and wires it up to stay synchronized with\nthe application state\u2019s color property.\nclass ColorSelect {\nconstructor(state, {dispatch}) {\nthis.input = elt(\"input\", {\ntype: \"color\",\nvalue: state.color,\nonchange: () => dispatch({color: this.input.value})\n});\nthis.dom = elt(\"label\", null, \"\ud83c\udfa8Color: \", this.input);\n}\nsyncState(state) { this.input.value = state.color; }\n}\nDrawing tools\nBefore we can draw anything, we need to implement the tools that will control\nthe functionality of mouse or touch events on the canvas.\nThe most basic tool is the draw tool, which changes any pixel you click or\ntap to the currently selected color. It dispatches an action that updates the\npicture to a version in which the pointed-at pixel is given the currently selected\ncolor.\nfunction draw(pos, state, dispatch) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_751",
    "text": "picture to a version in which the pointed-at pixel is given the currently selected\ncolor.\nfunction draw(pos, state, dispatch) {\nfunction drawPixel({x, y}, state) {\nlet drawn = {x, y, color: state.color};\ndispatch({picture: state.picture.draw([drawn])});\n}\n327\ndrawPixel(pos, state);\nreturn drawPixel;\n}\nThe function immediately calls the drawPixel function but then also returns it\nso that it\u2019s called again for newly touched pixels when the user drags or swipes\nover the picture.\nTo draw larger shapes, it can be useful to quickly create rectangles. The\nrectangle tool draws a rectangle between the point where you start dragging\nand the point that you drag to.\nfunction rectangle(start, state, dispatch) {\nfunction drawRectangle(pos) {\nlet xStart = Math.min(start.x, pos.x);\nlet yStart = Math.min(start.y, pos.y);\nlet xEnd = Math.max(start.x, pos.x);\nlet yEnd = Math.max(start.y, pos.y);\nlet drawn = [];\nfor (let y = yStart; y <= yEnd; y++) {\nfor (let x = xStart; x <= xEnd; x++) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_752",
    "text": "let xEnd = Math.max(start.x, pos.x);\nlet yEnd = Math.max(start.y, pos.y);\nlet drawn = [];\nfor (let y = yStart; y <= yEnd; y++) {\nfor (let x = xStart; x <= xEnd; x++) {\ndrawn.push({x, y, color: state.color});\n}\n}\ndispatch({picture: state.picture.draw(drawn)});\n}\ndrawRectangle(start);\nreturn drawRectangle;\n}\nAn important detail in this implementation is that when dragging, the rectangle\nis redrawn on the picture from the original state. That way, you can make the\nrectangle larger and smaller again while creating it, without the intermediate\nrectangles sticking around in the final picture. This is one of the reasons why\nimmutable picture objects are useful\u2014we\u2019ll see another reason later.\nImplementing flood fill is somewhat more involved. This is a tool that fills\nthe pixel under the pointer and all adjacent pixels that have the same color.\n\u201cAdjacent\u201d means directly horizontally or vertically adjacent, not diagonally.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_753",
    "text": "the pixel under the pointer and all adjacent pixels that have the same color.\n\u201cAdjacent\u201d means directly horizontally or vertically adjacent, not diagonally.\nThis picture illustrates the set of pixels colored when the flood fill tool is used\nat the marked pixel:\n328\nInterestingly, the way we\u2019ll do this looks a bit like the pathfinding code from\nChapter 7. Whereas that code searched through a graph to find a route, this\ncode searches through a grid to find all \u201cconnected\u201d pixels. The problem of\nkeeping track of a branching set of possible routes is similar.\nconst around = [{dx: -1, dy: 0}, {dx: 1, dy: 0},\n{dx: 0, dy: -1}, {dx: 0, dy: 1}];\nfunction fill({x, y}, state, dispatch) {\nlet targetColor = state.picture.pixel(x, y);\nlet drawn = [{x, y, color: state.color}];\nlet visited = new Set();\nfor (let done = 0; done < drawn.length; done++) {\nfor (let {dx, dy} of around) {\nlet x = drawn[done].x + dx, y = drawn[done].y + dy;\nif (x >= 0 && x < state.picture.width &&",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_754",
    "text": "let visited = new Set();\nfor (let done = 0; done < drawn.length; done++) {\nfor (let {dx, dy} of around) {\nlet x = drawn[done].x + dx, y = drawn[done].y + dy;\nif (x >= 0 && x < state.picture.width &&\ny >= 0 && y < state.picture.height &&\n!visited.has(x + \",\" + y) &&\nstate.picture.pixel(x, y) == targetColor) {\ndrawn.push({x, y, color: state.color});\nvisited.add(x + \",\" + y);\n}\n}\n}\ndispatch({picture: state.picture.draw(drawn)});\n}\nThe array of drawn pixels doubles as the function\u2019s work list. For each pixel\nreached, we have to see whether any adjacent pixels have the same color and\nhaven\u2019t already been painted over. The loop counter lags behind the length of\nthe drawn array as new pixels are added. Any pixels ahead of it still need to\nbe explored. When it catches up with the length, no unexplored pixels remain,\nand the function is done.\nThe final tool is a color picker, which allows you to point at a color in the\npicture to use it as the current drawing color.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_755",
    "text": "and the function is done.\nThe final tool is a color picker, which allows you to point at a color in the\npicture to use it as the current drawing color.\nfunction pick(pos, state, dispatch) {\ndispatch({color: state.picture.pixel(pos.x, pos.y)});\n329\n}\nSaving and loading\nWhen we\u2019ve drawn our masterpiece, we\u2019ll want to save it for later. We should\nadd a button for downloading the current picture as an image file. This control\nprovides that button:\nclass SaveButton {\nconstructor(state) {\nthis.picture = state.picture;\nthis.dom = elt(\"button\", {\nonclick: () => this.save()\n}, \"\ud83d\udcbeSave\");\n}\nsave() {\nlet canvas = elt(\"canvas\");\ndrawPicture(this.picture, canvas, 1);\nlet link = elt(\"a\", {\nhref: canvas.toDataURL(),\ndownload: \"pixelart.png\"\n});\ndocument.body.appendChild(link);\nlink.click();\nlink.remove();\n}\nsyncState(state) { this.picture = state.picture; }\n}\nThe component keeps track of the current picture so that it can access it when",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_756",
    "text": "});\ndocument.body.appendChild(link);\nlink.click();\nlink.remove();\n}\nsyncState(state) { this.picture = state.picture; }\n}\nThe component keeps track of the current picture so that it can access it when\nsaving. To create the image file, it uses a <canvas> element on which it draws\nthe picture (at a scale of one pixel per pixel).\nThe toDataURL method on a canvas element creates a URL that uses the\ndata: scheme. Unlike http: and https: URLs, data URLs contain the whole\nresource in the URL. They are usually very long, but they allow us to create\nworking links to arbitrary pictures, right here in the browser.\nTo actually get the browser to download the picture, we then create a link\nelement that points at this URL and has a download attribute. Such links,\nwhen clicked, make the browser show a file save dialog. We add that link to\nthe document, simulate a click on it, and remove it again. You can do a lot\nwith browser technology, but sometimes the way to do it is rather odd.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_757",
    "text": "the document, simulate a click on it, and remove it again. You can do a lot\nwith browser technology, but sometimes the way to do it is rather odd.\nAnd it gets worse. We\u2019ll also want to be able to load existing image files into\n330\nour application. To do that, we again define a button component.\nclass LoadButton {\nconstructor(_, {dispatch}) {\nthis.dom = elt(\"button\", {\nonclick: () => startLoad(dispatch)\n}, \"\ud83d\udcc1Load\");\n}\nsyncState() {}\n}\nfunction startLoad(dispatch) {\nlet input = elt(\"input\", {\ntype: \"file\",\nonchange: () => finishLoad(input.files[0], dispatch)\n});\ndocument.body.appendChild(input);\ninput.click();\ninput.remove();\n}\nTo get access to a file on the user\u2019s computer, we need the user to select the\nfile through a file input field. But we don\u2019t want the load button to look like a\nfile input field, so we create the file input when the button is clicked and then\npretend that this file input itself was clicked.\nWhen the user has selected a file, we can use FileReader to get access to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_758",
    "text": "pretend that this file input itself was clicked.\nWhen the user has selected a file, we can use FileReader to get access to\nits contents, again as a data URL. That URL can be used to create an <img>\nelement, but because we can\u2019t get direct access to the pixels in such an image,\nwe can\u2019t create a Picture object from that.\nfunction finishLoad(file, dispatch) {\nif (file == null) return;\nlet reader = new FileReader();\nreader.addEventListener(\"load\", () => {\nlet image = elt(\"img\", {\nonload: () => dispatch({\npicture: pictureFromImage(image)\n}),\nsrc: reader.result\n});\n});\nreader.readAsDataURL(file);\n}\nTo get access to the pixels, we must first draw the picture to a <canvas> element.\n331\nThe canvas context has a getImageData method that allows a script to read its\npixels. So once the picture is on the canvas, we can access it and construct a\nPicture object.\nfunction pictureFromImage(image) {\nlet width = Math.min(100, image.width);\nlet height = Math.min(100, image.height);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_759",
    "text": "Picture object.\nfunction pictureFromImage(image) {\nlet width = Math.min(100, image.width);\nlet height = Math.min(100, image.height);\nlet canvas = elt(\"canvas\", {width, height});\nlet cx = canvas.getContext(\"2d\");\ncx.drawImage(image, 0, 0);\nlet pixels = [];\nlet {data} = cx.getImageData(0, 0, width, height);\nfunction hex(n) {\nreturn n.toString(16).padStart(2, \"0\");\n}\nfor (let i = 0; i < data.length; i += 4) {\nlet [r, g, b] = data.slice(i, i + 3);\npixels.push(\"#\" + hex(r) + hex(g) + hex(b));\n}\nreturn new Picture(width, height, pixels);\n}\nWe\u2019ll limit the size of images to 100 by 100 pixels, since anything bigger will\nlook huge on our display and might slow down the interface.\nThe data property of the object returned by getImageData is an array of\ncolor components. For each pixel in the rectangle specified by the arguments,\nit contains four values that represent the red, green, blue, and alpha components\nof the pixel\u2019s color, as numbers between 0 and 255. The alpha part represents",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_760",
    "text": "it contains four values that represent the red, green, blue, and alpha components\nof the pixel\u2019s color, as numbers between 0 and 255. The alpha part represents\nopacity\u2014when it is 0, the pixel is fully transparent, and when it is 255, it is\nfully opaque. For our purpose, we can ignore it.\nThe two hexadecimal digits per component, as used in our color notation,\ncorrespond precisely to the 0 to 255 range\u2014two base-16 digits can express 162\n= 256 different numbers. The toString method of numbers can be given a\nbase as an argument, so n.toString(16) will produce a string representation\nin base 16. We have to make sure that each number takes up two digits, so the\nhex helper function calls padStart to add a leading 0 when necessary.\nWe can load and save now! That leaves just one more feature before we\u2019re\ndone.\n332\nUndo history\nBecause half the process of editing is making little mistakes and correcting\nthem, an important feature in a drawing program is an undo history.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_761",
    "text": "done.\n332\nUndo history\nBecause half the process of editing is making little mistakes and correcting\nthem, an important feature in a drawing program is an undo history.\nTo be able to undo changes, we need to store previous versions of the pic-\nture. Since pictures are immutable values, that\u2019s easy. But it does require an\nadditional field in the application state.\nWe\u2019ll add a done array to keep previous versions of the picture. Maintaining\nthis property requires a more complicated state update function that adds\npictures to the array.\nWe don\u2019t want to store every change, though\u2014just changes that are a certain\namount of time apart. To be able to do that, we\u2019ll need a second property,\ndoneAt, to track the time at which we last stored a picture in the history.\nfunction historyUpdateState(state, action) {\nif (action.undo == true) {\nif (state.done.length == 0) return state;\nreturn {\n...state,\npicture: state.done[0],\ndone: state.done.slice(1),\ndoneAt: 0\n};\n} else if (action.picture &&",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_762",
    "text": "if (action.undo == true) {\nif (state.done.length == 0) return state;\nreturn {\n...state,\npicture: state.done[0],\ndone: state.done.slice(1),\ndoneAt: 0\n};\n} else if (action.picture &&\nstate.doneAt < Date.now() - 1000) {\nreturn {\n...state,\n...action,\ndone: [state.picture, ...state.done],\ndoneAt: Date.now()\n};\n} else {\nreturn {...state, ...action};\n}\n}\nWhen the action is an undo action, the function takes the most recent picture\nfrom the history and makes that the current picture. It sets doneAt to zero\nso that the next change is guaranteed to store the picture back in the history,\nallowing you to revert to it another time if you want.\nOtherwise, if the action contains a new picture and the last time we stored\nsomething is more than a second (1000 milliseconds) ago, the done and doneAt\nproperties are updated to store the previous picture.\n333\nThe undo button component doesn\u2019t do much. It dispatches undo actions\nwhen clicked and disables itself when there is nothing to undo.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_763",
    "text": "properties are updated to store the previous picture.\n333\nThe undo button component doesn\u2019t do much. It dispatches undo actions\nwhen clicked and disables itself when there is nothing to undo.\nclass UndoButton {\nconstructor(state, {dispatch}) {\nthis.dom = elt(\"button\", {\nonclick: () => dispatch({undo: true}),\ndisabled: state.done.length == 0\n}, \"\u2baaUndo\");\n}\nsyncState(state) {\nthis.dom.disabled = state.done.length == 0;\n}\n}\nLet's draw\nTo set up the application, we need to create a state, a set of tools, a set\nof controls, and a dispatch function. We can pass them to the PixelEditor\nconstructor to create the main component. Since we\u2019ll need to create several\neditors in the exercises, we first define some bindings.\nconst startState = {\ntool: \"draw\",\ncolor: \"#000000\",\npicture: Picture.empty(60, 30, \"#f0f0f0\"),\ndone: [],\ndoneAt: 0\n};\nconst baseTools = {draw, fill, rectangle, pick};\nconst baseControls = [\nToolSelect, ColorSelect, SaveButton, LoadButton, UndoButton\n];",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_764",
    "text": "picture: Picture.empty(60, 30, \"#f0f0f0\"),\ndone: [],\ndoneAt: 0\n};\nconst baseTools = {draw, fill, rectangle, pick};\nconst baseControls = [\nToolSelect, ColorSelect, SaveButton, LoadButton, UndoButton\n];\nfunction startPixelEditor({state = startState,\ntools = baseTools,\ncontrols = baseControls}) {\nlet app = new PixelEditor(state, {\ntools,\ncontrols,\ndispatch(action) {\nstate = historyUpdateState(state, action);\n334\napp.syncState(state);\n}\n});\nreturn app.dom;\n}\nWhen destructuring an object or array, you can use = after a binding name to\ngive the binding a default value, which is used when the property is missing or\nholds undefined. The startPixelEditor function makes use of this to accept\nan object with a number of optional properties as an argument. If you don\u2019t\nprovide a tools property, for example, tools will be bound to baseTools.\nThis is how we get an actual editor on the screen:\n<div></div>\n<script>\ndocument.querySelector(\"div\")\n.appendChild(startPixelEditor({}));\n</script>",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_765",
    "text": "This is how we get an actual editor on the screen:\n<div></div>\n<script>\ndocument.querySelector(\"div\")\n.appendChild(startPixelEditor({}));\n</script>\nWhy is this so hard?\nBrowser technology is amazing. It provides a powerful set of interface building\nblocks, ways to style and manipulate them, and tools to inspect and debug your\napplications. The software you write for the browser can be run on almost every\ncomputer and phone on the planet.\nAt the same time, browser technology is ridiculous. You have to learn a\nlarge number of silly tricks and obscure facts to master it, and the default\nprogramming model it provides is so problematic that most programmers prefer\nto cover it in several layers of abstraction rather than deal with it directly.\nWhile the situation is definitely improving, it mostly does so in the form\nof more elements being added to address shortcomings\u2014creating even more\ncomplexity. A feature used by a million websites can\u2019t really be replaced. Even",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_766",
    "text": "of more elements being added to address shortcomings\u2014creating even more\ncomplexity. A feature used by a million websites can\u2019t really be replaced. Even\nif it could, it would be hard to decide what it should be replaced with.\nTechnology never exists in a vacuum\u2014we\u2019re constrained by our tools and\nthe social, economic, and historical factors that produced them. This can be\nannoying, but it is generally more productive to try to build a good under-\nstanding of how the existing technical reality works\u2014and why it is the way it\nis\u2014than to rage against it or hold out for another reality.\nNew abstractions can be helpful. The component model and data flow con-\nvention I used in this chapter is a crude form of that. As mentioned, there\nare libraries that try to make user interface programming more pleasant. At\n335\nthe time of writing, React and Svelte are popular choices, but there\u2019s a whole\ncottage industry of such frameworks. If you\u2019re interested in programming web",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_767",
    "text": "335\nthe time of writing, React and Svelte are popular choices, but there\u2019s a whole\ncottage industry of such frameworks. If you\u2019re interested in programming web\napplications, I recommend investigating a few of them to understand how they\nwork and what benefits they provide.\nExercises\nThere is still room for improvement in our program. Let\u2019s add a few more\nfeatures as exercises.\nKeyboard bindings\nAdd keyboard shortcuts to the application. The first letter of a tool\u2019s name\nselects the tool, and ctrl-Z or command-Z activates undo.\nDo this by modifying the PixelEditor component. Add a tabIndex property\nof 0 to the wrapping <div> element so that it can receive keyboard focus. Note\nthat the property corresponding to the tabindex attribute is called tabIndex,\nwith a capital I, and our elt function expects property names. Register the key\nevent handlers directly on that element. This means you have to click, touch,\nor tab to the application before you can interact with it with the keyboard.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_768",
    "text": "event handlers directly on that element. This means you have to click, touch,\nor tab to the application before you can interact with it with the keyboard.\nRemember that keyboard events have ctrlKey and metaKey (for command\non Mac) properties that you can use to see whether those keys are held down.\nEfficient drawing\nDuring drawing, the majority of work that our application does happens in\ndrawPicture. Creating a new state and updating the rest of the DOM isn\u2019t\nvery expensive, but repainting all the pixels on the canvas is quite a bit of\nwork.\nFind a way to make the syncState method of PictureCanvas faster by re-\ndrawing only the pixels that actually changed.\nRemember that drawPicture is also used by the save button, so if you change\nit, either make sure the changes don\u2019t break the old use or create a new version\nwith a different name.\nAlso note that changing the size of a <canvas> element, by setting its width\nor height properties, clears it, making it entirely transparent again.\n336",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_769",
    "text": "with a different name.\nAlso note that changing the size of a <canvas> element, by setting its width\nor height properties, clears it, making it entirely transparent again.\n336\nCircles\nDefine a tool called circle that draws a filled circle when you drag. The center\nof the circle lies at the point where the drag or touch gesture starts, and its\nradius is determined by the distance dragged.\nProper lines\nThis is a more advanced exercise than the preceding three, and it will require\nyou to design a solution to a nontrivial problem. Make sure you have plenty\nof time and patience before starting to work on this exercise, and don\u2019t get\ndiscouraged by initial failures.\nOn most browsers, when you select the draw tool and quickly drag across\nthe picture, you don\u2019t get a closed line. Rather, you get dots with gaps be-\ntween them because the \"mousemove\" or \"touchmove\" events did not fire quickly\nenough to hit every pixel.\nImprove the draw tool to make it draw a full line. This means you have to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_770",
    "text": "tween them because the \"mousemove\" or \"touchmove\" events did not fire quickly\nenough to hit every pixel.\nImprove the draw tool to make it draw a full line. This means you have to\nmake the motion handler function remember the previous position and connect\nthat to the current one.\nTo do this, since the pixels can be an arbitrary distance apart, you\u2019ll have\nto write a general line drawing function.\nA line between two pixels is a connected chain of pixels, as straight as pos-\nsible, going from the start to the end. Diagonally adjacent pixels count as\nconnected.\nA slanted line should look like the picture on the left, not the\npicture on the right.\nFinally, if we have code that draws a line between two arbitrary points, we\nmight as well use it to also define a line tool, which draws a straight line\nbetween the start and end of a drag.\n337\n\u201cA student asked, \u2018The programmers of old used only simple\nmachines and no programming languages, yet they made beautiful",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_771",
    "text": "between the start and end of a drag.\n337\n\u201cA student asked, \u2018The programmers of old used only simple\nmachines and no programming languages, yet they made beautiful\nprograms. Why do we use complicated machines and programming\nlanguages?\u2019 Fu-Tzu replied, \u2018The builders of old used only sticks and\nclay, yet they made beautiful huts.\u201d\u2019\n\u2014Master Yuan-Ma, The Book of Programming\nChapter 20\nNode.js\nSo far, we\u2019ve used the JavaScript language in a single environment: the browser.\nThis chapter and the next one will briefly introduce Node.js, a program that\nallows you to apply your JavaScript skills outside of the browser. With it, you\ncan build anything from small command line tools to HTTP servers that power\ndynamic websites.\nThese chapters aim to teach you the main concepts that Node.js uses and to\ngive you enough information to write useful programs for it. They do not try\nto be a complete, or even a thorough, treatment of the platform.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_772",
    "text": "give you enough information to write useful programs for it. They do not try\nto be a complete, or even a thorough, treatment of the platform.\nIf you want to follow along and run the code in this chapter, you\u2019ll need\nto install Node.js version 18 or higher. To do so, go to https://nodejs.org and\nfollow the installation instructions for your operating system. You can also find\nfurther documentation for Node.js there.\nBackground\nWhen building systems that communicate over the network, the way you man-\nage input and output\u2014that is, the reading and writing of data to and from the\nnetwork and hard drive\u2014can make a big difference in how quickly a system\nresponds to the user or to network requests.\nIn such programs, asynchronous programming is often helpful. It allows the\nprogram to send and receive data from and to multiple devices at the same\ntime without complicated thread management and synchronization.\nNode was initially conceived for the purpose of making asynchronous pro-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_773",
    "text": "time without complicated thread management and synchronization.\nNode was initially conceived for the purpose of making asynchronous pro-\ngramming easy and convenient. JavaScript lends itself well to a system like\nNode. It is one of the few programming languages that does not have a built-in\nway to do input and output. Thus, JavaScript could be fit onto Node\u2019s rather\neccentric approach to network and filesystem programming without ending up\nwith two inconsistent interfaces.\nIn 2009, when Node was being designed,\npeople were already doing callback-based programming in the browser, so the\ncommunity around the language was used to an asynchronous programming\n338\nstyle.\nThe node command\nWhen Node.js is installed on a system, it provides a program called node, which\nis used to run JavaScript files. Say you have a file hello.js, containing this\ncode:\nlet message = \"Hello world\";\nconsole.log(message);\nYou can then run node from the command line like this to execute the program:\n$ node hello.js",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_774",
    "text": "code:\nlet message = \"Hello world\";\nconsole.log(message);\nYou can then run node from the command line like this to execute the program:\n$ node hello.js\nHello world\nThe console.log method in Node does something similar to what it does in\nthe browser. It prints out a piece of text. But in Node, the text will go to\nthe process\u2019s standard output stream rather than to a browser\u2019s JavaScript\nconsole. When running node from the command line, that means you see the\nlogged values in your terminal.\nIf you run node without giving it a file, it provides you with a prompt at\nwhich you can type JavaScript code and immediately see the result.\n$ node\n> 1 + 1\n2\n> [-1, -2, -3].map(Math.abs)\n[1, 2, 3]\n> process.exit(0)\n$\nThe process binding, just like the console binding, is available globally in\nNode. It provides various ways to inspect and manipulate the current program.\nThe exit method ends the process and can be given an exit status code, which",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_775",
    "text": "Node. It provides various ways to inspect and manipulate the current program.\nThe exit method ends the process and can be given an exit status code, which\ntells the program that started node (in this case, the command line shell)\nwhether the program completed successfully (code zero) or encountered an\nerror (any other code).\nTo find the command line arguments given to your script, you can read\nprocess.argv, which is an array of strings. Note that it also includes the name\nof the node command and your script name, so the actual arguments start at\nindex 2. If showargv.js contains the statement console.log(process.argv),\nyou could run it like this:\n339\n$ node showargv.js one --and two\n[\"node\", \"/tmp/showargv.js\", \"one\", \"--and\", \"two\"]\nAll the standard JavaScript global bindings, such as Array, Math, and JSON,\nare also present in Node\u2019s environment. Browser-related functionality, such as\ndocument or prompt, is not.\nModules",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_776",
    "text": "All the standard JavaScript global bindings, such as Array, Math, and JSON,\nare also present in Node\u2019s environment. Browser-related functionality, such as\ndocument or prompt, is not.\nModules\nBeyond the bindings I mentioned, such as console and process, Node puts\nfew additional bindings in the global scope.\nIf you want to access built-in\nfunctionality, you have to ask the module system for it.\nNode started out using the CommonJS module system, based on the require\nfunction, which we saw in Chapter 10. It will still use this system by default\nwhen you load a .js file.\nBut today, Node also supports the more modern ES module system. When\na script\u2019s filename ends in .mjs, it is considered to be such a module, and you\ncan use import and export in it (but not require). We will use ES modules in\nthis chapter.\nWhen importing a module\u2014whether with require or import\u2014Node has to\nresolve the given string to an actual file that it can load. Names that start with",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_777",
    "text": "this chapter.\nWhen importing a module\u2014whether with require or import\u2014Node has to\nresolve the given string to an actual file that it can load. Names that start with\n/, ./, or ../ are resolved as files, relative to the current module\u2019s path. Here,\n. stands for the current directory, ../ for one directory up, and / for the root\nof the filesystem. If you ask for \"./graph.mjs\" from the file /tmp/robot/robot\n.mjs, Node will try to load the file /tmp/robot/graph.mjs.\nWhen a string that does not look like a relative or absolute path is imported,\nit is assumed to refer to either a built-in module or a module installed in a\nnode_modules directory. For example, importing from \"node:fs\" will give you\nNode\u2019s built-in filesystem module. Importing \"robot\" might try to load the\nlibrary found in node_modules/robot/. It\u2019s common to install such libraries\nusing NPM, which we\u2019ll return to in a moment.\nLet\u2019s set up a small project consisting of two files. The first one, called main",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_778",
    "text": "using NPM, which we\u2019ll return to in a moment.\nLet\u2019s set up a small project consisting of two files. The first one, called main\n.mjs, defines a script that can be called from the command line to reverse a\nstring.\nimport {reverse} from \"./reverse.mjs\";\n// Index 2 holds the first actual command line argument\nlet argument = process.argv[2];\nconsole.log(reverse(argument));\n340\nThe file reverse.mjs defines a library for reversing strings, which can be used\nboth by this command line tool and by other scripts that need direct access to\na string-reversing function.\nexport function reverse(string) {\nreturn Array.from(string).reverse().join(\"\");\n}\nRemember that export is used to declare that a binding is part of the module\u2019s\ninterface. That allows main.mjs to import and use the function.\nWe can now call our tool like this:\n$ node main.mjs JavaScript\ntpircSavaJ\nInstalling with NPM\nNPM, introduced in Chapter 10, is an online repository of JavaScript modules,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_779",
    "text": "We can now call our tool like this:\n$ node main.mjs JavaScript\ntpircSavaJ\nInstalling with NPM\nNPM, introduced in Chapter 10, is an online repository of JavaScript modules,\nmany of which are specifically written for Node. When you install Node on\nyour computer, you also get the npm command, which you can use to interact\nwith this repository.\nNPM\u2019s main use is downloading packages. We saw the ini package in Chap-\nter 10. We can use NPM to fetch and install that package on our computer.\n$ npm install ini\nadded 1 package in 723ms\n$ node\n> const {parse} = require(\"ini\");\n> parse(\"x = 1\\ny = 2\");\n{ x: '1', y: '2' }\nAfter running npm install, NPM will have created a directory called node_modules\n. Inside that directory will be an ini directory that contains the library. You\ncan open it and look at the code. When we import \"ini\", this library is loaded,\nand we can call its parse property to parse a configuration file.\nBy default, NPM installs packages under the current directory rather than",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_780",
    "text": "and we can call its parse property to parse a configuration file.\nBy default, NPM installs packages under the current directory rather than\nin a central place. If you are used to other package managers, this may seem\nunusual, but it has advantages\u2014it puts each application in full control of the\npackages it installs and makes it easier to manage versions and clean up when\nremoving an application.\n341\nPackage files\nAfter running npm install to install some package, you will find not only a\nnode_modules directory but also a file called package.json in your current di-\nrectory. It is recommended to have such a file for each project. You can create\nit manually or run npm init. This file contains information about the project,\nsuch as its name and version, and lists its dependencies.\nThe robot simulation from Chapter 7, as modularized in the exercise in\nChapter 10, might have a package.json file like this:\n{\n\"author\": \"Marijn Haverbeke\",\n\"name\": \"eloquent-javascript-robot\",",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_781",
    "text": "The robot simulation from Chapter 7, as modularized in the exercise in\nChapter 10, might have a package.json file like this:\n{\n\"author\": \"Marijn Haverbeke\",\n\"name\": \"eloquent-javascript-robot\",\n\"description\": \"Simulation of a package-delivery robot\",\n\"version\": \"1.0.0\",\n\"main\": \"run.mjs\",\n\"dependencies\": {\n\"dijkstrajs\": \"^1.0.1\",\n\"random-item\": \"^1.0.0\"\n},\n\"license\": \"ISC\"\n}\nWhen you run npm install without naming a package to install, NPM will\ninstall the dependencies listed in package.json. When you install a specific\npackage that is not already listed as a dependency, NPM will add it to package\n.json.\nVersions\nA package.json file lists both the program\u2019s own version and versions for its\ndependencies. Versions are a way to deal with the fact that packages evolve\nseparately, and code written to work with a package as it existed at one point\nmay not work with a later, modified version of the package.\nNPM demands that its packages follow a schema called semantic versioning,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_782",
    "text": "may not work with a later, modified version of the package.\nNPM demands that its packages follow a schema called semantic versioning,\nwhich encodes some information about which versions are compatible (don\u2019t\nbreak the old interface) in the version number. A semantic version consists\nof three numbers separated by periods, such as 2.3.0. Every time new func-\ntionality is added, the middle number has to be incremented.\nEvery time\ncompatibility is broken, so that existing code that uses the package might not\nwork with the new version, the first number has to be incremented.\nA caret character (^) in front of the version number for a dependency in\npackage.json indicates that any version compatible with the given number\n342\nmay be installed. For example, \"^2.3.0\" would mean that any version greater\nthan or equal to 2.3.0 and less than 3.0.0 is allowed.\nThe npm command is also used to publish new packages or new versions of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_783",
    "text": "than or equal to 2.3.0 and less than 3.0.0 is allowed.\nThe npm command is also used to publish new packages or new versions of\npackages. If you run npm publish in a directory that has a package.json file, it\nwill publish a package with the name and version listed in the JSON file to the\nregistry. Anyone can publish packages to NPM\u2014though only under a package\nname that isn\u2019t in use yet, since it wouldn\u2019t be good if random people could\nupdate existing packages.\nThis book won\u2019t delve further into the details of NPM usage.\nRefer to\nhttps://npmjs.com for further documentation and a way to search for packages.\nThe filesystem module\nOne of the most commonly used built-in modules in Node is the node:fs mod-\nule, which stands for filesystem. It exports functions for working with files and\ndirectories.\nFor example, the function called readFile reads a file and then calls a call-\nback with the file\u2019s contents.\nimport {readFile} from \"node:fs\";\nreadFile(\"file.txt\", \"utf8\", (error, text) => {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_784",
    "text": "For example, the function called readFile reads a file and then calls a call-\nback with the file\u2019s contents.\nimport {readFile} from \"node:fs\";\nreadFile(\"file.txt\", \"utf8\", (error, text) => {\nif (error) throw error;\nconsole.log(\"The file contains:\", text);\n});\nThe second argument to readFile indicates the character encoding used to\ndecode the file into a string.\nThere are several ways in which text can be\nencoded to binary data, but most modern systems use UTF-8. Unless you\nhave reasons to believe another encoding is used, pass \"utf8\" when reading a\ntext file. If you do not pass an encoding, Node will assume you are interested\nin the binary data and will give you a Buffer object instead of a string. This is\nan array-like object that contains numbers representing the bytes (8-bit chunks\nof data) in the files.\nimport {readFile} from \"node:fs\";\nreadFile(\"file.txt\", (error, buffer) => {\nif (error) throw error;\nconsole.log(\"The file contained\", buffer.length, \"bytes.\",",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_785",
    "text": "of data) in the files.\nimport {readFile} from \"node:fs\";\nreadFile(\"file.txt\", (error, buffer) => {\nif (error) throw error;\nconsole.log(\"The file contained\", buffer.length, \"bytes.\",\n\"The first byte is:\", buffer[0]);\n});\nA similar function, writeFile, is used to write a file to disk.\n343\nimport {writeFile} from \"node:fs\";\nwriteFile(\"graffiti.txt\", \"Node was here\", err => {\nif (err) console.log(`Failed to write file: ${err}`);\nelse console.log(\"File written.\");\n});\nHere it was not necessary to specify the encoding\u2014writeFile will assume that\nwhen it is given a string to write, rather than a Buffer object, it should write\nit out as text using its default character encoding, which is UTF-8.\nThe node:fs module contains many other useful functions: readdir will give\nyou the files in a directory as an array of strings, stat will retrieve information\nabout a file, rename will rename a file, unlink will remove one, and so on. See\nthe documentation at https://nodejs.org for specifics.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_786",
    "text": "about a file, rename will rename a file, unlink will remove one, and so on. See\nthe documentation at https://nodejs.org for specifics.\nMost of these take a callback function as the last parameter, which they call\neither with an error (the first argument) or with a successful result (the second).\nAs we saw in Chapter 11, there are downsides to this style of programming\u2014the\nbiggest one being that error handling becomes verbose and error prone.\nThe node:fs/promises module exports most of the same functions as the old\nnode:fs module but uses promises rather than callback functions.\nimport {readFile} from \"node:fs/promises\";\nreadFile(\"file.txt\", \"utf8\")\n.then(text => console.log(\"The file contains:\", text));\nSometimes you don\u2019t need asynchronicity and it just gets in the way. Many of\nthe functions in node:fs also have a synchronous variant, which has the same\nname with Sync added to the end. For example, the synchronous version of\nreadFile is called readFileSync.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_787",
    "text": "the functions in node:fs also have a synchronous variant, which has the same\nname with Sync added to the end. For example, the synchronous version of\nreadFile is called readFileSync.\nimport {readFileSync} from \"node:fs\";\nconsole.log(\"The file contains:\",\nreadFileSync(\"file.txt\", \"utf8\"));\nNote that while such a synchronous operation is being performed, your program\nis stopped entirely. If it should be responding to the user or to other machines\non the network, being stuck on a synchronous action might produce annoying\ndelays.\nThe HTTP module\nAnother central module is called node:http. It provides functionality for run-\nning an HTTP server.\nThis is all it takes to start an HTTP server:\n344\nimport {createServer} from \"node:http\";\nlet server = createServer((request, response) => {\nresponse.writeHead(200, {\"Content-Type\": \"text/html\"});\nresponse.write(`\n<h1>Hello!</h1>\n<p>You asked for <code>${request.url}</code></p>`);\nresponse.end();\n});\nserver.listen(8000);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_788",
    "text": "response.writeHead(200, {\"Content-Type\": \"text/html\"});\nresponse.write(`\n<h1>Hello!</h1>\n<p>You asked for <code>${request.url}</code></p>`);\nresponse.end();\n});\nserver.listen(8000);\nconsole.log(\"Listening! (port 8000)\");\nIf you run this script on your own machine, you can point your web browser\nat http://localhost:8000/hello to make a request to your server. It will respond\nwith a small HTML page.\nThe function passed as the argument to createServer is called every time a\nclient connects to the server. The request and response bindings are objects\nrepresenting the incoming and outgoing data. The first contains information\nabout the request, such as its url property, which tells us to what URL the\nrequest was made.\nWhen you open that page in your browser, it sends a request to your own\ncomputer. This causes the server function to run and send back a response,\nwhich you can then see in the browser.\nTo send something to the client, you call methods on the response object.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_789",
    "text": "computer. This causes the server function to run and send back a response,\nwhich you can then see in the browser.\nTo send something to the client, you call methods on the response object.\nThe first, writeHead, will write out the response headers (see Chapter 18). You\ngive it the status code (200 for \u201cOK\u201d in this case) and an object that contains\nheader values. The example sets the Content-Type header to inform the client\nthat we\u2019ll be sending back an HTML document.\nNext, the actual response body (the document itself) is sent with response\n.write. You\u2019re allowed to call this method multiple times if you want to send\nthe response piece by piece\u2014for example, to stream data to the client as it\nbecomes available. Finally, response.end signals the end of the response.\nThe call to server.listen causes the server to start waiting for connections\non port 8000. This is why you have to connect to localhost:8000 to speak to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_790",
    "text": "The call to server.listen causes the server to start waiting for connections\non port 8000. This is why you have to connect to localhost:8000 to speak to\nthis server, rather than just localhost, which would use the default port 80.\nWhen you run this script, the process just sits there and waits. When a\nscript is listening for events\u2014in this case, network connections\u2014node will not\nautomatically exit when it reaches the end of the script. To close it, press\nctrl-C.\nA real web server usually does more than the one in the example\u2014it looks\nat the request\u2019s method (the method property) to see what action the client is\ntrying to perform and looks at the request\u2019s URL to find out on which resource\n345\nthis action is being performed. We\u2019ll see a more advanced server later in this\nchapter.\nThe node:http module also provides a request function that can be used\nto make HTTP requests. However, it is a lot more cumbersome to use than",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_791",
    "text": "chapter.\nThe node:http module also provides a request function that can be used\nto make HTTP requests. However, it is a lot more cumbersome to use than\nfetch, which we saw in Chapter 18. Fortunately, fetch is also available in\nNode as a global binding. Unless you want to do something very specific, such\nas processing the response document piece by piece as the data comes in over\nthe network, I recommend sticking to fetch.\nStreams\nThe response object that the HTTP server could write to is an example of a\nwritable stream object, which is a widely used concept in Node. Such objects\nhave a write method that can be passed a string or a Buffer object to write\nsomething to the stream. Their end method closes the stream and optionally\ntakes a value to write to the stream before closing. Both of these methods can\nalso be given a callback as an additional argument, which they will call when\nthe writing or closing has finished.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_792",
    "text": "takes a value to write to the stream before closing. Both of these methods can\nalso be given a callback as an additional argument, which they will call when\nthe writing or closing has finished.\nIt is possible to create a writable stream that points at a file with the\ncreateWriteStream function from the node:fs module. You can then use the\nwrite method on the resulting object to write the file one piece at a time rather\nthan in one shot, as with writeFile.\nReadable streams are a little more involved. The request argument to the\nHTTP server\u2019s callback is a readable stream. Reading from a stream is done\nusing event handlers rather than methods.\nObjects that emit events in Node have a method called on that is similar to\nthe addEventListener method in the browser. You give it an event name and\nthen a function, and it will register that function to be called whenever the\ngiven event occurs.\nReadable streams have \"data\" and \"end\" events. The first is fired every time",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_793",
    "text": "then a function, and it will register that function to be called whenever the\ngiven event occurs.\nReadable streams have \"data\" and \"end\" events. The first is fired every time\ndata comes in, and the second is called whenever the stream is at its end. This\nmodel is most suited for streaming data that can be immediately processed,\neven when the whole document isn\u2019t available yet. A file can be read as a\nreadable stream by using the createReadStream function from node:fs.\nThis code creates a server that reads request bodies and streams them back\nto the client as all-uppercase text:\nimport {createServer} from \"node:http\";\ncreateServer((request, response) => {\nresponse.writeHead(200, {\"Content-Type\": \"text/plain\"});\n346\nrequest.on(\"data\", chunk =>\nresponse.write(chunk.toString().toUpperCase()));\nrequest.on(\"end\", () => response.end());\n}).listen(8000);\nThe chunk value passed to the data handler will be a binary Buffer. We can",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_794",
    "text": "response.write(chunk.toString().toUpperCase()));\nrequest.on(\"end\", () => response.end());\n}).listen(8000);\nThe chunk value passed to the data handler will be a binary Buffer. We can\nconvert this to a string by decoding it as UTF-8 encoded characters with its\ntoString method.\nThe following piece of code, when run with the uppercasing server active,\nwill send a request to that server and write out the response it gets:\nfetch(\"http://localhost:8000/\", {\nmethod: \"POST\",\nbody: \"Hello server\"\n}).then(resp => resp.text()).then(console.log);\n// \u2192HELLO SERVER\nA file server\nLet\u2019s combine our newfound knowledge about HTTP servers and working with\nthe filesystem to create a bridge between the two: an HTTP server that allows\nremote access to a filesystem. Such a server has all kinds of uses\u2014it allows web\napplications to store and share data, or it can give a group of people shared\naccess to a bunch of files.\nWhen we treat files as HTTP resources, the HTTP methods GET, PUT, and",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_795",
    "text": "applications to store and share data, or it can give a group of people shared\naccess to a bunch of files.\nWhen we treat files as HTTP resources, the HTTP methods GET, PUT, and\nDELETE can be used to read, write, and delete the files, respectively. We will\ninterpret the path in the request as the path of the file that the request refers\nto.\nWe probably don\u2019t want to share our whole filesystem, so we\u2019ll interpret these\npaths as starting in the server\u2019s working directory, which is the directory in\nwhich it was started. If I ran the server from /tmp/public/ (or C:\\tmp\\public\\\non Windows), then a request for /file.txt should refer to /tmp/public/file.\ntxt (or C:\\tmp\\public\\file.txt).\nWe\u2019ll build the program piece by piece, using an object called methods to\nstore the functions that handle the various HTTP methods. Method handlers\nare async functions that get the request object as their argument and return a\npromise that resolves to an object that describes the response.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_796",
    "text": "are async functions that get the request object as their argument and return a\npromise that resolves to an object that describes the response.\nimport {createServer} from \"node:http\";\nconst methods = Object.create(null);\n347\ncreateServer((request, response) => {\nlet handler = methods[request.method] || notAllowed;\nhandler(request).catch(error => {\nif (error.status != null) return error;\nreturn {body: String(error), status: 500};\n}).then(({body, status = 200, type = \"text/plain\"}) => {\nresponse.writeHead(status, {\"Content-Type\": type});\nif (body?.pipe) body.pipe(response);\nelse response.end(body);\n});\n}).listen(8000);\nasync function notAllowed(request) {\nreturn {\nstatus: 405,\nbody: `Method ${request.method} not allowed.`\n};\n}\nThis starts a server that just returns 405 error responses, which is the code\nused to indicate that the server refuses to handle a given method.\nWhen a request handler\u2019s promise is rejected, the catch call translates the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_797",
    "text": "used to indicate that the server refuses to handle a given method.\nWhen a request handler\u2019s promise is rejected, the catch call translates the\nerror into a response object, if it isn\u2019t one already, so that the server can send\nback an error response to inform the client that it failed to handle the request.\nThe status field of the response description may be omitted, in which case\nit defaults to 200 (OK). The content type, in the type property, can also be\nleft off, in which case the response is assumed to be plain text.\nWhen the value of body is a readable stream, it will have a pipe method that\nwe can use to forward all content from a readable stream to a writable stream.\nIf not, it is assumed to be either null (no body), a string, or a buffer, and it is\npassed directly to the response\u2019s end method.\nTo figure out which file path corresponds to a request URL, the urlPath\nfunction uses the built-in URL class (which also exists in the browser) to parse",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_798",
    "text": "passed directly to the response\u2019s end method.\nTo figure out which file path corresponds to a request URL, the urlPath\nfunction uses the built-in URL class (which also exists in the browser) to parse\nthe URL. This constructor expects a full URL, not just the part starting with\nthe slash that we get from request.url, so we give it a dummy domain name\nto fill in. It extracts its pathname, which will be something like \"/file.txt\",\ndecodes that to get rid of the %20-style escape codes, and resolves it relative to\nthe program\u2019s working directory.\nimport {resolve, sep} from \"node:path\";\nconst baseDirectory = process.cwd();\n348\nfunction urlPath(url) {\nlet {pathname} = new URL(url, \"http://d\");\nlet path = resolve(decodeURIComponent(pathname).slice(1));\nif (path != baseDirectory &&\n!path.startsWith(baseDirectory + sep)) {\nthrow {status: 403, body: \"Forbidden\"};\n}\nreturn path;\n}\nAs soon as you set up a program to accept network requests, you have to start",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_799",
    "text": "!path.startsWith(baseDirectory + sep)) {\nthrow {status: 403, body: \"Forbidden\"};\n}\nreturn path;\n}\nAs soon as you set up a program to accept network requests, you have to start\nworrying about security. In this case, if we aren\u2019t careful, it is likely that we\u2019ll\naccidentally expose our whole filesystem to the network.\nFile paths are strings in Node. To map such a string to an actual file, there\u2019s\na nontrivial amount of interpretation going on. Paths may, for example, include\n../ to refer to a parent directory. One obvious source of problems would be\nrequests for paths like /../secret_file.\nTo avoid such problems, urlPath uses the resolve function from the node\n:path module, which resolves relative paths. It then verifies that the result\nis below the working directory. The process.cwd function (where cwd stands\nfor current working directory) can be used to find this working directory. The\nsep binding from the node:path package is the system\u2019s path separator\u2014a",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_800",
    "text": "for current working directory) can be used to find this working directory. The\nsep binding from the node:path package is the system\u2019s path separator\u2014a\nbackslash on Windows and a forward slash on most other systems. When the\npath doesn\u2019t start with the base directory, the function throws an error response\nobject, using the HTTP status code indicating that access to the resource is\nforbidden.\nWe\u2019ll set up the GET method to return a list of files when reading a directory\nand to return the file\u2019s content when reading a regular file.\nOne tricky question is what kind of Content-Type header we should set when\nreturning a file\u2019s content. Since these files could be anything, our server can\u2019t\nsimply return the same content type for all of them. NPM can help us again\nhere. The mime-types package (content type indicators like text/plain are also\ncalled MIME types) knows the correct type for a large number of file extensions.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_801",
    "text": "here. The mime-types package (content type indicators like text/plain are also\ncalled MIME types) knows the correct type for a large number of file extensions.\nThe following npm command, in the directory where the server script lives,\ninstalls a specific version of mime:\n$ npm install mime-types@2.1.0\nWhen a requested file does not exist, the correct HTTP status code to return\nis 404. We\u2019ll use the stat function, which looks up information about a file, to\nfind out both whether the file exists and whether it is a directory.\n349\nimport {createReadStream} from \"node:fs\";\nimport {stat, readdir} from \"node:fs/promises\";\nimport {lookup} from \"mime-types\";\nmethods.GET = async function(request) {\nlet path = urlPath(request.url);\nlet stats;\ntry {\nstats = await stat(path);\n} catch (error) {\nif (error.code != \"ENOENT\") throw error;\nelse return {status: 404, body: \"File not found\"};\n}\nif (stats.isDirectory()) {\nreturn {body: (await readdir(path)).join(\"\\n\")};\n} else {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_802",
    "text": "} catch (error) {\nif (error.code != \"ENOENT\") throw error;\nelse return {status: 404, body: \"File not found\"};\n}\nif (stats.isDirectory()) {\nreturn {body: (await readdir(path)).join(\"\\n\")};\n} else {\nreturn {body: createReadStream(path),\ntype: lookup(path)};\n}\n};\nBecause it has to touch the disk and thus might take a while, stat is asyn-\nchronous. Since we\u2019re using promises rather than callback style, it has to be\nimported from node:fs/promises instead of directly from node:fs.\nWhen the file does not exist, stat will throw an error object with a code\nproperty of \"ENOENT\". These somewhat obscure, Unix-inspired codes are how\nyou recognize error types in Node.\nThe stats object returned by stat tells us a number of things about a file,\nsuch as its size (size property) and its modification date (mtime property).\nHere we are interested in the question of whether it is a directory or a regular\nfile, which the isDirectory method tells us.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_803",
    "text": "Here we are interested in the question of whether it is a directory or a regular\nfile, which the isDirectory method tells us.\nWe use readdir to read the array of files in a directory and return it to the\nclient. For normal files, we create a readable stream with createReadStream\nand return that as the body, along with the content type that the mime package\ngives us for the file\u2019s name.\nThe code to handle DELETE requests is slightly simpler.\nimport {rmdir, unlink} from \"node:fs/promises\";\nmethods.DELETE = async function(request) {\nlet path = urlPath(request.url);\nlet stats;\ntry {\nstats = await stat(path);\n350\n} catch (error) {\nif (error.code != \"ENOENT\") throw error;\nelse return {status: 204};\n}\nif (stats.isDirectory()) await rmdir(path);\nelse await unlink(path);\nreturn {status: 204};\n};\nWhen an HTTP response does not contain any data, the status code 204 (\u201cno\ncontent\u201d) can be used to indicate this. Since the response to deletion doesn\u2019t",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_804",
    "text": "return {status: 204};\n};\nWhen an HTTP response does not contain any data, the status code 204 (\u201cno\ncontent\u201d) can be used to indicate this. Since the response to deletion doesn\u2019t\nneed to transmit any information beyond whether the operation succeeded,\nthat is a sensible thing to return here.\nYou may be wondering why trying to delete a nonexistent file returns a\nsuccess status code rather than an error. When the file being deleted is not\nthere, you could say that the request\u2019s objective is already fulfilled. The HTTP\nstandard encourages us to make requests idempotent, which means that making\nthe same request multiple times produces the same result as making it once.\nIn a way, if you try to delete something that\u2019s already gone, the effect you were\ntrying to create has been achieved\u2014the thing is no longer there.\nThis is the handler for PUT requests:\nimport {createWriteStream} from \"node:fs\";\nfunction pipeStream(from, to) {\nreturn new Promise((resolve, reject) => {\nfrom.on(\"error\", reject);",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_805",
    "text": "This is the handler for PUT requests:\nimport {createWriteStream} from \"node:fs\";\nfunction pipeStream(from, to) {\nreturn new Promise((resolve, reject) => {\nfrom.on(\"error\", reject);\nto.on(\"error\", reject);\nto.on(\"finish\", resolve);\nfrom.pipe(to);\n});\n}\nmethods.PUT = async function(request) {\nlet path = urlPath(request.url);\nawait pipeStream(request, createWriteStream(path));\nreturn {status: 204};\n};\nWe don\u2019t need to check whether the file exists this time\u2014if it does, we\u2019ll just\noverwrite it. We again use pipe to move data from a readable stream to a\nwritable one, in this case from the request to the file. But since pipe isn\u2019t\nwritten to return a promise, we have to write a wrapper, pipeStream, that\ncreates a promise around the outcome of calling pipe.\n351\nWhen something goes wrong when opening the file, createWriteStream will\nstill return a stream, but that stream will fire an \"error\" event. The stream\nfrom the request may also fail\u2014for example, if the network goes down. So",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_806",
    "text": "still return a stream, but that stream will fire an \"error\" event. The stream\nfrom the request may also fail\u2014for example, if the network goes down. So\nwe wire up both streams\u2019 \"error\" events to reject the promise. When pipe is\ndone, it will close the output stream, which causes it to fire a \"finish\" event.\nThat\u2019s the point at which we can successfully resolve the promise (returning\nnothing).\nThe full script for the server is available at https://eloquentjavascript.net/\ncode/file_server.mjs. You can download that and, after installing its depen-\ndencies, run it with Node to start your own file server. And, of course, you can\nmodify and extend it to solve this chapter\u2019s exercises or to experiment.\nThe command line tool curl, widely available on Unix-like systems (such as\nmacOS and Linux), can be used to make HTTP requests. The following session\nbriefly tests our server. The -X option is used to set the request\u2019s method, and\n-d is used to include a request body.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_807",
    "text": "macOS and Linux), can be used to make HTTP requests. The following session\nbriefly tests our server. The -X option is used to set the request\u2019s method, and\n-d is used to include a request body.\n$ curl http://localhost:8000/file.txt\nFile not found\n$ curl -X PUT -d CONTENT http://localhost:8000/file.txt\n$ curl http://localhost:8000/file.txt\nCONTENT\n$ curl -X DELETE http://localhost:8000/file.txt\n$ curl http://localhost:8000/file.txt\nFile not found\nThe first request for file.txt fails since the file does not exist yet. The PUT\nrequest creates the file, and behold, the next request successfully retrieves it.\nAfter deleting it with a DELETE request, the file is again missing.\nSummary\nNode is a nice, small system that lets us run JavaScript in a nonbrowser context.\nIt was originally designed for network tasks to play the role of a node in a\nnetwork, but it lends itself to all kinds of scripting tasks. If writing JavaScript",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_808",
    "text": "It was originally designed for network tasks to play the role of a node in a\nnetwork, but it lends itself to all kinds of scripting tasks. If writing JavaScript\nis something you enjoy, automating tasks with Node may work well for you.\nNPM provides packages for everything you can think of (and quite a few\nthings you\u2019d probably never think of), and it allows you to fetch and install\nthose packages with the npm program. Node comes with a number of built-in\nmodules, including the node:fs module for working with the filesystem and the\nnode:http module for running HTTP servers.\nAll input and output in Node is done asynchronously, unless you explicitly\n352\nuse a synchronous variant of a function, such as readFileSync. Node origi-\nnally used callbacks for asynchronous functionality, but the node:fs/promises\npackage provides a promise-based interface to the filesystem.\nExercises\nSearch tool\nOn Unix systems, there is a command line tool called grep that can be used to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_809",
    "text": "package provides a promise-based interface to the filesystem.\nExercises\nSearch tool\nOn Unix systems, there is a command line tool called grep that can be used to\nquickly search files for a regular expression.\nWrite a Node script that can be run from the command line and acts some-\nwhat like grep. It treats its first command line argument as a regular expression\nand treats any further arguments as files to search. It outputs the names of\nany file whose content matches the regular expression.\nWhen that works, extend it so that when one of the arguments is a directory,\nit searches through all files in that directory and its subdirectories.\nUse asynchronous or synchronous filesystem functions as you see fit. Setting\nthings up so that multiple asynchronous actions are requested at the same time\nmight speed things up a little, but not a huge amount, since most filesystems\ncan read only one thing at a time.\nDirectory creation",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_810",
    "text": "might speed things up a little, but not a huge amount, since most filesystems\ncan read only one thing at a time.\nDirectory creation\nThough the DELETE method in our file server is able to delete directories (using\nrmdir), the server currently does not provide any way to create a directory.\nAdd support for the MKCOL method (\u201cmake collection\u201d), which should create\na directory by calling mkdir from the node:fs module. MKCOL is not a widely\nused HTTP method, but it does exist for this same purpose in the WebDAV\nstandard, which specifies a set of conventions on top of HTTP that make it\nsuitable for creating documents.\nA public space on the web\nSince the file server serves up any kind of file and even includes the right Content\n-Type header, you can use it to serve a website. Given that this server allows\neverybody to delete and replace files, this would make for an interesting kind\nof website: one that can be modified, improved, and vandalized by everybody",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_811",
    "text": "everybody to delete and replace files, this would make for an interesting kind\nof website: one that can be modified, improved, and vandalized by everybody\nwho takes the time to make the right HTTP request.\nWrite a basic HTML page that includes a simple JavaScript file. Put the\nfiles in a directory served by the file server and open them in your browser.\n353\nNext, as an advanced exercise or even a weekend project, combine all the\nknowledge you gained from this book to build a more user-friendly interface\nfor modifying the website\u2014from inside the website.\nUse an HTML form to edit the content of the files that make up the website,\nallowing the user to update them on the server by using HTTP requests, as\ndescribed in Chapter 18.\nStart by making only a single file editable. Then make it so that the user\ncan select which file to edit. Use the fact that our file server returns lists of\nfiles when reading a directory.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_812",
    "text": "Start by making only a single file editable. Then make it so that the user\ncan select which file to edit. Use the fact that our file server returns lists of\nfiles when reading a directory.\nDon\u2019t work directly in the code exposed by the file server, since if you make\na mistake, you are likely to damage the files there. Instead, keep your work\noutside of the publicly accessible directory and copy it there when testing.\n354\n\u201cIf you have knowledge, let others light their candles at it.\u201d\n\u2014Margaret Fuller\nChapter 21\nProject: Skill-Sharing Website\nA skill-sharing meeting is an event where people with a shared interest come\ntogether and give small, informal presentations about things they know. At a\ngardening skill-sharing meeting, someone might explain how to cultivate celery.\nOr in a programming skill-sharing group, you could drop by and tell people\nabout Node.js.\nIn this final project chapter, our goal is to set up a website for managing",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_813",
    "text": "Or in a programming skill-sharing group, you could drop by and tell people\nabout Node.js.\nIn this final project chapter, our goal is to set up a website for managing\ntalks given at a skill-sharing meeting. Imagine a small group of people meeting\nup regularly in the o\ufb00ice of one of the members to talk about unicycling. The\nprevious organizer of the meetings moved to another town, and nobody stepped\nforward to take over this task. We want a system that will let the participants\npropose and discuss talks among themselves without an active organizer.\nThe full code for the project can be downloaded from https://eloquentjavascript.net/\ncode/skillsharing.zip.\nDesign\nThere is a server part to this project, written for Node.js, and a client part,\nwritten for the browser. The server stores the system\u2019s data and provides it to\nthe client. It also serves the files that implement the client-side system.\nThe server keeps the list of talks proposed for the next meeting, and the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_814",
    "text": "the client. It also serves the files that implement the client-side system.\nThe server keeps the list of talks proposed for the next meeting, and the\nclient shows this list. Each talk has a presenter name, a title, a summary, and\nan array of comments associated with it. The client allows users to propose new\ntalks (adding them to the list), delete talks, and comment on existing talks.\nWhenever the user makes such a change, the client makes an HTTP request to\ntell the server about it.\n355\nThe application will be set up to show a live view of the current proposed\ntalks and their comments. Whenever someone, somewhere, submits a new talk\nor adds a comment, all people who have the page open in their browsers should\nimmediately see the change. This poses a bit of a challenge\u2014there is no way\nfor a web server to open a connection to a client, nor is there a good way to\nknow which clients are currently looking at a given website.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_815",
    "text": "for a web server to open a connection to a client, nor is there a good way to\nknow which clients are currently looking at a given website.\nA common solution to this problem is called long polling, which happens to\nbe one of the motivations for Node\u2019s design.\nLong polling\nTo be able to immediately notify a client that something changed, we need a\nconnection to that client. Since web browsers do not traditionally accept con-\nnections and clients are often behind routers that would block such connections\nanyway, having the server initiate this connection is not practical.\nWe can arrange for the client to open the connection and keep it around so\nthat the server can use it to send information when it needs to do so. But\nan HTTP request allows only a simple flow of information: the client sends a\nrequest, the server comes back with a single response, and that\u2019s it. A tech-\nnology called WebSockets makes it possible to open connections for arbitrary",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_816",
    "text": "request, the server comes back with a single response, and that\u2019s it. A tech-\nnology called WebSockets makes it possible to open connections for arbitrary\ndata exchange, but using such sockets properly is somewhat tricky.\n356\nIn this chapter, we use a simpler technique, long polling, where clients con-\ntinuously ask the server for new information using regular HTTP requests, and\nthe server stalls its answer when it has nothing new to report.\nAs long as the client makes sure it constantly has a polling request open, it\nwill receive information from the server quickly after it becomes available. For\nexample, if Fatma has our skill-sharing application open in her browser, that\nbrowser will have made a request for updates and will be waiting for a response\nto that request. When Iman submits a talk on Extreme Downhill Unicycling,\nthe server will notice that Fatma is waiting for updates and send a response\ncontaining the new talk to her pending request. Fatma\u2019s browser will receive",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_817",
    "text": "the server will notice that Fatma is waiting for updates and send a response\ncontaining the new talk to her pending request. Fatma\u2019s browser will receive\nthe data and update the screen to show the talk.\nTo prevent connections from timing out (being aborted because of a lack of\nactivity), long polling techniques usually set a maximum time for each request,\nafter which the server will respond anyway, even though it has nothing to\nreport. The client can then start a new request. Periodically restarting the\nrequest also makes the technique more robust, allowing clients to recover from\ntemporary connection failures or server problems.\nA busy server that is using long polling may have thousands of waiting\nrequests, and thus TCP connections, open.\nNode, which makes it easy to\nmanage many connections without creating a separate thread of control for\neach one, is a good fit for such a system.\nHTTP interface\nBefore we start designing either the server or the client, let\u2019s think about the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_818",
    "text": "each one, is a good fit for such a system.\nHTTP interface\nBefore we start designing either the server or the client, let\u2019s think about the\npoint where they touch: the HTTP interface over which they communicate.\nWe will use JSON as the format of our request and response body. Like in\nthe file server from Chapter 20, we\u2019ll try to make good use of HTTP methods\nand headers. The interface is centered around the /talks path. Paths that\ndo not start with /talks will be used for serving static files\u2014the HTML and\nJavaScript code for the client-side system.\nA GET request to /talks returns a JSON document like this:\n[{\"title\": \"Unituning\",\n\"presenter\": \"Jamal\",\n\"summary\": \"Modifying your cycle for extra style\",\n\"comments\": []}]\nCreating a new talk is done by making a PUT request to a URL like /talks/\nUnituning, where the part after the second slash is the title of the talk. The PUT\n357\nrequest\u2019s body should contain a JSON object that has presenter and summary\nproperties.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_819",
    "text": "Unituning, where the part after the second slash is the title of the talk. The PUT\n357\nrequest\u2019s body should contain a JSON object that has presenter and summary\nproperties.\nSince talk titles may contain spaces and other characters that may not appear\nnormally in a URL, title strings must be encoded with the encodeURIComponent\nfunction when building up such a URL.\nconsole.log(\"/talks/\" + encodeURIComponent(\"How to Idle\"));\n// \u2192/talks/How%20to%20Idle\nA request to create a talk about idling might look something like this:\nPUT /talks/How%20to%20Idle HTTP/1.1\nContent-Type: application/json\nContent-Length: 92\n{\"presenter\": \"Maureen\",\n\"summary\": \"Standing still on a unicycle\"}\nSuch URLs also support GET requests to retrieve the JSON representation of a\ntalk and DELETE requests to delete a talk.\nAdding a comment to a talk is done with a POST request to a URL like /\ntalks/Unituning/comments, with a JSON body that has author and message\nproperties.\nPOST /talks/Unituning/comments HTTP/1.1",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_820",
    "text": "Adding a comment to a talk is done with a POST request to a URL like /\ntalks/Unituning/comments, with a JSON body that has author and message\nproperties.\nPOST /talks/Unituning/comments HTTP/1.1\nContent-Type: application/json\nContent-Length: 72\n{\"author\": \"Iman\",\n\"message\": \"Will you talk about raising a cycle?\"}\nTo support long polling, GET requests to /talks may include extra headers\nthat inform the server to delay the response if no new information is available.\nWe\u2019ll use a pair of headers normally intended to manage caching: ETag and\nIf-None-Match.\nServers may include an ETag (\u201centity tag\u201d) header in a response. Its value is\na string that identifies the current version of the resource. Clients, when they\nlater request that resource again, may make a conditional request by including\nan If-None-Match header whose value holds that same string. If the resource\nhasn\u2019t changed, the server will respond with status code 304, which means \u201cnot",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_821",
    "text": "an If-None-Match header whose value holds that same string. If the resource\nhasn\u2019t changed, the server will respond with status code 304, which means \u201cnot\nmodified\u201d, telling the client that its cached version is still current. When the\ntag does not match, the server responds as normal.\nWe need something like this, where the client can tell the server which version\nof the list of talks it has, and the server responds only when that list has\n358\nchanged.\nBut instead of immediately returning a 304 response, the server\nshould stall the response and return only when something new is available or\na given amount of time has elapsed. To distinguish long polling requests from\nnormal conditional requests, we give them another header, Prefer: wait=90,\nwhich tells the server that the client is willing to wait up to 90 seconds for the\nresponse.\nThe server will keep a version number that it updates every time the talks\nchange and will use that as the ETag value. Clients can make requests like this",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_822",
    "text": "response.\nThe server will keep a version number that it updates every time the talks\nchange and will use that as the ETag value. Clients can make requests like this\nto be notified when the talks change:\nGET /talks HTTP/1.1\nIf-None-Match: \"4\"\nPrefer: wait=90\n(time passes)\nHTTP/1.1 200 OK\nContent-Type: application/json\nETag: \"5\"\nContent-Length: 295\n[...]\nThe protocol described here doesn\u2019t do any access control.\nEverybody can\ncomment, modify talks, and even delete them. (Since the internet is full of\nhooligans, putting such a system online without further protection probably\nwouldn\u2019t end well.)\nThe server\nLet\u2019s start by building the server-side part of the program. The code in this\nsection runs on Node.js.\nRouting\nOur server will use Node\u2019s createServer to start an HTTP server.\nIn the\nfunction that handles a new request, we must distinguish between the various\nkinds of requests (as determined by the method and the path) that we support.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_823",
    "text": "In the\nfunction that handles a new request, we must distinguish between the various\nkinds of requests (as determined by the method and the path) that we support.\nThis can be done with a long chain of if statements, but there\u2019s a nicer way.\nA router is a component that helps dispatch a request to the function that\ncan handle it. You can tell the router, for example, that PUT requests with\na path that matches the regular expression /^\\/talks\\/([^\\/]+)$/ (/talks/\n359\nfollowed by a talk title) can be handled by a given function. In addition, it\ncan help extract the meaningful parts of the path (in this case the talk title),\nwrapped in parentheses in the regular expression, and pass them to the handler\nfunction.\nThere are a number of good router packages on NPM, but here we\u2019ll write\none ourselves to illustrate the principle.\nThis is router.mjs, which we will later import from our server module:\nexport class Router {\nconstructor() {\nthis.routes = [];\n}\nadd(method, url, handler) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_824",
    "text": "one ourselves to illustrate the principle.\nThis is router.mjs, which we will later import from our server module:\nexport class Router {\nconstructor() {\nthis.routes = [];\n}\nadd(method, url, handler) {\nthis.routes.push({method, url, handler});\n}\nasync resolve(request, context) {\nlet {pathname} = new URL(request.url, \"http://d\");\nfor (let {method, url, handler} of this.routes) {\nlet match = url.exec(pathname);\nif (!match || request.method != method) continue;\nlet parts = match.slice(1).map(decodeURIComponent);\nreturn handler(context, ...parts, request);\n}\n}\n}\nThe module exports the Router class. A router object allows you to register\nhandlers for specific methods and URL patterns with its add method. When a\nrequest is resolved with the resolve method, the router calls the handler whose\nmethod and URL match the request and return its result.\nHandler functions are called with the context value given to resolve. We",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_825",
    "text": "method and URL match the request and return its result.\nHandler functions are called with the context value given to resolve. We\nwill use this to give them access to our server state. Additionally, they receive\nthe match strings for any groups they defined in their regular expression, and\nthe request object. The strings have to be URL-decoded, since the raw URL\nmay contain %20-style codes.\nServing files\nWhen a request matches none of the request types defined in our router, the\nserver must interpret it as a request for a file in the public directory. It would\nbe possible to use the file server defined in Chapter 20 to serve such files, but\nwe neither need nor want to support PUT and DELETE requests on files, and we\nwould like to have advanced features such as support for caching. Let\u2019s use a\n360\nsolid, well-tested static file server from NPM instead.\nI opted for serve-static. This isn\u2019t the only such server on NPM, but it",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_826",
    "text": "360\nsolid, well-tested static file server from NPM instead.\nI opted for serve-static. This isn\u2019t the only such server on NPM, but it\nworks well and fits our purposes. The serve-static package exports a function\nthat can be called with a root directory to produce a request handler function.\nThe handler function accepts the request and response arguments provided by\nthe server from \"node:http\", and a third argument, a function that it will call\nif no file matches the request. We want our server to first check for requests\nwe should handle specially, as defined in the router, so we wrap it in another\nfunction.\nimport {createServer} from \"node:http\";\nimport serveStatic from \"serve-static\";\nfunction notFound(request, response) {\nresponse.writeHead(404, \"Not found\");\nresponse.end(\"<h1>Not found</h1>\");\n}\nclass SkillShareServer {\nconstructor(talks) {\nthis.talks = talks;\nthis.version = 0;\nthis.waiting = [];\nlet fileServer = serveStatic(\"./public\");",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_827",
    "text": "response.end(\"<h1>Not found</h1>\");\n}\nclass SkillShareServer {\nconstructor(talks) {\nthis.talks = talks;\nthis.version = 0;\nthis.waiting = [];\nlet fileServer = serveStatic(\"./public\");\nthis.server = createServer((request, response) => {\nserveFromRouter(this, request, response, () => {\nfileServer(request, response,\n() => notFound(request, response));\n});\n});\n}\nstart(port) {\nthis.server.listen(port);\n}\nstop() {\nthis.server.close();\n}\n}\nThe serveFromRouter function has the same interface as fileServer, taking\n(request, response, next) arguments. We can use this to \u201cchain\u201d several re-\nquest handlers, allowing each to either handle the request or pass responsibility\nfor that on to the next handler. The final handler, notFound, simply responds\n361\nwith a \u201cnot found\u201d error.\nOur serveFromRouter function uses a similar convention to the file server\nfrom the previous chapter for responses\u2014handlers in the router return promises\nthat resolve to objects describing the response.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_828",
    "text": "from the previous chapter for responses\u2014handlers in the router return promises\nthat resolve to objects describing the response.\nimport {Router} from \"./router.mjs\";\nconst router = new Router();\nconst defaultHeaders = {\"Content-Type\": \"text/plain\"};\nasync function serveFromRouter(server, request,\nresponse, next) {\nlet resolved = await router.resolve(request, server)\n.catch(error => {\nif (error.status != null) return error;\nreturn {body: String(err), status: 500};\n});\nif (!resolved) return next();\nlet {body, status = 200, headers = defaultHeaders} =\nawait resolved;\nresponse.writeHead(status, headers);\nresponse.end(body);\n}\nTalks as resources\nThe talks that have been proposed are stored in the talks property of the\nserver, an object whose property names are the talk titles. We\u2019ll add some\nhandlers to our router that expose these as HTTP resources under /talks/<\ntitle>.\nThe handler for requests that GET a single talk must look up the talk and",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_829",
    "text": "handlers to our router that expose these as HTTP resources under /talks/<\ntitle>.\nThe handler for requests that GET a single talk must look up the talk and\nrespond either with the talk\u2019s JSON data or with a 404 error response.\nconst talkPath = /^\\/talks\\/([^\\/]+)$/;\nrouter.add(\"GET\", talkPath, async (server, title) => {\nif (Object.hasOwn(server.talks, title)) {\nreturn {body: JSON.stringify(server.talks[title]),\nheaders: {\"Content-Type\": \"application/json\"}};\n} else {\nreturn {status: 404, body: `No talk '${title}' found`};\n}\n});\n362\nDeleting a talk is done by removing it from the talks object.\nrouter.add(\"DELETE\", talkPath, async (server, title) => {\nif (Object.hasOwn(server.talks, title)) {\ndelete server.talks[title];\nserver.updated();\n}\nreturn {status: 204};\n});\nThe updated method, which we will define later, notifies waiting long polling\nrequests about the change.\nOne handler that needs to read request bodies is the PUT handler, which",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_830",
    "text": "});\nThe updated method, which we will define later, notifies waiting long polling\nrequests about the change.\nOne handler that needs to read request bodies is the PUT handler, which\nis used to create new talks. It has to check whether the data it was given\nhas presenter and summary properties, which are strings. Any data coming\nfrom outside the system might be nonsense, and we don\u2019t want to corrupt our\ninternal data model or crash when bad requests come in.\nIf the data looks valid, the handler stores an object that represents the new\ntalk in the talks object, possibly overwriting an existing talk with this title,\nand again calls updated.\nTo read the body from the request stream, we will use the json function\nfrom \"node:stream/consumers\", which collects the data in the stream and then\nparses it as JSON. There are similar exports called text (to read the content\nas a string) and buffer (to read it as binary data) in this package. Since json",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_831",
    "text": "parses it as JSON. There are similar exports called text (to read the content\nas a string) and buffer (to read it as binary data) in this package. Since json\nis a very generic name, the import renames it to readJSON to avoid confusion.\nimport {json as readJSON} from \"node:stream/consumers\";\nrouter.add(\"PUT\", talkPath,\nasync (server, title, request) => {\nlet talk = await readJSON(request);\nif (!talk ||\ntypeof talk.presenter != \"string\" ||\ntypeof talk.summary != \"string\") {\nreturn {status: 400, body: \"Bad talk data\"};\n}\nserver.talks[title] = {\ntitle,\npresenter: talk.presenter,\nsummary: talk.summary,\ncomments: []\n};\nserver.updated();\nreturn {status: 204};\n363\n});\nAdding a comment to a talk works similarly.\nWe use readJSON to get the\ncontent of the request, validate the resulting data, and store it as a comment\nwhen it looks valid.\nrouter.add(\"POST\", /^\\/talks\\/([^\\/]+)\\/comments$/,\nasync (server, title, request) => {\nlet comment = await readJSON(request);\nif (!comment ||",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_832",
    "text": "when it looks valid.\nrouter.add(\"POST\", /^\\/talks\\/([^\\/]+)\\/comments$/,\nasync (server, title, request) => {\nlet comment = await readJSON(request);\nif (!comment ||\ntypeof comment.author != \"string\" ||\ntypeof comment.message != \"string\") {\nreturn {status: 400, body: \"Bad comment data\"};\n} else if (Object.hasOwn(server.talks, title)) {\nserver.talks[title].comments.push(comment);\nserver.updated();\nreturn {status: 204};\n} else {\nreturn {status: 404, body: `No talk '${title}' found`};\n}\n});\nTrying to add a comment to a nonexistent talk returns a 404 error.\nLong polling support\nThe most interesting aspect of the server is the part that handles long polling.\nWhen a GET request comes in for /talks, it may be either a regular request or\na long polling request.\nThere will be multiple places in which we have to send an array of talks to\nthe client, so we first define a helper method that builds up such an array and\nincludes an ETag header in the response.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_833",
    "text": "There will be multiple places in which we have to send an array of talks to\nthe client, so we first define a helper method that builds up such an array and\nincludes an ETag header in the response.\nSkillShareServer.prototype.talkResponse = function() {\nlet talks = Object.keys(this.talks)\n.map(title => this.talks[title]);\nreturn {\nbody: JSON.stringify(talks),\nheaders: {\"Content-Type\": \"application/json\",\n\"ETag\": `\"${this.version}\"`,\n\"Cache-Control\": \"no-store\"}\n};\n};\nThe handler itself needs to look at the request headers to see whether If-None\n364\n-Match and Prefer headers are present. Node stores headers, whose names are\nspecified to be case insensitive, under their lowercase names.\nrouter.add(\"GET\", /^\\/talks$/, async (server, request) => {\nlet tag = /\"(.*)\"/.exec(request.headers[\"if-none-match\"]);\nlet wait = /\\bwait=(\\d+)/.exec(request.headers[\"prefer\"]);\nif (!tag || tag[1] != server.version) {\nreturn server.talkResponse();\n} else if (!wait) {\nreturn {status: 304};\n} else {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_834",
    "text": "let wait = /\\bwait=(\\d+)/.exec(request.headers[\"prefer\"]);\nif (!tag || tag[1] != server.version) {\nreturn server.talkResponse();\n} else if (!wait) {\nreturn {status: 304};\n} else {\nreturn server.waitForChanges(Number(wait[1]));\n}\n});\nIf no tag was given or a tag was given that doesn\u2019t match the server\u2019s current\nversion, the handler responds with the list of talks. If the request is conditional\nand the talks did not change, we consult the Prefer header to see whether we\nshould delay the response or respond right away.\nCallback functions for delayed requests are stored in the server\u2019s waiting ar-\nray so that they can be notified when something happens. The waitForChanges\nmethod also immediately sets a timer to respond with a 304 status when the\nrequest has waited long enough.\nSkillShareServer.prototype.waitForChanges = function(time) {\nreturn new Promise(resolve => {\nthis.waiting.push(resolve);\nsetTimeout(() => {\nif (!this.waiting.includes(resolve)) return;",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_835",
    "text": "SkillShareServer.prototype.waitForChanges = function(time) {\nreturn new Promise(resolve => {\nthis.waiting.push(resolve);\nsetTimeout(() => {\nif (!this.waiting.includes(resolve)) return;\nthis.waiting = this.waiting.filter(r => r != resolve);\nresolve({status: 304});\n}, time * 1000);\n});\n};\nRegistering a change with updated increases the version property and wakes\nup all waiting requests.\nSkillShareServer.prototype.updated = function() {\nthis.version++;\nlet response = this.talkResponse();\nthis.waiting.forEach(resolve => resolve(response));\nthis.waiting = [];\n};\nThat concludes the server code. If we create an instance of SkillShareServer\n365\nand start it on port 8000, the resulting HTTP server serves files from the public\nsubdirectory alongside a talk-managing interface under the /talks URL.\nnew SkillShareServer({}).start(8000);\nThe client\nThe client-side part of the skill-sharing website consists of three files: a tiny\nHTML page, a style sheet, and a JavaScript file.\nHTML",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_836",
    "text": "new SkillShareServer({}).start(8000);\nThe client\nThe client-side part of the skill-sharing website consists of three files: a tiny\nHTML page, a style sheet, and a JavaScript file.\nHTML\nIt is a widely used convention for web servers to try to serve a file named index\n.html when a request is made directly to a path that corresponds to a directory.\nThe file server module we use, serve-static, supports this convention. When a\nrequest is made to the path /, the server looks for the file ./public/index.html\n(./public being the root we gave it) and returns that file if found.\nThus, if we want a page to show up when a browser is pointed at our server,\nwe should put it in public/index.html. This is our index file:\n<!doctype html>\n<meta charset=\"utf-8\">\n<title>Skill Sharing</title>\n<link rel=\"stylesheet\" href=\"skillsharing.css\">\n<h1>Skill Sharing</h1>\n<script src=\"skillsharing_client.js\"></script>\nIt defines the document title and includes a style sheet, which defines a few",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_837",
    "text": "<link rel=\"stylesheet\" href=\"skillsharing.css\">\n<h1>Skill Sharing</h1>\n<script src=\"skillsharing_client.js\"></script>\nIt defines the document title and includes a style sheet, which defines a few\nstyles to, among other things, make sure there is some space between talks. It\nthen adds a heading at the top of the page and loads the script that contains\nthe client-side application.\nActions\nThe application state consists of the list of talks and the name of the user, and\nwe\u2019ll store it in a {talks, user} object. We don\u2019t allow the user interface to\ndirectly manipulate the state or send off HTTP requests. Rather, it may emit\nactions that describe what the user is trying to do.\nThe handleAction function takes such an action and makes it happen. Be-\ncause our state updates are so simple, state changes are handled in the same\n366\nfunction.\nfunction handleAction(state, action) {\nif (action.type == \"setUser\") {\nlocalStorage.setItem(\"userName\", action.user);\nreturn {...state, user: action.user};",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_838",
    "text": "366\nfunction.\nfunction handleAction(state, action) {\nif (action.type == \"setUser\") {\nlocalStorage.setItem(\"userName\", action.user);\nreturn {...state, user: action.user};\n} else if (action.type == \"setTalks\") {\nreturn {...state, talks: action.talks};\n} else if (action.type == \"newTalk\") {\nfetchOK(talkURL(action.title), {\nmethod: \"PUT\",\nheaders: {\"Content-Type\": \"application/json\"},\nbody: JSON.stringify({\npresenter: state.user,\nsummary: action.summary\n})\n}).catch(reportError);\n} else if (action.type == \"deleteTalk\") {\nfetchOK(talkURL(action.talk), {method: \"DELETE\"})\n.catch(reportError);\n} else if (action.type == \"newComment\") {\nfetchOK(talkURL(action.talk) + \"/comments\", {\nmethod: \"POST\",\nheaders: {\"Content-Type\": \"application/json\"},\nbody: JSON.stringify({\nauthor: state.user,\nmessage: action.message\n})\n}).catch(reportError);\n}\nreturn state;\n}\nWe\u2019ll store the user\u2019s name in localStorage so that it can be restored when\nthe page is loaded.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_839",
    "text": "author: state.user,\nmessage: action.message\n})\n}).catch(reportError);\n}\nreturn state;\n}\nWe\u2019ll store the user\u2019s name in localStorage so that it can be restored when\nthe page is loaded.\nThe actions that need to involve the server make network requests, using\nfetch, to the HTTP interface described earlier. We use a wrapper function,\nfetchOK, which makes sure the returned promise is rejected when the server\nreturns an error code.\nfunction fetchOK(url, options) {\nreturn fetch(url, options).then(response => {\nif (response.status < 400) return response;\nelse throw new Error(response.statusText);\n});\n}\n367\nThis helper function is used to build up a URL for a talk with a given title.\nfunction talkURL(title) {\nreturn \"talks/\" + encodeURIComponent(title);\n}\nWhen the request fails, we don\u2019t want our page to just sit there doing nothing\nwithout explanation. The function called reportError, which we used as the\ncatch handler, shows the user a crude dialog to tell them something went\nwrong.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_840",
    "text": "without explanation. The function called reportError, which we used as the\ncatch handler, shows the user a crude dialog to tell them something went\nwrong.\nfunction reportError(error) {\nalert(String(error));\n}\nRendering components\nWe\u2019ll use an approach similar to the one we saw in Chapter 19, splitting the\napplication into components. However, since some of the components either\nnever need to update or are always fully redrawn when updated, we\u2019ll define\nthose not as classes but as functions that directly return a DOM node. For\nexample, here is a component that shows the field where the user can enter\ntheir name:\nfunction renderUserField(name, dispatch) {\nreturn elt(\"label\", {}, \"Your name: \", elt(\"input\", {\ntype: \"text\",\nvalue: name,\nonchange(event) {\ndispatch({type: \"setUser\", user: event.target.value});\n}\n}));\n}\nThe elt function used to construct DOM elements is the one we used in Chapter\n19.\nA similar function is used to render talks, which include a list of comments and",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_841",
    "text": "}\n}));\n}\nThe elt function used to construct DOM elements is the one we used in Chapter\n19.\nA similar function is used to render talks, which include a list of comments and\na form for adding a new comment.\nfunction renderTalk(talk, dispatch) {\nreturn elt(\n\"section\", {className: \"talk\"},\nelt(\"h2\", null, talk.title, \" \", elt(\"button\", {\ntype: \"button\",\n368\nonclick() {\ndispatch({type: \"deleteTalk\", talk: talk.title});\n}\n}, \"Delete\")),\nelt(\"div\", null, \"by \",\nelt(\"strong\", null, talk.presenter)),\nelt(\"p\", null, talk.summary),\n...talk.comments.map(renderComment),\nelt(\"form\", {\nonsubmit(event) {\nevent.preventDefault();\nlet form = event.target;\ndispatch({type: \"newComment\",\ntalk: talk.title,\nmessage: form.elements.comment.value});\nform.reset();\n}\n}, elt(\"input\", {type: \"text\", name: \"comment\"}), \" \",\nelt(\"button\", {type: \"submit\"}, \"Add comment\")));\n}\nThe \"submit\" event handler calls form.reset to clear the form\u2019s content after\ncreating a \"newComment\" action.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_842",
    "text": "elt(\"button\", {type: \"submit\"}, \"Add comment\")));\n}\nThe \"submit\" event handler calls form.reset to clear the form\u2019s content after\ncreating a \"newComment\" action.\nWhen creating moderately complex pieces of DOM, this style of program-\nming starts to look rather messy. To avoid this, people often use a templating\nlanguage, which allows you to write your interface as an HTML file with some\nspecial markers to indicate where dynamic elements go. Or they use JSX, a\nnonstandard JavaScript dialect that allows you to write something very close\nto HTML tags in your program as if they are JavaScript expressions. Both of\nthese approaches use additional tools to preprocess the code before it can be\nrun, which we will avoid in this chapter.\nComments are simple to render.\nfunction renderComment(comment) {\nreturn elt(\"p\", {className: \"comment\"},\nelt(\"strong\", null, comment.author),\n\": \", comment.message);\n}\nFinally, the form that the user can use to create a new talk is rendered like\nthis:",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_843",
    "text": "return elt(\"p\", {className: \"comment\"},\nelt(\"strong\", null, comment.author),\n\": \", comment.message);\n}\nFinally, the form that the user can use to create a new talk is rendered like\nthis:\nfunction renderTalkForm(dispatch) {\nlet title = elt(\"input\", {type: \"text\"});\nlet summary = elt(\"input\", {type: \"text\"});\n369\nreturn elt(\"form\", {\nonsubmit(event) {\nevent.preventDefault();\ndispatch({type: \"newTalk\",\ntitle: title.value,\nsummary: summary.value});\nevent.target.reset();\n}\n}, elt(\"h3\", null, \"Submit a Talk\"),\nelt(\"label\", null, \"Title: \", title),\nelt(\"label\", null, \"Summary: \", summary),\nelt(\"button\", {type: \"submit\"}, \"Submit\"));\n}\nPolling\nTo start the app, we need the current list of talks. Since the initial load is closely\nrelated to the long polling process\u2014the ETag from the load must be used when\npolling\u2014we\u2019ll write a function that keeps polling the server for /talks and calls\na callback function when a new set of talks is available.\nasync function pollTalks(update) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_844",
    "text": "polling\u2014we\u2019ll write a function that keeps polling the server for /talks and calls\na callback function when a new set of talks is available.\nasync function pollTalks(update) {\nlet tag = undefined;\nfor (;;) {\nlet response;\ntry {\nresponse = await fetchOK(\"/talks\", {\nheaders: tag && {\"If-None-Match\": tag,\n\"Prefer\": \"wait=90\"}\n});\n} catch (e) {\nconsole.log(\"Request failed: \" + e);\nawait new Promise(resolve => setTimeout(resolve, 500));\ncontinue;\n}\nif (response.status == 304) continue;\ntag = response.headers.get(\"ETag\");\nupdate(await response.json());\n}\n}\nThis is an async function so that looping and waiting for the request is easier.\nIt runs an infinite loop that, on each iteration, retrieves the list of talks\u2014either\nnormally or, if this isn\u2019t the first request, with the headers included that make\n370\nit a long polling request.\nWhen a request fails, the function waits a moment and then tries again. This\nway, if your network connection goes away for a while and then comes back,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_845",
    "text": "370\nit a long polling request.\nWhen a request fails, the function waits a moment and then tries again. This\nway, if your network connection goes away for a while and then comes back,\nthe application can recover and continue updating. The promise resolved via\nsetTimeout is a way to force the async function to wait.\nWhen the server gives back a 304 response, that means a long polling request\ntimed out, so the function should just immediately start the next request. If\nthe response is a normal 200 response, its body is read as JSON and passed to\nthe callback, and its ETag header value is stored for the next iteration.\nThe application\nThe following component ties the whole user interface together:\nclass SkillShareApp {\nconstructor(state, dispatch) {\nthis.dispatch = dispatch;\nthis.talkDOM = elt(\"div\", {className: \"talks\"});\nthis.dom = elt(\"div\", null,\nrenderUserField(state.user, dispatch),\nthis.talkDOM,\nrenderTalkForm(dispatch));\nthis.syncState(state);\n}\nsyncState(state) {",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_846",
    "text": "this.talkDOM = elt(\"div\", {className: \"talks\"});\nthis.dom = elt(\"div\", null,\nrenderUserField(state.user, dispatch),\nthis.talkDOM,\nrenderTalkForm(dispatch));\nthis.syncState(state);\n}\nsyncState(state) {\nif (state.talks != this.talks) {\nthis.talkDOM.textContent = \"\";\nfor (let talk of state.talks) {\nthis.talkDOM.appendChild(\nrenderTalk(talk, this.dispatch));\n}\nthis.talks = state.talks;\n}\n}\n}\nWhen the talks change, this component redraws all of them. This is simple but\nalso wasteful. We\u2019ll get back to that in the exercises.\nWe can start the application like this:\nfunction runApp() {\nlet user = localStorage.getItem(\"userName\") || \"Anon\";\nlet state, app;\nfunction dispatch(action) {\n371\nstate = handleAction(state, action);\napp.syncState(state);\n}\npollTalks(talks => {\nif (!app) {\nstate = {user, talks};\napp = new SkillShareApp(state, dispatch);\ndocument.body.appendChild(app.dom);\n} else {\ndispatch({type: \"setTalks\", talks});\n}\n}).catch(reportError);\n}\nrunApp();",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_847",
    "text": "if (!app) {\nstate = {user, talks};\napp = new SkillShareApp(state, dispatch);\ndocument.body.appendChild(app.dom);\n} else {\ndispatch({type: \"setTalks\", talks});\n}\n}).catch(reportError);\n}\nrunApp();\nIf you run the server and open two browser windows for http://localhost:8000\nnext to each other, you can see that the actions you perform in one window\nare immediately visible in the other.\nExercises\nThe following exercises will involve modifying the system defined in this chap-\nter. To work on them, make sure you\u2019ve downloaded the code (https://eloquentjavascript.net/\ncode/skillsharing.zip), installed Node (https://nodejs.org), and installed the\nproject\u2019s dependency with npm install.\nDisk persistence\nThe skill-sharing server keeps its data purely in memory. This means that when\nit crashes or is restarted for any reason, all talks and comments are lost.\nExtend the server so that it stores the talk data to disk and automatically",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_848",
    "text": "it crashes or is restarted for any reason, all talks and comments are lost.\nExtend the server so that it stores the talk data to disk and automatically\nreloads the data when it is restarted. Don\u2019t worry about e\ufb00iciency\u2014do the\nsimplest thing that works.\nComment field resets\nThe wholesale redrawing of talks works pretty well because you usually can\u2019t\ntell the difference between a DOM node and its identical replacement. But\nthere are exceptions. If you start typing something in the comment field for a\ntalk in one browser window and then, in another, add a comment to that talk,\n372\nthe field in the first window will be redrawn, removing both its content and its\nfocus.\nWhen multiple people are adding comments at the same time, this would be\nannoying. Can you come up with a way to solve it?\n373\nExercise Hints\nThe hints below might help when you are stuck with one of the exercises in\nthis book. They don\u2019t give away the entire solution, but rather try to help you\nfind it yourself.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_849",
    "text": "373\nExercise Hints\nThe hints below might help when you are stuck with one of the exercises in\nthis book. They don\u2019t give away the entire solution, but rather try to help you\nfind it yourself.\nProgram Structure\nLooping a triangle\nYou can start with a program that prints out the numbers 1 to 7, which you\ncan derive by making a few modifications to the even number printing example\ngiven earlier in the chapter, where the for loop was introduced.\nNow consider the equivalence between numbers and strings of hash charac-\nters. You can go from 1 to 2 by adding 1 (+= 1). You can go from \"#\" to\n\"##\" by adding a character (+= \"#\"). Thus, your solution can closely follow\nthe number-printing program.\nFizzBuzz\nGoing over the numbers is clearly a looping job, and selecting what to print is\na matter of conditional execution. Remember the trick of using the remainder\n(%) operator for checking whether a number is divisible by another number (has\na remainder of zero).",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_850",
    "text": "a matter of conditional execution. Remember the trick of using the remainder\n(%) operator for checking whether a number is divisible by another number (has\na remainder of zero).\nIn the first version, there are three possible outcomes for every number, so\nyou\u2019ll have to create an if/else if/else chain.\nThe second version of the program has a straightforward solution and a clever\none. The simple solution is to add another conditional \u201cbranch\u201d to precisely\ntest the given condition. For the clever solution, build up a string containing\nthe word or words to output and print either this word or the number if there\nis no word, potentially by making good use of the || operator.\n374\nChessboard\nYou can build the string by starting with an empty one (\"\") and repeatedly\nadding characters. A newline character is written \"\\n\".\nTo work with two dimensions, you will need a loop inside of a loop. Put\nbraces around the bodies of both loops to make it easy to see where they start",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_851",
    "text": "To work with two dimensions, you will need a loop inside of a loop. Put\nbraces around the bodies of both loops to make it easy to see where they start\nand end. Try to properly indent these bodies. The order of the loops must\nfollow the order in which we build up the string (line by line, left to right, top\nto bottom). So the outer loop handles the lines, and the inner loop handles the\ncharacters on a line.\nYou\u2019ll need two bindings to track your progress. To know whether to put a\nspace or a hash sign at a given position, you could test whether the sum of the\ntwo counters is even (% 2).\nTerminating a line by adding a newline character must happen after the line\nhas been built up, so do this after the inner loop but inside the outer loop.\nFunctions\nMinimum\nIf you have trouble putting braces and parentheses in the right place to get a\nvalid function definition, start by copying one of the examples in this chapter\nand modifying it.\nA function may contain multiple return statements.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_852",
    "text": "valid function definition, start by copying one of the examples in this chapter\nand modifying it.\nA function may contain multiple return statements.\nRecursion\nYour function will likely look somewhat similar to the inner find function in the\nrecursive findSolution example in this chapter, with an if/else if/else chain\nthat tests which of the three cases applies. The final else, corresponding to\nthe third case, makes the recursive call. Each of the branches should contain\na return statement or in some other way arrange for a specific value to be\nreturned.\nWhen given a negative number, the function will recurse again and again,\npassing itself an ever more negative number, thus getting further and further\naway from returning a result. It will eventually run out of stack space and\nabort.\n375\nBean counting\nYour function will need a loop that looks at every character in the string. It\ncan run an index from zero to one below its length (< string.length). If the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_853",
    "text": "abort.\n375\nBean counting\nYour function will need a loop that looks at every character in the string. It\ncan run an index from zero to one below its length (< string.length). If the\ncharacter at the current position is the same as the one the function is looking\nfor, it adds 1 to a counter variable. Once the loop has finished, the counter can\nbe returned.\nTake care to make all the bindings used in the function local to the function\nby properly declaring them with the let or const keyword.\nData Structures: Objects and Arrays\nThe sum of a range\nBuilding up an array is most easily done by first initializing a binding to []\n(a fresh, empty array) and repeatedly calling its push method to add a value.\nDon\u2019t forget to return the array at the end of the function.\nSince the end boundary is inclusive, you\u2019ll need to use the <= operator rather\nthan < to check for the end of your loop.\nThe step parameter can be an optional parameter that defaults (using the =\noperator) to 1.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_854",
    "text": "than < to check for the end of your loop.\nThe step parameter can be an optional parameter that defaults (using the =\noperator) to 1.\nHaving range understand negative step values is probably best done by writ-\ning two separate loops\u2014one for counting up and one for counting down\u2014\nbecause the comparison that checks whether the loop is finished needs to be >=\nrather than <= when counting downward.\nIt might also be worthwhile to use a different default step, namely, -1, when\nthe end of the range is smaller than the start. That way, range(5, 2) returns\nsomething meaningful rather than getting stuck in an infinite loop. It is possible\nto refer to previous parameters in the default value of a parameter.\nReversing an array\nThere are two obvious ways to implement reverseArray. The first is to sim-\nply go over the input array from front to back and use the unshift method\non the new array to insert each element at its start. The second is to loop",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_855",
    "text": "ply go over the input array from front to back and use the unshift method\non the new array to insert each element at its start. The second is to loop\nover the input array backward and use the push method. Iterating over an\narray backward requires a (somewhat awkward) for specification, like (let i\n= array.length - 1; i >= 0; i--).\nReversing the array in place is harder. You have to be careful not to overwrite\nelements that you will later need. Using reverseArray or otherwise copying\n376\nthe whole array (array.slice() is a good way to copy an array) works but is\ncheating.\nThe trick is to swap the first and last elements, then the second and second-\nto-last, and so on. You can do this by looping over half the length of the array\n(use Math.floor to round down\u2014you don\u2019t need to touch the middle element\nin an array with an odd number of elements) and swapping the element at\nposition i with the one at position array.length - 1 - i. You can use a local",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_856",
    "text": "in an array with an odd number of elements) and swapping the element at\nposition i with the one at position array.length - 1 - i. You can use a local\nbinding to briefly hold onto one of the elements, overwrite that one with its\nmirror image, and then put the value from the local binding in the place where\nthe mirror image used to be.\nA list\nBuilding up a list is easier when done back to front. So arrayToList could iter-\nate over the array backward (see the previous exercise) and, for each element,\nadd an object to the list. You can use a local binding to hold the part of the\nlist that was built so far and use an assignment like list = {value: X, rest:\nlist} to add an element.\nTo run over a list (in listToArray and nth), a for loop specification like this\ncan be used:\nfor (let node = list; node; node = node.rest) {}\nCan you see how that works? Every iteration of the loop, node points to the\ncurrent sublist, and the body can read its value property to get the current",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_857",
    "text": "Can you see how that works? Every iteration of the loop, node points to the\ncurrent sublist, and the body can read its value property to get the current\nelement. At the end of an iteration, node moves to the next sublist. When that\nis null, we have reached the end of the list, and the loop is finished.\nThe recursive version of nth will, similarly, look at an ever smaller part of\nthe \u201ctail\u201d of the list and at the same time count down the index until it reaches\nzero, at which point it can return the value property of the node it is looking\nat. To get the zeroth element of a list, you simply take the value property of\nits head node. To get element N + 1, you take the Nth element of the list\nthat\u2019s in this list\u2019s rest property.\nDeep comparison\nYour test for whether you are dealing with a real object will look something like\ntypeof x == \"object\" && x != null. Be careful to compare properties only\nwhen both arguments are objects. In all other cases you can just immediately",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_858",
    "text": "typeof x == \"object\" && x != null. Be careful to compare properties only\nwhen both arguments are objects. In all other cases you can just immediately\nreturn the result of applying ===.\n377\nUse Object.keys to go over the properties. You need to test whether both\nobjects have the same set of property names and whether those properties have\nidentical values. One way to do that is to ensure that both objects have the\nsame number of properties (the lengths of the property lists are the same).\nAnd then, when looping over one of the object\u2019s properties to compare them,\nalways first make sure the other actually has a property by that name. If they\nhave the same number of properties and all properties in one also exist in the\nother, they have the same set of property names.\nReturning the correct value from the function is best done by immediately\nreturning false when a mismatch is found and returning true at the end of\nthe function.\nHigher-Order Functions\nEverything",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_859",
    "text": "Returning the correct value from the function is best done by immediately\nreturning false when a mismatch is found and returning true at the end of\nthe function.\nHigher-Order Functions\nEverything\nLike the && operator, the every method can stop evaluating further elements\nas soon as it has found one that doesn\u2019t match. So the loop-based version\ncan jump out of the loop\u2014with break or return\u2014as soon as it runs into an\nelement for which the predicate function returns false. If the loop runs to its\nend without finding such an element, we know that all elements matched and\nwe should return true.\nTo build every on top of some, we can apply De Morgan\u2019s laws, which state\nthat a && b equals !(!a || !b). This can be generalized to arrays, where all\nelements in the array match if there is no element in the array that does not\nmatch.\nDominant writing direction\nYour solution might look a lot like the first half of the textScripts example.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_860",
    "text": "elements in the array match if there is no element in the array that does not\nmatch.\nDominant writing direction\nYour solution might look a lot like the first half of the textScripts example.\nYou again have to count characters by a criterion based on characterScript\nand then filter out the part of the result that refers to uninteresting (script-less)\ncharacters.\nFinding the direction with the highest character count can be done with\nreduce. If it\u2019s not clear how, refer to the example earlier in the chapter, where\nreduce was used to find the script with the most characters.\n378\nThe Secret Life of Objects\nA vector type\nLook back to the Rabbit class example if you\u2019re unsure how class declarations\nlook.\nAdding a getter property to the constructor can be done by putting the word\nget before the method name. To compute the distance from (0, 0) to (x, y), you\ncan use the Pythagorean theorem, which says that the square of the distance",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_861",
    "text": "get before the method name. To compute the distance from (0, 0) to (x, y), you\ncan use the Pythagorean theorem, which says that the square of the distance\nwe are looking for is equal to the square of the x-coordinate plus the square of\nthe y-coordinate. Thus,\n\u221a\nx2 + y2 is the number you want. Math.sqrt is the\nway you compute a square root in JavaScript and x ** 2 can be used to square\na number.\nGroups\nThe easiest way to do this is to store an array of group members in an instance\nproperty. The includes or indexOf methods can be used to check whether a\ngiven value is in the array.\nYour class\u2019s constructor can set the member collection to an empty array.\nWhen add is called, it must check whether the given value is in the array or\nadd it otherwise, possibly using push.\nDeleting an element from an array, in delete, is less straightforward, but\nyou can use filter to create a new array without the value. Don\u2019t forget to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_862",
    "text": "add it otherwise, possibly using push.\nDeleting an element from an array, in delete, is less straightforward, but\nyou can use filter to create a new array without the value. Don\u2019t forget to\noverwrite the property holding the members with the newly filtered version of\nthe array.\nThe from method can use a for/of loop to get the values out of the iterable\nobject and call add to put them into a newly created group.\nIterable groups\nIt is probably worthwhile to define a new class GroupIterator. Iterator in-\nstances should have a property that tracks the current position in the group.\nEvery time next is called, it checks whether it is done and, if not, moves past\nthe current value and returns it.\nThe Group class itself gets a method named by Symbol.iterator that, when\ncalled, returns a new instance of the iterator class for that group.\n379\nProject: A Robot\nMeasuring a robot\nYou\u2019ll have to write a variant of the runRobot function that, instead of log-",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_863",
    "text": "called, returns a new instance of the iterator class for that group.\n379\nProject: A Robot\nMeasuring a robot\nYou\u2019ll have to write a variant of the runRobot function that, instead of log-\nging the events to the console, returns the number of steps the robot took to\ncomplete the task.\nYour measurement function can then, in a loop, generate new states and\ncount the steps each of the robots takes. When it has generated enough mea-\nsurements, it can use console.log to output the average for each robot, which\nis the total number of steps taken divided by the number of measurements.\nRobot efficiency\nThe main limitation of goalOrientedRobot is that it considers only one parcel\nat a time. It will often walk back and forth across the village because the parcel\nit happens to be looking at happens to be at the other side of the map, even if\nthere are others much closer.\nOne possible solution would be to compute routes for all packages and then",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_864",
    "text": "it happens to be looking at happens to be at the other side of the map, even if\nthere are others much closer.\nOne possible solution would be to compute routes for all packages and then\ntake the shortest one. Even better results can be obtained, if there are multiple\nshortest routes, by preferring the ones that go to pick up a package instead of\ndelivering a package.\nPersistent group\nThe most convenient way to represent the set of member values is still as an\narray, since arrays are easy to copy.\nWhen a value is added to the group, you can create a new group with a copy\nof the original array that has the value added (for example, using concat).\nWhen a value is deleted, you filter it from the array.\nThe class\u2019s constructor can take such an array as its argument and store it\nas the instance\u2019s (only) property. This array is never updated.\nTo add the empty property to the constructor, you can declare it as a static\nproperty.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_865",
    "text": "as the instance\u2019s (only) property. This array is never updated.\nTo add the empty property to the constructor, you can declare it as a static\nproperty.\nYou need only one empty instance because all empty groups are the same\nand instances of the class don\u2019t change. You can create many different groups\nfrom that single empty group without affecting it.\n380\nBugs and Errors\nRetry\nThe call to primitiveMultiply should definitely happen in a try block. The\ncorresponding catch block should rethrow the exception when it is not an\ninstance of MultiplicatorUnitFailure and ensure the call is retried when it is.\nTo do the retrying, you can either use a loop that stops only when a call\nsucceeds\u2014as in the look example earlier in this chapter\u2014or use recursion and\nhope you don\u2019t get a string of failures so long that it overflows the stack (which\nis a pretty safe bet).\nThe locked box\nThis exercise calls for a finally block. Your function should first unlock the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_866",
    "text": "hope you don\u2019t get a string of failures so long that it overflows the stack (which\nis a pretty safe bet).\nThe locked box\nThis exercise calls for a finally block. Your function should first unlock the\nbox and then call the argument function from inside a try body. The finally\nblock after it should lock the box again.\nTo make sure we don\u2019t lock the box when it wasn\u2019t already locked, check its\nlock at the start of the function and unlock and lock it only when it started\nout locked.\nRegular Expressions\nQuoting style\nThe most obvious solution is to replace only quotes with a nonletter character\non at least one side\u2014something like /\\P{L}'|'\\P{L}/u. But you also have to\ntake the start and end of the line into account.\nIn addition, you must ensure that the replacement also includes the charac-\nters that were matched by the \\P{L} pattern so that those are not dropped.\nThis can be done by wrapping them in parentheses and including their groups",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_867",
    "text": "ters that were matched by the \\P{L} pattern so that those are not dropped.\nThis can be done by wrapping them in parentheses and including their groups\nin the replacement string ($1, $2). Groups that are not matched will be re-\nplaced by nothing.\nNumbers again\nFirst, do not forget the backslash in front of the period.\nMatching the optional sign in front of the number, as well as in front of the\nexponent, can be done with [+\\-]? or (\\+|-|) (plus, minus, or nothing).\nThe more complicated part of the exercise is the problem of matching both\n\"5.\" and \".5\" without also matching \".\". For this, a good solution is to use\n381\nthe | operator to separate the two cases\u2014either one or more digits optionally\nfollowed by a dot and zero or more digits or a dot followed by one or more\ndigits.\nFinally, to make the e case insensitive, either add an i option to the regular\nexpression or use [eE].\nModules\nA modular robot\nHere\u2019s what I would have done (but again, there is no single right way to design",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_868",
    "text": "expression or use [eE].\nModules\nA modular robot\nHere\u2019s what I would have done (but again, there is no single right way to design\na given module):\nThe code used to build the road graph lives in the graph.js module. Because\nI\u2019d rather use dijkstrajs from NPM than our own pathfinding code, we\u2019ll\nmake this build the kind of graph data that dijkstrajs expects. This module\nexports a single function, buildGraph. I\u2019d have buildGraph accept an array\nof two-element arrays, rather than strings containing hyphens, to make the\nmodule less dependent on the input format.\nThe roads.js module contains the raw road data (the roads array) and the\nroadGraph binding. This module depends on ./graph.js and exports the road\ngraph.\nThe VillageState class lives in the state.js module. It depends on the ./\nroads.js module because it needs to be able to verify that a given road exists.\nIt also needs randomPick. Since that is a three-line function, we could just put",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_869",
    "text": "roads.js module because it needs to be able to verify that a given road exists.\nIt also needs randomPick. Since that is a three-line function, we could just put\nit into the state.js module as an internal helper function. But randomRobot\nneeds it too. So we\u2019d have to either duplicate it or put it into its own module.\nSince this function happens to exist on NPM in the random-item package, a\nreasonable solution is to just make both modules depend on that. We can add\nthe runRobot function to this module as well, since it\u2019s small and closely related\nto state management. The module exports both the VillageState class and\nthe runRobot function.\nFinally, the robots, along with the values they depend on, such as mailRoute,\ncould go into an example-robots.js module, which depends on ./roads.js and\nexports the robot functions. To make it possible for goalOrientedRobot to do\nroute-finding, this module also depends on dijkstrajs.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_870",
    "text": "exports the robot functions. To make it possible for goalOrientedRobot to do\nroute-finding, this module also depends on dijkstrajs.\nBy offloading some work to NPM modules, the code became a little smaller.\nEach individual module does something rather simple and can be read on its\nown. Dividing code into modules also often suggests further improvements to\nthe program\u2019s design. In this case, it seems a little odd that the VillageState\nand the robots depend on a specific road graph. It might be a better idea to\n382\nmake the graph an argument to the state\u2019s constructor and make the robots\nread it from the state object\u2014this reduces dependencies (which is always good)\nand makes it possible to run simulations on different maps (which is even\nbetter).\nIs it a good idea to use NPM modules for things that we could have written\nourselves? In principle, yes\u2014for nontrivial things like the pathfinding function\nyou are likely to make mistakes and waste time writing them yourself. For tiny",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_871",
    "text": "ourselves? In principle, yes\u2014for nontrivial things like the pathfinding function\nyou are likely to make mistakes and waste time writing them yourself. For tiny\nfunctions like random-item, writing them yourself is easy enough. But adding\nthem wherever you need them does tend to clutter your modules.\nHowever, you should also not underestimate the work involved in finding an\nappropriate NPM package. And even if you find one, it might not work well\nor may be missing some feature you need. On top of that, depending on NPM\npackages means you have to make sure they are installed, you have to distribute\nthem with your program, and you might have to periodically upgrade them.\nSo again, this is a trade-off, and you can decide either way depending on how\nmuch a given package actually helps you.\nRoads module\nSince this is an ES module, you have to use import to access the graph module.\nThat was described as exporting a buildGraph function, which you can pick",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_872",
    "text": "Roads module\nSince this is an ES module, you have to use import to access the graph module.\nThat was described as exporting a buildGraph function, which you can pick\nout of its interface object with a destructuring const declaration.\nTo export roadGraph, you put the keyword export before its definition. Be-\ncause buildGraph takes a data structure that doesn\u2019t precisely match roads,\nthe splitting of the road strings must happen in your module.\nCircular dependencies\nThe trick is that require adds the interface object for a module to its cache\nbefore it starts loading the module. That way, if any require call made while\nit is running tries to load it, it is already known, and the current interface will\nbe returned, rather than starting to load the module once more (which would\neventually overflow the stack).\nAsynchronous Programming\nQuiet Times\nYou will need to convert the content of these files to an array. The easiest way",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_873",
    "text": "eventually overflow the stack).\nAsynchronous Programming\nQuiet Times\nYou will need to convert the content of these files to an array. The easiest way\nto do that is to use the split method on the string produced by textFile.\n383\nNote that for the logfiles, that will still give you an array of strings, which you\nhave to convert to numbers before passing them to new Date.\nSummarizing all the time points into a table of hours can be done by creating\na table (array) that holds a number for each hour in the day. You can then\nloop over all the timestamps (over the logfiles and the numbers in every logfile)\nand for each one, if it happened on the correct day, take the hour it occurred\nin, and add one to the corresponding number in the table.\nMake sure you use await on the result of asynchronous functions before doing\nanything with it, or you\u2019ll end up with a Promise where you expected a string.\nReal Promises\nThe most straightforward approach to writing this function is to use a chain of",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_874",
    "text": "anything with it, or you\u2019ll end up with a Promise where you expected a string.\nReal Promises\nThe most straightforward approach to writing this function is to use a chain of\nthen calls. The first promise is produced by reading the list of logfiles. The first\ncallback can split this list and map textFile over it to get an array of promises\nto pass to Promise.all. It can return the object returned by Promise.all, so\nthat whatever that returns becomes the result of the return value of this first\nthen.\nWe now have a promise that returns an array of logfiles. We can call then\nagain on that, and put the timestamp-counting logic in there. Something like\nthis:\nfunction activityTable(day) {\nreturn textFile(\"camera_logs.txt\").then(files => {\nreturn Promise.all(files.split(\"\\n\").map(textFile));\n}).then(logs => {\n// analyze...\n});\n}\nOr you could, for even better work scheduling, put the analysis of each file\ninside of the Promise.all, so that that work can be started for the first file",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_875",
    "text": "}).then(logs => {\n// analyze...\n});\n}\nOr you could, for even better work scheduling, put the analysis of each file\ninside of the Promise.all, so that that work can be started for the first file\nthat comes back from disk, even before the other files come back.\nfunction activityTable(day) {\nlet table = []; // init...\nreturn textFile(\"camera_logs.txt\").then(files => {\nreturn Promise.all(files.split(\"\\n\").map(name => {\nreturn textFile(name).then(log => {\n// analyze...\n});\n}));\n}).then(() => table);\n384\n}\nThis shows that the way you structure your promises can have a real effect\non the way the work is scheduled. A simple loop with await in it will make\nthe process completely linear\u2014it waits for each file to load before proceeding.\nPromise.all makes it possible for multiple tasks to conceptually be worked on\nat the same time, allowing them to make progress while files are still being\nloaded. This can be faster, but it also makes the order in which things will\nhappen less predictable.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_876",
    "text": "at the same time, allowing them to make progress while files are still being\nloaded. This can be faster, but it also makes the order in which things will\nhappen less predictable.\nIn this case, we\u2019re only going to be incrementing\nnumbers in a table, which isn\u2019t hard to do in a safe way. For other kinds of\nproblems, it may be a lot more di\ufb00icult.\nWhen a file in the list doesn\u2019t exist, the promise returned by textFile will\nbe rejected. Because Promise.all rejects if any of the promises given to it fail,\nthe return value of the callback given to the first then will also be a rejected\npromise. That makes the promise returned by then fail, so the callback given\nto the second then isn\u2019t even called, and a rejected promise is returned from\nthe function.\nBuilding Promise.all\nThe function passed to the Promise constructor will have to call then on each\nof the promises in the given array. When one of them succeeds, two things",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_877",
    "text": "the function.\nBuilding Promise.all\nThe function passed to the Promise constructor will have to call then on each\nof the promises in the given array. When one of them succeeds, two things\nneed to happen. The resulting value needs to be stored in the correct position\nof a result array, and we must check whether this was the last pending promise\nand finish our own promise if it was.\nThe latter can be done with a counter that is initialized to the length of\nthe input array and from which we subtract 1 every time a promise succeeds.\nWhen it reaches 0, we are done. Make sure you take into account the situation\nwhere the input array is empty (and thus no promise will ever resolve).\nHandling failure requires some thought but turns out to be extremely simple.\nJust pass the reject function of the wrapping promise to each of the promises\nin the array as a catch handler or as a second argument to then so that a failure\nin one of them triggers the rejection of the whole wrapper promise.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_878",
    "text": "in the array as a catch handler or as a second argument to then so that a failure\nin one of them triggers the rejection of the whole wrapper promise.\nProject: A Programming Language\nArrays\nThe easiest way to do this is to represent Egg arrays with JavaScript arrays.\nThe values added to the top scope must be functions. By using a rest argu-\nment (with triple-dot notation), the definition of array can be very simple.\n385\nClosure\nAgain, we are riding along on a JavaScript mechanism to get the equivalent\nfeature in Egg. Special forms are passed the local scope in which they are\nevaluated so that they can evaluate their subforms in that scope. The function\nreturned by fun has access to the scope argument given to its enclosing function\nand uses that to create the function\u2019s local scope when it is called.\nThis means that the prototype of the local scope will be the scope in which\nthe function was created, which makes it possible to access bindings in that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_879",
    "text": "This means that the prototype of the local scope will be the scope in which\nthe function was created, which makes it possible to access bindings in that\nscope from the function. This is all there is to implementing closure (though\nto compile it in a way that is actually e\ufb00icient, you\u2019d need to do some more\nwork).\nComments\nMake sure your solution handles multiple comments in a row, with whitespace\npotentially between or after them.\nA regular expression is probably the easiest way to solve this. Write some-\nthing that matches \u201cwhitespace or a comment, zero or more times\u201d. Use the\nexec or match method and look at the length of the first element in the returned\narray (the whole match) to find out how many characters to slice off.\nFixing scope\nYou will have to loop through one scope at a time, using Object.getPrototypeOf\nto go to the next outer scope. For each scope, use Object.hasOwn to find out\nwhether the binding, indicated by the name property of the first argument to",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_880",
    "text": "to go to the next outer scope. For each scope, use Object.hasOwn to find out\nwhether the binding, indicated by the name property of the first argument to\nset, exists in that scope. If it does, set it to the result of evaluating the second\nargument to set and then return that value.\nIf the outermost scope is reached (Object.getPrototypeOf returns null) and\nwe haven\u2019t found the binding yet, it doesn\u2019t exist, and an error should be\nthrown.\nThe Document Object Model\nBuild a table\nYou can use document.createElement to create new element nodes, document.\ncreateTextNode to create text nodes, and the appendChild method to put nodes\ninto other nodes.\n386\nYou\u2019ll want to loop over the key names once to fill in the top row and then\nagain for each object in the array to construct the data rows. To get an array\nof key names from the first object, Object.keys will be useful.\nTo add the table to the correct parent node, you can use document.getElementById",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_881",
    "text": "of key names from the first object, Object.keys will be useful.\nTo add the table to the correct parent node, you can use document.getElementById\nor document.querySelector with \"#mountains\" to find the node.\nElements by tag name\nThe solution is most easily expressed with a recursive function, similar to the\ntalksAbout function defined earlier in this chapter.\nYou could call byTagname itself recursively, concatenating the resulting arrays\nto produce the output. Or you could create an inner function that calls itself\nrecursively and that has access to an array binding defined in the outer function,\nto which it can add the matching elements it finds. Don\u2019t forget to call the\ninner function once from the outer function to start the process.\nThe recursive function must check the node type. Here we are interested only\nin node type 1 (Node.ELEMENT_NODE). For such nodes, we must loop over their\nchildren and, for each child, see whether the child matches the query while also",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_882",
    "text": "in node type 1 (Node.ELEMENT_NODE). For such nodes, we must loop over their\nchildren and, for each child, see whether the child matches the query while also\ndoing a recursive call on it to inspect its own children.\nThe cat's hat\nMath.cos and Math.sin measure angles in radians, where a full circle is 2\u03c0. For\na given angle, you can get the opposite angle by adding half of this, which is\nMath.PI. This can be useful for putting the hat on the opposite side of the\norbit.\nHandling Events\nBalloon\nYou\u2019ll want to register a handler for the \"keydown\" event and look at event.key\nto figure out whether the up or down arrow key was pressed.\nThe current size can be kept in a binding so that you can base the new size on\nit. It\u2019ll be helpful to define a function that updates the size\u2014both the binding\nand the style of the balloon in the DOM\u2014so that you can call it from your\nevent handler, and possibly also once when starting, to set the initial size.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_883",
    "text": "and the style of the balloon in the DOM\u2014so that you can call it from your\nevent handler, and possibly also once when starting, to set the initial size.\nYou can change the balloon to an explosion by replacing the text node with\nanother one (using replaceChild) or by setting the textContent property of its\nparent node to a new string.\n387\nMouse trail\nCreating the elements is best done with a loop. Append them to the document\nto make them show up. To be able to access them later to change their position,\nyou\u2019ll want to store the elements in an array.\nCycling through them can be done by keeping a counter variable and adding\n1 to it every time the \"mousemove\" event fires.\nThe remainder operator (%\nelements.length) can then be used to get a valid array index to pick the\nelement you want to position during a given event.\nAnother interesting effect can be achieved by modeling a simple physics\nsystem.\nUse the \"mousemove\" event only to update a pair of bindings that",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_884",
    "text": "element you want to position during a given event.\nAnother interesting effect can be achieved by modeling a simple physics\nsystem.\nUse the \"mousemove\" event only to update a pair of bindings that\ntrack the mouse position. Then use requestAnimationFrame to simulate the\ntrailing elements being attracted to the position of the mouse pointer.\nAt\nevery animation step, update their position based on their position relative to\nthe pointer (and, optionally, a speed that is stored for each element). Figuring\nout a good way to do this is up to you.\nTabs\nOne pitfall you might run into is that you can\u2019t directly use the node\u2019s childNodes\nproperty as a collection of tab nodes. For one thing, when you add the buttons,\nthey will also become child nodes and end up in this object because it is a live\ndata structure. For another, the text nodes created for the whitespace between\nthe nodes are also in childNodes but should not get their own tabs. You can",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_885",
    "text": "data structure. For another, the text nodes created for the whitespace between\nthe nodes are also in childNodes but should not get their own tabs. You can\nuse children instead of childNodes to ignore text nodes.\nYou could start by building up an array of tabs so that you have easy access\nto them. To implement the styling of the buttons, you could store objects that\ncontain both the tab panel and its button.\nI recommend writing a separate function for changing tabs. You can either\nstore the previously selected tab and change only the styles needed to hide that\nand show the new one, or you can just update the style of all tabs every time\na new tab is selected.\nYou might want to call this function immediately to make the interface start\nwith the first tab visible.\nProject: A Platform Game\nPausing the game\nAn animation can be interrupted by returning false from the function given\nto runAnimation. It can be continued by calling runAnimation again.\n388",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_886",
    "text": "Project: A Platform Game\nPausing the game\nAn animation can be interrupted by returning false from the function given\nto runAnimation. It can be continued by calling runAnimation again.\n388\nSo we need to communicate the fact that we are pausing the game to the\nfunction given to runAnimation. For that, you can use a binding that both the\nevent handler and that function have access to.\nWhen finding a way to unregister the handlers registered by trackKeys, re-\nmember that the exact same function value that was passed to addEventListener\nmust be passed to removeEventListener to successfully remove a handler.\nThus, the handler function value created in trackKeys must be available to the\ncode that unregisters the handlers.\nYou can add a property to the object returned by trackKeys, containing\neither that function value or a method that handles the unregistering directly.\nA monster\nIf you want to implement a type of motion that is stateful, such as bouncing,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_887",
    "text": "either that function value or a method that handles the unregistering directly.\nA monster\nIf you want to implement a type of motion that is stateful, such as bouncing,\nmake sure you store the necessary state in the actor object\u2014include it as a\nconstructor argument and add it as a property.\nRemember that update returns a new object rather than changing the old\none.\nWhen handling collision, find the player in state.actors and compare its\nposition to the monster\u2019s position. To get the bottom of the player, you have\nto add its vertical size to its vertical position. The creation of an updated\nstate will resemble either Coin\u2019s collide method (removing the actor) or Lava\n\u2019s (changing the status to \"lost\"), depending on the player position.\nDrawing on Canvas\nShapes\nThe trapezoid (1) is easiest to draw using a path. Pick suitable center coordi-\nnates and add each of the four corners around the center.\nThe diamond (2) can be drawn the straightforward way, with a path, or the",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_888",
    "text": "nates and add each of the four corners around the center.\nThe diamond (2) can be drawn the straightforward way, with a path, or the\ninteresting way, with a rotate transformation. To use rotation, you will have to\napply a trick similar to what we did in the flipHorizontally function. Because\nyou want to rotate around the center of your rectangle and not around the point\n(0, 0), you must first translate to there, then rotate, and then translate back.\nMake sure you reset the transformation after drawing any shape that creates\none.\nFor the zigzag (3) it becomes impractical to write a new call to lineTo for\neach line segment. Instead, you should use a loop. You can have each iteration\ndraw either two line segments (right and then left again) or one, in which case\n389\nyou must use the evenness (% 2) of the loop index to determine whether to go\nleft or right.\nYou\u2019ll also need a loop for the spiral (4). If you draw a series of points, with",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_889",
    "text": "389\nyou must use the evenness (% 2) of the loop index to determine whether to go\nleft or right.\nYou\u2019ll also need a loop for the spiral (4). If you draw a series of points, with\neach point moving farther along a circle around the spiral\u2019s center, you get a\ncircle. If, during the loop, you vary the radius of the circle on which you are\nputting the current point and go around more than once, the result is a spiral.\nThe star (5) depicted is built out of quadraticCurveTo lines.\nYou could\nalso draw one with straight lines.\nDivide a circle into eight pieces for a\nstar with eight points, or however many pieces you want.\nDraw lines be-\ntween these points, making them curve toward the center of the star. With\nquadraticCurveTo, you can use the center as the control point.\nThe pie chart\nYou will need to call fillText and set the context\u2019s textAlign and textBaseline\nproperties in such a way that the text ends up where you want it.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_890",
    "text": "The pie chart\nYou will need to call fillText and set the context\u2019s textAlign and textBaseline\nproperties in such a way that the text ends up where you want it.\nA sensible way to position the labels would be to put the text on the line\ngoing from the center of the pie through the middle of the slice. You don\u2019t\nwant to put the text directly against the side of the pie but rather move the\ntext out to the side of the pie by a given number of pixels.\nThe angle of this line is currentAngle + 0.5 * sliceAngle. The following\ncode finds a position on this line 120 pixels from the center:\nlet middleAngle = currentAngle + 0.5 * sliceAngle;\nlet textX = Math.cos(middleAngle) * 120 + centerX;\nlet textY = Math.sin(middleAngle) * 120 + centerY;\nFor textBaseline, the value \"middle\" is probably appropriate when using this\napproach. What to use for textAlign depends on which side of the circle we\nare on. On the left, it should be \"right\", and on the right, it should be \"left\",",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_891",
    "text": "approach. What to use for textAlign depends on which side of the circle we\nare on. On the left, it should be \"right\", and on the right, it should be \"left\",\nso that the text is positioned away from the pie.\nIf you are not sure how to find out which side of the circle a given angle is on,\nlook to the explanation of Math.cos in Chapter 14. The cosine of an angle tells\nus which x-coordinate it corresponds to, which in turn tells us exactly which\nside of the circle we are on.\nA bouncing ball\nA box is easy to draw with strokeRect. Define a binding that holds its size,\nor define two bindings if your box\u2019s width and height differ. To create a round\nball, start a path and call arc(x, y, radius, 0, 7), which creates an arc going\n390\nfrom zero to more than a whole circle. Then fill the path.\nTo model the ball\u2019s position and speed, you can use the Vec class from\nChapter 16. Give it a starting speed, preferably one that is not purely vertical or",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_892",
    "text": "To model the ball\u2019s position and speed, you can use the Vec class from\nChapter 16. Give it a starting speed, preferably one that is not purely vertical or\nhorizontal, and for every frame multiply that speed by the amount of time that\nelapsed. When the ball gets too close to a vertical wall, invert the x component\nin its speed. Likewise, invert the y component when it hits a horizontal wall.\nAfter finding the ball\u2019s new position and speed, use clearRect to delete the\nscene and redraw it using the new position.\nPrecomputed mirroring\nThe key to the solution is the fact that we can use a canvas element as a source\nimage when using drawImage. It is possible to create an extra <canvas> element,\nwithout adding it to the document, and draw our inverted sprites to it, once.\nWhen drawing an actual frame, we just copy the already inverted sprites to\nthe main canvas.\nSome care would be required because images do not load instantly. We do",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_893",
    "text": "When drawing an actual frame, we just copy the already inverted sprites to\nthe main canvas.\nSome care would be required because images do not load instantly. We do\nthe inverted drawing only once, and if we do it before the image loads, it\nwon\u2019t draw anything. A \"load\" handler on the image can be used to draw the\ninverted images to the extra canvas. This canvas can be used as a drawing\nsource immediately (it\u2019ll simply be blank until we draw the character onto it).\nHTTP and Forms\nContent negotiation\nBase your code on the fetch examples earlier in the chapter.\nAsking for a bogus media type will return a response with code 406, \u201cNot\nacceptable\u201d, which is the code a server should return when it can\u2019t fulfill the\nAccept header.\nA JavaScript workbench\nUse document.querySelector or document.getElementById to get access to the\nelements defined in your HTML. An event handler for \"click\" or \"mousedown\n\" events on the button can get the value property of the text field and call\nFunction on it.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_894",
    "text": "elements defined in your HTML. An event handler for \"click\" or \"mousedown\n\" events on the button can get the value property of the text field and call\nFunction on it.\nMake sure you wrap both the call to Function and the call to its result in a\ntry block so you can catch the exceptions it produces. In this case, we really\ndon\u2019t know what type of exception we are looking for, so catch everything.\n391\nThe textContent property of the output element can be used to fill it with\na string message. Or, if you want to keep the old content around, create a\nnew text node using document.createTextNode and append it to the element.\nRemember to add a newline character to the end so that not all output appears\non a single line.\nConway's Game of Life\nTo solve the problem of having the changes conceptually happen at the same\ntime, try to see the computation of a generation as a pure function, which takes\none grid and produces a new grid that represents the next turn.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_895",
    "text": "time, try to see the computation of a generation as a pure function, which takes\none grid and produces a new grid that represents the next turn.\nRepresenting the matrix can be done with a single array of width \u00d7 height\nelements, storing values row by row, so, for example, the third element in\nthe fifth row is (using zero-based indexing) stored at position 4 \u00d7 width +\n2. You can count live neighbors with two nested loops, looping over adjacent\ncoordinates in both dimensions. Take care not to count cells outside of the field\nand to ignore the cell in the center, whose neighbors we are counting.\nEnsuring that changes to checkboxes take effect on the next generation can\nbe done in two ways. An event handler could notice these changes and update\nthe current grid to reflect them, or you could generate a fresh grid from the\nvalues in the checkboxes before computing the next turn.\nIf you choose to go with event handlers, you might want to attach attributes",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_896",
    "text": "values in the checkboxes before computing the next turn.\nIf you choose to go with event handlers, you might want to attach attributes\nthat identify the position that each checkbox corresponds to so that it is easy\nto find out which cell to change.\nTo draw the grid of checkboxes, you can either use a <table> element (see\nChapter 14) or simply put them all in the same element and put <br> (line\nbreak) elements between the rows.\nProject: A Pixel Art Editor\nKeyboard bindings\nThe key property of events for letter keys will be the lowercase letter itself, if\nshift isn\u2019t being held. We\u2019re not interested in key events with shift here.\nA \"keydown\" handler can inspect its event object to see whether it matches\nany of the shortcuts. You can automatically get the list of first letters from the\ntools object so that you don\u2019t have to write them out.\nWhen the key event matches a shortcut, call preventDefault on it and dis-\npatch the appropriate action.\n392\nEfficient drawing",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_897",
    "text": "tools object so that you don\u2019t have to write them out.\nWhen the key event matches a shortcut, call preventDefault on it and dis-\npatch the appropriate action.\n392\nEfficient drawing\nThis exercise is a good example of how immutable data structures can make\ncode faster. Because we have both the old and the new picture, we can compare\nthem and redraw only the pixels that changed color, saving more than 99\npercent of the drawing work in most cases.\nYou can either write a new function updatePicture or have drawPicture take\nan extra argument, which may be undefined or the previous picture. For each\npixel, the function checks whether a previous picture was passed with the same\ncolor at this position and skips the pixel when that is the case.\nBecause the canvas gets cleared when we change its size, you should also\navoid touching its width and height properties when the old picture and the\nnew picture have the same size. If they are different, which will happen when",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_898",
    "text": "avoid touching its width and height properties when the old picture and the\nnew picture have the same size. If they are different, which will happen when\na new picture has been loaded, you can set the binding holding the old picture\nto null after changing the canvas size because you shouldn\u2019t skip any pixels\nafter you\u2019ve changed the canvas size.\nCircles\nYou can take some inspiration from the rectangle tool. As with that tool,\nyou\u2019ll want to keep drawing on the starting picture, rather than the current\npicture, when the pointer moves.\nTo figure out which pixels to color, you can use the Pythagorean theorem.\nFirst figure out the distance between the current pointer position and the start\nposition by taking the square root (Math.sqrt) of the sum of the square (x\n** 2) of the difference in x-coordinates and the square of the difference in\ny-coordinates. Then loop over a square of pixels around the start position,",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_899",
    "text": "** 2) of the difference in x-coordinates and the square of the difference in\ny-coordinates. Then loop over a square of pixels around the start position,\nwhose sides are at least twice the radius, and color those that are within the\ncircle\u2019s radius, again using the Pythagorean formula to figure out their distance\nfrom the center.\nMake sure you don\u2019t try to color pixels that are outside of the picture\u2019s\nboundaries.\nProper lines\nThe thing about the problem of drawing a pixelated line is that it is really four\nsimilar but slightly different problems. Drawing a horizontal line from the left\nto the right is easy\u2014you loop over the x-coordinates and color a pixel at every\nstep. If the line has a slight slope (less than 45 degrees or \u00bc\u03c0 radians), you\ncan interpolate the y-coordinate along the slope. You still need one pixel per\nx position, with the y position of those pixels determined by the slope.\n393\nBut as soon as your slope goes across 45 degrees, you need to switch the way",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_900",
    "text": "x position, with the y position of those pixels determined by the slope.\n393\nBut as soon as your slope goes across 45 degrees, you need to switch the way\nyou treat the coordinates. You now need one pixel per y position, since the\nline goes up more than it goes left. And then, when you cross 135 degrees, you\nhave to go back to looping over the x-coordinates, but from right to left.\nYou don\u2019t actually have to write four loops. Since drawing a line from A to\nB is the same as drawing a line from B to A, you can swap the start and end\npositions for lines going from right to left and treat them as going left to right.\nSo you need two different loops. The first thing your line drawing function\nshould do is check whether the difference between the x-coordinates is larger\nthan the difference between the y-coordinates. If it is, this is a horizontalish\nline, and if not, a verticalish one.\nMake sure you compare the absolute values of the x and y difference, which\nyou can get with Math.abs.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_901",
    "text": "line, and if not, a verticalish one.\nMake sure you compare the absolute values of the x and y difference, which\nyou can get with Math.abs.\nOnce you know along which axis you will be looping, you can check whether\nthe start point has a higher coordinate along that axis than the endpoint and\nswap them if necessary. A succinct way to swap the values of two bindings in\nJavaScript uses destructuring assignment like this:\n[start, end] = [end, start];\nThen you can compute the slope of the line, which determines the amount the\ncoordinate on the other axis changes for each step you take along your main\naxis. With that, you can run a loop along the main axis while also tracking\nthe corresponding position on the other axis, and you can draw pixels on every\niteration. Make sure you round the nonmain axis coordinates, since they are\nlikely to be fractional and the draw method doesn\u2019t respond well to fractional\ncoordinates.\nNode.js\nSearch tool",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_902",
    "text": "iteration. Make sure you round the nonmain axis coordinates, since they are\nlikely to be fractional and the draw method doesn\u2019t respond well to fractional\ncoordinates.\nNode.js\nSearch tool\nYour first command line argument, the regular expression, can be found in\nprocess.argv[2]. The input files come after that. You can use the RegExp\nconstructor to go from a string to a regular expression object.\nDoing this synchronously, with readFileSync, is more straightforward, but\nif you use node:fs/promises to get promise-returning functions and write an\nasync function, the code looks similar.\nTo figure out whether something is a directory, you can again use stat (or\nstatSync) and the stats object\u2019s isDirectory method.\n394\nExploring a directory is a branching process. You can do it either by using\na recursive function or by keeping an array of work (files that still need to be\nexplored). To find the files in a directory, you can call readdir or readdirSync.",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_903",
    "text": "a recursive function or by keeping an array of work (files that still need to be\nexplored). To find the files in a directory, you can call readdir or readdirSync.\nNote the strange capitalization\u2014Node\u2019s filesystem function naming is loosely\nbased on standard Unix functions, such as readdir, that are all lowercase, but\nthen it adds Sync with a capital letter.\nTo go from a filename read with readdir to a full path name, you have to\ncombine it with the name of the directory, either putting sep from node:path\nbetween them or using the join function from that same package.\nDirectory creation\nYou can use the function that implements the DELETE method as a blueprint\nfor the MKCOL method. When no file is found, try to create a directory with\nmkdir. When a directory exists at that path, you can return a 204 response\nso that directory creation requests are idempotent. If a nondirectory file exists\nhere, return an error code. Code 400 (\u201cbad request\u201d) would be appropriate.\nA public space on the web",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_904",
    "text": "so that directory creation requests are idempotent. If a nondirectory file exists\nhere, return an error code. Code 400 (\u201cbad request\u201d) would be appropriate.\nA public space on the web\nYou can create a <textarea> element to hold the content of the file that is being\nedited. A GET request, using fetch, can retrieve the current content of the file.\nYou can use relative URLs like index.html, instead of http://localhost:8000/\nindex.html, to refer to files on the same server as the running script.\nThen, when the user clicks a button (you can use a <form> element and \"\nsubmit\" event), make a PUT request to the same URL, with the content of the\n<textarea> as the request body, to save the file.\nYou can then add a <select> element that contains all the files in the server\u2019s\ntop directory by adding <option> elements containing the lines returned by a\nGET request to the URL /. When the user selects another file (a \"change\" event",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_905",
    "text": "top directory by adding <option> elements containing the lines returned by a\nGET request to the URL /. When the user selects another file (a \"change\" event\non the field), the script must fetch and display that file. When saving a file,\nuse the currently selected filename.\nProject: Skill-Sharing Website\nDisk persistence\nThe simplest solution I can come up with is to encode the whole talks object as\nJSON and dump it to a file with writeFile. There is already a method (updated\n) that is called every time the server\u2019s data changes. It can be extended to write\n395\nthe new data to disk.\nPick a filename, for example ./talks.json. When the server starts, it can\ntry to read that file with readFile, and if that succeeds, the server can use the\nfile\u2019s contents as its starting data.\nComment field resets\nThe best way to do this is probably to make the talk component an object, with\na syncState method, so that they can be updated to show a modified version",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_906",
    "text": "Comment field resets\nThe best way to do this is probably to make the talk component an object, with\na syncState method, so that they can be updated to show a modified version\nof the talk. During normal operation, the only way a talk can be changed is\nby adding more comments, so the syncState method can be relatively simple.\nThe di\ufb00icult part is that when a changed list of talks comes in, we have to\nreconcile the existing list of DOM components with the talks on the new list\u2014\ndeleting components whose talk was deleted and updating components whose\ntalk changed.\nTo do this, it might be helpful to keep a data structure that stores the talk\ncomponents under the talk titles so that you can easily figure out whether a\ncomponent exists for a given talk. You can then loop over the new array of\ntalks, and for each of them, either synchronize an existing component or create\na new one. To delete components for deleted talks, you\u2019ll have to also loop over",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_907",
    "text": "talks, and for each of them, either synchronize an existing component or create\na new one. To delete components for deleted talks, you\u2019ll have to also loop over\nthe components and check whether the corresponding talks still exist.\n396\nIndex\n! operator, 17, 30\n!= operator, 16\n!== operator, 19\n* operator, 12, 18, 142\n** operator, 30\n*= operator, 32\n+ operator, 12, 14, 18, 142\n++ operator, 33\n+= operator, 32, 190\n\u2212operator, 12, 15, 18\n\u2212\u2212operator, 33\n\u2212= operator, 32\n/ operator, 12\n/= operator, 32\n< operator, 16\n<= operator, 16\n= operator, 22, 59, 335\nas expression, 156\nfor default value, 45\nin Egg, 200\n== operator, 16, 18, 62, 78\n=== operator, 19, 78, 111, 377\n> operator, 16\n>= operator, 16\n?: operator, 17, 20, 199\n?? operator, 19, 49, 314\n[] (array), 56, 71\n[] (subscript), 56, 57\n% operator, 13, 32, 283, 374, 375,\n388, 389\n&& operator, 16, 20, 92\n| | operator, 17, 19, 92, 374\n{} (block), 27\n{} (object), 59, 62, 71\n200 (HTTP status code), 297, 345,\n348\n204 (HTTP status code), 351",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_908",
    "text": "388, 389\n&& operator, 16, 20, 92\n| | operator, 17, 19, 92, 374\n{} (block), 27\n{} (object), 59, 62, 71\n200 (HTTP status code), 297, 345,\n348\n204 (HTTP status code), 351\n2d (canvas context), 274\n304 (HTTP status code), 358, 365,\n371\n400 (HTTP status code), 395\n403 (HTTP status code), 349\n404 (HTTP status code), 297, 349,\n362, 364\n405 (HTTP status code), 300, 348\n406 (HTTP status code), 391\n500 (HTTP status code), 348\na (HTML tag), 209, 222, 224, 305,\n330\nAbelson, Hal, 193\nabsolute positioning, 228, 232, 239,\n243, 249\nabsolute value, 73, 394\nabstract data type, 93, 97\nabstract syntax tree, see syntax tree\nabstraction, 5, 38, 80, 82, 193, 217,\n301, 335\nin Egg, 193\n397\nof the network, 207\nwith higher-order functions, 79\nacceleration, 268\nAccept header, 315, 391\naccess control, 137, 359\nAccess-Control-Allow-Origin header,\n301\naction, 319, 321, 322\nactiveElement property, 305\nactor, 255, 260, 266\nadd method, 111\naddEntry function, 62\naddEventListener method, 233, 234,\n268, 346",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_909",
    "text": "Access-Control-Allow-Origin header,\n301\naction, 319, 321, 322\nactiveElement property, 305\nactor, 255, 260, 266\nadd method, 111\naddEntry function, 62\naddEventListener method, 233, 234,\n268, 346\naddition, 12, 111\naddress, 75, 296\naddress bar, 208, 296, 298\nadoption, 138\nages example, 101\nalert function, 211\nalpha, 332\nalphanumeric character, 140\nalt attribute, 220\nalt key, 238\naltKey property, 238\nambiguity, 205\nAmerican English, 142\nampersand character, 210, 298\nanalysis, 123, 128\nancestor element, 261\nAndroid, 238\nangle, 229, 279, 280, 390\nangle brackets, 209\nanimation, 229, 243, 249, 252, 257,\n292, 390\nbouncing ball, 295\nplatform game, 263, 264, 268\u2013\n270, 282, 283, 290, 388\nspinning cat, 228, 231\nappendChild method, 219, 386\nApple, 213\nappliance, 93\napplication, 1, 318, 356\narc, 279, 280\narc method, 279, 390\nargument, 25, 44, 48, 71, 193\nargv property, 339\narithmetic, 12, 18, 201\narray, 57, 58, 60, 77\nas matrix, 254\nas table, 64\ncounting, 90\ncreation, 56, 88, 320, 376, 380",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_910",
    "text": "arc method, 279, 390\nargument, 25, 44, 48, 71, 193\nargv property, 339\narithmetic, 12, 18, 201\narray, 57, 58, 60, 77\nas matrix, 254\nas table, 64\ncounting, 90\ncreation, 56, 88, 320, 376, 380\nfiltering, 84\nflattening, 91\nin Egg, 204\nindexing, 56, 65, 68, 376, 388\niteration, 65, 80, 83\nlength of, 57\nmethods, 68, 77, 83\u201385, 88, 91,\n92\nnotation, 75\nof rest arguments, 71\nrandom element, 117\nRegExp match, 143\nrepresentation, 75\nsearching, 65, 68\nArray constructor, 320\nArray prototype, 96, 100\narray-like object, 103, 216, 217, 219,\n242, 306, 311, 343\nArray.from function, 341\narrays in egg (exercise), 204, 385\narrow function, 42, 95, 190\narrow key, 249\nartificial intelligence, 112\nartificial life, 252, 316\nassert function, 135\nassertion, 135\nassignment, 22, 32, 156, 205, 386\n398\nassumption, 134, 135\nasterisk, 12, 142\nasync function, 183, 184, 190\u2013192,\n370, 384\nasynchronous programming, 173\u2013176,\n182, 188, 189, 271, 384\nin Node.js, 338, 344, 346, 350,\n353\nreading files, 311\nat sign, 253",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_911",
    "text": "asterisk, 12, 142\nasync function, 183, 184, 190\u2013192,\n370, 384\nasynchronous programming, 173\u2013176,\n182, 188, 189, 271, 384\nin Node.js, 338, 344, 346, 350,\n353\nreading files, 311\nat sign, 253\nattribute, 209, 217, 222, 305, 322,\n392\nautofocus attribute, 305\nautomatic semicolon insertion, 22\nautomation, 121, 126\nautomaton, 112\navatar, 252\naverage function, 87\nawait keyword, 183, 184, 190, 192,\n384, 385\naxis, 267, 275, 284, 285, 394\nBabbage, Charles, 55\nbackground, 252, 259, 265\nbackground (CSS), 249, 252, 260\nbackslash character\nas path separator, 349\nin regular expressions, 138, 140,\n152, 381\nin strings, 13, 210\nbacktick, 13, 14\nbacktracking, 147, 148, 151\nball, 295, 390\nballoon, 249\nballoon (exercise), 249, 387\nbanking example, 131\nBanks, Iain, 251\nbaseControls constant, 334\nbaseTools constant, 334\nbean counting (exercise), 54, 376\nbeforeunload event, 245\nbehavior, 159\nbenchmark, 223\nBerners-Lee, Tim, 206\nbest practices, 2\nbezierCurveTo method, 278\nbig ball of mud, 161",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_912",
    "text": "baseTools constant, 334\nbean counting (exercise), 54, 376\nbeforeunload event, 245\nbehavior, 159\nbenchmark, 223\nBerners-Lee, Tim, 206\nbest practices, 2\nbezierCurveTo method, 278\nbig ball of mud, 161\nbinary data, 3, 10, 343\nbinary number, 10, 11, 64, 127, 147,\n310\nbinary operator, 12, 15, 21\nbinding, 4, 29, 59\nas\nstate, 29, 31\nas state, 62, 312\nassignment, 22, 41\ncompilation of, 386\ndefinition, 22, 38, 41, 203, 205\ndestructuring, 74\nfrom parameter, 39, 46\nglobal, 39, 124, 162, 271, 339,\n340\nin Egg, 200\nlocal, 39\nmodel of, 23, 59, 62\nnaming, 24, 34, 50, 72, 125\nscope of, 39\nundefined, 133\nvisibility, 40\nbit, 3, 10, 11, 15, 64\nbitfield, 241\nbitmap graphics, 282, 295\nblack, 321\nblock, 27, 30, 38, 40, 43, 59, 131,\n132, 194\nblock comment, 34, 151\nblock element, 222, 224, 225\nblocking, 174, 229, 247, 344\nblue, 321\nblur event, 244\n399\nblur method, 305\nbody (HTML tag), 209, 210, 215\nbody (HTTP), 298\u2013300, 345, 351,\n352\nbody property, 215, 216, 218, 300\nbold, 224\nBook of Programming, 10, 161, 338",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_913",
    "text": "blue, 321\nblur event, 244\n399\nblur method, 305\nbody (HTML tag), 209, 210, 215\nbody (HTTP), 298\u2013300, 345, 351,\n352\nbody property, 215, 216, 218, 300\nbold, 224\nBook of Programming, 10, 161, 338\nBoolean, 15, 26, 29, 61, 139, 199, 200\nconversion to, 19, 26, 30\nBoolean function, 26\nborder (CSS), 222, 225\nborder-radius (CSS), 239\nbouncing, 253, 256, 264, 267, 295\nbound, 84\nboundary, 145, 156, 159, 289, 381\nbox, 137, 214, 251, 252, 295, 390\nbox shadow (CSS), 261\nbr (HTML tag), 325, 392\nbraces\nblock, 5, 27, 375\nbody, 81\nclass, 97\nfunction body, 38, 42\nin regular expression, 142\nobject, 59, 62, 74\nbranching, 146, 148\nbranching recursion, 48, 286\nbreak keyword, 32, 33\nbreakpoint, 128\nBritish English, 142\nbrowser, 1, 5, 174, 206, 208, 210,\n212, 234, 252, 295, 296, 298,\n301, 307, 313, 330, 335, 355\nenvironment, 24, 25, 296\nsecurity, 301, 356\nstorage, 312, 314\nwindow, 233\nbrowser wars, 212\nbrowsers, 8, 168\nbubbling, see event propagation\nBuffer class, 343, 344, 346, 347",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_914",
    "text": "environment, 24, 25, 296\nsecurity, 301, 356\nstorage, 312, 314\nwindow, 233\nbrowser wars, 212\nbrowsers, 8, 168\nbubbling, see event propagation\nBuffer class, 343, 344, 346, 347\nbug, 79, 123, 127, 151, 153, 159, 164,\n212, 213\nbuilding Promise.all (exercise), 192,\n385\nbundler, 168\nbutton, 233, 298, 306, 317\nbutton (HTML tag), 211, 234, 238,\n249, 306, 313, 316, 322\nbutton property, 235, 241, 323\nbuttons property, 241, 323\ncall method, 94, 100\ncall stack, 43\u201345, 49, 58, 130, 131,\n133, 188\ncallback function, 174\u2013176, 178, 233,\n269, 270, 322, 343, 344, 346,\n365, 370\ncamel case, 34, 225\ncancelAnimationFrame function, 246\ncanvas, 252, 273, 275\u2013278, 281\u2013287,\n292\u2013294, 391\ncontext, 274\npath, 276\nsize, 274, 276\ncanvas (HTML tag), 274, 318, 322,\n330, 331, 336, 393\nCanvasDisplay class, 287, 288, 290\ncapitalization, 34, 98, 143, 225, 231,\n346\ncapture group, 143\u2013145, 149, 150,\n360\ncareer, 251\ncaret character, 140, 145, 156, 342\nCarla the crow, 180, 181, 185, 191\ncarriage return, 155\ncascading, 226",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_915",
    "text": "capitalization, 34, 98, 143, 225, 231,\n346\ncapture group, 143\u2013145, 149, 150,\n360\ncareer, 251\ncaret character, 140, 145, 156, 342\nCarla the crow, 180, 181, 185, 191\ncarriage return, 155\ncascading, 226\nCascading Style Sheets, see CSS\ncase conversion, 58\ncase keyword, 33\n400\ncase sensitivity, 143, 382\ncasual computing, 1\ncat\u2019s hat (exercise), 231\ncatch keyword, 130, 131, 133, 134,\n136, 188, 381\ncatch method, 179\nCD, 10\ncelery, 355\ncell, 316\nCelsius, 104\ncenter, 262\ncentering, 229\ncertificate, 302\nchange event, 304, 308, 326, 392, 395\ncharacter, 13, 14, 88, 89, 307\ncharacter category, 141\ncharacter encoding, 343, 344\ncharacterCount function, 86\ncharacterScript function, 91, 92, 378\ncharCodeAt method, 89\ncheckbox, 303, 309, 317, 392\nchecked attribute, 303, 309\nchess board (exercise), 375\nchessboard (exercise), 36\nchild node, 216, 217, 219\nchildNodes property, 217, 220, 388\nchildren property, 218\nChinese characters, 89, 90\nchoice, 146\nChrome, 213\ncircle, 229, 279\ncircle (SVG tag), 274",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_916",
    "text": "chessboard (exercise), 36\nchild node, 216, 217, 219\nchildNodes property, 217, 220, 388\nchildren property, 218\nChinese characters, 89, 90\nchoice, 146\nChrome, 213\ncircle, 229, 279\ncircle (SVG tag), 274\ncircles (exercise), 337, 393\ncircular dependency, 172, 383\nclass, 93, 97, 111, 114, 253, 319\nclass attribute, 219, 222, 226, 259,\n261\nclass declaration, 97\u201399\nclass hierarchy, 109\nclassName property, 222\ncleaning up, 131\nclearing, 273, 282, 288, 289, 391\nclearInterval function, 247\nclearRect method, 282, 391\nclearTimeout function, 246, 247\nclick event, 233\u2013235, 239, 241, 322,\n391\nclient, 207, 301, 355, 366\nclientHeight property, 222\nclientWidth property, 222\nclientX property, 239, 242, 324\nclientY property, 239, 242, 324\nclipboard, 212\nclipping, 289\nclosePath method, 277\nclosing tag, 209, 211\nclosure, 46, 204, 386\u2013388\nclosure in egg (exercise), 204, 386\ncode, 7, 150, 251\nstructure of, 21, 30, 38, 161, 169\ncode golf, 159\ncode unit, 88\ncodePointAt method, 89\ncoin, 251, 253, 267, 292",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_917",
    "text": "closure, 46, 204, 386\u2013388\nclosure in egg (exercise), 204, 386\ncode, 7, 150, 251\nstructure of, 21, 30, 38, 161, 169\ncode golf, 159\ncode unit, 88\ncodePointAt method, 89\ncoin, 251, 253, 267, 292\nCoin class, 257, 267\ncollaboration, 206\ncollection, 5, 56, 58, 60, 77, 106\ncollision detection, 263, 264, 267, 268,\n389, 391\ncolon character, 17, 33, 59, 225\ncolor, 274, 275, 289, 318, 332\ncolor (CSS), 225\ncolor code, 321\ncolor component, 321\ncolor field, 319, 321, 326\ncolor picker, 319, 326, 329\ncolor property, 320\nColorSelect class, 327\ncomma character, 193\ncommand key, 238, 336\n401\ncommand line, 164, 338\u2013340, 353\ncomment, 34, 75, 150, 154, 205, 216,\n355, 358, 364, 368\ncomment field reset (exercise), 372,\n396\nCOMMENT_NODE code, 216\ncomments in egg (exercise), 205, 386\nCommonJS, 340\nCommonJS modules, 166, 167, 172\ncommunication, 206, 301\ncommunity, 338\ncompareRobots function, 121\ncomparison, 15, 19, 201, 376\ndeep, 78, 377\nof NaN, 16\nof numbers, 16, 25\nof objects, 62\nof strings, 16",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_918",
    "text": "communication, 206, 301\ncommunity, 338\ncompareRobots function, 121\ncomparison, 15, 19, 201, 376\ndeep, 78, 377\nof NaN, 16\nof numbers, 16, 25\nof objects, 62\nof strings, 16\nof undefined values, 18\ncompatibility, 6, 124, 206, 212, 213,\n336, 342\ncompilation, 168, 203, 386\ncomplexity, 2, 3, 79, 109, 148, 227,\n335\ncomponent, 318, 319, 325, 334\ncomposability, 5, 87, 169\ncomputed property, 57, 314\ncomputer, 1, 2\nconcat method, 69, 91, 380, 387\nconcatenation, 14, 69, 387\nconditional execution, 17, 26, 33, 36,\n199\nconditional operator, 17, 20, 199\nconditional request, 358\nconfiguration, 154\nconnected graph, 120\nconnection, 207, 296, 302, 356, 357\nconsistency, 34, 206, 216\nconsole.log, 5, 9, 15, 25, 43, 45, 52,\n128, 339\nconst keyword, 23, 39, 62, 72, 74\nconstant, 23, 72, 268\nconstructor, 34, 97, 98, 109, 122, 124,\n131, 144, 152, 379, 380\ncontent negotiation (exercise), 315,\n391\nContent-Length header, 297\nContent-Type header, 297, 345, 348,\n349, 353\ncontext, 274, 275\ncontext menu, 237",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_919",
    "text": "131, 144, 152, 379, 380\ncontent negotiation (exercise), 315,\n391\nContent-Length header, 297\nContent-Type header, 297, 345, 348,\n349, 353\ncontext, 274, 275\ncontext menu, 237\ncontinuation, 175\ncontinue keyword, 32\ncontrol, 325, 327, 330, 333, 334\ncontrol flow, 26, 82\nasynchronous, 174, 183\nconditional, 26\nexceptions, 130, 131\nfunctions, 43\nloop, 28, 30, 31\ncontrol key, 238, 336\ncontrol point, 277\u2013279\nconvention, 34\nConway\u2019s Game of Life, 316\ncoordinates, 111, 229, 239, 259, 262,\n265, 275, 279, 284, 285\ncopy-paste programming, 51, 164\ncopyright, 165\ncorrelation, 63\u201367\ncosine, 72, 229\ncountBy function, 90, 92\ncounter variable, 29, 31, 230, 375,\n376, 385, 388\nCPU, 174\ncrash, 133, 135, 363, 372\ncreateElement method, 221, 321, 386\ncreateReadStream function, 346, 350\ncreateServer function, 344\u2013346, 359,\n361\ncreateTextNode method, 220, 391\n402\ncreateWriteStream function, 346, 351\ncrisp, 292\ncross-domain request, 301\ncrying, 143\ncryptography, 302\nCSS, 225\u2013227, 258, 260\u2013263, 273, 275,\n321, 366",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_920",
    "text": "361\ncreateTextNode method, 220, 391\n402\ncreateWriteStream function, 346, 351\ncrisp, 292\ncross-domain request, 301\ncrying, 143\ncryptography, 302\nCSS, 225\u2013227, 258, 260\u2013263, 273, 275,\n321, 366\nctrlKey property, 238, 336\ncurl program, 352\ncurly braces, see braces\ncursor, 307, 308\ncurve, 277\u2013279\ncwd function, 349\ncycle, 215\nDark Blue (game), 251\ndata, 2, 10, 55\ndata attribute, 222, 249\ndata event, 346\ndata flow, 319, 335\ndata format, 75, 216\ndata loss, 372\ndata structure, 55, 169, 171, 214,\n316\ncollection, 56\nimmutable, 116\nlist, 77, 106\nmap, 101\nstack, 58\ntree, 194, 215, 292\ndata URL, 330, 331\ndataset, 65, 83\ndate, 140, 142, 144\nDate class, 144, 145, 162, 166, 191,\n383\ndate-names package, 166\nDate.now function, 145, 191, 333\ndblclick event, 239\nDe Morgan\u2019s laws, 378\ndebouncing, 247\ndebugger statement, 128\ndebugging, 6, 123, 125, 127, 128, 131,\n134, 135, 159\ndecentralization, 206\ndecimal number, 10, 127, 147\ndeclaration, 225\ndecodeURIComponent function, 298,\n348, 360",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_921",
    "text": "debugger statement, 128\ndebugging, 6, 123, 125, 127, 128, 131,\n134, 135, 159\ndecentralization, 206\ndecimal number, 10, 127, 147\ndeclaration, 225\ndecodeURIComponent function, 298,\n348, 360\ndeep comparison, 62, 78\ndeep comparison (exercise), 78, 377\ndefault behavior, 224, 237\ndefault keyword, 33\ndefault value, 19, 45, 276, 314, 335\ndefineProperty function, 379\ndegree, 279, 284\nDELETE method, 297, 298, 300, 347,\n350, 362\ndelete method, 111\ndelete operator, 59\ndependence, 63\ndependency, 161, 163, 164, 166, 172,\n211, 342\ndeserialization, 75\ndesign, 171\ndestructuring, 145\ndestructuring assignment, 394\ndestructuring binding, 73, 166, 335,\n383\ndeveloper tools, 7, 25, 128, 133\ndialect, 168\ndialog, 24\ndiamond, 294, 389\ndigit, 10, 11, 127, 139, 140, 142, 143,\n321\nDijkstra\u2019s algorithm, 170\nDijkstra, Edsger, 112, 170\ndijkstrajs package, 170, 382\ndimensions, 111, 222, 251, 252, 264,\n274, 375\ndirect child node, 227\n403\ndirection (writing), 92\ndirectory, 340, 343, 344, 347, 349,\n350, 353, 395",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_922",
    "text": "dijkstrajs package, 170, 382\ndimensions, 111, 222, 251, 252, 264,\n274, 375\ndirect child node, 227\n403\ndirection (writing), 92\ndirectory, 340, 343, 344, 347, 349,\n350, 353, 395\ndirectory creation (exercise), 353, 395\ndisabled attribute, 305\ndiscretization, 252, 264, 269\ndispatch, 33, 319\u2013321, 325, 334, 359,\n392\ndisplay, 258, 270, 287, 292, 293\ndisplay (CSS), 225, 249\ndistance, 393\ndivision, 12, 13\ndivision by zero, 13\ndo loop, 30, 118\ndoctype, 209, 210\ndocument, 208, 214, 245, 273\ndocument format, 302, 315\nDocument Object Model, see DOM\ndocumentation, 338\ndocumentElement property, 215\ndollar sign, 24, 145, 149, 156\nDOM, 215, 222\nattributes, 222\ncomponents, 318, 319\nconstruction, 217, 219, 221, 321\nevents, 234, 238\nfields, 303, 307\ngraphics, 252, 258, 260, 261, 273,\n274, 292\ninterface, 216\nmodification, 219\nquerying, 218, 227\ntree, 215\ndom property, 319\ndomain, 208, 301, 313\ndomain-specific language, 79, 127, 138,\n204, 227\nDOMDisplay class, 258, 259, 287",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_923",
    "text": "274, 292\ninterface, 216\nmodification, 219\nquerying, 218, 227\ntree, 215\ndom property, 319\ndomain, 208, 301, 313\ndomain-specific language, 79, 127, 138,\n204, 227\nDOMDisplay class, 258, 259, 287\ndominant direction (exercise), 92, 378\ndone property, 333\ndoneAt property, 333\ndot character, see period character\ndouble click, 239\ndouble-quote character, 13, 159, 193,\n210\ndownload, 7, 164, 330, 341, 352, 355,\n372\ndownload attribute, 330\ndraggable bar example, 240\ndragging, 240, 318, 328, 337\ndraw function, 327, 337\ndrawImage method, 282, 284, 287,\n290, 391\ndrawing, 214, 222, 223, 229, 273\u2013\n275, 277, 286, 290, 292, 318,\n392\ndrawing program example, 239, 318\ndrawPicture function, 323, 330, 336,\n393\ndrop-down menu, 304, 310\nduplication, 164\nECMAScript, 6, 124\nECMAScript 6, 6\neconomic factors, 335\neditor, 31\ne\ufb00iciency, 47, 77, 88, 203, 223, 252,\n261, 274, 323, 336\ne\ufb00icient drawing (exercise), 336, 393\nEgg language, 193, 194, 197, 198,\n200\u2013205, 215\nelectronic life, 252\nelegance, 47, 195",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_924",
    "text": "editor, 31\ne\ufb00iciency, 47, 77, 88, 203, 223, 252,\n261, 274, 323, 336\ne\ufb00icient drawing (exercise), 336, 393\nEgg language, 193, 194, 197, 198,\n200\u2013205, 215\nelectronic life, 252\nelegance, 47, 195\nelement, 209, 216, 218, 221\nELEMENT_NODE code, 216, 387\nelements property, 306\nellipse, 228, 230\nelse keyword, 27\nelt function, 221, 321, 336, 368\nemail, 302\n404\nemoji, 14, 89, 157, 249\nempty set, 151\nencapsulation, 93, 102, 109, 234, 258\nencodeURIComponent function, 298,\n358, 368\nencoding, 206\nencryption, 302\nend event, 346\nend method, 345, 346, 348\nenemies example, 154\nengineering, 213\nENOENT (status code), 350\nenter key, 306\nentity, 210\nenum (reserved word), 24\nenvironment, 24, 199\nequality, 16\nerror, 88, 123, 124, 127\u2013129, 133,\n134, 178\nerror event, 312, 351\nerror handling, 123, 129, 130, 133,\n344, 348, 350, 368, 371\nerror message, 197, 316\nerror recovery, 129\nerror response, 297, 348, 351\nerror tolerance, 210\nError type, 131, 133, 134, 350\nES modules, 162, 163, 211, 340, 341\nescape key, 271",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_925",
    "text": "error message, 197, 316\nerror recovery, 129\nerror response, 297, 348, 351\nerror tolerance, 210\nError type, 131, 133, 134, 350\nES modules, 162, 163, 211, 340, 341\nescape key, 271\nescaping\nin HTML, 209, 211\nin regexps, 138, 140, 152\nin strings, 13, 193\nin URLs, 298, 348, 358, 360\nEscher, M.C., 273\nETag header, 358, 364, 371\neval, 167\nevaluate function, 197, 198, 200\nevaluation, 197, 203\neven number, 28, 53\nevent handling, 233\u2013235, 237, 243\u2013\n245, 252, 268, 271, 282, 292,\n307, 322, 346, 389, 392\nevent loop, 188\nevent object, 235, 239, 242\nevent propagation, 235, 236, 244, 245\nevent type, 235\nevery method, 92\neverything (exercise), 92, 378\nevolution, 138, 335, 342\nexception handling, 130, 131, 133\u2013\n137, 178, 180, 183, 188, 391\nexception safety, 133\nexec method, 143, 144, 153, 154\nexecution order, 26, 42, 43\nexercises, 2, 7, 35, 127\nexit method, 339\nexpectation, 237\nexperiment, 3, 7, 159\nexploit, 212\nexponent, 12, 160, 381, 382\nexponentiation, 29, 31\nexport keyword, 341",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_926",
    "text": "execution order, 26, 42, 43\nexercises, 2, 7, 35, 127\nexit method, 339\nexpectation, 237\nexperiment, 3, 7, 159\nexploit, 212\nexponent, 12, 160, 381, 382\nexponentiation, 29, 31\nexport keyword, 341\nexports object, 166, 167, 383\nexpression, 21, 22, 26, 29, 31, 41,\n193, 194, 198\nexpressivity, 204\nextraction, 144\nfactorial function, 8\nFahrenheit, 104\nfallthrough, 33\nfalse, 15\nfarm example, 50, 52, 146\nfetch function, 299, 316, 346, 367,\n370, 395\nfield, 238, 298, 303, 305, 306, 309,\n312, 317, 318, 372\nFielding, Roy, 296\nfile, 311, 340, 350, 396\n405\naccess, 167, 168, 331, 343\nimage, 318, 330\nresource, 297, 298, 347, 349\nstream, 346\nfile extension, 349\nfile field, 303, 311\nfile format, 154\nfile reading, 311\nfile server, 366\nfile server example, 347, 349\u2013353, 395\nfile size, 168\nFile type, 311\nFileReader class, 311, 312, 331\nfiles property, 311\nfileSizes function, 189, 190\nfilesystem, 311, 343, 347, 349, 395\nfill function, 329\nfill method, 277, 320\nfilling, 275, 277, 281, 293",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_927",
    "text": "File type, 311\nFileReader class, 311, 312, 331\nfiles property, 311\nfileSizes function, 189, 190\nfilesystem, 311, 343, 347, 349, 395\nfill function, 329\nfill method, 277, 320\nfilling, 275, 277, 281, 293\nfillRect method, 275, 282\nfillStyle property, 275, 281, 321\nfillText method, 281, 390\nfilter method, 84, 87, 91, 115, 378\u2013\n380\nfinally keyword, 132, 137, 381\nfind method, 90\nfindInStorage function, 183\nfindRoute function, 119\nfinish event, 351\nFirefox, 213\nfirstChild property, 217\nfixed positioning, 243\nfixing scope (exercise), 205, 386\nFizzBuzz (exercise), 36, 374\nflattening (exercise), 91\nflexibility, 6\nflipHorizontally function, 290, 389\nflipHorizontally method, 285\nflipping, see mirroring\nfloating-point number, 11, 12\nflood fill, 325, 328\nflow diagram, 147\nfocus, 238, 244, 304\u2013306, 308, 309,\n336, 373\nfocus event, 244\nfocus method, 305\nfold, see reduce method\nfont, 281\nfont-family (CSS), 225\nfont-size (CSS), 249\nfont-weight (CSS), 226\nfor attribute, 309",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_928",
    "text": "focus, 238, 244, 304\u2013306, 308, 309,\n336, 373\nfocus event, 244\nfocus method, 305\nfold, see reduce method\nfont, 281\nfont-family (CSS), 225\nfont-size (CSS), 249\nfont-weight (CSS), 226\nfor attribute, 309\nfor loop, 31, 32, 65, 80, 91, 134, 376,\n377\nfor/of loop, 66, 89, 105, 106, 108,\n379\nforEach method, 83, 103\nform, 298, 299, 305, 307, 354\nform (HTML tag), 303, 306, 369,\n395\nform property, 306\nformatDate module, 166\nfractal example, 286\nfractional number, 12, 160, 252\nframe, 283, 290, 391\nframework, 52, 319\nfrequency table, 63\nfunction, 5, 24, 38, 42, 124, 193, 194,\n202\napplication, 24\u201326, 39, 43, 44, 47,\n71, 84, 133, 193, 198\nas property, 57\nas value, 38, 41, 45, 81, 82, 84,\n235, 269, 389\nbody, 38, 42\ncallback, see callback function\ndeclaration, 42\ndefinition, 38, 42, 50\nhigher-order, 41, 81, 82, 84, 85,\n87, 150, 269\n406\nmodel of, 46\nnaming, 50, 51\npurity, 52\nscope, 41, 165, 204\nFunction constructor, 167, 201, 203,\n316, 391\nfunction keyword, 38, 42\nFunction prototype, 96, 100",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_929",
    "text": "87, 150, 269\n406\nmodel of, 46\nnaming, 50, 51\npurity, 52\nscope, 41, 165, 204\nFunction constructor, 167, 201, 203,\n316, 391\nfunction keyword, 38, 42\nFunction prototype, 96, 100\nfuture, 6, 24, 42, 295\ngame, 251\u2013253, 268, 271, 287\nscreenshot, 263, 292\nwith canvas, 292\ngame of life (exercise), 316, 392\nGAME_LEVELS dataset, 271\ngarbage collection, 11\ngarble example, 340\ngardening, 355\ngaudy home pages, 249\ngeneration, 316, 317, 392\ngenerator, 184\nGET method, 297, 298, 300, 307,\n347, 349, 357, 362\nget method, 102\ngetAttribute method, 222\ngetBoundingClientRect method, 223,\n324\ngetContext method, 274\ngetDate method, 145\ngetElementById method, 219, 387\ngetElementsByClassName method, 219\ngetElementsByTagName method, 218,\n220, 231, 387\ngetFullYear method, 145\ngetHours method, 145\ngetImageData method, 331, 332\ngetItem method, 313, 314\ngetMinutes method, 145\ngetMonth method, 145\ngetPrototypeOf function, 96, 98, 205,\n386\ngetSeconds method, 145\ngetter, 103, 111, 256\ngetTime method, 145",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_930",
    "text": "getItem method, 313, 314\ngetMinutes method, 145\ngetMonth method, 145\ngetPrototypeOf function, 96, 98, 205,\n386\ngetSeconds method, 145\ngetter, 103, 111, 256\ngetTime method, 145\ngetYear method, 145\nGitHub, 297\nglobal object, 124\nglobal scope, 39, 162, 166, 200, 246,\n339, 340, 386\ngoalOrientedRobot function, 121\nGoogle, 213\ngrammar, 21, 123, 155\ngraph, 113, 119, 170, 293\ngraphics, 252, 258, 261, 273, 274,\n282, 292, 293\ngrave accent, see backtick\ngravity, 268\ngreater than, 16\ngreed, 150, 151\ngreen, 321\ngrep, 353\ngrid, 252, 259, 265, 316, 392\nGroup class, 111, 122, 184, 379\ngroupBy function, 92\ngrouping, 12, 27, 143, 149, 150, 381\ngroups (exercise), 111, 379\nh1 (HTML tag), 209, 222\nhandleAction function, 366\nhard disk, 169, 173\nhard drive, 10, 311, 313, 338, 372\nhard-coding, 218\nhardcoding, 294\nhas method, 102, 111\nhash character, 205\nhash sign, 321\nhasOwn function, 102, 205, 362, 386\nhead (HTML tag), 209, 210, 215\nhead property, 215\n407\nheader, 297, 298, 301, 345, 357",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_931",
    "text": "hardcoding, 294\nhas method, 102, 111\nhash character, 205\nhash sign, 321\nhasOwn function, 102, 205, 362, 386\nhead (HTML tag), 209, 210, 215\nhead property, 215\n407\nheader, 297, 298, 301, 345, 357\nheaders property, 300, 316\nheight property, 336, 393\nhelp text example, 244\nhexadecimal number, 147, 298, 321,\n332\nhidden element, 225, 249\nhigher-order function, see function,\nhigher-order\nhistory, 5, 335\nhistoryUpdateState function, 333\nhooligan, 359\nhref attribute, 209, 218, 222\nHTML, 208, 214, 296, 312, 353\nnotation, 209\nstructure, 214, 216\nhtml (HTML tag), 210, 215\nHTTP, 206\u2013208, 296\u2013299, 301, 302,\n345, 351, 353, 356, 357\nclient, 346, 352, 355\nserver, 344, 347, 365\nHTTPS, 208, 302\nhuman language, 21\nHyperText Markup Language, see HTML\nHyperText Transfer Protocol, see HTTP\nhyphen character, 12, 139, 225\nid attribute, 219, 226, 309\nidempotence, 351\nidempotency, 395\nidentifier, 194\nidentity, 61\nif keyword, 27, 156\nchaining, 28, 33, 374, 375\nIf-None-Match header, 358, 365, 370",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_932",
    "text": "id attribute, 219, 226, 309\nidempotence, 351\nidempotency, 395\nidentifier, 194\nidentity, 61\nif keyword, 27, 156\nchaining, 28, 33, 374, 375\nIf-None-Match header, 358, 365, 370\nimage, 220, 245, 273, 298\nimagination, 251\nIME, 238\nimg (HTML tag), 209, 220, 224, 245,\n273, 282, 283, 331\nimmediately invoked function expres-\nsion, 165\nimmutable, 61, 116, 256, 320, 321,\n328, 333, 393\nimplements (reserved word), 24\nimport keyword, 163, 340, 360\nin operator, 60, 102\nincludes method, 65, 66, 379\nindentation, 30\nindex, 56\nindex property, 143\nindex.html, 366\nindexOf method, 68, 69, 111, 139,\n152, 379\ninfinite loop, 32, 44, 134, 376\ninfinity, 13\ninfrastructure, 164\ninheritance, 96, 108\u2013110, 135, 350\nINI file, 154\nini package, 164, 165, 169, 341\ninitialization, 245\ninline element, 222, 224\ninner function, 40, 387\ninner loop, 149\ninnerHeight property, 243\ninnerWidth property, 243\ninput, 128, 233, 252, 304, 338, 363\ninput (HTML tag), 244, 303, 307,\n309, 311, 326, 331\ninput event, 308",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_933",
    "text": "inner function, 40, 387\ninner loop, 149\ninnerHeight property, 243\ninnerWidth property, 243\ninput, 128, 233, 252, 304, 338, 363\ninput (HTML tag), 244, 303, 307,\n309, 311, 326, 331\ninput event, 308\ninsertBefore method, 219, 220\ninstallation, 164\ninstance, 97, 98\ninstanceof operator, 109, 134\ninstruction, 3\ninteger, 12\nintegration, 138, 216\ninterface, 99\ncanvas, 273, 274\ndesign, 52, 138, 145, 153, 216,\n408\n217, 276\nHTTP, 301, 357\nmodule, 161, 165\u2013167, 169, 299,\n341\nobject, 94, 102, 103, 111, 122,\n255, 287, 307, 319\ninterface (reserved word), 24\ninternationalization, 140\ninternet, 154, 206\u2013208, 212\nInternet Explorer, 212, 213\ninterpolation, 14\ninterpretation, 7, 197, 198, 203\ninterview question, 36\ninversion, 140\nIP address, 208, 296\nisDirectory method, 350, 394\nisEven (exercise), 53, 375\nisolation, 93, 161, 166, 212\niterable interface, 106, 379\niterator, 184\niterator interface, 105, 106, 111\nJacques, 55\nJava, 6\nJavaScript, 5\navailability of, 1\nflexibility of, 6\nhistory of, 5, 206",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_934",
    "text": "isolation, 93, 161, 166, 212\niterable interface, 106, 379\niterator, 184\niterator interface, 105, 106, 111\nJacques, 55\nJava, 6\nJavaScript, 5\navailability of, 1\nflexibility of, 6\nhistory of, 5, 206\nin HTML, 211\nsyntax, 21\nuses of, 7\nversions of, 6\nweaknesses of, 6\nJavaScript console, 7, 15, 25, 128,\n133, 316, 339\nJavaScript Object Notation, see JSON\njob, 280\njoin method, 91, 100, 341\njournal, 56, 58, 60, 62, 66\nJOURNAL dataset, 65\njournalEvents function, 66\nJSON, 75, 169, 300, 314, 357, 358,\n363, 371, 395\njson method, 300\nJSON.parse function, 75, 396\nJSON.stringify function, 75\nJSX, 369\njump, 4\njump-and-run game, 251\njumping, 252, 268\nKernighan, Brian, 123\nkey code, 268\nkey property, 238, 387, 392\nkeyboard, 24, 233, 237, 252, 268, 271,\n304, 305, 307, 336\nkeyboard bindings (exercise), 336, 392\nkeyboard focus, see focus\nkeydown event, 237, 247, 269, 336,\n387, 392\nkeyup event, 237, 269\nkeyword, 22, 24, 222\nKhasekhemwy, 307\nkill process, 345\nKnuth, Donald, 38\nlabel, 281, 294",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_935",
    "text": "keyboard focus, see focus\nkeydown event, 237, 247, 269, 336,\n387, 392\nkeyup event, 237, 269\nkeyword, 22, 24, 222\nKhasekhemwy, 307\nkill process, 345\nKnuth, Donald, 38\nlabel, 281, 294\nlabel (HTML tag), 309, 326\nlabeling, 309\nlandscape example, 40\nLaozi, 173\nLast-Modified header, 297\nlastChild property, 217\nlastIndex property, 153, 154\nlastIndexOf method, 68\nlatency, 168\nlava, 251\u2013253, 261, 264, 266, 267,\n292\nLava class, 256, 266\nlayering, 207\n409\nlayout, 222, 223, 225\nlaziness, 223\nLe Guin, Ursula K., 2\nleaf node, 215, 216\nleak, 212, 271\nlearning, 2, 6, 7\nleft (CSS), 228\u2013230, 232\nLEGO, 162\nlength property\nfor array, 57, 320\nfor string, 50, 54, 57, 70, 376\nLengthList class, 108\nless than, 16\nlet keyword, 22, 23, 39, 62, 72, 74,\n124\nlevel, 252, 253, 258, 259, 261, 270,\n271\nLevel class, 253\nlexical scoping, 40, 41\nlibrary, 217, 319, 341\nlicense, 165\nline, 22, 30, 155, 273, 275\u2013280, 294,\n389\nline break, 13, 155\nline comment, 34, 151\nline drawing, 337, 393\nline width, 275, 284",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_936",
    "text": "lexical scoping, 40, 41\nlibrary, 217, 319, 341\nlicense, 165\nline, 22, 30, 155, 273, 275\u2013280, 294,\n389\nline break, 13, 155\nline comment, 34, 151\nline drawing, 337, 393\nline width, 275, 284\nlines of code, 202\nlineTo method, 276\nlineWidth property, 275\nlink, 209, 217, 218, 237, 238, 330\nlink (HTML tag), 263\nlinked list, 77, 106, 108, 377\nLiskov, Barbara, 93\nlist (exercise), 77, 377\nlisten method, 344, 345\nlistening (TCP), 207, 344\nListIterator class, 107\nliteral expression, 21, 138, 196, 198\nlive data structure, 214, 220, 227,\n388\nlive view, 356, 357, 371, 396\nlives (exercise), 271\nload event, 245, 282, 290, 312, 391\nLoadButton class, 330\nlocal binding, 45, 205, 376\nlocal scope, 39, 202\nlocalhost, 345\nlocalStorage object, 313, 367\nlocked box (exercise), 136, 381\nlogging, 128\nlogical and, 16\nlogical operators, 16\nlogical or, 17\nlong polling, 356\u2013358, 363\u2013365, 370\nlook-ahead, 146\nloop, 4, 5, 29, 31, 36, 47, 65, 80, 81,\n86, 87, 154, 375, 376, 389\ntermination of, 32\nloop body, 30, 81",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_937",
    "text": "logical operators, 16\nlogical or, 17\nlong polling, 356\u2013358, 363\u2013365, 370\nlook-ahead, 146\nloop, 4, 5, 29, 31, 36, 47, 65, 80, 81,\n86, 87, 154, 375, 376, 389\ntermination of, 32\nloop body, 30, 81\nlycanthropy, 55, 62\nmachine code, 3, 203\nmagic, 193\nmailRoute array, 118\nmaintenance, 164\nmalicious script, 212\nman-in-the-middle, 302\nmap, 258, 306\nmap (data structure), 101\nMap class, 102, 103\nmap method, 85, 87, 91, 101, 115,\n254, 325\nMarcus Aurelius, 233\nmatch method, 143, 154\nmatching, 139, 145, 153, 159\nalgorithm, 147, 148\nMath object, 53, 57, 72\nMath.abs function, 73, 394\nMath.acos function, 72\n410\nMath.asin function, 72\nMath.atan function, 72\nMath.ceil function, 73, 264, 289\nMath.cos function, 72, 229, 230, 390\nMath.floor function, 73, 117, 264, 289\nMath.max function, 25, 57, 71, 72,\n289\nMath.min function, 26, 53, 72, 289\nMath.PI constant, 72, 279\nMath.random function, 72, 117, 258,\n316\nMath.round function, 73\nMath.sin function, 72, 229, 230, 258,\n267\nMath.sqrt function, 64, 72, 379",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_938",
    "text": "Math.min function, 26, 53, 72, 289\nMath.PI constant, 72, 279\nMath.random function, 72, 117, 258,\n316\nMath.round function, 73\nMath.sin function, 72, 229, 230, 258,\n267\nMath.sqrt function, 64, 72, 379\nMath.tan function, 72\nmathematics, 47, 82\nmax example, 71\nmax-height (CSS), 261\nmax-width (CSS), 261\nmaximum, 25, 72, 86\nMeadowfield, 112\nmeasuring a robot (exercise), 121,\n380\nmedia type, 302, 315, 316, 349\nmeetup, 355\nmemory, 3, 10\ncall\nstack, 44\norganization, 10, 22, 56, 61, 75\npersistence, 372\nspeed, 173, 203\nstructure\nsharing, 77\nmesh, 208\nmessage event, 246\nmeta key, 238\nmetaKey property, 238, 336\nmethod, 57, 94, 99, 124, 345\narray, 68\nHTTP, 297, 302, 345, 352, 357,\n359\nprivate, 99\nmethod attribute, 298\nmethod call, 94\nmethod property, 300\nmethods object, 347\nMicrosoft, 212, 213\nMIME type, 316, 349\nmime-types package, 349\nmini application, 312\nminifier, 168\nminimalism, 251\nminimum, 26, 53, 72\nminimum (exercise), 53, 375\nminus, 12, 160\nmirror, 285, 295, 391\nmirroring, 283\u2013285",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_939",
    "text": "MIME type, 316, 349\nmime-types package, 349\nmini application, 312\nminifier, 168\nminimalism, 251\nminimum, 26, 53, 72\nminimum (exercise), 53, 375\nminus, 12, 160\nmirror, 285, 295, 391\nmirroring, 283\u2013285\nMir\u00f3, Joan, 318\nmixer example, 93\nMKCOL method, 353, 395\nmkdir function, 353, 395\nmodification date, 350\nmodifier key, 238\nmodular robot (exercise), 171, 382\nmodularity, 93, 319\nmodule, 161, 165, 171, 258, 340, 341,\n360\ndesign, 169\nresolution, 163\nmodule loader, 340\nmodule object, 167\nmodule system, 165\nmodulo operator, 13\nMongolian vowel separator, 141\nmonster (exercise), 272, 389\nMosaic, 212\nmotion, 252\nmouse, 24\nmouse button, 235, 236, 239\n411\nmouse cursor, 239\nmouse trail (exercise), 249, 388\nmousedown event, 236, 239, 241, 322,\n323, 391\nmousemove event, 240, 241, 247\u2013249,\n323, 337, 388\nmouseup event, 239, 241\nmoveTo method, 276, 279\nMozilla, 213\nmultiple attribute, 310, 311\nmultiple choice, 304\nmultiple-choice, 303, 309, 310\nmultiplication, 12, 256, 267\nmultiplier function, 46",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_940",
    "text": "mouseup event, 239, 241\nmoveTo method, 276, 279\nMozilla, 213\nmultiple attribute, 310, 311\nmultiple choice, 304\nmultiple-choice, 303, 309, 310\nmultiplication, 12, 256, 267\nmultiplier function, 46\nmusic, 251\nmutability, 59, 61, 116\nname attribute, 306, 309\nnamespace, 72\nnaming, 4, 6, 23\nNaN, 13, 16, 18, 123\nnegation, 15, 17\nneighbor, 316, 392\nnerd, 152\nnesting\nin regexps, 149\nof arrays, 64\nof expressions, 21, 195\nof functions, 40\nof loops, 36, 375\nof objects, 215, 218\nof scope, 40\nNetscape, 5, 212, 213\nnetwork, 173, 206, 356\nabstraction, 301\nprotocol, 206\nsecurity, 302\nspeed, 168, 173, 338\nnew operator, 97\nnewline character, 13, 36, 140, 151,\n155, 254, 391\nnext method, 106, 184, 379\nnextSibling property, 217\nnode, 215, 216\nnode program, 339\nNode.js, 7, 8, 25, 166, 174, 338\u2013341,\n343\u2013347, 349\u2013352, 355\u2013357, 359,\n372\nnode:fs package, 343, 344\nnode:fs/promises package, 344\nnode:http package, 344, 346\nnode:path package, 349\nnode:stream/consumers package, 363\nnode_modules directory, 340, 341",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_941",
    "text": "372\nnode:fs package, 343, 344\nnode:fs/promises package, 344\nnode:http package, 344, 346\nnode:path package, 349\nnode:stream/consumers package, 363\nnode_modules directory, 340, 341\nNodeList type, 216, 227\nnodeName property, 231\nnodeType property, 216, 387, 388\nnodeValue property, 218\nnonbreaking space, 141\nnot a number, 13\nnote-taking example, 313\nnotification, 356\nNPM, 164\u2013166, 170, 171, 340, 341,\n343, 349, 360, 361, 372, 382\nnpm program, 341, 342, 349\nnull, 17\u201319, 49, 57, 74, 78, 129\nnumber, 11, 61, 139, 160, 381\nconversion to, 18, 26\nnotation, 11, 12\nprecision of, 12\nrepresentation, 11\nspecial values, 13\nNumber function, 26, 27, 34, 141\nnumber puzzle example, 48\nNumber.isNaN function, 27\nobject, 55, 59, 60, 109\nas\nmodule, 165\n412\nas map, 258\ncreation, 75, 97, 314\nidentity, 61\nmutability, 61\nproperty, 25, 57, 72, 74, 95\nrepresentation, 75\nObject prototype, 95, 96\nobject-oriented programming, 93, 97,\n102, 103, 108, 114, 169\nObject.create function, 96, 101, 201",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_942",
    "text": "identity, 61\nmutability, 61\nproperty, 25, 57, 72, 74, 95\nrepresentation, 75\nObject prototype, 95, 96\nobject-oriented programming, 93, 97,\n102, 103, 108, 114, 169\nObject.create function, 96, 101, 201\nObject.keys function, 60, 78, 377, 386\nObject.prototype, 101\nobstacle, 263, 264\noffsetHeight property, 222, 223\noffsetWidth property, 222\non method, 346\nonclick attribute, 211, 234\nonclick property, 322\nOpenGL, 274\nopening tag, 209\noperator, 12, 15, 19, 194, 201\napplication, 12\noptimization, 47, 52, 223, 247, 252,\n261, 292, 295, 344\noption (HTML tag), 304, 310, 395\noptional, 142\noptional argument, 45, 76\noptional chaining, 74\noptions property, 310\nordering, 207\nordinal package, 166, 167\norganic growth, 161\norganization, 161\noutline, 275\noutput, 15, 24, 25, 128, 201, 338, 391\noverflow, 11\noverflow (CSS), 261\noverlap, 264\noverlay, 226\noverriding, 100, 102, 108, 383\noverwriting, 351, 354, 363\np (HTML tag), 209, 222\npackage, 164, 166, 342\npackage (reserved word), 24\npackage manager, 164",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_943",
    "text": "overflow (CSS), 261\noverlap, 264\noverlay, 226\noverriding, 100, 102, 108, 383\noverwriting, 351, 354, 363\np (HTML tag), 209, 222\npackage, 164, 166, 342\npackage (reserved word), 24\npackage manager, 164\npackage.json, 342\npadding (CSS), 260\npage reload, 245, 307, 313\npageX property, 239, 242\npageXOffset property, 223\npageY property, 239, 242\npageYOffset property, 223, 243\nPalef, Thomas, 251\npanning, 324\nparagraph, 209\nparallelism, 174, 298\nparameter, 25, 38, 39, 42, 44, 45, 71,\n73, 94, 125, 167\nparent node, 235\nparentheses, 12\narguments, 25, 38, 42, 43, 81,\n193\nexpression, 21\nin regular expressions, 143, 145,\n146, 156, 381\nstatement, 27, 29, 31\nparentNode property, 217\nparse function, 197\nparseApply function, 196\nparseExpression function, 195\nparseINI function, 156, 164\nparser generator, 204\nparsing, 75, 123, 156, 193\u2013195, 197,\n198, 201, 210, 214, 348, 364\npassword, 302\npassword field, 303\npath\ncanvas, 279\ncanvas, 276, 277, 389\n413\nclosing, 277\nfilesystem, 340, 347",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_944",
    "text": "parser generator, 204\nparsing, 75, 123, 156, 193\u2013195, 197,\n198, 201, 210, 214, 348, 364\npassword, 302\npassword field, 303\npath\ncanvas, 279\ncanvas, 276, 277, 389\n413\nclosing, 277\nfilesystem, 340, 347\nURL, 297, 300, 347, 348, 357,\n359\npathfinding, 119, 170, 329\npatience, 337\npattern, 138\u2013140, 152\npausing (exercise), 271, 388\npea soup, 80\npeanuts, 67\npercent sign, 299\npercentage, 91, 243\nperformance, 148, 168, 174, 192, 203,\n223, 252, 292, 344\nperiod character, 25, 57, 71, 74, 140,\n151, 160, 321\npersistence, 312, 355, 372, 395\npersistent data structure, 114, 116,\n122, 127, 320, 328, 333, 389\npersistent group (exercise), 122\npersistent map (exercise), 380\nPGroup class, 122, 380\nphase, 257, 267\nphi coe\ufb00icient, 63, 64\nphi function, 64, 73\nphone, 238\nphysics, 263, 268, 388\nphysics engine, 264\npi, 12, 72, 229, 258, 279\nPI constant, 72, 229\npick function, 329\npicture, 273, 283, 292, 318, 333\nPicture class, 320, 331\npicture property, 320\nPictureCanvas class, 322, 336",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_945",
    "text": "physics engine, 264\npi, 12, 72, 229, 258, 279\nPI constant, 72, 229\npick function, 329\npicture, 273, 283, 292, 318, 333\nPicture class, 320, 331\npicture property, 320\nPictureCanvas class, 322, 336\npictureFromImage function, 331\npie chart example, 280, 281, 294, 390\npink, 321\npipe, 207\npipe character, 146, 381\npipe method, 348, 351\npipeline, 168\npixel, 223, 230, 239, 252, 259, 273\u2013\n275, 282, 283, 288, 293, 295,\n318, 320, 324, 327, 328, 332,\n337, 393\npixel art, 282\nPixelEditor class, 325, 334, 336\npizza, 63, 64\nplatform game, 251, 271\nPlauger, P.J., 123\nplayer, 251, 253, 261, 264, 267, 270,\n282, 290, 292\nPlayer class, 256, 267\nplus character, 12, 142, 160\nPoignant Guide, 21\npointer, 217\npointer event, 236, 322\npointerPosition function, 323\npolling, 233\npollTalks function, 370\npolymorphism, 102\npop method, 58, 68\nPopper, Karl, 221\nport, 207, 296, 345\npose, 282\nposition, 223\nposition (CSS), 228, 232, 243, 252,\n261\nPOST method, 298, 299, 307, 358\npostMessage method, 246\npower example, 47",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_946",
    "text": "pop method, 58, 68\nPopper, Karl, 221\nport, 207, 296, 345\npose, 282\nposition, 223\nposition (CSS), 228, 232, 243, 252,\n261\nPOST method, 298, 299, 307, 358\npostMessage method, 246\npower example, 47\nprecedence, 12, 17, 226, 227\npredicate function, 84, 88, 91, 92\nPrefer header, 358, 365, 370\npremature optimization, 48\npreventDefault method, 237, 242, 243,\n245, 268, 307, 324, 392\npreviousSibling property, 217\nprimitiveMultiply (exercise), 136, 381\n414\nprivacy, 212\nprivate (reserved word), 24\nprivate property, 137\nprocess object, 339, 349\nprocessor, 173\nprofiling, 47\nprogram, 21, 26\nnature of, 2\nprogram size, 79, 159\nprogramming, 1\ndi\ufb00iculty of, 2\nhistory of, 3\njoy of, 1, 2\nprogramming language, 1, 3, 193, 216,\n338\npower of, 5\nprogramming style, 2, 22, 30, 34\nprogress bar, 243\nproject chapter, 112, 193, 251, 318,\n355\npromise, 192, 385\nPromise class, 176, 178, 182, 188,\n189, 192, 299, 300, 312, 344,\n347, 371, 384, 385\nPromise.all function, 187, 190, 192,\n384, 385\nPromise.reject function, 178",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_947",
    "text": "355\npromise, 192, 385\nPromise class, 176, 178, 182, 188,\n189, 192, 299, 300, 312, 344,\n347, 371, 384, 385\nPromise.all function, 187, 190, 192,\n384, 385\nPromise.reject function, 178\nPromise.resolve function, 176\npromptDirection function, 134\npromptNumber function, 129\npropagation, see event propagation\nproper lines (exercise), 337, 393\nproperty, 314\naccess, 25, 57, 94, 123, 335\nassignment, 59\ndefinition, 59, 62, 103\ndeletion, 59\ninheritance, 95, 97, 100\nmodel of, 59\nnaming, 101, 105, 106\nprivate, 99\npublic, 99\ntesting for, 60\nprotected (reserved word), 24\nprotocol, 206\u2013208, 296, 297\nprototype, 95\u201397, 100, 101, 108, 201,\n205, 386\ndiagram, 100\nprototype property, 97, 98\npseudorandom number, 73\npublic, 99\npublic (reserved word), 24\npublic space (exercise), 353, 395\npublishing, 343\npunch card, 3\npure function, 51, 52, 77, 84, 169,\n316, 392\npush method, 58, 66, 68, 379\npushing data, 356\nPUT method, 297, 298, 347, 351,\n357, 363, 395\nPythagoras, 379\nPythagorean theorem, 393",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_948",
    "text": "punch card, 3\npure function, 51, 52, 77, 84, 169,\n316, 392\npush method, 58, 66, 68, 379\npushing data, 356\nPUT method, 297, 298, 347, 351,\n357, 363, 395\nPythagoras, 379\nPythagorean theorem, 393\nquadratic curve, 278\nquadraticCurveTo method, 277, 390\nquery string, 298, 299, 358, 364\nquerySelector method, 228, 387\nquerySelectorAll method, 227, 309\nquestion mark, 17, 142, 151, 298\nqueue, 188\nquiet times (exercise), 191, 383\nquotation mark, 13, 159\nquoting\nin JSON, 75\nof object properties, 59\nquoting style (exercise), 159, 381\nrabbit example, 94, 96, 97\nradian, 229, 279, 284\n415\nradio button, 303, 309\nradius, 337, 393\nraising (exception), 130\nrandom number, 72, 73, 258\nrandom-item package, 382\nrandomPick function, 117\nrandomRobot function, 117\nrange, 84, 139, 142\nrange function, 5, 76, 376\nRange header, 300\nray tracer, 292\nread-eval-print loop, 339\nreadability, 4, 5, 34, 47, 51, 129, 161,\n198, 262, 294\nreadable stream, 346, 348, 363\nreadAsDataURL method, 331\nreadAsText method, 312",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_949",
    "text": "Range header, 300\nray tracer, 292\nread-eval-print loop, 339\nreadability, 4, 5, 34, 47, 51, 129, 161,\n198, 262, 294\nreadable stream, 346, 348, 363\nreadAsDataURL method, 331\nreadAsText method, 312\nreaddir function, 344, 350, 394\nreaddirSync function, 394\nreadFile function, 167, 343, 396\nreadFileSync function, 344, 394\nreading code, 7, 112\nreadTextFile function, 175\nreal promises (exercise), 192, 384\nreal-time, 233\nreasoning, 16\nrecipe analogy, 80\nrecord, 58\nrect (SVG tag), 274\nrectangle, 252, 264, 275, 294, 328\nrectangle function, 328, 393\nrecursion, 44, 47, 48, 53, 78, 182,\n195, 197, 198, 218, 231, 286,\n375, 377, 381, 387\nred, 321\nreduce method, 85\u201387, 91, 325, 378\nReferenceError type, 205\nRegExp class, 138, 152, 394\nregexp golf (exercise), 159\nregular expression, 138\u2013140, 149\u2013151,\n153, 154, 159, 196, 353, 360,\n386, 394\nalternatives, 146\nbacktracking, 147\nboundary, 145\ncreation, 138, 152\nescaping, 138, 152, 381\nflags, 143, 149, 152, 382\nglobal, 149, 153, 154\ngrouping, 143, 149",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_950",
    "text": "153, 154, 159, 196, 353, 360,\n386, 394\nalternatives, 146\nbacktracking, 147\nboundary, 145\ncreation, 138, 152\nescaping, 138, 152, 381\nflags, 143, 149, 152, 382\nglobal, 149, 153, 154\ngrouping, 143, 149\ninternationalization, 140\nmatching, 147, 153\nmethods, 139, 144, 152\nrepetition, 142\nrejecting (a promise), 178, 189, 192,\n385\nrelative path, 211, 340, 347, 395\nrelative positioning, 228, 229\nrelative URL, 300\nremainder operator, 13, 32, 283, 374,\n375, 388, 389\nremote access, 347\nremote procedure call, 301\nremoveChild method, 219\nremoveEventListener method, 234, 389\nremoveItem method, 313\nrename function, 344\nrendering, 274\nrenderTalk function, 368\nrenderTalkForm function, 369\nrenderUserField function, 368\nrepeat method, 70, 243\nrepeating key, 238\nrepetition, 50, 142, 148, 151, 247\nreplace method, 149, 159, 381\nreplaceChild method, 220, 387\nreplaceSelection function, 308\nreportError function, 368\nrequest, 207, 296\u2013298, 307, 345, 352,\n355\n416\nrequest function, 346",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_951",
    "text": "replace method, 149, 159, 381\nreplaceChild method, 220, 387\nreplaceSelection function, 308\nreportError function, 368\nrequest, 207, 296\u2013298, 307, 345, 352,\n355\n416\nrequest function, 346\nrequestAnimationFrame function, 229,\n245, 246, 269, 295, 388\nrequire function, 166, 167, 172, 340,\n341\nreserved word, 24\nresolution, 163, 340\nresolve function, 349\nresolving (a promise), 176, 178, 189\nresource, 207, 208, 297, 298, 302,\n347, 362\nresponse, 296\u2013298, 301, 345, 348, 351\nResponse class, 300\nresponsiveness, 233, 338\nrest parameter, 71\nrestore method, 286, 287\nresult property, 312\nreturn keyword, 39, 44, 183, 375, 378\nreturn value, 25, 39, 129, 378\nreuse, 52, 109, 161, 164, 341\nreverse method, 77\nreversing (exercise), 77, 376\nrgb (CSS), 260\nright-aligning, 231\nrmdir function, 350, 353\nroadGraph object, 113\nroads array, 112\nroads module (exercise), 172, 383\nrobot, 112, 114, 116, 118, 119, 121,\n171\nrobot e\ufb00iciency (exercise), 121, 380\nrobustness, 357\nroot, 215\nrotate method, 284, 287",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_952",
    "text": "roadGraph object, 113\nroads array, 112\nroads module (exercise), 172, 383\nrobot, 112, 114, 116, 118, 119, 121,\n171\nrobot e\ufb00iciency (exercise), 121, 380\nrobustness, 357\nroot, 215\nrotate method, 284, 287\nrotation, 294, 389\nrounding, 73, 128, 265, 289, 394\nroundTo example, 38, 45\nrouter, 356, 359\nRouter class, 360\nrouteRobot function, 119\nrow, 231\nrule (CSS), 226\nrun function, 201\nrun-time error, 126\u2013128, 135, 386\nrunAnimation function, 269, 271\nrunGame function, 270, 271\nrunLevel function, 270, 271\nrunning code, 7\nrunRobot function, 116, 380\nSafari, 213\nsandbox, 7, 55, 212, 214, 301\nsave method, 286, 287\nSaveButton class, 330\nscale constant, 322\nscale method, 283, 285\nscaling, 259, 282, 283, 290, 391\nscheduling, 188, 385\nscientific notation, 12, 160\nscope, 39\u201341, 45, 167, 198, 200, 201,\n204, 205, 386\nscript (HTML tag), 211, 245\nSCRIPTS dataset, 83, 86, 88, 90, 92\nscroll event, 243, 247\nscrolling, 237, 243, 261, 262, 268,\n288\nsearch method, 152\nsearch problem, 119, 147, 148, 218,\n353",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_953",
    "text": "204, 205, 386\nscript (HTML tag), 211, 245\nSCRIPTS dataset, 83, 86, 88, 90, 92\nscroll event, 243, 247\nscrolling, 237, 243, 261, 262, 268,\n288\nsearch method, 152\nsearch problem, 119, 147, 148, 218,\n353\nsearch tool (exercise), 353, 394\nsection, 155\nSecure HTTP, see HTTPS\nsecurity, 167, 212, 301, 302, 311, 313,\n349, 359\nsecurity camera, 191\nselect (HTML tag), 304, 310, 313,\n318, 325, 326, 395\nselected attribute, 310\nselection, 307\nselectionEnd property, 307\n417\nselectionStart property, 307\nselector, 227\nself-closing tag, 209\nsemantic versioning, 342\nsemicolon, 21, 22, 31, 225\nsep binding, 349\nsequence, 142\nserialization, 75\nserve-static package, 361\nserver, 207, 208, 296, 297, 300, 301,\n338, 344\u2013347, 355, 359\nsession, 314\nsessionStorage object, 314\nset, 139, 140, 215\nset (data structure), 111, 122\nSet class, 111, 122, 380\nset method, 102\nsetAttribute method, 222, 322\nsetInterval function, 247, 283\nsetItem method, 313\nsetter, 104\nsetTimeout function, 175, 188, 246,\n247, 365, 371",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_954",
    "text": "Set class, 111, 122, 380\nset method, 102\nsetAttribute method, 222, 322\nsetInterval function, 247, 283\nsetItem method, 313\nsetter, 104\nsetTimeout function, 175, 188, 246,\n247, 365, 371\nshape, 273, 276, 277, 279, 282, 294\nshapes (exercise), 294, 389\nshared property, 96, 100\nshift key, 238, 392\nshift method, 68\nshiftKey property, 238\nshort-circuit evaluation, 20, 49, 199,\n378\nSICP, 193\nside effect, 22, 25, 32, 39, 52, 61, 77,\n84, 153, 169, 190, 217, 219,\n220, 223, 276, 286, 299, 319,\n320\nsign, 11, 160, 381\nsign bit, 11\nsignal, 10\nsimplicity, 203\nsimulation, 114, 116, 251, 256, 316,\n388\nsine, 72, 229, 258, 267\nsingle-quote character, 13, 159, 211\nsingleton, 122\nskill, 318\nskill-sharing, 355\nskill-sharing project, 355, 357, 359,\n366\nSkillShareApp class, 371\nskipSpace function, 196, 205\nslash character, 12, 34, 138, 151, 300,\n349\nslice method, 68, 69, 84, 220, 376,\n385\nslope, 394\nsloppy programming, 247\nsmooth animation, 229\nSMTP, 207\nsocial factors, 335\nsocket, 356\nsome method, 88, 92",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_955",
    "text": "349\nslice method, 68, 69, 84, 220, 376,\n385\nslope, 394\nsloppy programming, 247\nsmooth animation, 229\nSMTP, 207\nsocial factors, 335\nsocket, 356\nsome method, 88, 92\nsorting, 215\nsource property, 153\nspecial form, 193, 198, 199\nspecial return value, 129\nspecialForms object, 199\nspecificity, 227\nspeed, 1, 2, 295, 391\nspiral, 294, 390\nsplit method, 70, 113, 254, 383\nspread, 71, 108, 314, 321\nspread operator, 260\nsprite, 282, 283, 290\nspy, 243\nsquare, 26\nsquare bracket, 106\nsquare brackets, 56, 57, 74, 140, 309,\n314, 376\nsquare example, 38, 42\n418\nsquare root, 64, 72, 379\nsrc attribute, 209, 211\nstack, see call stack, 58\nstack overflow, 44, 47, 54, 375\nstack trace, 131\nstandard, 6, 24, 34, 84, 131, 140,\n335, 338, 340\nstandard environment, 24\nstandard output, 339\nstandards, 206, 213\nstar, 294, 390\nStar Trek, 278\nstartPixelEditor function, 334\nstartState constant, 334\nstartsWith method, 348\nstat function, 344, 349, 350, 394\nstate, 31, 114\nin\nbinding, 22, 29, 32\niterator, 184\nobjects, 114, 254",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_956",
    "text": "Star Trek, 278\nstartPixelEditor function, 334\nstartState constant, 334\nstartsWith method, 348\nstat function, 344, 349, 350, 394\nstate, 31, 114\nin\nbinding, 22, 29, 32\niterator, 184\nobjects, 114, 254\nin objects, 287\nof application, 261, 318, 322, 333,\n372\nof canvas, 275, 286\npersistence, 328\ntransitions, 189, 319, 321\nstatement, 21, 22, 26, 29, 31, 38, 59\nstatic (reserved word), 24\nstatic file, 357, 361\nstatic method, 104, 111, 254\nstatic property, 104, 380\nStats type, 350\nstatSync function, 394\nstatus code, 297, 339\nstatus property, 300, 367\nstoicism, 233\nstopPropagation method, 235\nstream, 207, 345, 346, 348, 351\nstrict mode, 124\nstring, 13, 56, 57, 61, 88\nindexing, 54, 69, 70, 89, 143\nlength, 36, 89\nmethods, 69, 143\nnotation, 13\nproperties, 69\nrepresentation, 14\nsearching, 69\nString function, 26, 102\nstroke method, 276\u2013278\nstrokeRect method, 275, 390\nstrokeStyle property, 275\nstrokeText method, 281\nstroking, 275, 281, 293\nstrong (HTML tag), 222, 224\nstructure, 164, 209, 214, 319",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_957",
    "text": "stroke method, 276\u2013278\nstrokeRect method, 275, 390\nstrokeStyle property, 275\nstrokeText method, 281\nstroking, 275, 281, 293\nstrong (HTML tag), 222, 224\nstructure, 164, 209, 214, 319\nstructure sharing, 77\nstyle, 224\nstyle (HTML tag), 226\nstyle attribute, 224\u2013226, 258\nstyle sheet, see CSS\nsubclass, 109\nsubmit, 303, 306\nsubmit event, 307, 369, 395\nsubstitution, 52\nsubtraction, 12, 111\nsum function, 5, 76\nsumming (exercise), 76, 376\nsumming example, 4, 79, 85, 201\nsuperclass, 109\nsurvey, 280\nSussman, Gerald, 193\nSVG, 273, 275, 292, 293\nswapping bindings, 394\nswipe, 328\nswitch keyword, 33\nsymbol, 105\nSymbol function, 105\nSymbol.iterator symbol, 106\nsynchronization, 371, 396\n419\nsynchronous programming, 173, 182,\n344, 353\nsyncState method, 320, 323, 325\u2013327,\n336, 396\nsyntax\nerror, 24, 123, 124\nexpression, 21\nfunction, 38, 42\nidentifier, 24\nnumber, 11, 160\nobject, 59\nof Egg, 193, 194\noperator, 12\nstatement, 21, 22, 27, 29, 31, 33,\n130\nstring, 13\nsyntax tree, 194, 195, 197, 215",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_958",
    "text": "expression, 21\nfunction, 38, 42\nidentifier, 24\nnumber, 11, 160\nobject, 59\nof Egg, 193, 194\noperator, 12\nstatement, 21, 22, 27, 29, 31, 33,\n130\nstring, 13\nsyntax tree, 194, 195, 197, 215\nSyntaxError type, 196\ntab character, 14, 30\ntab key, 305\ntabbed interface (exercise), 249, 388\ntabindex attribute, 238, 305, 336\ntable, 64, 65, 260\ntable (HTML tag), 230, 252, 260,\n392\ntable example, 386\ntableFor function, 65\ntag, 208, 209, 214, 226\ntalk, 355, 362\u2013364\ntalkResponse method, 364\ntalksAbout function, 218\ntalkURL function, 368\nTamil, 83\ntampering, 302\ntangent, 72\ntarget property, 236\ntask management example, 68\nTCP, 207, 296, 357\ntd (HTML tag), 231, 260\ntemperature example, 104\ntemplate, 166, 372, 396\ntemplate literals, 14\ntemplating language, 369\ntentacle (analogy), 23, 59, 62\nterminal, 339\nternary operator, 17, 20, 199\ntest method, 139\ntest runners, 127\ntest suite, 126\ntest suites, 127\ntesting, 121, 126\ntext, 13, 208, 209, 214, 216, 281,\n292\u2013294, 307, 310, 343, 391",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_959",
    "text": "terminal, 339\nternary operator, 17, 20, 199\ntest method, 139\ntest runners, 127\ntest suite, 126\ntest suites, 127\ntesting, 121, 126\ntext, 13, 208, 209, 214, 216, 281,\n292\u2013294, 307, 310, 343, 391\ntext field, 244, 303, 304, 307, 308\ntext method, 300\ntext node, 216, 218, 220, 388\ntext wrapping, 292\ntext-align (CSS), 231\nTEXT_NODE code, 216, 388\ntextAlign property, 281, 390\ntextarea (HTML tag), 247, 304, 307,\n313, 316, 395\ntextBaseline property, 281, 390\ntextContent property, 387, 391\ntextFile function, 176, 179, 191, 383,\n384\ntextScripts function, 90, 378\nth (HTML tag), 231\nthen method, 176\u2013179, 384, 385\ntheory, 128\nthis binding, 58, 94, 95, 97, 124\nthread, 174, 188, 245, 246\nthrow keyword, 130, 131, 135, 136,\n381\ntile, 290\ntime, 140, 142, 144, 229, 248, 263,\n264, 267, 269, 290, 333\ntime zone, 145\ntimeline, 174, 188, 211, 229, 233, 245\n420\ntimeout, 246, 357, 358, 365\ntimes method, 256\ntimestamp, 145, 191\ntitle, 366\ntitle (HTML tag), 209, 210\ntoDataURL method, 330\ntoLowerCase method, 58, 231",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_960",
    "text": "timeline, 174, 188, 211, 229, 233, 245\n420\ntimeout, 246, 357, 358, 365\ntimes method, 256\ntimestamp, 145, 191\ntitle, 366\ntitle (HTML tag), 209, 210\ntoDataURL method, 330\ntoLowerCase method, 58, 231\ntool, 138, 158, 168, 318, 325\u2013329,\n334, 337, 342\ntool property, 320\nToolSelect class, 326\ntop (CSS), 228\u2013230, 232\ntop-level scope, see global scope\ntoString method, 95, 100\u2013102, 332,\n347\ntouch, 241, 318\ntouchend event, 241\ntouches method, 264\ntouches property, 242, 324\ntouchmove event, 241, 324, 337\ntouchstart event, 241, 322, 324\ntoUpperCase method, 58, 126, 231,\n346\ntr (HTML tag), 231, 260\ntrackKeys function, 268, 271\ntransform (CSS), 273\ntransformation, 283\u2013286, 295, 389\ntranslate method, 284, 285\nTransmission Control Protocol, see\nTCP\ntransparency, 332\ntransparent, 274, 283\ntranspilation, 203\ntrapezoid, 294, 389\ntraversal, 147\ntree, 194, 215, 216\ntrial and error, 128, 279\ntriangle (exercise), 36, 374\ntrigonometry, 72, 229\ntrim method, 70, 254\ntrue, 15\ntrust, 212",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_961",
    "text": "transpilation, 203\ntrapezoid, 294, 389\ntraversal, 147\ntree, 194, 215, 216\ntrial and error, 128, 279\ntriangle (exercise), 36, 374\ntrigonometry, 72, 229\ntrim method, 70, 254\ntrue, 15\ntrust, 212\ntry keyword, 131, 132, 381, 391\ntype, 10, 15, 93, 109\ntype attribute, 303, 306\ntype checking, 126, 168\ntype coercion, 18, 19, 26\ntype property, 194, 235\ntype variable, 126\ntypeof operator, 15, 78, 377\nTypeScript, 126\ntyping, 247\ntypo, 123\nunary operator, 15, 21\nuncaught exception, 133, 180\nundefined, 17\u201319, 23, 39, 44, 57, 59,\n74, 123, 124, 129\nunderline, 224\nunderscore character, 24, 34, 145, 152\nundo history, 333\nUndoButton class, 333\nUnicode, 14, 16, 83, 88, 139\u2013141\nproperty, 141\nunicycling, 355\nuniform resource locator, see URL\nuniformity, 194\nuniqueness, 226\nunit (CSS), 230, 243\nUnix, 350, 352, 353\nUnix time, 145\nunlink function, 344, 350\nunshift method, 68\nunwinding the stack, 130\nupcasing server example, 346\nupdated method, 363, 365, 395\nupdateState function, 321\nupgrading, 164\nupload, 311",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_962",
    "text": "Unix time, 145\nunlink function, 344, 350\nunshift method, 68\nunwinding the stack, 130\nupcasing server example, 346\nupdated method, 363, 365, 395\nupdateState function, 321\nupgrading, 164\nupload, 311\n421\nURL, 208, 211, 274, 298, 300, 302,\n345, 357, 368\nURL class, 348\nURL encoding, 299\nurl package, 364\nurlPath function, 348\nusability, 237\nuse strict, see strict mode\nuser experience, 233, 306, 356, 368\nuser interface, 133, 319\nUTF16, 14, 88\nUTF8, 343, 344\nvalidation, 128, 129, 135, 193, 263,\n307, 363\nvalue, 10\nvalue attribute, 303, 307, 310\nvar keyword, 23, 39, 74\nvariable, see binding\nVec class, 111, 254, 255, 267, 391\nvector (exercise), 111, 379\nvector graphics, 282\nverbosity, 43, 174\nversion, 164, 209, 297, 342\nviewport, 261, 263, 287, 288, 292\nVillageState class, 114\nvirtual keyboard, 238\nvirtual world, 112, 114, 116\nvirus, 212\nvocabulary, 38, 79, 80\nvoid operator, 24\nvolatile data storage, 10\nwaitForChanges method, 365\nwaiting, 175\nwalking, 290\nwave, 258, 267\nWeb, see World Wide Web",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_963",
    "text": "virtual world, 112, 114, 116\nvirus, 212\nvocabulary, 38, 79, 80\nvoid operator, 24\nvolatile data storage, 10\nwaitForChanges method, 365\nwaiting, 175\nwalking, 290\nwave, 258, 267\nWeb, see World Wide Web\nweb application, 5, 312, 318\nweb browser, see browser\nweb page, 168\nweb worker, 245\nWebDAV, 353\nwebgl (canvas context), 274\nwebsite, 212, 298, 338, 353, 355\nWebSockets, 356\nweekDay module, 162\nweekend project, 354\nweresquirrel example, 55, 58, 60, 62,\n66, 67\nwhile loop, 5, 29, 31, 50\nwhitespace, 205\nin HTML, 218, 325, 388\nin URLs, 358\nindentation, 30\nmatching, 140, 141\nsyntax, 34, 193, 196, 386\ntrimming, 70, 254\nwhy, 21\nwidth property, 336, 393\nwindow, 235, 241, 244\nwindow object, 233, 234\nwith statement, 125\nwizard (mighty), 3\nword boundary, 146\nword character, 140, 141, 146\nwork list, 120, 329\nworkbench (exercise), 316, 391\nworld, 251\nWorld Wide Web, 5, 75, 206, 208,\n212, 296\nwritable stream, 345, 346, 348\nwrite method, 345, 346\nwriteFile function, 343, 346, 395\nwriteHead method, 345",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  },
  {
    "id": "Eloquent_JavaScript_964",
    "text": "workbench (exercise), 316, 391\nworld, 251\nWorld Wide Web, 5, 75, 206, 208,\n212, 296\nwritable stream, 345, 346, 348\nwrite method, 345, 346\nwriteFile function, 343, 346, 395\nwriteHead method, 345\nwriting code, 7, 112\nwriting system, 83\nWWW, see World Wide Web\nXML, 216, 274\n422\nXML namespace, 274\nxmlns attribute, 274\nyield (reserved word), 24\nyield keyword, 184\nyour own loop (example), 91\nYuan-Ma, 10, 161, 338\nZawinski, Jamie, 138\nzero-based counting, 54, 56, 145\nzeroPad function, 51\nzigzag, 389\nzooming, 292\n423",
    "metadata": {
      "source": "Eloquent_JavaScript"
    }
  }
]