[
  {
    "id": "thinkpython2_0",
    "text": "Think Python\nHow to Think Like a Computer Scientist\n2nd Edition, Version 2.4.0\nThink Python\nHow to Think Like a Computer Scientist\n2nd Edition, Version 2.4.0\nAllen Downey\nGreen Tea Press\nNeedham, Massachusetts\nCopyright \u00a9 2015 Allen Downey.\nGreen Tea Press\n9 Washburn Ave\nNeedham MA 02492\nPermission is granted to copy, distribute, and/or modify this document under the terms of the\nCreative Commons Attribution-NonCommercial 3.0 Unported License, which is available at http:\n//creativecommons.org/licenses/by-nc/3.0/.\nThe original form of this book is LATEX source code. Compiling this LATEX source has the effect of gen-\nerating a device-independent representation of a textbook, which can be converted to other formats\nand printed.\nThe LATEX source for this book is available from http://www.thinkpython.com\nPreface\nThe strange history of this book\nIn January 1999 I was preparing to teach an introductory programming class in Java. I had",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_1",
    "text": "Preface\nThe strange history of this book\nIn January 1999 I was preparing to teach an introductory programming class in Java. I had\ntaught it three times and I was getting frustrated. The failure rate in the class was too high\nand, even for students who succeeded, the overall level of achievement was too low.\nOne of the problems I saw was the books. They were too big, with too much unnecessary\ndetail about Java, and not enough high-level guidance about how to program. And they all\nsuffered from the trap door effect: they would start out easy, proceed gradually, and then\nsomewhere around Chapter 5 the bottom would fall out. The students would get too much\nnew material, too fast, and I would spend the rest of the semester picking up the pieces.\nTwo weeks before the \ufb01rst day of classes, I decided to write my own book. My goals were:\n\u2022 Keep it short. It is better for students to read 10 pages than not read 50 pages.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_2",
    "text": "Two weeks before the \ufb01rst day of classes, I decided to write my own book. My goals were:\n\u2022 Keep it short. It is better for students to read 10 pages than not read 50 pages.\n\u2022 Be careful with vocabulary. I tried to minimize jargon and de\ufb01ne each term at \ufb01rst\nuse.\n\u2022 Build gradually. To avoid trap doors, I took the most dif\ufb01cult topics and split them\ninto a series of small steps.\n\u2022 Focus on programming, not the programming language. I included the minimum\nuseful subset of Java and left out the rest.\nI needed a title, so on a whim I chose How to Think Like a Computer Scientist.\nMy \ufb01rst version was rough, but it worked. Students did the reading, and they understood\nenough that I could spend class time on the hard topics, the interesting topics and (most\nimportant) letting the students practice.\nI released the book under the GNU Free Documentation License, which allows users to\ncopy, modify, and distribute the book.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_3",
    "text": "important) letting the students practice.\nI released the book under the GNU Free Documentation License, which allows users to\ncopy, modify, and distribute the book.\nWhat happened next is the cool part. Jeff Elkner, a high school teacher in Virginia, adopted\nmy book and translated it into Python. He sent me a copy of his translation, and I had the\nunusual experience of learning Python by reading my own book. As Green Tea Press, I\npublished the \ufb01rst Python version in 2001.\nIn 2003 I started teaching at Olin College and I got to teach Python for the \ufb01rst time. The\ncontrast with Java was striking. Students struggled less, learned more, worked on more\ninteresting projects, and generally had a lot more fun.\nvi\nChapter 0. Preface\nSince then I\u2019ve continued to develop the book, correcting errors, improving some of the\nexamples and adding material, especially exercises.\nThe result is this book, now with the less grandiose title Think Python. Some of the changes\nare:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_4",
    "text": "examples and adding material, especially exercises.\nThe result is this book, now with the less grandiose title Think Python. Some of the changes\nare:\n\u2022 I added a section about debugging at the end of each chapter. These sections present\ngeneral techniques for \ufb01nding and avoiding bugs, and warnings about Python pit-\nfalls.\n\u2022 I added more exercises, ranging from short tests of understanding to a few substantial\nprojects. Most exercises include a link to my solution.\n\u2022 I added a series of case studies\u2014longer examples with exercises, solutions, and dis-\ncussion.\n\u2022 I expanded the discussion of program development plans and basic design patterns.\n\u2022 I added appendices about debugging and analysis of algorithms.\nThe second edition of Think Python has these new features:\n\u2022 The book and all supporting code have been updated to Python 3.\n\u2022 I added a few sections, and more details on the web, to help beginners get started",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_5",
    "text": "\u2022 The book and all supporting code have been updated to Python 3.\n\u2022 I added a few sections, and more details on the web, to help beginners get started\nrunning Python in a browser, so you don\u2019t have to deal with installing Python until\nyou want to.\n\u2022 For Chapter 4.1 I switched from my own turtle graphics package, called Swampy, to a\nmore standard Python module, turtle, which is easier to install and more powerful.\n\u2022 I added a new chapter called \u201cThe Goodies\u201d, which introduces some additional\nPython features that are not strictly necessary, but sometimes handy.\nI hope you enjoy working with this book, and that it helps you learn to program and think\nlike a computer scientist, at least a little bit.\nAllen B. Downey\nOlin College\nAcknowledgments\nMany thanks to Jeff Elkner, who translated my Java book into Python, which got this\nproject started and introduced me to what has turned out to be my favorite language.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_6",
    "text": "Olin College\nAcknowledgments\nMany thanks to Jeff Elkner, who translated my Java book into Python, which got this\nproject started and introduced me to what has turned out to be my favorite language.\nThanks also to Chris Meyers, who contributed several sections to How to Think Like a Com-\nputer Scientist.\nThanks to the Free Software Foundation for developing the GNU Free Documentation Li-\ncense, which helped make my collaboration with Jeff and Chris possible, and Creative\nCommons for the license I am using now.\nvii\nThanks to the editors at Lulu who worked on How to Think Like a Computer Scientist.\nThanks to the editors at O\u2019Reilly Media who worked on Think Python.\nThanks to all the students who worked with earlier versions of this book and all the con-\ntributors (listed below) who sent in corrections and suggestions.\nContributor List\nMore than 100 sharp-eyed and thoughtful readers have sent in suggestions and corrections",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_7",
    "text": "tributors (listed below) who sent in corrections and suggestions.\nContributor List\nMore than 100 sharp-eyed and thoughtful readers have sent in suggestions and corrections\nover the past few years. Their contributions, and enthusiasm for this project, have been a\nhuge help.\nIf you have a suggestion or correction, please send email to feedback@thinkpython.com.\nIf I make a change based on your feedback, I will add you to the contributor list (unless\nyou ask to be omitted).\nIf you include at least part of the sentence the error appears in, that makes it easy for me to\nsearch. Page and section numbers are \ufb01ne, too, but not quite as easy to work with. Thanks!\n\u2022 Lloyd Hugh Allen sent in a correction to Section 8.4.\n\u2022 Yvon Boulianne sent in a correction of a semantic error in Chapter 5.\n\u2022 Fred Bremmer submitted a correction in Section 2.1.\n\u2022 Jonah Cohen wrote the Perl scripts to convert the LaTeX source for this book into beautiful\nHTML.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_8",
    "text": "\u2022 Fred Bremmer submitted a correction in Section 2.1.\n\u2022 Jonah Cohen wrote the Perl scripts to convert the LaTeX source for this book into beautiful\nHTML.\n\u2022 Michael Conlon sent in a grammar correction in Chapter 2 and an improvement in style in\nChapter 1, and he initiated discussion on the technical aspects of interpreters.\n\u2022 Beno\u00eet Girard sent in a correction to a humorous mistake in Section 5.6.\n\u2022 Courtney Gleason and Katherine Smith wrote horsebet.py, which was used as a case study\nin an earlier version of the book. Their program can now be found on the website.\n\u2022 Lee Harr submitted more corrections than we have room to list here, and indeed he should be\nlisted as one of the principal editors of the text.\n\u2022 James Kaylin is a student using the text. He has submitted numerous corrections.\n\u2022 David Kershaw \ufb01xed the broken catTwice function in Section 3.10.\n\u2022 Eddie Lam has sent in numerous corrections to Chapters 1, 2, and 3. He also \ufb01xed the Make\ufb01le",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_9",
    "text": "\u2022 David Kershaw \ufb01xed the broken catTwice function in Section 3.10.\n\u2022 Eddie Lam has sent in numerous corrections to Chapters 1, 2, and 3. He also \ufb01xed the Make\ufb01le\nso that it creates an index the \ufb01rst time it is run and helped us set up a versioning scheme.\n\u2022 Man-Yong Lee sent in a correction to the example code in Section 2.4.\n\u2022 David Mayo pointed out that the word \u201cunconsciously\" in Chapter 1 needed to be changed to\n\u201csubconsciously\".\n\u2022 Chris McAloon sent in several corrections to Sections 3.9 and 3.10.\n\u2022 Matthew J. Moelter has been a long-time contributor who sent in numerous corrections and\nsuggestions to the book.\nviii\nChapter 0. Preface\n\u2022 Simon Dicon Montford reported a missing function de\ufb01nition and several typos in Chapter 3.\nHe also found errors in the increment function in Chapter 13.\n\u2022 John Ouzts corrected the de\ufb01nition of \u201creturn value\" in Chapter 3.\n\u2022 Kevin Parks sent in valuable comments and suggestions as to how to improve the distribution\nof the book.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_10",
    "text": "\u2022 John Ouzts corrected the de\ufb01nition of \u201creturn value\" in Chapter 3.\n\u2022 Kevin Parks sent in valuable comments and suggestions as to how to improve the distribution\nof the book.\n\u2022 David Pool sent in a typo in the glossary of Chapter 1, as well as kind words of encouragement.\n\u2022 Michael Schmitt sent in a correction to the chapter on \ufb01les and exceptions.\n\u2022 Robin Shaw pointed out an error in Section 13.1, where the printTime function was used in an\nexample without being de\ufb01ned.\n\u2022 Paul Sleigh found an error in Chapter 7 and a bug in Jonah Cohen\u2019s Perl script that generates\nHTML from LaTeX.\n\u2022 Craig T. Snydal is testing the text in a course at Drew University. He has contributed several\nvaluable suggestions and corrections.\n\u2022 Ian Thomas and his students are using the text in a programming course. They are the \ufb01rst ones\nto test the chapters in the latter half of the book, and they have made numerous corrections and\nsuggestions.\n\u2022 Keith Verheyden sent in a correction in Chapter 3.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_11",
    "text": "to test the chapters in the latter half of the book, and they have made numerous corrections and\nsuggestions.\n\u2022 Keith Verheyden sent in a correction in Chapter 3.\n\u2022 Peter Winstanley let us know about a longstanding error in our Latin in Chapter 3.\n\u2022 Chris Wrobel made corrections to the code in the chapter on \ufb01le I/O and exceptions.\n\u2022 Moshe Zadka has made invaluable contributions to this project. In addition to writing the \ufb01rst\ndraft of the chapter on Dictionaries, he provided continual guidance in the early stages of the\nbook.\n\u2022 Christoph Zwerschke sent several corrections and pedagogic suggestions, and explained the\ndifference between gleich and selbe.\n\u2022 James Mayer sent us a whole slew of spelling and typographical errors, including two in the\ncontributor list.\n\u2022 Hayden McAfee caught a potentially confusing inconsistency between two examples.\n\u2022 Angel Arnal is part of an international team of translators working on the Spanish version of",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_12",
    "text": "contributor list.\n\u2022 Hayden McAfee caught a potentially confusing inconsistency between two examples.\n\u2022 Angel Arnal is part of an international team of translators working on the Spanish version of\nthe text. He has also found several errors in the English version.\n\u2022 Tauhidul Hoque and Lex Berezhny created the illustrations in Chapter 1 and improved many\nof the other illustrations.\n\u2022 Dr. Michele Alzetta caught an error in Chapter 8 and sent some interesting pedagogic com-\nments and suggestions about Fibonacci and Old Maid.\n\u2022 Andy Mitchell caught a typo in Chapter 1 and a broken example in Chapter 2.\n\u2022 Kalin Harvey suggested a clari\ufb01cation in Chapter 7 and caught some typos.\n\u2022 Christopher P. Smith caught several typos and helped us update the book for Python 2.2.\n\u2022 David Hutchins caught a typo in the Foreword.\n\u2022 Gregor Lingl is teaching Python at a high school in Vienna, Austria. He is working on a Ger-\nman translation of the book, and he caught a couple of bad errors in Chapter 5.\nix",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_13",
    "text": "\u2022 Gregor Lingl is teaching Python at a high school in Vienna, Austria. He is working on a Ger-\nman translation of the book, and he caught a couple of bad errors in Chapter 5.\nix\n\u2022 Julie Peters caught a typo in the Preface.\n\u2022 Florin Oprina sent in an improvement in makeTime, a correction in printTime, and a nice typo.\n\u2022 D. J. Webre suggested a clari\ufb01cation in Chapter 3.\n\u2022 Ken found a \ufb01stful of errors in Chapters 8, 9 and 11.\n\u2022 Ivo Wever caught a typo in Chapter 5 and suggested a clari\ufb01cation in Chapter 3.\n\u2022 Curtis Yanko suggested a clari\ufb01cation in Chapter 2.\n\u2022 Ben Logan sent in a number of typos and problems with translating the book into HTML.\n\u2022 Jason Armstrong saw the missing word in Chapter 2.\n\u2022 Louis Cordier noticed a spot in Chapter 16 where the code didn\u2019t match the text.\n\u2022 Brian Cain suggested several clari\ufb01cations in Chapters 2 and 3.\n\u2022 Rob Black sent in a passel of corrections, including some changes for Python 2.2.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_14",
    "text": "\u2022 Brian Cain suggested several clari\ufb01cations in Chapters 2 and 3.\n\u2022 Rob Black sent in a passel of corrections, including some changes for Python 2.2.\n\u2022 Jean-Philippe Rey at \u00c9cole Centrale Paris sent a number of patches, including some updates\nfor Python 2.2 and other thoughtful improvements.\n\u2022 Jason Mader at George Washington University made a number of useful suggestions and cor-\nrections.\n\u2022 Jan Gundtofte-Bruun reminded us that \u201ca error\u201d is an error.\n\u2022 Abel David and Alexis Dinno reminded us that the plural of \u201cmatrix\u201d is \u201cmatrices\u201d, not \u201cma-\ntrixes\u201d. This error was in the book for years, but two readers with the same initials reported it\non the same day. Weird.\n\u2022 Charles Thayer encouraged us to get rid of the semi-colons we had put at the ends of some\nstatements and to clean up our use of \u201cargument\u201d and \u201cparameter\u201d.\n\u2022 Roger Sperberg pointed out a twisted piece of logic in Chapter 3.\n\u2022 Sam Bull pointed out a confusing paragraph in Chapter 2.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_15",
    "text": "statements and to clean up our use of \u201cargument\u201d and \u201cparameter\u201d.\n\u2022 Roger Sperberg pointed out a twisted piece of logic in Chapter 3.\n\u2022 Sam Bull pointed out a confusing paragraph in Chapter 2.\n\u2022 Andrew Cheung pointed out two instances of \u201cuse before def\u201d.\n\u2022 C. Corey Capel spotted the missing word in the Third Theorem of Debugging and a typo in\nChapter 4.\n\u2022 Alessandra helped clear up some Turtle confusion.\n\u2022 Wim Champagne found a brain-o in a dictionary example.\n\u2022 Douglas Wright pointed out a problem with \ufb02oor division in arc.\n\u2022 Jared Spindor found some jetsam at the end of a sentence.\n\u2022 Lin Peiheng sent a number of very helpful suggestions.\n\u2022 Ray Hagtvedt sent in two errors and a not-quite-error.\n\u2022 Torsten H\u00fcbsch pointed out an inconsistency in Swampy.\n\u2022 Inga Petuhhov corrected an example in Chapter 14.\n\u2022 Arne Babenhauserheide sent several helpful corrections.\nx\nChapter 0. Preface\n\u2022 Mark E. Casida is is good at spotting repeated words.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_16",
    "text": "\u2022 Inga Petuhhov corrected an example in Chapter 14.\n\u2022 Arne Babenhauserheide sent several helpful corrections.\nx\nChapter 0. Preface\n\u2022 Mark E. Casida is is good at spotting repeated words.\n\u2022 Scott Tyler \ufb01lled in a that was missing. And then sent in a heap of corrections.\n\u2022 Gordon Shephard sent in several corrections, all in separate emails.\n\u2022 Andrew Turner spotted an error in Chapter 8.\n\u2022 Adam Hobart \ufb01xed a problem with \ufb02oor division in arc.\n\u2022 Daryl Hammond and Sarah Zimmerman pointed out that I served up math.pi too early. And\nZim spotted a typo.\n\u2022 George Sass found a bug in a Debugging section.\n\u2022 Brian Bingham suggested Exercise 11.5.\n\u2022 Leah Engelbert-Fenton pointed out that I used tuple as a variable name, contrary to my own\nadvice. And then found a bunch of typos and a \u201cuse before def\u201d.\n\u2022 Joe Funke spotted a typo.\n\u2022 Chao-chao Chen found an inconsistency in the Fibonacci example.\n\u2022 Jeff Paine knows the difference between space and spam.\n\u2022 Lubos Pintes sent in a typo.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_17",
    "text": "\u2022 Joe Funke spotted a typo.\n\u2022 Chao-chao Chen found an inconsistency in the Fibonacci example.\n\u2022 Jeff Paine knows the difference between space and spam.\n\u2022 Lubos Pintes sent in a typo.\n\u2022 Gregg Lind and Abigail Heithoff suggested Exercise 14.3.\n\u2022 Max Hailperin has sent in a number of corrections and suggestions. Max is one of the authors\nof the extraordinary Concrete Abstractions, which you might want to read when you are done\nwith this book.\n\u2022 Chotipat Pornavalai found an error in an error message.\n\u2022 Stanislaw Antol sent a list of very helpful suggestions.\n\u2022 Eric Pashman sent a number of corrections for Chapters 4\u201311.\n\u2022 Miguel Azevedo found some typos.\n\u2022 Jianhua Liu sent in a long list of corrections.\n\u2022 Nick King found a missing word.\n\u2022 Martin Zuther sent a long list of suggestions.\n\u2022 Adam Zimmerman found an inconsistency in my instance of an \u201cinstance\u201d and several other\nerrors.\n\u2022 Ratnakar Tiwari suggested a footnote explaining degenerate triangles.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_18",
    "text": "\u2022 Adam Zimmerman found an inconsistency in my instance of an \u201cinstance\u201d and several other\nerrors.\n\u2022 Ratnakar Tiwari suggested a footnote explaining degenerate triangles.\n\u2022 Anurag Goel suggested another solution for is_abecedarian and sent some additional correc-\ntions. And he knows how to spell Jane Austen.\n\u2022 Kelli Kratzer spotted one of the typos.\n\u2022 Mark Grif\ufb01ths pointed out a confusing example in Chapter 3.\n\u2022 Roydan Ongie found an error in my Newton\u2019s method.\n\u2022 Patryk Wolowiec helped me with a problem in the HTML version.\nxi\n\u2022 Mark Chonofsky told me about a new keyword in Python 3.\n\u2022 Russell Coleman helped me with my geometry.\n\u2022 Nam Nguyen found a typo and pointed out that I used the Decorator pattern but didn\u2019t men-\ntion it by name.\n\u2022 St\u00e9phane Morin sent in several corrections and suggestions.\n\u2022 Paul Stoop corrected a typo in uses_only.\n\u2022 Eric Bronner pointed out a confusion in the discussion of the order of operations.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_19",
    "text": "\u2022 St\u00e9phane Morin sent in several corrections and suggestions.\n\u2022 Paul Stoop corrected a typo in uses_only.\n\u2022 Eric Bronner pointed out a confusion in the discussion of the order of operations.\n\u2022 Alexandros Gezerlis set a new standard for the number and quality of suggestions he submit-\nted. We are deeply grateful!\n\u2022 Gray Thomas knows his right from his left.\n\u2022 Giovanni Escobar Sosa sent a long list of corrections and suggestions.\n\u2022 Daniel Neilson corrected an error about the order of operations.\n\u2022 Will McGinnis pointed out that polyline was de\ufb01ned differently in two places.\n\u2022 Frank Hecker pointed out an exercise that was under-speci\ufb01ed, and some broken links.\n\u2022 Animesh B helped me clean up a confusing example.\n\u2022 Martin Caspersen found two round-off errors.\n\u2022 Gregor Ulm sent several corrections and suggestions.\n\u2022 Dimitrios Tsirigkas suggested I clarify an exercise.\n\u2022 Carlos Tafur sent a page of corrections and suggestions.\n\u2022 Martin Nordsletten found a bug in an exercise solution.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_20",
    "text": "\u2022 Dimitrios Tsirigkas suggested I clarify an exercise.\n\u2022 Carlos Tafur sent a page of corrections and suggestions.\n\u2022 Martin Nordsletten found a bug in an exercise solution.\n\u2022 Sven Hoexter pointed out that a variable named input shadows a build-in function.\n\u2022 Stephen Gregory pointed out the problem with cmp in Python 3.\n\u2022 Ishwar Bhat corrected my statement of Fermat\u2019s last theorem.\n\u2022 Andrea Zanella translated the book into Italian, and sent a number of corrections along the\nway.\n\u2022 Many, many thanks to Melissa Lewis and Luciano Ramalho for excellent comments and sug-\ngestions on the second edition.\n\u2022 Thanks to Harry Percival from PythonAnywhere for his help getting people started running\nPython in a browser.\n\u2022 Xavier Van Aubel made several useful corrections in the second edition.\n\u2022 William Murray corrected my de\ufb01nition of \ufb02oor division.\n\u2022 Per Starb\u00e4ck brought me up to date on universal newlines in Python 3.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_21",
    "text": "\u2022 William Murray corrected my de\ufb01nition of \ufb02oor division.\n\u2022 Per Starb\u00e4ck brought me up to date on universal newlines in Python 3.\n\u2022 Laurent Rosenfeld and Mihaela Rotaru translated this book into French. Along the way, they\nsent many corrections and suggestions.\nIn addition, people who spotted typos or made corrections include Czeslaw Czapla, Dale Wil-\nson, Francesco Carlo Cimini, Richard Fursa, Brian McGhie, Lokesh Kumar Makani, Matthew\nShultz, Viet Le, Victor Simeone, Lars O.D. Christensen, Swarup Sahoo, Alix Etienne, Kuang\nHe, Wei Huang, Karen Barber, and Eric Ransom.\nxii\nChapter 0. Preface\nContents\nPreface\nv\n1\nThe way of the program\n1\n1.1\nWhat is a program? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1\n1.2\nRunning Python . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n2\n1.3\nThe \ufb01rst program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\n1.4\nArithmetic operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_22",
    "text": "2\n1.3\nThe \ufb01rst program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\n1.4\nArithmetic operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n3\n1.5\nValues and types\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n4\n1.6\nFormal and natural languages . . . . . . . . . . . . . . . . . . . . . . . . . .\n4\n1.7\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6\n1.8\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n6\n1.9\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n2\nVariables, expressions and statements\n9\n2.1\nAssignment statements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n9\n2.2\nVariable names\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n9\n2.3\nExpressions and statements . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10\n2.4\nScript mode",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_23",
    "text": "9\n2.2\nVariable names\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n9\n2.3\nExpressions and statements . . . . . . . . . . . . . . . . . . . . . . . . . . .\n10\n2.4\nScript mode\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n11\n2.5\nOrder of operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n11\n2.6\nString operations\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\n2.7\nComments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n12\n2.8\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n2.9\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\n2.10\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n14\nxiv\nContents\n3\nFunctions\n17\n3.1\nFunction calls\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n17\n3.2",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_24",
    "text": "14\nxiv\nContents\n3\nFunctions\n17\n3.1\nFunction calls\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n17\n3.2\nMath functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n18\n3.3\nComposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.4\nAdding new functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n19\n3.5\nDe\ufb01nitions and uses\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n20\n3.6\nFlow of execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\n3.7\nParameters and arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n21\n3.8\nVariables and parameters are local\n. . . . . . . . . . . . . . . . . . . . . . .\n22\n3.9\nStack diagrams\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n23\n3.10\nFruitful functions and void functions . . . . . . . . . . . . . . . . . . . . . .\n24\n3.11",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_25",
    "text": "22\n3.9\nStack diagrams\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n23\n3.10\nFruitful functions and void functions . . . . . . . . . . . . . . . . . . . . . .\n24\n3.11\nWhy functions? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\n3.12\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n25\n3.13\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n25\n3.14\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n26\n4\nCase study: interface design\n29\n4.1\nThe turtle module . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n29\n4.2\nSimple repetition\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n30\n4.3\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n31\n4.4\nEncapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n32\n4.5",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_26",
    "text": "30\n4.3\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n31\n4.4\nEncapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n32\n4.5\nGeneralization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n32\n4.6\nInterface design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n33\n4.7\nRefactoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n34\n4.8\nA development plan\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n35\n4.9\ndocstring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n35\n4.10\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n36\n4.11\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n36\n4.12\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n37\nContents\nxv\n5\nConditionals and recursion\n39\n5.1",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_27",
    "text": "36\n4.12\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n37\nContents\nxv\n5\nConditionals and recursion\n39\n5.1\nFloor division and modulus . . . . . . . . . . . . . . . . . . . . . . . . . . .\n39\n5.2\nBoolean expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n40\n5.3\nLogical operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n40\n5.4\nConditional execution\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n41\n5.5\nAlternative execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n41\n5.6\nChained conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n41\n5.7\nNested conditionals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n42\n5.8\nRecursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n43\n5.9\nStack diagrams for recursive functions . . . . . . . . . . . . . . . . . . . . .\n44\n5.10\nIn\ufb01nite recursion",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_28",
    "text": "Recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n43\n5.9\nStack diagrams for recursive functions . . . . . . . . . . . . . . . . . . . . .\n44\n5.10\nIn\ufb01nite recursion\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n44\n5.11\nKeyboard input . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n45\n5.12\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n46\n5.13\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n47\n5.14\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n47\n6\nFruitful functions\n51\n6.1\nReturn values\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n51\n6.2\nIncremental development\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n52\n6.3\nComposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n54\n6.4",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_29",
    "text": "51\n6.2\nIncremental development\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n52\n6.3\nComposition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n54\n6.4\nBoolean functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n54\n6.5\nMore recursion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n55\n6.6\nLeap of faith . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n57\n6.7\nOne more example\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n57\n6.8\nChecking types\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n58\n6.9\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n59\n6.10\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n60\n6.11\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n60\nxvi\nContents\n7\nIteration\n63\n7.1\nReassignment",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_30",
    "text": "60\n6.11\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n60\nxvi\nContents\n7\nIteration\n63\n7.1\nReassignment\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n63\n7.2\nUpdating variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n64\n7.3\nThe while statement\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n64\n7.4\nbreak . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n66\n7.5\nSquare roots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n66\n7.6\nAlgorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n67\n7.7\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n68\n7.8\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n68\n7.9\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n69\n8\nStrings\n71\n8.1",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_31",
    "text": "Glossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n68\n7.9\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n69\n8\nStrings\n71\n8.1\nA string is a sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n71\n8.2\nlen\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n72\n8.3\nTraversal with a for loop . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n72\n8.4\nString slices\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n73\n8.5\nStrings are immutable\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n74\n8.6\nSearching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n74\n8.7\nLooping and counting\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n75\n8.8\nString methods\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n75\n8.9",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_32",
    "text": "74\n8.7\nLooping and counting\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n75\n8.8\nString methods\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n75\n8.9\nThe in operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n76\n8.10\nString comparison . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n77\n8.11\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n77\n8.12\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n79\n8.13\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n79\n9\nCase study: word play\n83\n9.1\nReading word lists\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n83\n9.2\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n84\n9.3\nSearch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n85\n9.4",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_33",
    "text": "83\n9.2\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n84\n9.3\nSearch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n85\n9.4\nLooping with indices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n86\n9.5\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n87\n9.6\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n87\n9.7\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n88\nContents\nxvii\n10 Lists\n89\n10.1\nA list is a sequence\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n89\n10.2\nLists are mutable\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n90\n10.3\nTraversing a list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n91\n10.4\nList operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n91\n10.5",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_34",
    "text": "90\n10.3\nTraversing a list . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n91\n10.4\nList operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n91\n10.5\nList slices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n91\n10.6\nList methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n92\n10.7\nMap, \ufb01lter and reduce\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n93\n10.8\nDeleting elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n94\n10.9\nLists and strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n94\n10.10 Objects and values\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n95\n10.11 Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n96\n10.12 List arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n97",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_35",
    "text": "95\n10.11 Aliasing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n96\n10.12 List arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n97\n10.13 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n98\n10.14 Glossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n100\n10.15 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n100\n11 Dictionaries\n103\n11.1\nA dictionary is a mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n103\n11.2\nDictionary as a collection of counters . . . . . . . . . . . . . . . . . . . . . .\n104\n11.3\nLooping and dictionaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n106\n11.4\nReverse lookup\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n106\n11.5\nDictionaries and lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n107\n11.6",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_36",
    "text": "106\n11.4\nReverse lookup\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n106\n11.5\nDictionaries and lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n107\n11.6\nMemos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n109\n11.7\nGlobal variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n110\n11.8\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n111\n11.9\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n112\n11.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n113\nxviii\nContents\n12 Tuples\n115\n12.1\nTuples are immutable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n115\n12.2\nTuple assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n116\n12.3\nTuples as return values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n117\n12.4",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_37",
    "text": "115\n12.2\nTuple assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n116\n12.3\nTuples as return values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n117\n12.4\nVariable-length argument tuples\n. . . . . . . . . . . . . . . . . . . . . . . .\n118\n12.5\nLists and tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n118\n12.6\nDictionaries and tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n120\n12.7\nSequences of sequences . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n121\n12.8\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n122\n12.9\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n122\n12.10 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n123\n13 Case study: data structure selection\n125\n13.1\nWord frequency analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n125\n13.2",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_38",
    "text": "123\n13 Case study: data structure selection\n125\n13.1\nWord frequency analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n125\n13.2\nRandom numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n126\n13.3\nWord histogram . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n127\n13.4\nMost common words . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n128\n13.5\nOptional parameters\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n129\n13.6\nDictionary subtraction\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n129\n13.7\nRandom words\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n130\n13.8\nMarkov analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n130\n13.9\nData structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n132\n13.10 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n133\n13.11 Glossary",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_39",
    "text": "Data structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n132\n13.10 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n133\n13.11 Glossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n134\n13.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n134\n14 Files\n137\n14.1\nPersistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n137\n14.2\nReading and writing\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n137\n14.3\nFormat operator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n138\n14.4\nFilenames and paths\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n139\n14.5\nCatching exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n140\nContents\nxix\n14.6\nDatabases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n141\n14.7",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_40",
    "text": "Catching exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n140\nContents\nxix\n14.6\nDatabases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n141\n14.7\nPickling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n142\n14.8\nPipes\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n142\n14.9\nWriting modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n143\n14.10 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n144\n14.11 Glossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n145\n14.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n145\n15 Classes and objects\n147\n15.1\nProgrammer-de\ufb01ned types . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n147\n15.2\nAttributes\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n148\n15.3",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_41",
    "text": "147\n15.1\nProgrammer-de\ufb01ned types . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n147\n15.2\nAttributes\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n148\n15.3\nRectangles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n149\n15.4\nInstances as return values\n. . . . . . . . . . . . . . . . . . . . . . . . . . . .\n150\n15.5\nObjects are mutable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n151\n15.6\nCopying\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n151\n15.7\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n152\n15.8\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n153\n15.9\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n154\n16 Classes and functions\n155\n16.1\nTime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n155\n16.2",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_42",
    "text": "154\n16 Classes and functions\n155\n16.1\nTime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n155\n16.2\nPure functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n156\n16.3\nModi\ufb01ers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n157\n16.4\nPrototyping versus planning . . . . . . . . . . . . . . . . . . . . . . . . . . .\n158\n16.5\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n159\n16.6\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n160\n16.7\nExercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n160\n17 Classes and methods\n161\n17.1\nObject-oriented features\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n161\n17.2\nPrinting objects\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n162\n17.3\nAnother example\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n163\nxx",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_43",
    "text": "161\n17.2\nPrinting objects\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n162\n17.3\nAnother example\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n163\nxx\nContents\n17.4\nA more complicated example . . . . . . . . . . . . . . . . . . . . . . . . . .\n164\n17.5\nThe init method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n164\n17.6\nThe __str__ method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n165\n17.7\nOperator overloading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n165\n17.8\nType-based dispatch\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n166\n17.9\nPolymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n167\n17.10 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n168\n17.11 Interface and implementation . . . . . . . . . . . . . . . . . . . . . . . . . .\n169\n17.12 Glossary",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_44",
    "text": "17.10 Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n168\n17.11 Interface and implementation . . . . . . . . . . . . . . . . . . . . . . . . . .\n169\n17.12 Glossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n169\n17.13 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n170\n18 Inheritance\n171\n18.1\nCard objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n171\n18.2\nClass attributes\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n172\n18.3\nComparing cards\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n173\n18.4\nDecks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n174\n18.5\nPrinting the deck\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n174\n18.6\nAdd, remove, shuf\ufb02e and sort . . . . . . . . . . . . . . . . . . . . . . . . . .\n175\n18.7",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_45",
    "text": "174\n18.5\nPrinting the deck\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n174\n18.6\nAdd, remove, shuf\ufb02e and sort . . . . . . . . . . . . . . . . . . . . . . . . . .\n175\n18.7\nInheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n176\n18.8\nClass diagrams\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n177\n18.9\nDebugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n178\n18.10 Data encapsulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n179\n18.11 Glossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n180\n18.12 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n181\n19 The Goodies\n183\n19.1\nConditional expressions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n183\n19.2\nList comprehensions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n184\n19.3\nGenerator expressions",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_46",
    "text": ". . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n183\n19.2\nList comprehensions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n184\n19.3\nGenerator expressions\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n185\n19.4\nany and all\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n185\n19.5\nSets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n186\n19.6\nCounters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n187\nContents\nxxi\n19.7\ndefaultdict . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n188\n19.8\nNamed tuples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n189\n19.9\nGathering keyword args . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n190\n19.10 Glossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n191",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_47",
    "text": "189\n19.9\nGathering keyword args . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n190\n19.10 Glossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n191\n19.11 Exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n192\nA Debugging\n193\nA.1\nSyntax errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n193\nA.2\nRuntime errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n195\nA.3\nSemantic errors\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n198\nB\nAnalysis of Algorithms\n201\nB.1\nOrder of growth . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n202\nB.2\nAnalysis of basic Python operations\n. . . . . . . . . . . . . . . . . . . . . .\n204\nB.3\nAnalysis of search algorithms . . . . . . . . . . . . . . . . . . . . . . . . . .\n205\nB.4\nHashtables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n206\nB.5\nGlossary",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_48",
    "text": "204\nB.3\nAnalysis of search algorithms . . . . . . . . . . . . . . . . . . . . . . . . . .\n205\nB.4\nHashtables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n206\nB.5\nGlossary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n209\nxxii\nContents\nChapter 1\nThe way of the program\nThe goal of this book is to teach you to think like a computer scientist. This way of think-\ning combines some of the best features of mathematics, engineering, and natural science.\nLike mathematicians, computer scientists use formal languages to denote ideas (speci\ufb01-\ncally computations). Like engineers, they design things, assembling components into sys-\ntems and evaluating tradeoffs among alternatives. Like scientists, they observe the behav-\nior of complex systems, form hypotheses, and test predictions.\nThe single most important skill for a computer scientist is problem solving. Problem solv-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_49",
    "text": "ior of complex systems, form hypotheses, and test predictions.\nThe single most important skill for a computer scientist is problem solving. Problem solv-\ning means the ability to formulate problems, think creatively about solutions, and express\na solution clearly and accurately. As it turns out, the process of learning to program is an\nexcellent opportunity to practice problem-solving skills. That\u2019s why this chapter is called,\n\u201cThe way of the program\u201d.\nOn one level, you will be learning to program, a useful skill by itself. On another level, you\nwill use programming as a means to an end. As we go along, that end will become clearer.\n1.1\nWhat is a program?\nA program is a sequence of instructions that speci\ufb01es how to perform a computation. The\ncomputation might be something mathematical, such as solving a system of equations or\n\ufb01nding the roots of a polynomial, but it can also be a symbolic computation, such as search-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_50",
    "text": "computation might be something mathematical, such as solving a system of equations or\n\ufb01nding the roots of a polynomial, but it can also be a symbolic computation, such as search-\ning and replacing text in a document or something graphical, like processing an image or\nplaying a video.\nThe details look different in different languages, but a few basic instructions appear in just\nabout every language:\ninput: Get data from the keyboard, a \ufb01le, the network, or some other device.\noutput: Display data on the screen, save it in a \ufb01le, send it over the network, etc.\nmath: Perform basic mathematical operations like addition and multiplication.\nconditional execution: Check for certain conditions and run the appropriate code.\n2\nChapter 1. The way of the program\nrepetition: Perform some action repeatedly, usually with some variation.\nBelieve it or not, that\u2019s pretty much all there is to it. Every program you\u2019ve ever used,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_51",
    "text": "2\nChapter 1. The way of the program\nrepetition: Perform some action repeatedly, usually with some variation.\nBelieve it or not, that\u2019s pretty much all there is to it. Every program you\u2019ve ever used,\nno matter how complicated, is made up of instructions that look pretty much like these.\nSo you can think of programming as the process of breaking a large, complex task into\nsmaller and smaller subtasks until the subtasks are simple enough to be performed with\none of these basic instructions.\n1.2\nRunning Python\nOne of the challenges of getting started with Python is that you might have to install\nPython and related software on your computer. If you are familiar with your operating\nsystem, and especially if you are comfortable with the command-line interface, you will\nhave no trouble installing Python. But for beginners, it can be painful to learn about sys-\ntem administration and programming at the same time.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_52",
    "text": "have no trouble installing Python. But for beginners, it can be painful to learn about sys-\ntem administration and programming at the same time.\nTo avoid that problem, I recommend that you start out running Python in a browser. Later,\nwhen you are comfortable with Python, I\u2019ll make suggestions for installing Python on your\ncomputer.\nThere are a number of web pages you can use to run Python. If you already have a fa-\nvorite, go ahead and use it. Otherwise I recommend PythonAnywhere. I provide detailed\ninstructions for getting started at http://tinyurl.com/thinkpython2e.\nThere are two versions of Python, called Python 2 and Python 3. They are very similar, so\nif you learn one, it is easy to switch to the other. In fact, there are only a few differences you\nwill encounter as a beginner. This book is written for Python 3, but I include some notes\nabout Python 2.\nThe Python interpreter is a program that reads and executes Python code. Depending",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_53",
    "text": "will encounter as a beginner. This book is written for Python 3, but I include some notes\nabout Python 2.\nThe Python interpreter is a program that reads and executes Python code. Depending\non your environment, you might start the interpreter by clicking on an icon, or by typing\npython on a command line. When it starts, you should see output like this:\nPython 3.4.0 (default, Jun 19 2015, 14:20:21)\n[GCC 4.8.2] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>>\nThe \ufb01rst three lines contain information about the interpreter and the operating system it\u2019s\nrunning on, so it might be different for you. But you should check that the version number,\nwhich is 3.4.0 in this example, begins with 3, which indicates that you are running Python\n3. If it begins with 2, you are running (you guessed it) Python 2.\nThe last line is a prompt that indicates that the interpreter is ready for you to enter code. If",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_54",
    "text": "3. If it begins with 2, you are running (you guessed it) Python 2.\nThe last line is a prompt that indicates that the interpreter is ready for you to enter code. If\nyou type a line of code and hit Enter, the interpreter displays the result:\n>>> 1 + 1\n2\nNow you\u2019re ready to get started. From here on, I assume that you know how to start the\nPython interpreter and run code.\n1.3. The \ufb01rst program\n3\n1.3\nThe \ufb01rst program\nTraditionally, the \ufb01rst program you write in a new language is called \u201cHello, World!\u201d be-\ncause all it does is display the words \u201cHello, World!\u201d. In Python, it looks like this:\n>>> print('Hello, World!')\nThis is an example of a print statement, although it doesn\u2019t actually print anything on\npaper. It displays a result on the screen. In this case, the result is the words\nHello, World!\nThe quotation marks in the program mark the beginning and end of the text to be dis-\nplayed; they don\u2019t appear in the result.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_55",
    "text": "Hello, World!\nThe quotation marks in the program mark the beginning and end of the text to be dis-\nplayed; they don\u2019t appear in the result.\nThe parentheses indicate that print is a function. We\u2019ll get to functions in Chapter 3.\nIn Python 2, the print statement is slightly different; it is not a function, so it doesn\u2019t use\nparentheses.\n>>> print 'Hello, World!'\nThis distinction will make more sense soon, but that\u2019s enough to get started.\n1.4\nArithmetic operators\nAfter \u201cHello, World\u201d, the next step is arithmetic. Python provides operators, which are\nspecial symbols that represent computations like addition and multiplication.\nThe operators +, -, and * perform addition, subtraction, and multiplication, as in the fol-\nlowing examples:\n>>> 40 + 2\n42\n>>> 43 - 1\n42\n>>> 6 * 7\n42\nThe operator / performs division:\n>>> 84 / 2\n42.0\nYou might wonder why the result is 42.0 instead of 42. I\u2019ll explain in the next section.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_56",
    "text": "lowing examples:\n>>> 40 + 2\n42\n>>> 43 - 1\n42\n>>> 6 * 7\n42\nThe operator / performs division:\n>>> 84 / 2\n42.0\nYou might wonder why the result is 42.0 instead of 42. I\u2019ll explain in the next section.\nFinally, the operator ** performs exponentiation; that is, it raises a number to a power:\n>>> 6**2 + 6\n42\nIn some other languages, ^ is used for exponentiation, but in Python it is a bitwise operator\ncalled XOR. If you are not familiar with bitwise operators, the result will surprise you:\n>>> 6 ^ 2\n4\nI won\u2019t cover bitwise operators in this book, but you can read about them at http://wiki.\npython.org/moin/BitwiseOperators.\n4\nChapter 1. The way of the program\n1.5\nValues and types\nA value is one of the basic things a program works with, like a letter or a number. Some\nvalues we have seen so far are 2, 42.0, and 'Hello, World!'.\nThese values belong to different types: 2 is an integer, 42.0 is a \ufb02oating-point number, and",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_57",
    "text": "values we have seen so far are 2, 42.0, and 'Hello, World!'.\nThese values belong to different types: 2 is an integer, 42.0 is a \ufb02oating-point number, and\n'Hello, World!' is a string, so-called because the letters it contains are strung together.\nIf you are not sure what type a value has, the interpreter can tell you:\n>>> type(2)\n<class 'int'>\n>>> type(42.0)\n<class 'float'>\n>>> type('Hello, World!')\n<class 'str'>\nIn these results, the word \u201cclass\u201d is used in the sense of a category; a type is a category of\nvalues.\nNot surprisingly, integers belong to the type int, strings belong to str and \ufb02oating-point\nnumbers belong to float.\nWhat about values like '2' and '42.0'? They look like numbers, but they are in quotation\nmarks like strings.\n>>> type('2')\n<class 'str'>\n>>> type('42.0')\n<class 'str'>\nThey\u2019re strings.\nWhen you type a large integer, you might be tempted to use commas between groups of\ndigits, as in 1,000,000. This is not a legal integer in Python, but it is legal:\n>>> 1,000,000",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_58",
    "text": "They\u2019re strings.\nWhen you type a large integer, you might be tempted to use commas between groups of\ndigits, as in 1,000,000. This is not a legal integer in Python, but it is legal:\n>>> 1,000,000\n(1, 0, 0)\nThat\u2019s not what we expected at all! Python interprets 1,000,000 as a comma-separated\nsequence of integers. We\u2019ll learn more about this kind of sequence later.\n1.6\nFormal and natural languages\nNatural languages are the languages people speak, such as English, Spanish, and French.\nThey were not designed by people (although people try to impose some order on them);\nthey evolved naturally.\nFormal languages are languages that are designed by people for speci\ufb01c applications. For\nexample, the notation that mathematicians use is a formal language that is particularly\ngood at denoting relationships among numbers and symbols. Chemists use a formal lan-\nguage to represent the chemical structure of molecules. And most importantly:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_59",
    "text": "good at denoting relationships among numbers and symbols. Chemists use a formal lan-\nguage to represent the chemical structure of molecules. And most importantly:\nProgramming languages are formal languages that have been designed to\nexpress computations.\n1.6. Formal and natural languages\n5\nFormal languages tend to have strict syntax rules that govern the structure of statements.\nFor example, in mathematics the statement 3 + 3 = 6 has correct syntax, but 3+ = 3$6\ndoes not. In chemistry H2O is a syntactically correct formula, but 2Zz is not.\nSyntax rules come in two \ufb02avors, pertaining to tokens and structure. Tokens are the basic\nelements of the language, such as words, numbers, and chemical elements. One of the\nproblems with 3+ = 3$6 is that $ is not a legal token in mathematics (at least as far as I\nknow). Similarly, 2Zz is not legal because there is no element with the abbreviation Zz.\nThe second type of syntax rule pertains to the way tokens are combined. The equation",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_60",
    "text": "know). Similarly, 2Zz is not legal because there is no element with the abbreviation Zz.\nThe second type of syntax rule pertains to the way tokens are combined. The equation\n3 + /3 is illegal because even though + and / are legal tokens, you can\u2019t have one right\nafter the other. Similarly, in a chemical formula the subscript comes after the element name,\nnot before.\nThis is @ well-structured Engli$h sentence with invalid t*kens in it. This sentence all valid\ntokens has, but invalid structure with.\nWhen you read a sentence in English or a statement in a formal language, you have to\n\ufb01gure out the structure (although in a natural language you do this subconsciously). This\nprocess is called parsing.\nAlthough formal and natural languages have many features in common\u2014tokens, struc-\nture, and syntax\u2014there are some differences:\nambiguity: Natural languages are full of ambiguity, which people deal with by using con-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_61",
    "text": "ture, and syntax\u2014there are some differences:\nambiguity: Natural languages are full of ambiguity, which people deal with by using con-\ntextual clues and other information. Formal languages are designed to be nearly or\ncompletely unambiguous, which means that any statement has exactly one meaning,\nregardless of context.\nredundancy: In order to make up for ambiguity and reduce misunderstandings, natural\nlanguages employ lots of redundancy. As a result, they are often verbose. Formal\nlanguages are less redundant and more concise.\nliteralness: Natural languages are full of idiom and metaphor.\nIf I say, \u201cThe penny\ndropped\u201d, there is probably no penny and nothing dropping (this idiom means that\nsomeone understood something after a period of confusion). Formal languages mean\nexactly what they say.\nBecause we all grow up speaking natural languages, it is sometimes hard to adjust to for-\nmal languages. The difference between formal and natural language is like the difference",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_62",
    "text": "Because we all grow up speaking natural languages, it is sometimes hard to adjust to for-\nmal languages. The difference between formal and natural language is like the difference\nbetween poetry and prose, but more so:\nPoetry: Words are used for their sounds as well as for their meaning, and the whole poem\ntogether creates an effect or emotional response. Ambiguity is not only common but\noften deliberate.\nProse: The literal meaning of words is more important, and the structure contributes more\nmeaning. Prose is more amenable to analysis than poetry but still often ambiguous.\nPrograms: The meaning of a computer program is unambiguous and literal, and can be\nunderstood entirely by analysis of the tokens and structure.\n6\nChapter 1. The way of the program\nFormal languages are more dense than natural languages, so it takes longer to read them.\nAlso, the structure is important, so it is not always best to read from top to bottom, left to",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_63",
    "text": "Formal languages are more dense than natural languages, so it takes longer to read them.\nAlso, the structure is important, so it is not always best to read from top to bottom, left to\nright. Instead, learn to parse the program in your head, identifying the tokens and inter-\npreting the structure. Finally, the details matter. Small errors in spelling and punctuation,\nwhich you can get away with in natural languages, can make a big difference in a formal\nlanguage.\n1.7\nDebugging\nProgrammers make mistakes. For whimsical reasons, programming errors are called bugs\nand the process of tracking them down is called debugging.\nProgramming, and especially debugging, sometimes brings out strong emotions. If you\nare struggling with a dif\ufb01cult bug, you might feel angry, despondent, or embarrassed.\nThere is evidence that people naturally respond to computers as if they were people. When\nthey work well, we think of them as teammates, and when they are obstinate or rude, we",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_64",
    "text": "There is evidence that people naturally respond to computers as if they were people. When\nthey work well, we think of them as teammates, and when they are obstinate or rude, we\nrespond to them the same way we respond to rude, obstinate people (Reeves and Nass,\nThe Media Equation: How People Treat Computers, Television, and New Media Like Real People\nand Places).\nPreparing for these reactions might help you deal with them. One approach is to think of\nthe computer as an employee with certain strengths, like speed and precision, and partic-\nular weaknesses, like lack of empathy and inability to grasp the big picture.\nYour job is to be a good manager: \ufb01nd ways to take advantage of the strengths and mitigate\nthe weaknesses. And \ufb01nd ways to use your emotions to engage with the problem, without\nletting your reactions interfere with your ability to work effectively.\nLearning to debug can be frustrating, but it is a valuable skill that is useful for many activ-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_65",
    "text": "letting your reactions interfere with your ability to work effectively.\nLearning to debug can be frustrating, but it is a valuable skill that is useful for many activ-\nities beyond programming. At the end of each chapter there is a section, like this one, with\nmy suggestions for debugging. I hope they help!\n1.8\nGlossary\nproblem solving: The process of formulating a problem, \ufb01nding a solution, and express-\ning it.\nhigh-level language: A programming language like Python that is designed to be easy for\nhumans to read and write.\nlow-level language: A programming language that is designed to be easy for a computer\nto run; also called \u201cmachine language\u201d or \u201cassembly language\u201d.\nportability: A property of a program that can run on more than one kind of computer.\ninterpreter: A program that reads another program and executes it\nprompt: Characters displayed by the interpreter to indicate that it is ready to take input\nfrom the user.\nprogram: A set of instructions that speci\ufb01es a computation.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_66",
    "text": "prompt: Characters displayed by the interpreter to indicate that it is ready to take input\nfrom the user.\nprogram: A set of instructions that speci\ufb01es a computation.\n1.9. Exercises\n7\nprint statement: An instruction that causes the Python interpreter to display a value on\nthe screen.\noperator: A special symbol that represents a simple computation like addition, multipli-\ncation, or string concatenation.\nvalue: One of the basic units of data, like a number or string, that a program manipulates.\ntype: A category of values. The types we have seen so far are integers (type int), \ufb02oating-\npoint numbers (type float), and strings (type str).\ninteger: A type that represents whole numbers.\n\ufb02oating-point: A type that represents numbers with fractional parts.\nstring: A type that represents sequences of characters.\nnatural language: Any one of the languages that people speak that evolved naturally.\nformal language: Any one of the languages that people have designed for speci\ufb01c pur-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_67",
    "text": "natural language: Any one of the languages that people speak that evolved naturally.\nformal language: Any one of the languages that people have designed for speci\ufb01c pur-\nposes, such as representing mathematical ideas or computer programs; all program-\nming languages are formal languages.\ntoken: One of the basic elements of the syntactic structure of a program, analogous to a\nword in a natural language.\nsyntax: The rules that govern the structure of a program.\nparse: To examine a program and analyze the syntactic structure.\nbug: An error in a program.\ndebugging: The process of \ufb01nding and correcting bugs.\n1.9\nExercises\nExercise 1.1. It is a good idea to read this book in front of a computer so you can try out the\nexamples as you go.\nWhenever you are experimenting with a new feature, you should try to make mistakes. For example,\nin the \u201cHello, world!\u201d program, what happens if you leave out one of the quotation marks? What if\nyou leave out both? What if you spell print wrong?",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_68",
    "text": "in the \u201cHello, world!\u201d program, what happens if you leave out one of the quotation marks? What if\nyou leave out both? What if you spell print wrong?\nThis kind of experiment helps you remember what you read; it also helps when you are programming,\nbecause you get to know what the error messages mean. It is better to make mistakes now and on\npurpose than later and accidentally.\n1. In a print statement, what happens if you leave out one of the parentheses, or both?\n2. If you are trying to print a string, what happens if you leave out one of the quotation marks,\nor both?\n3. You can use a minus sign to make a negative number like -2. What happens if you put a plus\nsign before a number? What about 2++2?\n8\nChapter 1. The way of the program\n4. In math notation, leading zeros are ok, as in 09. What happens if you try this in Python?\nWhat about 011?\n5. What happens if you have two values with no operator between them?\nExercise 1.2. Start the Python interpreter and use it as a calculator.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_69",
    "text": "What about 011?\n5. What happens if you have two values with no operator between them?\nExercise 1.2. Start the Python interpreter and use it as a calculator.\n1. How many seconds are there in 42 minutes 42 seconds?\n2. How many miles are there in 10 kilometers? Hint: there are 1.61 kilometers in a mile.\n3. If you run a 10 kilometer race in 42 minutes 42 seconds, what is your average pace (time per\nmile in minutes and seconds)? What is your average speed in miles per hour?\nChapter 2\nVariables, expressions and\nstatements\nOne of the most powerful features of a programming language is the ability to manipulate\nvariables. A variable is a name that refers to a value.\n2.1\nAssignment statements\nAn assignment statement creates a new variable and gives it a value:\n>>> message = 'And now for something completely different'\n>>> n = 17\n>>> pi = 3.1415926535897932\nThis example makes three assignments. The \ufb01rst assigns a string to a new variable named",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_70",
    "text": ">>> message = 'And now for something completely different'\n>>> n = 17\n>>> pi = 3.1415926535897932\nThis example makes three assignments. The \ufb01rst assigns a string to a new variable named\nmessage; the second gives the integer 17 to n; the third assigns the (approximate) value of\n\u03c0 to pi.\nA common way to represent variables on paper is to write the name with an arrow pointing\nto its value. This kind of \ufb01gure is called a state diagram because it shows what state each\nof the variables is in (think of it as the variable\u2019s state of mind). Figure 2.1 shows the result\nof the previous example.\n2.2\nVariable names\nProgrammers generally choose names for their variables that are meaningful\u2014they docu-\nment what the variable is used for.\nmessage\nn\npi\n17\n\u2019And now for something completely different\u2019\n3.1415926535897932\nFigure 2.1: State diagram.\n10\nChapter 2. Variables, expressions and statements\nVariable names can be as long as you like. They can contain both letters and numbers, but",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_71",
    "text": "3.1415926535897932\nFigure 2.1: State diagram.\n10\nChapter 2. Variables, expressions and statements\nVariable names can be as long as you like. They can contain both letters and numbers, but\nthey can\u2019t begin with a number. It is legal to use uppercase letters, but it is conventional to\nuse only lower case for variables names.\nThe underscore character, _, can appear in a name. It is often used in names with multiple\nwords, such as your_name or airspeed_of_unladen_swallow.\nIf you give a variable an illegal name, you get a syntax error:\n>>> 76trombones = 'big parade'\nSyntaxError: invalid syntax\n>>> more@ = 1000000\nSyntaxError: invalid syntax\n>>> class = 'Advanced Theoretical Zymurgy'\nSyntaxError: invalid syntax\n76trombones is illegal because it begins with a number. more@ is illegal because it contains\nan illegal character, @. But what\u2019s wrong with class?\nIt turns out that class is one of Python\u2019s keywords. The interpreter uses keywords to",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_72",
    "text": "an illegal character, @. But what\u2019s wrong with class?\nIt turns out that class is one of Python\u2019s keywords. The interpreter uses keywords to\nrecognize the structure of the program, and they cannot be used as variable names.\nPython 3 has these keywords:\nFalse\nclass\nfinally\nis\nreturn\nNone\ncontinue\nfor\nlambda\ntry\nTrue\ndef\nfrom\nnonlocal\nwhile\nand\ndel\nglobal\nnot\nwith\nas\nelif\nif\nor\nyield\nassert\nelse\nimport\npass\nbreak\nexcept\nin\nraise\nYou don\u2019t have to memorize this list. In most development environments, keywords are\ndisplayed in a different color; if you try to use one as a variable name, you\u2019ll know.\n2.3\nExpressions and statements\nAn expression is a combination of values, variables, and operators. A value all by itself is\nconsidered an expression, and so is a variable, so the following are all legal expressions:\n>>> 42\n42\n>>> n\n17\n>>> n + 25\n42\nWhen you type an expression at the prompt, the interpreter evaluates it, which means that",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_73",
    "text": ">>> 42\n42\n>>> n\n17\n>>> n + 25\n42\nWhen you type an expression at the prompt, the interpreter evaluates it, which means that\nit \ufb01nds the value of the expression. In this example, n has the value 17 and n + 25 has the\nvalue 42.\nA statement is a unit of code that has an effect, like creating a variable or displaying a\nvalue.\n>>> n = 17\n>>> print(n)\n2.4. Script mode\n11\nThe \ufb01rst line is an assignment statement that gives a value to n. The second line is a print\nstatement that displays the value of n.\nWhen you type a statement, the interpreter executes it, which means that it does whatever\nthe statement says. In general, statements don\u2019t have values.\n2.4\nScript mode\nSo far we have run Python in interactive mode, which means that you interact directly\nwith the interpreter. Interactive mode is a good way to get started, but if you are working\nwith more than a few lines of code, it can be clumsy.\nThe alternative is to save code in a \ufb01le called a script and then run the interpreter in script",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_74",
    "text": "with more than a few lines of code, it can be clumsy.\nThe alternative is to save code in a \ufb01le called a script and then run the interpreter in script\nmode to execute the script. By convention, Python scripts have names that end with .py.\nIf you know how to create and run a script on your computer, you are ready to go. Oth-\nerwise I recommend using PythonAnywhere again. I have posted instructions for running\nin script mode at http://tinyurl.com/thinkpython2e.\nBecause Python provides both modes, you can test bits of code in interactive mode before\nyou put them in a script. But there are differences between interactive mode and script\nmode that can be confusing.\nFor example, if you are using Python as a calculator, you might type\n>>> miles = 26.2\n>>> miles * 1.61\n42.182\nThe \ufb01rst line assigns a value to miles, but it has no visible effect. The second line is an ex-\npression, so the interpreter evaluates it and displays the result. It turns out that a marathon\nis about 42 kilometers.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_75",
    "text": "pression, so the interpreter evaluates it and displays the result. It turns out that a marathon\nis about 42 kilometers.\nBut if you type the same code into a script and run it, you get no output at all. In script\nmode an expression, all by itself, has no visible effect. Python evaluates the expression, but\nit doesn\u2019t display the result. To display the result, you need a print statement like this:\nmiles = 26.2\nprint(miles * 1.61)\nThis behavior can be confusing at \ufb01rst. To check your understanding, type the following\nstatements in the Python interpreter and see what they do:\n5\nx = 5\nx + 1\nNow put the same statements in a script and run it. What is the output? Modify the script\nby transforming each expression into a print statement and then run it again.\n2.5\nOrder of operations\nWhen an expression contains more than one operator, the order of evaluation depends\non the order of operations. For mathematical operators, Python follows mathematical",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_76",
    "text": "2.5\nOrder of operations\nWhen an expression contains more than one operator, the order of evaluation depends\non the order of operations. For mathematical operators, Python follows mathematical\nconvention. The acronym PEMDAS is a useful way to remember the rules:\n12\nChapter 2. Variables, expressions and statements\n\u2022 Parentheses have the highest precedence and can be used to force an expression to\nevaluate in the order you want. Since expressions in parentheses are evaluated \ufb01rst,\n2 * (3-1) is 4, and (1+1)**(5-2) is 8. You can also use parentheses to make an\nexpression easier to read, as in (minute * 100) / 60, even if it doesn\u2019t change the\nresult.\n\u2022 Exponentiation has the next highest precedence, so 1 + 2**3 is 9, not 27, and 2 *\n3**2 is 18, not 36.\n\u2022 Multiplication and Division have higher precedence than Addition and Subtraction.\nSo 2*3-1 is 5, not 4, and 6+4/2 is 8, not 5.\n\u2022 Operators with the same precedence are evaluated from left to right (except exponen-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_77",
    "text": "So 2*3-1 is 5, not 4, and 6+4/2 is 8, not 5.\n\u2022 Operators with the same precedence are evaluated from left to right (except exponen-\ntiation). So in the expression degrees / 2 * pi, the division happens \ufb01rst and the\nresult is multiplied by pi. To divide by 2\u03c0, you can use parentheses or write degrees\n/ 2 / pi.\nI don\u2019t work very hard to remember the precedence of operators. If I can\u2019t tell by looking\nat the expression, I use parentheses to make it obvious.\n2.6\nString operations\nIn general, you can\u2019t perform mathematical operations on strings, even if the strings look\nlike numbers, so the following are illegal:\n'chinese'-'food'\n'eggs'/'easy'\n'third'*'a charm'\nBut there are two exceptions, + and *.\nThe + operator performs string concatenation, which means it joins the strings by linking\nthem end-to-end. For example:\n>>> first = 'throat'\n>>> second = 'warbler'\n>>> first + second\nthroatwarbler\nThe * operator also works on strings; it performs repetition. For example, 'Spam'*3 is",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_78",
    "text": "them end-to-end. For example:\n>>> first = 'throat'\n>>> second = 'warbler'\n>>> first + second\nthroatwarbler\nThe * operator also works on strings; it performs repetition. For example, 'Spam'*3 is\n'SpamSpamSpam'. If one of the values is a string, the other has to be an integer.\nThis use of + and * makes sense by analogy with addition and multiplication. Just as 4*3\nis equivalent to 4+4+4, we expect 'Spam'*3 to be the same as 'Spam'+'Spam'+'Spam', and\nit is. On the other hand, there is a signi\ufb01cant way in which string concatenation and repe-\ntition are different from integer addition and multiplication. Can you think of a property\nthat addition has that string concatenation does not?\n2.7\nComments\nAs programs get bigger and more complicated, they get more dif\ufb01cult to read. Formal\nlanguages are dense, and it is often dif\ufb01cult to look at a piece of code and \ufb01gure out what\nit is doing, or why.\n2.8. Debugging\n13",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_79",
    "text": "languages are dense, and it is often dif\ufb01cult to look at a piece of code and \ufb01gure out what\nit is doing, or why.\n2.8. Debugging\n13\nFor this reason, it is a good idea to add notes to your programs to explain in natural lan-\nguage what the program is doing. These notes are called comments, and they start with\nthe # symbol:\n# compute the percentage of the hour that has elapsed\npercentage = (minute * 100) / 60\nIn this case, the comment appears on a line by itself. You can also put comments at the end\nof a line:\npercentage = (minute * 100) / 60\n# percentage of an hour\nEverything from the # to the end of the line is ignored\u2014it has no effect on the execution of\nthe program.\nComments are most useful when they document non-obvious features of the code. It is\nreasonable to assume that the reader can \ufb01gure out what the code does; it is more useful to\nexplain why.\nThis comment is redundant with the code and useless:\nv = 5\n# assign 5 to v",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_80",
    "text": "reasonable to assume that the reader can \ufb01gure out what the code does; it is more useful to\nexplain why.\nThis comment is redundant with the code and useless:\nv = 5\n# assign 5 to v\nThis comment contains useful information that is not in the code:\nv = 5\n# velocity in meters/second.\nGood variable names can reduce the need for comments, but long names can make com-\nplex expressions hard to read, so there is a tradeoff.\n2.8\nDebugging\nThree kinds of errors can occur in a program: syntax errors, runtime errors, and semantic\nerrors. It is useful to distinguish between them in order to track them down more quickly.\nSyntax error: \u201cSyntax\u201d refers to the structure of a program and the rules about that struc-\nture. For example, parentheses have to come in matching pairs, so (1 + 2) is legal,\nbut 8) is a syntax error.\nIf there is a syntax error anywhere in your program, Python displays an error mes-\nsage and quits, and you will not be able to run the program. During the \ufb01rst few",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_81",
    "text": "but 8) is a syntax error.\nIf there is a syntax error anywhere in your program, Python displays an error mes-\nsage and quits, and you will not be able to run the program. During the \ufb01rst few\nweeks of your programming career, you might spend a lot of time tracking down\nsyntax errors. As you gain experience, you will make fewer errors and \ufb01nd them\nfaster.\nRuntime error: The second type of error is a runtime error, so called because the error does\nnot appear until after the program has started running. These errors are also called\nexceptions because they usually indicate that something exceptional (and bad) has\nhappened.\nRuntime errors are rare in the simple programs you will see in the \ufb01rst few chapters,\nso it might be a while before you encounter one.\nSemantic error: The third type of error is \u201csemantic\u201d, which means related to meaning.\nIf there is a semantic error in your program, it will run without generating error",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_82",
    "text": "Semantic error: The third type of error is \u201csemantic\u201d, which means related to meaning.\nIf there is a semantic error in your program, it will run without generating error\nmessages, but it will not do the right thing. It will do something else. Speci\ufb01cally, it\nwill do what you told it to do.\nIdentifying semantic errors can be tricky because it requires you to work backward\nby looking at the output of the program and trying to \ufb01gure out what it is doing.\n14\nChapter 2. Variables, expressions and statements\n2.9\nGlossary\nvariable: A name that refers to a value.\nassignment: A statement that assigns a value to a variable.\nstate diagram: A graphical representation of a set of variables and the values they refer to.\nkeyword: A reserved word that is used to parse a program; you cannot use keywords like\nif, def, and while as variable names.\noperand: One of the values on which an operator operates.\nexpression: A combination of variables, operators, and values that represents a single re-\nsult.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_83",
    "text": "if, def, and while as variable names.\noperand: One of the values on which an operator operates.\nexpression: A combination of variables, operators, and values that represents a single re-\nsult.\nevaluate: To simplify an expression by performing the operations in order to yield a single\nvalue.\nstatement: A section of code that represents a command or action. So far, the statements\nwe have seen are assignments and print statements.\nexecute: To run a statement and do what it says.\ninteractive mode: A way of using the Python interpreter by typing code at the prompt.\nscript mode: A way of using the Python interpreter to read code from a script and run it.\nscript: A program stored in a \ufb01le.\norder of operations: Rules governing the order in which expressions involving multiple\noperators and operands are evaluated.\nconcatenate: To join two operands end-to-end.\ncomment: Information in a program that is meant for other programmers (or anyone read-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_84",
    "text": "operators and operands are evaluated.\nconcatenate: To join two operands end-to-end.\ncomment: Information in a program that is meant for other programmers (or anyone read-\ning the source code) and has no effect on the execution of the program.\nsyntax error: An error in a program that makes it impossible to parse (and therefore im-\npossible to interpret).\nexception: An error that is detected while the program is running.\nsemantics: The meaning of a program.\nsemantic error: An error in a program that makes it do something other than what the\nprogrammer intended.\n2.10\nExercises\nExercise 2.1. Repeating my advice from the previous chapter, whenever you learn a new feature,\nyou should try it out in interactive mode and make errors on purpose to see what goes wrong.\n\u2022 We\u2019ve seen that n = 42 is legal. What about 42 = n?\n2.10. Exercises\n15\n\u2022 How about x = y = 1?\n\u2022 In some languages every statement ends with a semi-colon, ;. What happens if you put a\nsemi-colon at the end of a Python statement?",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_85",
    "text": "2.10. Exercises\n15\n\u2022 How about x = y = 1?\n\u2022 In some languages every statement ends with a semi-colon, ;. What happens if you put a\nsemi-colon at the end of a Python statement?\n\u2022 What if you put a period at the end of a statement?\n\u2022 In math notation you can multiply x and y like this: xy. What happens if you try that in\nPython?\nExercise 2.2. Practice using the Python interpreter as a calculator:\n1. The volume of a sphere with radius r is 4\n3\u03c0r3. What is the volume of a sphere with radius 5?\n2. Suppose the cover price of a book is $24.95, but bookstores get a 40% discount. Shipping costs\n$3 for the \ufb01rst copy and 75 cents for each additional copy. What is the total wholesale cost for\n60 copies?\n3. If I leave my house at 6:52 am and run 1 mile at an easy pace (8:15 per mile), then 3 miles at\ntempo (7:12 per mile) and 1 mile at easy pace again, what time do I get home for breakfast?\n16\nChapter 2. Variables, expressions and statements\nChapter 3\nFunctions",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_86",
    "text": "tempo (7:12 per mile) and 1 mile at easy pace again, what time do I get home for breakfast?\n16\nChapter 2. Variables, expressions and statements\nChapter 3\nFunctions\nIn the context of programming, a function is a named sequence of statements that performs\na computation. When you de\ufb01ne a function, you specify the name and the sequence of\nstatements. Later, you can \u201ccall\u201d the function by name.\n3.1\nFunction calls\nWe have already seen one example of a function call:\n>>> type(42)\n<class 'int'>\nThe name of the function is type. The expression in parentheses is called the argument of\nthe function. The result, for this function, is the type of the argument.\nIt is common to say that a function \u201ctakes\u201d an argument and \u201creturns\u201d a result. The result\nis also called the return value.\nPython provides functions that convert values from one type to another. The int function\ntakes any value and converts it to an integer, if it can, or complains otherwise:\n>>> int('32')\n32\n>>> int('Hello')",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_87",
    "text": "takes any value and converts it to an integer, if it can, or complains otherwise:\n>>> int('32')\n32\n>>> int('Hello')\nValueError: invalid literal for int(): Hello\nint can convert \ufb02oating-point values to integers, but it doesn\u2019t round off; it chops off the\nfraction part:\n>>> int(3.99999)\n3\n>>> int(-2.3)\n-2\nfloat converts integers and strings to \ufb02oating-point numbers:\n>>> float(32)\n32.0\n>>> float('3.14159')\n3.14159\n18\nChapter 3. Functions\nFinally, str converts its argument to a string:\n>>> str(32)\n'32'\n>>> str(3.14159)\n'3.14159'\n3.2\nMath functions\nPython has a math module that provides most of the familiar mathematical functions. A\nmodule is a \ufb01le that contains a collection of related functions.\nBefore we can use the functions in a module, we have to import it with an import state-\nment:\n>>> import math\nThis statement creates a module object named math. If you display the module object, you\nget some information about it:\n>>> math\n<module 'math' (built-in)>",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_88",
    "text": "ment:\n>>> import math\nThis statement creates a module object named math. If you display the module object, you\nget some information about it:\n>>> math\n<module 'math' (built-in)>\nThe module object contains the functions and variables de\ufb01ned in the module. To access\none of the functions, you have to specify the name of the module and the name of the\nfunction, separated by a dot (also known as a period). This format is called dot notation.\n>>> ratio = signal_power / noise_power\n>>> decibels = 10 * math.log10(ratio)\n>>> radians = 0.7\n>>> height = math.sin(radians)\nThe \ufb01rst example uses math.log10 to compute a signal-to-noise ratio in decibels (assuming\nthat signal_power and noise_power are de\ufb01ned). The math module also provides log,\nwhich computes logarithms base e.\nThe second example \ufb01nds the sine of radians. The variable name radians is a hint that\nsin and the other trigonometric functions (cos, tan, etc.) take arguments in radians. To",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_89",
    "text": "The second example \ufb01nds the sine of radians. The variable name radians is a hint that\nsin and the other trigonometric functions (cos, tan, etc.) take arguments in radians. To\nconvert from degrees to radians, divide by 180 and multiply by \u03c0:\n>>> degrees = 45\n>>> radians = degrees / 180.0 * math.pi\n>>> math.sin(radians)\n0.707106781187\nThe expression math.pi gets the variable pi from the math module. Its value is a \ufb02oating-\npoint approximation of \u03c0, accurate to about 15 digits.\nIf you know trigonometry, you can check the previous result by comparing it to the square\nroot of two, divided by two:\n>>> math.sqrt(2) / 2.0\n0.707106781187\n3.3. Composition\n19\n3.3\nComposition\nSo far, we have looked at the elements of a program\u2014variables, expressions, and\nstatements\u2014in isolation, without talking about how to combine them.\nOne of the most useful features of programming languages is their ability to take small\nbuilding blocks and compose them. For example, the argument of a function can be any",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_90",
    "text": "One of the most useful features of programming languages is their ability to take small\nbuilding blocks and compose them. For example, the argument of a function can be any\nkind of expression, including arithmetic operators:\nx = math.sin(degrees / 360.0 * 2 * math.pi)\nAnd even function calls:\nx = math.exp(math.log(x+1))\nAlmost anywhere you can put a value, you can put an arbitrary expression, with one ex-\nception: the left side of an assignment statement has to be a variable name. Any other\nexpression on the left side is a syntax error (we will see exceptions to this rule later).\n>>> minutes = hours * 60\n# right\n>>> hours * 60 = minutes\n# wrong!\nSyntaxError: can't assign to operator\n3.4\nAdding new functions\nSo far, we have only been using the functions that come with Python, but it is also possible\nto add new functions. A function de\ufb01nition speci\ufb01es the name of a new function and the\nsequence of statements that run when the function is called.\nHere is an example:\ndef print_lyrics():",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_91",
    "text": "to add new functions. A function de\ufb01nition speci\ufb01es the name of a new function and the\nsequence of statements that run when the function is called.\nHere is an example:\ndef print_lyrics():\nprint(\"I'm a lumberjack, and I'm okay.\")\nprint(\"I sleep all night and I work all day.\")\ndef is a keyword that indicates that this is a function de\ufb01nition. The name of the function\nis print_lyrics. The rules for function names are the same as for variable names: letters,\nnumbers and underscore are legal, but the \ufb01rst character can\u2019t be a number. You can\u2019t use a\nkeyword as the name of a function, and you should avoid having a variable and a function\nwith the same name.\nThe empty parentheses after the name indicate that this function doesn\u2019t take any argu-\nments.\nThe \ufb01rst line of the function de\ufb01nition is called the header; the rest is called the body. The\nheader has to end with a colon and the body has to be indented. By convention, indentation",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_92",
    "text": "ments.\nThe \ufb01rst line of the function de\ufb01nition is called the header; the rest is called the body. The\nheader has to end with a colon and the body has to be indented. By convention, indentation\nis always four spaces. The body can contain any number of statements.\nThe strings in the print statements are enclosed in double quotes. Single quotes and double\nquotes do the same thing; most people use single quotes except in cases like this where a\nsingle quote (which is also an apostrophe) appears in the string.\nAll quotation marks (single and double) must be \u201cstraight quotes\u201d, usually located next\nto Enter on the keyboard. \u201cCurly quotes\u201d, like the ones in this sentence, are not legal in\nPython.\nIf you type a function de\ufb01nition in interactive mode, the interpreter prints dots (...) to let\nyou know that the de\ufb01nition isn\u2019t complete:\n20\nChapter 3. Functions\n>>> def print_lyrics():\n...\nprint(\"I'm a lumberjack, and I'm okay.\")\n...\nprint(\"I sleep all night and I work all day.\")\n...",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_93",
    "text": "you know that the de\ufb01nition isn\u2019t complete:\n20\nChapter 3. Functions\n>>> def print_lyrics():\n...\nprint(\"I'm a lumberjack, and I'm okay.\")\n...\nprint(\"I sleep all night and I work all day.\")\n...\nTo end the function, you have to enter an empty line.\nDe\ufb01ning a function creates a function object, which has type function:\n>>> print(print_lyrics)\n<function print_lyrics at 0xb7e99e9c>\n>>> type(print_lyrics)\n<class 'function'>\nThe syntax for calling the new function is the same as for built-in functions:\n>>> print_lyrics()\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day.\nOnce you have de\ufb01ned a function, you can use it inside another function. For example, to\nrepeat the previous refrain, we could write a function called repeat_lyrics:\ndef repeat_lyrics():\nprint_lyrics()\nprint_lyrics()\nAnd then call repeat_lyrics:\n>>> repeat_lyrics()\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day.\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_94",
    "text": "And then call repeat_lyrics:\n>>> repeat_lyrics()\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day.\nI'm a lumberjack, and I'm okay.\nI sleep all night and I work all day.\nBut that\u2019s not really how the song goes.\n3.5\nDe\ufb01nitions and uses\nPulling together the code fragments from the previous section, the whole program looks\nlike this:\ndef print_lyrics():\nprint(\"I'm a lumberjack, and I'm okay.\")\nprint(\"I sleep all night and I work all day.\")\ndef repeat_lyrics():\nprint_lyrics()\nprint_lyrics()\nrepeat_lyrics()\nThis program contains two function de\ufb01nitions: print_lyrics and repeat_lyrics. Func-\ntion de\ufb01nitions get executed just like other statements, but the effect is to create function\nobjects. The statements inside the function do not run until the function is called, and the\nfunction de\ufb01nition generates no output.\n3.6. Flow of execution\n21\nAs you might expect, you have to create a function before you can run it. In other words,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_95",
    "text": "function de\ufb01nition generates no output.\n3.6. Flow of execution\n21\nAs you might expect, you have to create a function before you can run it. In other words,\nthe function de\ufb01nition has to run before the function gets called.\nAs an exercise, move the last line of this program to the top, so the function call appears\nbefore the de\ufb01nitions. Run the program and see what error message you get.\nNow move the function call back to the bottom and move the de\ufb01nition of print_lyrics\nafter the de\ufb01nition of repeat_lyrics. What happens when you run this program?\n3.6\nFlow of execution\nTo ensure that a function is de\ufb01ned before its \ufb01rst use, you have to know the order state-\nments run in, which is called the \ufb02ow of execution.\nExecution always begins at the \ufb01rst statement of the program. Statements are run one at a\ntime, in order from top to bottom.\nFunction de\ufb01nitions do not alter the \ufb02ow of execution of the program, but remember that",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_96",
    "text": "time, in order from top to bottom.\nFunction de\ufb01nitions do not alter the \ufb02ow of execution of the program, but remember that\nstatements inside the function don\u2019t run until the function is called.\nA function call is like a detour in the \ufb02ow of execution. Instead of going to the next state-\nment, the \ufb02ow jumps to the body of the function, runs the statements there, and then comes\nback to pick up where it left off.\nThat sounds simple enough, until you remember that one function can call another. While\nin the middle of one function, the program might have to run the statements in another\nfunction. Then, while running that new function, the program might have to run yet an-\nother function!\nFortunately, Python is good at keeping track of where it is, so each time a function com-\npletes, the program picks up where it left off in the function that called it. When it gets to\nthe end of the program, it terminates.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_97",
    "text": "pletes, the program picks up where it left off in the function that called it. When it gets to\nthe end of the program, it terminates.\nIn summary, when you read a program, you don\u2019t always want to read from top to bottom.\nSometimes it makes more sense if you follow the \ufb02ow of execution.\n3.7\nParameters and arguments\nSome of the functions we have seen require arguments.\nFor example, when you call\nmath.sin you pass a number as an argument. Some functions take more than one ar-\ngument: math.pow takes two, the base and the exponent.\nInside the function, the arguments are assigned to variables called parameters. Here is a\nde\ufb01nition for a function that takes an argument:\ndef print_twice(bruce):\nprint(bruce)\nprint(bruce)\nThis function assigns the argument to a parameter named bruce. When the function is\ncalled, it prints the value of the parameter (whatever it is) twice.\nThis function works with any value that can be printed.\n22\nChapter 3. Functions\n>>> print_twice('Spam')\nSpam\nSpam",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_98",
    "text": "called, it prints the value of the parameter (whatever it is) twice.\nThis function works with any value that can be printed.\n22\nChapter 3. Functions\n>>> print_twice('Spam')\nSpam\nSpam\n>>> print_twice(42)\n42\n42\n>>> print_twice(math.pi)\n3.14159265359\n3.14159265359\nThe same rules of composition that apply to built-in functions also apply to programmer-\nde\ufb01ned functions, so we can use any kind of expression as an argument for print_twice:\n>>> print_twice('Spam '*4)\nSpam Spam Spam Spam\nSpam Spam Spam Spam\n>>> print_twice(math.cos(math.pi))\n-1.0\n-1.0\nThe argument is evaluated before the function is called, so in the examples the expressions\n'Spam '*4 and math.cos(math.pi) are only evaluated once.\nYou can also use a variable as an argument:\n>>> michael = 'Eric, the half a bee.'\n>>> print_twice(michael)\nEric, the half a bee.\nEric, the half a bee.\nThe name of the variable we pass as an argument (michael) has nothing to do with the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_99",
    "text": ">>> michael = 'Eric, the half a bee.'\n>>> print_twice(michael)\nEric, the half a bee.\nEric, the half a bee.\nThe name of the variable we pass as an argument (michael) has nothing to do with the\nname of the parameter (bruce). It doesn\u2019t matter what the value was called back home (in\nthe caller); here in print_twice, we call everybody bruce.\n3.8\nVariables and parameters are local\nWhen you create a variable inside a function, it is local, which means that it only exists\ninside the function. For example:\ndef cat_twice(part1, part2):\ncat = part1 + part2\nprint_twice(cat)\nThis function takes two arguments, concatenates them, and prints the result twice. Here is\nan example that uses it:\n>>> line1 = 'Bing tiddle '\n>>> line2 = 'tiddle bang.'\n>>> cat_twice(line1, line2)\nBing tiddle tiddle bang.\nBing tiddle tiddle bang.\nWhen cat_twice terminates, the variable cat is destroyed. If we try to print it, we get an\nexception:\n3.9. Stack diagrams\n23\nline1\nline2\n\u2019tiddle bang.\u2019\npart1\npart2\ncat\nbruce",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_100",
    "text": "Bing tiddle tiddle bang.\nWhen cat_twice terminates, the variable cat is destroyed. If we try to print it, we get an\nexception:\n3.9. Stack diagrams\n23\nline1\nline2\n\u2019tiddle bang.\u2019\npart1\npart2\ncat\nbruce\n\u2019Bing tiddle \u2019\n\u2019Bing tiddle \u2019\n\u2019tiddle bang.\u2019\n\u2019Bing tiddle tiddle bang.\u2019\n\u2019Bing tiddle tiddle bang.\u2019\ncat_twice\nprint_twice\n__main__\nFigure 3.1: Stack diagram.\n>>> print(cat)\nNameError: name 'cat' is not defined\nParameters are also local. For example, outside print_twice, there is no such thing as\nbruce.\n3.9\nStack diagrams\nTo keep track of which variables can be used where, it is sometimes useful to draw a stack\ndiagram. Like state diagrams, stack diagrams show the value of each variable, but they\nalso show the function each variable belongs to.\nEach function is represented by a frame. A frame is a box with the name of a function\nbeside it and the parameters and variables of the function inside it. The stack diagram for\nthe previous example is shown in Figure 3.1.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_101",
    "text": "beside it and the parameters and variables of the function inside it. The stack diagram for\nthe previous example is shown in Figure 3.1.\nThe frames are arranged in a stack that indicates which function called which, and so\non. In this example, print_twice was called by cat_twice, and cat_twice was called\nby __main__, which is a special name for the topmost frame. When you create a variable\noutside of any function, it belongs to __main__.\nEach parameter refers to the same value as its corresponding argument. So, part1 has the\nsame value as line1, part2 has the same value as line2, and bruce has the same value as\ncat.\nIf an error occurs during a function call, Python prints the name of the function, the name\nof the function that called it, and the name of the function that called that, all the way back\nto __main__.\nFor example, if you try to access cat from within print_twice, you get a NameError:\nTraceback (innermost last):\nFile \"test.py\", line 13, in __main__\ncat_twice(line1, line2)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_102",
    "text": "to __main__.\nFor example, if you try to access cat from within print_twice, you get a NameError:\nTraceback (innermost last):\nFile \"test.py\", line 13, in __main__\ncat_twice(line1, line2)\nFile \"test.py\", line 5, in cat_twice\nprint_twice(cat)\nFile \"test.py\", line 9, in print_twice\nprint(cat)\nNameError: name 'cat' is not defined\n24\nChapter 3. Functions\nThis list of functions is called a traceback. It tells you what program \ufb01le the error occurred\nin, and what line, and what functions were executing at the time. It also shows the line of\ncode that caused the error.\nThe order of the functions in the traceback is the same as the order of the frames in the\nstack diagram. The function that is currently running is at the bottom.\n3.10\nFruitful functions and void functions\nSome of the functions we have used, such as the math functions, return results; for lack of\na better name, I call them fruitful functions. Other functions, like print_twice, perform",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_103",
    "text": "Some of the functions we have used, such as the math functions, return results; for lack of\na better name, I call them fruitful functions. Other functions, like print_twice, perform\nan action but don\u2019t return a value. They are called void functions.\nWhen you call a fruitful function, you almost always want to do something with the result;\nfor example, you might assign it to a variable or use it as part of an expression:\nx = math.cos(radians)\ngolden = (math.sqrt(5) + 1) / 2\nWhen you call a function in interactive mode, Python displays the result:\n>>> math.sqrt(5)\n2.2360679774997898\nBut in a script, if you call a fruitful function all by itself, the return value is lost forever!\nmath.sqrt(5)\nThis script computes the square root of 5, but since it doesn\u2019t store or display the result, it\nis not very useful.\nVoid functions might display something on the screen or have some other effect, but they\ndon\u2019t have a return value. If you assign the result to a variable, you get a special value",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_104",
    "text": "is not very useful.\nVoid functions might display something on the screen or have some other effect, but they\ndon\u2019t have a return value. If you assign the result to a variable, you get a special value\ncalled None.\n>>> result = print_twice('Bing')\nBing\nBing\n>>> print(result)\nNone\nThe value None is not the same as the string 'None'. It is a special value that has its own\ntype:\n>>> type(None)\n<class 'NoneType'>\nThe functions we have written so far are all void. We will start writing fruitful functions in\na few chapters.\n3.11\nWhy functions?\nIt may not be clear why it is worth the trouble to divide a program into functions. There\nare several reasons:\n3.12. Debugging\n25\n\u2022 Creating a new function gives you an opportunity to name a group of statements,\nwhich makes your program easier to read and debug.\n\u2022 Functions can make a program smaller by eliminating repetitive code. Later, if you\nmake a change, you only have to make it in one place.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_105",
    "text": "which makes your program easier to read and debug.\n\u2022 Functions can make a program smaller by eliminating repetitive code. Later, if you\nmake a change, you only have to make it in one place.\n\u2022 Dividing a long program into functions allows you to debug the parts one at a time\nand then assemble them into a working whole.\n\u2022 Well-designed functions are often useful for many programs. Once you write and\ndebug one, you can reuse it.\n3.12\nDebugging\nOne of the most important skills you will acquire is debugging. Although it can be frus-\ntrating, debugging is one of the most intellectually rich, challenging, and interesting parts\nof programming.\nIn some ways debugging is like detective work. You are confronted with clues and you\nhave to infer the processes and events that led to the results you see.\nDebugging is also like an experimental science. Once you have an idea about what is going\nwrong, you modify your program and try again. If your hypothesis was correct, you can",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_106",
    "text": "Debugging is also like an experimental science. Once you have an idea about what is going\nwrong, you modify your program and try again. If your hypothesis was correct, you can\npredict the result of the modi\ufb01cation, and you take a step closer to a working program. If\nyour hypothesis was wrong, you have to come up with a new one. As Sherlock Holmes\npointed out, \u201cWhen you have eliminated the impossible, whatever remains, however im-\nprobable, must be the truth.\u201d (A. Conan Doyle, The Sign of Four)\nFor some people, programming and debugging are the same thing. That is, programming\nis the process of gradually debugging a program until it does what you want. The idea is\nthat you should start with a working program and make small modi\ufb01cations, debugging\nthem as you go.\nFor example, Linux is an operating system that contains millions of lines of code, but it\nstarted out as a simple program Linus Torvalds used to explore the Intel 80386 chip. Ac-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_107",
    "text": "them as you go.\nFor example, Linux is an operating system that contains millions of lines of code, but it\nstarted out as a simple program Linus Torvalds used to explore the Intel 80386 chip. Ac-\ncording to Larry Green\ufb01eld, \u201cOne of Linus\u2019s earlier projects was a program that would\nswitch between printing AAAA and BBBB. This later evolved to Linux.\u201d (The Linux Users\u2019\nGuide Beta Version 1).\n3.13\nGlossary\nfunction: A named sequence of statements that performs some useful operation. Func-\ntions may or may not take arguments and may or may not produce a result.\nfunction de\ufb01nition: A statement that creates a new function, specifying its name, param-\neters, and the statements it contains.\nfunction object: A value created by a function de\ufb01nition. The name of the function is a\nvariable that refers to a function object.\nheader: The \ufb01rst line of a function de\ufb01nition.\n26\nChapter 3. Functions\nbody: The sequence of statements inside a function de\ufb01nition.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_108",
    "text": "variable that refers to a function object.\nheader: The \ufb01rst line of a function de\ufb01nition.\n26\nChapter 3. Functions\nbody: The sequence of statements inside a function de\ufb01nition.\nparameter: A name used inside a function to refer to the value passed as an argument.\nfunction call: A statement that runs a function. It consists of the function name followed\nby an argument list in parentheses.\nargument: A value provided to a function when the function is called. This value is as-\nsigned to the corresponding parameter in the function.\nlocal variable: A variable de\ufb01ned inside a function. A local variable can only be used\ninside its function.\nreturn value: The result of a function. If a function call is used as an expression, the return\nvalue is the value of the expression.\nfruitful function: A function that returns a value.\nvoid function: A function that always returns None.\nNone: A special value returned by void functions.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_109",
    "text": "value is the value of the expression.\nfruitful function: A function that returns a value.\nvoid function: A function that always returns None.\nNone: A special value returned by void functions.\nmodule: A \ufb01le that contains a collection of related functions and other de\ufb01nitions.\nimport statement: A statement that reads a module \ufb01le and creates a module object.\nmodule object: A value created by an import statement that provides access to the values\nde\ufb01ned in a module.\ndot notation: The syntax for calling a function in another module by specifying the mod-\nule name followed by a dot (period) and the function name.\ncomposition: Using an expression as part of a larger expression, or a statement as part of\na larger statement.\n\ufb02ow of execution: The order statements run in.\nstack diagram: A graphical representation of a stack of functions, their variables, and the\nvalues they refer to.\nframe: A box in a stack diagram that represents a function call. It contains the local vari-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_110",
    "text": "values they refer to.\nframe: A box in a stack diagram that represents a function call. It contains the local vari-\nables and parameters of the function.\ntraceback: A list of the functions that are executing, printed when an exception occurs.\n3.14\nExercises\nExercise 3.1. Write a function named right_justify that takes a string named s as a parameter\nand prints the string with enough leading spaces so that the last letter of the string is in column 70\nof the display.\n>>> right_justify('monty')\nmonty\nHint: Use string concatenation and repetition. Also, Python provides a built-in function called len\nthat returns the length of a string, so the value of len('monty') is 5.\n3.14. Exercises\n27\nExercise 3.2. A function object is a value you can assign to a variable or pass as an argument. For\nexample, do_twice is a function that takes a function object as an argument and calls it twice:\ndef do_twice(f):\nf()\nf()\nHere\u2019s an example that uses do_twice to call a function named print_spam twice.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_111",
    "text": "example, do_twice is a function that takes a function object as an argument and calls it twice:\ndef do_twice(f):\nf()\nf()\nHere\u2019s an example that uses do_twice to call a function named print_spam twice.\ndef print_spam():\nprint('spam')\ndo_twice(print_spam)\n1. Type this example into a script and test it.\n2. Modify do_twice so that it takes two arguments, a function object and a value, and calls the\nfunction twice, passing the value as an argument.\n3. Copy the de\ufb01nition of print_twice from earlier in this chapter to your script.\n4. Use the modi\ufb01ed version of do_twice to call print_twice twice, passing 'spam' as an\nargument.\n5. De\ufb01ne a new function called do_four that takes a function object and a value and calls the\nfunction four times, passing the value as a parameter. There should be only two statements in\nthe body of this function, not four.\nSolution: https: // thinkpython. com/ code/ do_ four. py .",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_112",
    "text": "function four times, passing the value as a parameter. There should be only two statements in\nthe body of this function, not four.\nSolution: https: // thinkpython. com/ code/ do_ four. py .\nExercise 3.3. Note: This exercise should be done using only the statements and other features we\nhave learned so far.\n1. Write a function that draws a grid like the following:\n+ - - - - + - - - - +\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n+ - - - - + - - - - +\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n+ - - - - + - - - - +\nHint: to print more than one value on a line, you can print a comma-separated sequence of\nvalues:\nprint('+', '-')\nBy default, print advances to the next line, but you can override that behavior and put a\nspace at the end, like this:\nprint('+', end=' ')\nprint('-')\n28\nChapter 3. Functions\nThe output of these statements is '+ -' on the same line. The output from the next print\nstatement would begin on the next line.\n2. Write a function that draws a similar grid with four rows and four columns.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_113",
    "text": "statement would begin on the next line.\n2. Write a function that draws a similar grid with four rows and four columns.\nSolution: https: // thinkpython. com/ code/ grid. py . Credit: This exercise is based on an\nexercise in Oualline, Practical C Programming, Third Edition, O\u2019Reilly Media, 1997.\nChapter 4\nCase study: interface design\nThis chapter presents a case study that demonstrates a process for designing functions that\nwork together.\nIt introduces the turtle module, which allows you to create images using turtle graphics.\nThe turtle module is included in most Python installations, but if you are running Python\nusing PythonAnywhere, you won\u2019t be able to run the turtle examples (at least you couldn\u2019t\nwhen I wrote this).\nIf you have already installed Python on your computer, you should be able to run the\nexamples. Otherwise, now is a good time to install. I have posted instructions at http:\n//tinyurl.com/thinkpython2e.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_114",
    "text": "examples. Otherwise, now is a good time to install. I have posted instructions at http:\n//tinyurl.com/thinkpython2e.\nCode examples from this chapter are available from https://thinkpython.com/code/\npolygon.py.\n4.1\nThe turtle module\nTo check whether you have the turtle module, open the Python interpreter and type\n>>> import turtle\n>>> bob = turtle.Turtle()\nWhen you run this code, it should create a new window with small arrow that represents\nthe turtle. Close the window.\nCreate a \ufb01le named mypolygon.py and type in the following code:\nimport turtle\nbob = turtle.Turtle()\nprint(bob)\nturtle.mainloop()\nThe turtle module (with a lowercase \u2019t\u2019) provides a function called Turtle (with an up-\npercase \u2019T\u2019) that creates a Turtle object, which we assign to a variable named bob. Printing\nbob displays something like:\n<turtle.Turtle object at 0xb7bfbf4c>\n30\nChapter 4. Case study: interface design\nThis means that bob refers to an object with type Turtle as de\ufb01ned in module turtle.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_115",
    "text": "bob displays something like:\n<turtle.Turtle object at 0xb7bfbf4c>\n30\nChapter 4. Case study: interface design\nThis means that bob refers to an object with type Turtle as de\ufb01ned in module turtle.\nmainloop tells the window to wait for the user to do something, although in this case\nthere\u2019s not much for the user to do except close the window.\nOnce you create a Turtle, you can call a method to move it around the window. A method\nis similar to a function, but it uses slightly different syntax. For example, to move the turtle\nforward:\nbob.fd(100)\nThe method, fd, is associated with the turtle object we\u2019re calling bob. Calling a method is\nlike making a request: you are asking bob to move forward.\nThe argument of fd is a distance in pixels, so the actual size depends on your display.\nOther methods you can call on a Turtle are bk to move backward, lt for left turn, and rt\nright turn. The argument for lt and rt is an angle in degrees.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_116",
    "text": "Other methods you can call on a Turtle are bk to move backward, lt for left turn, and rt\nright turn. The argument for lt and rt is an angle in degrees.\nAlso, each Turtle is holding a pen, which is either down or up; if the pen is down, the Turtle\nleaves a trail when it moves. The methods pu and pd stand for \u201cpen up\u201d and \u201cpen down\u201d.\nTo draw a right angle, add these lines to the program (after creating bob and before calling\nmainloop):\nbob.fd(100)\nbob.lt(90)\nbob.fd(100)\nWhen you run this program, you should see bob move east and then north, leaving two\nline segments behind.\nNow modify the program to draw a square. Don\u2019t go on until you\u2019ve got it working!\n4.2\nSimple repetition\nChances are you wrote something like this:\nbob.fd(100)\nbob.lt(90)\nbob.fd(100)\nbob.lt(90)\nbob.fd(100)\nbob.lt(90)\nbob.fd(100)\nWe can do the same thing more concisely with a for statement. Add this example to\nmypolygon.py and run it again:\nfor i in range(4):\nprint('Hello!')\nYou should see something like this:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_117",
    "text": "bob.fd(100)\nWe can do the same thing more concisely with a for statement. Add this example to\nmypolygon.py and run it again:\nfor i in range(4):\nprint('Hello!')\nYou should see something like this:\n4.3. Exercises\n31\nHello!\nHello!\nHello!\nHello!\nThis is the simplest use of the for statement; we will see more later. But that should be\nenough to let you rewrite your square-drawing program. Don\u2019t go on until you do.\nHere is a for statement that draws a square:\nfor i in range(4):\nbob.fd(100)\nbob.lt(90)\nThe syntax of a for statement is similar to a function de\ufb01nition. It has a header that ends\nwith a colon and an indented body. The body can contain any number of statements.\nA for statement is also called a loop because the \ufb02ow of execution runs through the body\nand then loops back to the top. In this case, it runs the body four times.\nThis version is actually a little different from the previous square-drawing code because it",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_118",
    "text": "and then loops back to the top. In this case, it runs the body four times.\nThis version is actually a little different from the previous square-drawing code because it\nmakes another turn after drawing the last side of the square. The extra turn takes more\ntime, but it simpli\ufb01es the code if we do the same thing every time through the loop. This\nversion also has the effect of leaving the turtle back in the starting position, facing in the\nstarting direction.\n4.3\nExercises\nThe following is a series of exercises using the turtle module. They are meant to be fun,\nbut they have a point, too. While you are working on them, think about what the point is.\nThe following sections have solutions to the exercises, so don\u2019t look until you have \ufb01nished\n(or at least tried).\n1. Write a function called square that takes a parameter named t, which is a turtle. It\nshould use the turtle to draw a square.\nWrite a function call that passes bob as an argument to square, and then run the\nprogram again.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_119",
    "text": "should use the turtle to draw a square.\nWrite a function call that passes bob as an argument to square, and then run the\nprogram again.\n2. Add another parameter, named length, to square. Modify the body so length of the\nsides is length, and then modify the function call to provide a second argument. Run\nthe program again. Test your program with a range of values for length.\n3. Make a copy of square and change the name to polygon. Add another parameter\nnamed n and modify the body so it draws an n-sided regular polygon. Hint: The\nexterior angles of an n-sided regular polygon are 360/n degrees.\n4. Write a function called circle that takes a turtle, t, and radius, r, as parameters and\nthat draws an approximate circle by calling polygon with an appropriate length and\nnumber of sides. Test your function with a range of values of r.\nHint: \ufb01gure out the circumference of the circle and make sure that length * n =\ncircumference.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_120",
    "text": "number of sides. Test your function with a range of values of r.\nHint: \ufb01gure out the circumference of the circle and make sure that length * n =\ncircumference.\n5. Make a more general version of circle called arc that takes an additional parameter\nangle, which determines what fraction of a circle to draw. angle is in units of degrees,\nso when angle=360, arc should draw a complete circle.\n32\nChapter 4. Case study: interface design\n4.4\nEncapsulation\nThe \ufb01rst exercise asks you to put your square-drawing code into a function de\ufb01nition and\nthen call the function, passing the turtle as a parameter. Here is a solution:\ndef square(t):\nfor i in range(4):\nt.fd(100)\nt.lt(90)\nsquare(bob)\nThe innermost statements, fd and lt are indented twice to show that they are inside the\nfor loop, which is inside the function de\ufb01nition. The next line, square(bob), is \ufb02ush with\nthe left margin, which indicates the end of both the for loop and the function de\ufb01nition.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_121",
    "text": "for loop, which is inside the function de\ufb01nition. The next line, square(bob), is \ufb02ush with\nthe left margin, which indicates the end of both the for loop and the function de\ufb01nition.\nInside the function, t refers to the same turtle bob, so t.lt(90) has the same effect as\nbob.lt(90). In that case, why not call the parameter bob? The idea is that t can be any\nturtle, not just bob, so you could create a second turtle and pass it as an argument to square:\nalice = turtle.Turtle()\nsquare(alice)\nWrapping a piece of code up in a function is called encapsulation. One of the bene\ufb01ts of\nencapsulation is that it attaches a name to the code, which serves as a kind of documenta-\ntion. Another advantage is that if you re-use the code, it is more concise to call a function\ntwice than to copy and paste the body!\n4.5\nGeneralization\nThe next step is to add a length parameter to square. Here is a solution:\ndef square(t, length):\nfor i in range(4):\nt.fd(length)\nt.lt(90)\nsquare(bob, 100)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_122",
    "text": "4.5\nGeneralization\nThe next step is to add a length parameter to square. Here is a solution:\ndef square(t, length):\nfor i in range(4):\nt.fd(length)\nt.lt(90)\nsquare(bob, 100)\nAdding a parameter to a function is called generalization because it makes the function\nmore general: in the previous version, the square is always the same size; in this version it\ncan be any size.\nThe next step is also a generalization. Instead of drawing squares, polygon draws regular\npolygons with any number of sides. Here is a solution:\ndef polygon(t, n, length):\nangle = 360 / n\nfor i in range(n):\nt.fd(length)\nt.lt(angle)\npolygon(bob, 7, 70)\n4.6. Interface design\n33\nThis example draws a 7-sided polygon with side length 70.\nIf you are using Python 2, the value of angle might be off because of integer division. A\nsimple solution is to compute angle = 360.0 / n. Because the numerator is a \ufb02oating-\npoint number, the result is \ufb02oating point.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_123",
    "text": "simple solution is to compute angle = 360.0 / n. Because the numerator is a \ufb02oating-\npoint number, the result is \ufb02oating point.\nWhen a function has more than a few numeric arguments, it is easy to forget what they are,\nor what order they should be in. In that case it is often a good idea to include the names of\nthe parameters in the argument list:\npolygon(bob, n=7, length=70)\nThese are called keyword arguments because they include the parameter names as \u201ckey-\nwords\u201d (not to be confused with Python keywords like while and def).\nThis syntax makes the program more readable. It is also a reminder about how arguments\nand parameters work: when you call a function, the arguments are assigned to the param-\neters.\n4.6\nInterface design\nThe next step is to write circle, which takes a radius, r, as a parameter. Here is a simple\nsolution that uses polygon to draw a 50-sided polygon:\nimport math\ndef circle(t, r):\ncircumference = 2 * math.pi * r\nn = 50\nlength = circumference / n\npolygon(t, n, length)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_124",
    "text": "solution that uses polygon to draw a 50-sided polygon:\nimport math\ndef circle(t, r):\ncircumference = 2 * math.pi * r\nn = 50\nlength = circumference / n\npolygon(t, n, length)\nThe \ufb01rst line computes the circumference of a circle with radius r using the formula 2\u03c0r.\nSince we use math.pi, we have to import math. By convention, import statements are\nusually at the beginning of the script.\nn is the number of line segments in our approximation of a circle, so length is the length\nof each segment. Thus, polygon draws a 50-sided polygon that approximates a circle with\nradius r.\nOne limitation of this solution is that n is a constant, which means that for very big circles,\nthe line segments are too long, and for small circles, we waste time drawing very small\nsegments. One solution would be to generalize the function by taking n as a parameter.\nThis would give the user (whoever calls circle) more control, but the interface would be\nless clean.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_125",
    "text": "segments. One solution would be to generalize the function by taking n as a parameter.\nThis would give the user (whoever calls circle) more control, but the interface would be\nless clean.\nThe interface of a function is a summary of how it is used: what are the parameters? What\ndoes the function do? And what is the return value? An interface is \u201cclean\u201d if it allows the\ncaller to do what they want without dealing with unnecessary details.\nIn this example, r belongs in the interface because it speci\ufb01es the circle to be drawn. n is\nless appropriate because it pertains to the details of how the circle should be rendered.\nRather than clutter up the interface, it is better to choose an appropriate value of n depend-\ning on circumference:\n34\nChapter 4. Case study: interface design\ndef circle(t, r):\ncircumference = 2 * math.pi * r\nn = int(circumference / 3) + 3\nlength = circumference / n\npolygon(t, n, length)\nNow the number of segments is an integer near circumference/3, so the length of each",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_126",
    "text": "circumference = 2 * math.pi * r\nn = int(circumference / 3) + 3\nlength = circumference / n\npolygon(t, n, length)\nNow the number of segments is an integer near circumference/3, so the length of each\nsegment is approximately 3, which is small enough that the circles look good, but big\nenough to be ef\ufb01cient, and acceptable for any size circle.\nAdding 3 to n guarantees that the polygon has at least 3 sides.\n4.7\nRefactoring\nWhen I wrote circle, I was able to re-use polygon because a many-sided polygon is a good\napproximation of a circle. But arc is not as cooperative; we can\u2019t use polygon or circle to\ndraw an arc.\nOne alternative is to start with a copy of polygon and transform it into arc. The result\nmight look like this:\ndef arc(t, r, angle):\narc_length = 2 * math.pi * r * angle / 360\nn = int(arc_length / 3) + 1\nstep_length = arc_length / n\nstep_angle = angle / n\nfor i in range(n):\nt.fd(step_length)\nt.lt(step_angle)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_127",
    "text": "def arc(t, r, angle):\narc_length = 2 * math.pi * r * angle / 360\nn = int(arc_length / 3) + 1\nstep_length = arc_length / n\nstep_angle = angle / n\nfor i in range(n):\nt.fd(step_length)\nt.lt(step_angle)\nThe second half of this function looks like polygon, but we can\u2019t re-use polygon without\nchanging the interface. We could generalize polygon to take an angle as a third argument,\nbut then polygon would no longer be an appropriate name! Instead, let\u2019s call the more\ngeneral function polyline:\ndef polyline(t, n, length, angle):\nfor i in range(n):\nt.fd(length)\nt.lt(angle)\nNow we can rewrite polygon and arc to use polyline:\ndef polygon(t, n, length):\nangle = 360.0 / n\npolyline(t, n, length, angle)\ndef arc(t, r, angle):\narc_length = 2 * math.pi * r * angle / 360\nn = int(arc_length / 3) + 1\nstep_length = arc_length / n\nstep_angle = float(angle) / n\npolyline(t, n, step_length, step_angle)\nFinally, we can rewrite circle to use arc:\n4.8. A development plan\n35\ndef circle(t, r):\narc(t, r, 360)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_128",
    "text": "step_angle = float(angle) / n\npolyline(t, n, step_length, step_angle)\nFinally, we can rewrite circle to use arc:\n4.8. A development plan\n35\ndef circle(t, r):\narc(t, r, 360)\nThis process\u2014rearranging a program to improve interfaces and facilitate code re-use\u2014is\ncalled refactoring. In this case, we noticed that there was similar code in arc and polygon,\nso we \u201cfactored it out\u201d into polyline.\nIf we had planned ahead, we might have written polyline \ufb01rst and avoided refactoring,\nbut often you don\u2019t know enough at the beginning of a project to design all the interfaces.\nOnce you start coding, you understand the problem better. Sometimes refactoring is a sign\nthat you have learned something.\n4.8\nA development plan\nA development plan is a process for writing programs. The process we used in this case\nstudy is \u201cencapsulation and generalization\u201d. The steps of this process are:\n1. Start by writing a small program with no function de\ufb01nitions.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_129",
    "text": "study is \u201cencapsulation and generalization\u201d. The steps of this process are:\n1. Start by writing a small program with no function de\ufb01nitions.\n2. Once you get the program working, identify a coherent piece of it, encapsulate the\npiece in a function and give it a name.\n3. Generalize the function by adding appropriate parameters.\n4. Repeat steps 1\u20133 until you have a set of working functions. Copy and paste working\ncode to avoid retyping (and re-debugging).\n5. Look for opportunities to improve the program by refactoring. For example, if you\nhave similar code in several places, consider factoring it into an appropriately general\nfunction.\nThis process has some drawbacks\u2014we will see alternatives later\u2014but it can be useful if\nyou don\u2019t know ahead of time how to divide the program into functions. This approach\nlets you design as you go along.\n4.9\ndocstring\nA docstring is a string at the beginning of a function that explains the interface (\u201cdoc\u201d is\nshort for \u201cdocumentation\u201d). Here is an example:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_130",
    "text": "lets you design as you go along.\n4.9\ndocstring\nA docstring is a string at the beginning of a function that explains the interface (\u201cdoc\u201d is\nshort for \u201cdocumentation\u201d). Here is an example:\ndef polyline(t, n, length, angle):\n\"\"\"Draws n line segments with the given length and\nangle (in degrees) between them.\nt is a turtle.\n\"\"\"\nfor i in range(n):\nt.fd(length)\nt.lt(angle)\nBy convention, all docstrings are triple-quoted strings, also known as multiline strings\nbecause the triple quotes allow the string to span more than one line.\n36\nChapter 4. Case study: interface design\nIt is terse, but it contains the essential information someone would need to use this func-\ntion. It explains concisely what the function does (without getting into the details of how\nit does it). It explains what effect each parameter has on the behavior of the function and\nwhat type each parameter should be (if it is not obvious).\nWriting this kind of documentation is an important part of interface design.\nA well-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_131",
    "text": "what type each parameter should be (if it is not obvious).\nWriting this kind of documentation is an important part of interface design.\nA well-\ndesigned interface should be simple to explain; if you have a hard time explaining one\nof your functions, maybe the interface could be improved.\n4.10\nDebugging\nAn interface is like a contract between a function and a caller. The caller agrees to provide\ncertain parameters and the function agrees to do certain work.\nFor example, polyline requires four arguments: t has to be a Turtle; n has to be an integer;\nlength should be a positive number; and angle has to be a number, which is understood\nto be in degrees.\nThese requirements are called preconditions because they are supposed to be true before\nthe function starts executing. Conversely, conditions at the end of the function are post-\nconditions. Postconditions include the intended effect of the function (like drawing line",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_132",
    "text": "the function starts executing. Conversely, conditions at the end of the function are post-\nconditions. Postconditions include the intended effect of the function (like drawing line\nsegments) and any side effects (like moving the Turtle or making other changes).\nPreconditions are the responsibility of the caller. If the caller violates a (properly docu-\nmented!) precondition and the function doesn\u2019t work correctly, the bug is in the caller, not\nthe function.\nIf the preconditions are satis\ufb01ed and the postconditions are not, the bug is in the function.\nIf your pre- and postconditions are clear, they can help with debugging.\n4.11\nGlossary\nmethod: A function that is associated with an object and called using dot notation.\nloop: A part of a program that can run repeatedly.\nencapsulation: The process of transforming a sequence of statements into a function de\ufb01-\nnition.\ngeneralization: The process of replacing something unnecessarily speci\ufb01c (like a number)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_133",
    "text": "encapsulation: The process of transforming a sequence of statements into a function de\ufb01-\nnition.\ngeneralization: The process of replacing something unnecessarily speci\ufb01c (like a number)\nwith something appropriately general (like a variable or parameter).\nkeyword argument: An argument that includes the name of the parameter as a \u201ckey-\nword\u201d.\ninterface: A description of how to use a function, including the name and descriptions of\nthe arguments and return value.\nrefactoring: The process of modifying a working program to improve function interfaces\nand other qualities of the code.\ndevelopment plan: A process for writing programs.\n4.12. Exercises\n37\nFigure 4.1: Turtle \ufb02owers.\nFigure 4.2: Turtle pies.\ndocstring: A string that appears at the top of a function de\ufb01nition to document the func-\ntion\u2019s interface.\nprecondition: A requirement that should be satis\ufb01ed by the caller before a function starts.\npostcondition: A requirement that should be satis\ufb01ed by the function before it ends.\n4.12",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_134",
    "text": "tion\u2019s interface.\nprecondition: A requirement that should be satis\ufb01ed by the caller before a function starts.\npostcondition: A requirement that should be satis\ufb01ed by the function before it ends.\n4.12\nExercises\nExercise 4.1. Download the code in this chapter from https: // thinkpython. com/ code/\npolygon. py .\n1. Draw a stack diagram that shows the state of the program while executing circle(bob,\nradius). You can do the arithmetic by hand or add print statements to the code.\n2. The version of arc in Section 4.7 is not very accurate because the linear approximation of the\ncircle is always outside the true circle. As a result, the Turtle ends up a few pixels away from\nthe correct destination. My solution shows a way to reduce the effect of this error. Read the\ncode and see if it makes sense to you. If you draw a diagram, you might see how it works.\nExercise 4.2. Write an appropriately general set of functions that can draw \ufb02owers as in Figure 4.1.\nSolution:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_135",
    "text": "code and see if it makes sense to you. If you draw a diagram, you might see how it works.\nExercise 4.2. Write an appropriately general set of functions that can draw \ufb02owers as in Figure 4.1.\nSolution:\nhttps: // thinkpython. com/ code/ flower. py ,\nalso\nrequires\nhttps:\n// thinkpython. com/ code/ polygon. py .\nExercise 4.3. Write an appropriately general set of functions that can draw shapes as in Figure 4.2.\nSolution: https: // thinkpython. com/ code/ pie. py .\nExercise 4.4. The letters of the alphabet can be constructed from a moderate number of basic ele-\nments, like vertical and horizontal lines and a few curves. Design an alphabet that can be drawn\nwith a minimal number of basic elements and then write functions that draw the letters.\nYou should write one function for each letter, with names draw_a, draw_b, etc., and put your\nfunctions in a \ufb01le named letters.py. You can download a \u201cturtle typewriter\u201d from https:\n// thinkpython. com/ code/ typewriter. py to help you test your code.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_136",
    "text": "functions in a \ufb01le named letters.py. You can download a \u201cturtle typewriter\u201d from https:\n// thinkpython. com/ code/ typewriter. py to help you test your code.\n38\nChapter 4. Case study: interface design\nYou can get a solution from https: // thinkpython. com/ code/ letters. py ; it also requires\nhttps: // thinkpython. com/ code/ polygon. py .\nExercise 4.5. Read about spirals at http: // en. wikipedia. org/ wiki/ Spiral ; then write\na program that draws an Archimedian spiral (or one of the other kinds). Solution: https: //\nthinkpython. com/ code/ spiral. py .\nChapter 5\nConditionals and recursion\nThe main topic of this chapter is the if statement, which executes different code depending\non the state of the program. But \ufb01rst I want to introduce two new operators: \ufb02oor division\nand modulus.\n5.1\nFloor division and modulus\nThe \ufb02oor division operator, //, divides two numbers and rounds down to an integer. For\nexample, suppose the run time of a movie is 105 minutes. You might want to know how",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_137",
    "text": "Floor division and modulus\nThe \ufb02oor division operator, //, divides two numbers and rounds down to an integer. For\nexample, suppose the run time of a movie is 105 minutes. You might want to know how\nlong that is in hours. Conventional division returns a \ufb02oating-point number:\n>>> minutes = 105\n>>> minutes / 60\n1.75\nBut we don\u2019t normally write hours with decimal points. Floor division returns the integer\nnumber of hours, rounding down:\n>>> minutes = 105\n>>> hours = minutes // 60\n>>> hours\n1\nTo get the remainder, you could subtract off one hour in minutes:\n>>> remainder = minutes - hours * 60\n>>> remainder\n45\nAn alternative is to use the modulus operator, %, which divides two numbers and returns\nthe remainder.\n>>> remainder = minutes % 60\n>>> remainder\n45\nThe modulus operator is more useful than it seems. For example, you can check whether\none number is divisible by another\u2014if x % y is zero, then x is divisible by y.\n40\nChapter 5. Conditionals and recursion",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_138",
    "text": "one number is divisible by another\u2014if x % y is zero, then x is divisible by y.\n40\nChapter 5. Conditionals and recursion\nAlso, you can extract the right-most digit or digits from a number. For example, x % 10\nyields the right-most digit of x (in base 10). Similarly x % 100 yields the last two digits.\nIf you are using Python 2, division works differently. The division operator, /, performs\n\ufb02oor division if both operands are integers, and \ufb02oating-point division if either operand is\na float.\n5.2\nBoolean expressions\nA boolean expression is an expression that is either true or false. The following examples\nuse the operator ==, which compares two operands and produces True if they are equal\nand False otherwise:\n>>> 5 == 5\nTrue\n>>> 5 == 6\nFalse\nTrue and False are special values that belong to the type bool; they are not strings:\n>>> type(True)\n<class 'bool'>\n>>> type(False)\n<class 'bool'>\nThe == operator is one of the relational operators; the others are:\nx != y\n# x is not equal to y\nx > y",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_139",
    "text": ">>> type(True)\n<class 'bool'>\n>>> type(False)\n<class 'bool'>\nThe == operator is one of the relational operators; the others are:\nx != y\n# x is not equal to y\nx > y\n# x is greater than y\nx < y\n# x is less than y\nx >= y\n# x is greater than or equal to y\nx <= y\n# x is less than or equal to y\nAlthough these operations are probably familiar to you, the Python symbols are different\nfrom the mathematical symbols. A common error is to use a single equal sign (=) instead of\na double equal sign (==). Remember that = is an assignment operator and == is a relational\noperator. There is no such thing as =< or =>.\n5.3\nLogical operators\nThere are three logical operators: and, or, and not. The semantics (meaning) of these\noperators is similar to their meaning in English. For example, x > 0 and x < 10 is true\nonly if x is greater than 0 and less than 10.\nn%2 == 0 or n%3 == 0 is true if either or both of the conditions is true, that is, if the number\nis divisible by 2 or 3.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_140",
    "text": "only if x is greater than 0 and less than 10.\nn%2 == 0 or n%3 == 0 is true if either or both of the conditions is true, that is, if the number\nis divisible by 2 or 3.\nFinally, the not operator negates a boolean expression, so not (x > y) is true if x > y is\nfalse, that is, if x is less than or equal to y.\nStrictly speaking, the operands of the logical operators should be boolean expressions, but\nPython is not very strict. Any nonzero number is interpreted as True:\n5.4. Conditional execution\n41\n>>> 42 and True\nTrue\nThis \ufb02exibility can be useful, but there are some subtleties to it that might be confusing.\nYou might want to avoid it (unless you know what you are doing).\n5.4\nConditional execution\nIn order to write useful programs, we almost always need the ability to check conditions\nand change the behavior of the program accordingly. Conditional statements give us this\nability. The simplest form is the if statement:\nif x > 0:\nprint('x is positive')",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_141",
    "text": "and change the behavior of the program accordingly. Conditional statements give us this\nability. The simplest form is the if statement:\nif x > 0:\nprint('x is positive')\nThe boolean expression after if is called the condition. If it is true, the indented statement\nruns. If not, nothing happens.\nif statements have the same structure as function de\ufb01nitions: a header followed by an\nindented body. Statements like this are called compound statements.\nThere is no limit on the number of statements that can appear in the body, but there has to\nbe at least one. Occasionally, it is useful to have a body with no statements (usually as a\nplace keeper for code you haven\u2019t written yet). In that case, you can use the pass statement,\nwhich does nothing.\nif x < 0:\npass\n# TODO: need to handle negative values!\n5.5\nAlternative execution\nA second form of the if statement is \u201calternative execution\u201d, in which there are two possi-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_142",
    "text": "which does nothing.\nif x < 0:\npass\n# TODO: need to handle negative values!\n5.5\nAlternative execution\nA second form of the if statement is \u201calternative execution\u201d, in which there are two possi-\nbilities and the condition determines which one runs. The syntax looks like this:\nif x % 2 == 0:\nprint('x is even')\nelse:\nprint('x is odd')\nIf the remainder when x is divided by 2 is 0, then we know that x is even, and the program\ndisplays an appropriate message. If the condition is false, the second set of statements\nruns. Since the condition must be true or false, exactly one of the alternatives will run. The\nalternatives are called branches, because they are branches in the \ufb02ow of execution.\n5.6\nChained conditionals\nSometimes there are more than two possibilities and we need more than two branches.\nOne way to express a computation like that is a chained conditional:\n42\nChapter 5. Conditionals and recursion\nif x < y:\nprint('x is less than y')\nelif x > y:\nprint('x is greater than y')\nelse:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_143",
    "text": "One way to express a computation like that is a chained conditional:\n42\nChapter 5. Conditionals and recursion\nif x < y:\nprint('x is less than y')\nelif x > y:\nprint('x is greater than y')\nelse:\nprint('x and y are equal')\nelif is an abbreviation of \u201celse if\u201d. Again, exactly one branch will run. There is no limit on\nthe number of elif statements. If there is an else clause, it has to be at the end, but there\ndoesn\u2019t have to be one.\nif choice == 'a':\ndraw_a()\nelif choice == 'b':\ndraw_b()\nelif choice == 'c':\ndraw_c()\nEach condition is checked in order. If the \ufb01rst is false, the next is checked, and so on. If one\nof them is true, the corresponding branch runs and the statement ends. Even if more than\none condition is true, only the \ufb01rst true branch runs.\n5.7\nNested conditionals\nOne conditional can also be nested within another. We could have written the example in\nthe previous section like this:\nif x == y:\nprint('x and y are equal')\nelse:\nif x < y:\nprint('x is less than y')\nelse:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_144",
    "text": "the previous section like this:\nif x == y:\nprint('x and y are equal')\nelse:\nif x < y:\nprint('x is less than y')\nelse:\nprint('x is greater than y')\nThe outer conditional contains two branches. The \ufb01rst branch contains a simple statement.\nThe second branch contains another if statement, which has two branches of its own.\nThose two branches are both simple statements, although they could have been conditional\nstatements as well.\nAlthough the indentation of the statements makes the structure apparent, nested condi-\ntionals become dif\ufb01cult to read very quickly. It is a good idea to avoid them when you\ncan.\nLogical operators often provide a way to simplify nested conditional statements. For ex-\nample, we can rewrite the following code using a single conditional:\nif 0 < x:\nif x < 10:\nprint('x is a positive single-digit number.')\nThe print statement runs only if we make it past both conditionals, so we can get the same\neffect with the and operator:\nif 0 < x and x < 10:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_145",
    "text": "if x < 10:\nprint('x is a positive single-digit number.')\nThe print statement runs only if we make it past both conditionals, so we can get the same\neffect with the and operator:\nif 0 < x and x < 10:\nprint('x is a positive single-digit number.')\n5.8. Recursion\n43\nFor this kind of condition, Python provides a more concise option:\nif 0 < x < 10:\nprint('x is a positive single-digit number.')\n5.8\nRecursion\nIt is legal for one function to call another; it is also legal for a function to call itself. It may\nnot be obvious why that is a good thing, but it turns out to be one of the most magical\nthings a program can do. For example, look at the following function:\ndef countdown(n):\nif n <= 0:\nprint('Blastoff!')\nelse:\nprint(n)\ncountdown(n-1)\nIf n is 0 or negative, it outputs the word, \u201cBlastoff!\u201d Otherwise, it outputs n and then calls\na function named countdown\u2014itself\u2014passing n-1 as an argument.\nWhat happens if we call this function like this?\n>>> countdown(3)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_146",
    "text": "a function named countdown\u2014itself\u2014passing n-1 as an argument.\nWhat happens if we call this function like this?\n>>> countdown(3)\nThe execution of countdown begins with n=3, and since n is greater than 0, it outputs the\nvalue 3, and then calls itself...\nThe execution of countdown begins with n=2, and since n is greater than 0, it\noutputs the value 2, and then calls itself...\nThe execution of countdown begins with n=1, and since n is greater\nthan 0, it outputs the value 1, and then calls itself...\nThe execution of countdown begins with n=0, and since n is\nnot greater than 0, it outputs the word, \u201cBlastoff!\u201d and then\nreturns.\nThe countdown that got n=1 returns.\nThe countdown that got n=2 returns.\nThe countdown that got n=3 returns.\nAnd then you\u2019re back in __main__. So, the total output looks like this:\n3\n2\n1\nBlastoff!\nA function that calls itself is recursive; the process of executing it is called recursion.\nAs another example, we can write a function that prints a string n times.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_147",
    "text": "3\n2\n1\nBlastoff!\nA function that calls itself is recursive; the process of executing it is called recursion.\nAs another example, we can write a function that prints a string n times.\ndef print_n(s, n):\nif n <= 0:\nreturn\nprint(s)\nprint_n(s, n-1)\n44\nChapter 5. Conditionals and recursion\n__main__\ncountdown\ncountdown\ncountdown\ncountdown\nn\n3\nn\n2\nn\n1\nn\n0\nFigure 5.1: Stack diagram.\nIf n <= 0 the return statement exits the function. The \ufb02ow of execution immediately re-\nturns to the caller, and the remaining lines of the function don\u2019t run.\nThe rest of the function is similar to countdown: it displays s and then calls itself to display\ns n \u22121 additional times. So the number of lines of output is 1 + (n - 1), which adds up\nto n.\nFor simple examples like this, it is probably easier to use a for loop. But we will see\nexamples later that are hard to write with a for loop and easy to write with recursion, so it\nis good to start early.\n5.9\nStack diagrams for recursive functions",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_148",
    "text": "examples later that are hard to write with a for loop and easy to write with recursion, so it\nis good to start early.\n5.9\nStack diagrams for recursive functions\nIn Section 3.9, we used a stack diagram to represent the state of a program during a function\ncall. The same kind of diagram can help interpret a recursive function.\nEvery time a function gets called, Python creates a frame to contain the function\u2019s local\nvariables and parameters. For a recursive function, there might be more than one frame on\nthe stack at the same time.\nFigure 5.1 shows a stack diagram for countdown called with n = 3.\nAs usual, the top of the stack is the frame for __main__. It is empty because we did not\ncreate any variables in __main__ or pass any arguments to it.\nThe four countdown frames have different values for the parameter n. The bottom of the\nstack, where n=0, is called the base case. It does not make a recursive call, so there are no\nmore frames.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_149",
    "text": "The four countdown frames have different values for the parameter n. The bottom of the\nstack, where n=0, is called the base case. It does not make a recursive call, so there are no\nmore frames.\nAs an exercise, draw a stack diagram for print_n called with s = 'Hello' and n=2. Then\nwrite a function called do_n that takes a function object and a number, n, as arguments, and\nthat calls the given function n times.\n5.10\nIn\ufb01nite recursion\nIf a recursion never reaches a base case, it goes on making recursive calls forever, and the\nprogram never terminates. This is known as in\ufb01nite recursion, and it is generally not a\ngood idea. Here is a minimal program with an in\ufb01nite recursion:\n5.11. Keyboard input\n45\ndef recurse():\nrecurse()\nIn most programming environments, a program with in\ufb01nite recursion does not really run\nforever. Python reports an error message when the maximum recursion depth is reached:\nFile \"<stdin>\", line 2, in recurse\nFile \"<stdin>\", line 2, in recurse",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_150",
    "text": "forever. Python reports an error message when the maximum recursion depth is reached:\nFile \"<stdin>\", line 2, in recurse\nFile \"<stdin>\", line 2, in recurse\nFile \"<stdin>\", line 2, in recurse\n.\n.\n.\nFile \"<stdin>\", line 2, in recurse\nRuntimeError: Maximum recursion depth exceeded\nThis traceback is a little bigger than the one we saw in the previous chapter. When the error\noccurs, there are 1000 recurse frames on the stack!\nIf you encounter an in\ufb01nite recursion by accident, review your function to con\ufb01rm that\nthere is a base case that does not make a recursive call. And if there is a base case, check\nwhether you are guaranteed to reach it.\n5.11\nKeyboard input\nThe programs we have written so far accept no input from the user. They just do the same\nthing every time.\nPython provides a built-in function called input that stops the program and waits for the\nuser to type something. When the user presses Return or Enter, the program resumes and",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_151",
    "text": "thing every time.\nPython provides a built-in function called input that stops the program and waits for the\nuser to type something. When the user presses Return or Enter, the program resumes and\ninput returns what the user typed as a string. In Python 2, the same function is called\nraw_input.\n>>> text = input()\nWhat are you waiting for?\n>>> text\n'What are you waiting for?'\nBefore getting input from the user, it is a good idea to print a prompt telling the user what\nto type. input can take a prompt as an argument:\n>>> name = input('What...is your name?\\n')\nWhat...is your name?\nArthur, King of the Britons!\n>>> name\n'Arthur, King of the Britons!'\nThe sequence \\n at the end of the prompt represents a newline, which is a special character\nthat causes a line break. That\u2019s why the user\u2019s input appears below the prompt.\nIf you expect the user to type an integer, you can try to convert the return value to int:\n>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\\n'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_152",
    "text": "If you expect the user to type an integer, you can try to convert the return value to int:\n>>> prompt = 'What...is the airspeed velocity of an unladen swallow?\\n'\n>>> speed = input(prompt)\nWhat...is the airspeed velocity of an unladen swallow?\n42\n>>> int(speed)\n42\n46\nChapter 5. Conditionals and recursion\nBut if the user types something other than a string of digits, you get an error:\n>>> speed = input(prompt)\nWhat...is the airspeed velocity of an unladen swallow?\nWhat do you mean, an African or a European swallow?\n>>> int(speed)\nValueError: invalid literal for int() with base 10\nWe will see how to handle this kind of error later.\n5.12\nDebugging\nWhen a syntax or runtime error occurs, the error message contains a lot of information, but\nit can be overwhelming. The most useful parts are usually:\n\u2022 What kind of error it was, and\n\u2022 Where it occurred.\nSyntax errors are usually easy to \ufb01nd, but there are a few gotchas. Whitespace errors can",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_153",
    "text": "\u2022 What kind of error it was, and\n\u2022 Where it occurred.\nSyntax errors are usually easy to \ufb01nd, but there are a few gotchas. Whitespace errors can\nbe tricky because spaces and tabs are invisible and we are used to ignoring them.\n>>> x = 5\n>>>\ny = 6\nFile \"<stdin>\", line 1\ny = 6\n^\nIndentationError: unexpected indent\nIn this example, the problem is that the second line is indented by one space. But the error\nmessage points to y, which is misleading. In general, error messages indicate where the\nproblem was discovered, but the actual error might be earlier in the code, sometimes on a\nprevious line.\nThe same is true of runtime errors. Suppose you are trying to compute a signal-to-noise\nratio in decibels. The formula is SNRdb = 10 log10(Psignal/Pnoise). In Python, you might\nwrite something like this:\nimport math\nsignal_power = 9\nnoise_power = 10\nratio = signal_power // noise_power\ndecibels = 10 * math.log10(ratio)\nprint(decibels)\nWhen you run this program, you get an exception:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_154",
    "text": "import math\nsignal_power = 9\nnoise_power = 10\nratio = signal_power // noise_power\ndecibels = 10 * math.log10(ratio)\nprint(decibels)\nWhen you run this program, you get an exception:\nTraceback (most recent call last):\nFile \"snr.py\", line 5, in ?\ndecibels = 10 * math.log10(ratio)\nValueError: math domain error\nThe error message indicates line 5, but there is nothing wrong with that line. To \ufb01nd the\nreal error, it might be useful to print the value of ratio, which turns out to be 0. The\nproblem is in line 4, which uses \ufb02oor division instead of \ufb02oating-point division.\nYou should take the time to read error messages carefully, but don\u2019t assume that everything\nthey say is correct.\n5.13. Glossary\n47\n5.13\nGlossary\n\ufb02oor division: An operator, denoted //, that divides two numbers and rounds down (to-\nward negative in\ufb01nity) to an integer.\nmodulus operator: An operator, denoted with a percent sign (%), that works on integers\nand returns the remainder when one number is divided by another.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_155",
    "text": "ward negative in\ufb01nity) to an integer.\nmodulus operator: An operator, denoted with a percent sign (%), that works on integers\nand returns the remainder when one number is divided by another.\nboolean expression: An expression whose value is either True or False.\nrelational operator: One of the operators that compares its operands: ==, !=, >, <, >=, and\n<=.\nlogical operator: One of the operators that combines boolean expressions: and, or, and\nnot.\nconditional statement: A statement that controls the \ufb02ow of execution depending on some\ncondition.\ncondition: The boolean expression in a conditional statement that determines which\nbranch runs.\ncompound statement: A statement that consists of a header and a body. The header ends\nwith a colon (:). The body is indented relative to the header.\nbranch: One of the alternative sequences of statements in a conditional statement.\nchained conditional: A conditional statement with a series of alternative branches.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_156",
    "text": "branch: One of the alternative sequences of statements in a conditional statement.\nchained conditional: A conditional statement with a series of alternative branches.\nnested conditional: A conditional statement that appears in one of the branches of another\nconditional statement.\nreturn statement: A statement that causes a function to end immediately and return to the\ncaller.\nrecursion: The process of calling the function that is currently executing.\nbase case: A conditional branch in a recursive function that does not make a recursive call.\nin\ufb01nite recursion: A recursion that doesn\u2019t have a base case, or never reaches it. Eventu-\nally, an in\ufb01nite recursion causes a runtime error.\n5.14\nExercises\nExercise 5.1. The time module provides a function, also named time, that returns the current\nGreenwich Mean Time in \u201cthe epoch\u201d, which is an arbitrary time used as a reference point. On\nUNIX systems, the epoch is 1 January 1970.\n>>> import time\n>>> time.time()\n1437746094.5735958",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_157",
    "text": "Greenwich Mean Time in \u201cthe epoch\u201d, which is an arbitrary time used as a reference point. On\nUNIX systems, the epoch is 1 January 1970.\n>>> import time\n>>> time.time()\n1437746094.5735958\nWrite a script that reads the current time and converts it to a time of day in hours, minutes, and\nseconds, plus the number of days since the epoch.\n48\nChapter 5. Conditionals and recursion\nExercise 5.2. Fermat\u2019s Last Theorem says that there are no positive integers a, b, and c such that\nan + bn = cn\nfor any values of n greater than 2.\n1. Write a function named check_fermat that takes four parameters\u2014a, b, c and n\u2014and\nchecks to see if Fermat\u2019s theorem holds. If n is greater than 2 and\nan + bn = cn\nthe program should print, \u201cHoly smokes, Fermat was wrong!\u201d Otherwise the program should\nprint, \u201cNo, that doesn\u2019t work.\u201d\n2. Write a function that prompts the user to input values for a, b, c and n, converts them to\nintegers, and uses check_fermat to check whether they violate Fermat\u2019s theorem.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_158",
    "text": "2. Write a function that prompts the user to input values for a, b, c and n, converts them to\nintegers, and uses check_fermat to check whether they violate Fermat\u2019s theorem.\nExercise 5.3. If you are given three sticks, you may or may not be able to arrange them in a triangle.\nFor example, if one of the sticks is 12 inches long and the other two are one inch long, you will not\nbe able to get the short sticks to meet in the middle. For any three lengths, there is a simple test to\nsee if it is possible to form a triangle:\nIf any of the three lengths is greater than the sum of the other two, then you cannot\nform a triangle. Otherwise, you can. (If the sum of two lengths equals the third, they\nform what is called a \u201cdegenerate\u201d triangle.)\n1. Write a function named is_triangle that takes three integers as arguments, and that prints\neither \u201cYes\u201d or \u201cNo\u201d, depending on whether you can or cannot form a triangle from sticks\nwith the given lengths.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_159",
    "text": "either \u201cYes\u201d or \u201cNo\u201d, depending on whether you can or cannot form a triangle from sticks\nwith the given lengths.\n2. Write a function that prompts the user to input three stick lengths, converts them to integers,\nand uses is_triangle to check whether sticks with the given lengths can form a triangle.\nExercise 5.4. What is the output of the following program? Draw a stack diagram that shows the\nstate of the program when it prints the result.\ndef recurse(n, s):\nif n == 0:\nprint(s)\nelse:\nrecurse(n-1, n+s)\nrecurse(3, 0)\n1. What would happen if you called this function like this: recurse(-1, 0)?\n2. Write a docstring that explains everything someone would need to know in order to use this\nfunction (and nothing else).\nThe following exercises use the turtle module, described in Chapter 4:\nExercise 5.5. Read the following function and see if you can \ufb01gure out what it does (see the exam-\nples in Chapter 4). Then run it and see if you got it right.\n5.14. Exercises\n49\nFigure 5.2: A Koch curve.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_160",
    "text": "ples in Chapter 4). Then run it and see if you got it right.\n5.14. Exercises\n49\nFigure 5.2: A Koch curve.\ndef draw(t, length, n):\nif n == 0:\nreturn\nangle = 50\nt.fd(length*n)\nt.lt(angle)\ndraw(t, length, n-1)\nt.rt(2*angle)\ndraw(t, length, n-1)\nt.lt(angle)\nt.bk(length*n)\nExercise 5.6. The Koch curve is a fractal that looks something like Figure 5.2. To draw a Koch\ncurve with length x, all you have to do is\n1. Draw a Koch curve with length x/3.\n2. Turn left 60 degrees.\n3. Draw a Koch curve with length x/3.\n4. Turn right 120 degrees.\n5. Draw a Koch curve with length x/3.\n6. Turn left 60 degrees.\n7. Draw a Koch curve with length x/3.\nThe exception is if x is less than 3: in that case, you can just draw a straight line with length x.\n1. Write a function called koch that takes a turtle and a length as parameters, and that uses the\nturtle to draw a Koch curve with the given length.\n2. Write a function called snowflake that draws three Koch curves to make the outline of a\nsnow\ufb02ake.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_161",
    "text": "turtle to draw a Koch curve with the given length.\n2. Write a function called snowflake that draws three Koch curves to make the outline of a\nsnow\ufb02ake.\nSolution: https: // thinkpython. com/ code/ koch. py .\n3. The Koch curve can be generalized in several ways. See http: // en. wikipedia. org/\nwiki/ Koch_ snowflake for examples and implement your favorite.\n50\nChapter 5. Conditionals and recursion\nChapter 6\nFruitful functions\nMany of the Python functions we have used, such as the math functions, produce return\nvalues. But the functions we\u2019ve written are all void: they have an effect, like printing a\nvalue or moving a turtle, but they don\u2019t have a return value. In this chapter you will learn\nto write fruitful functions.\n6.1\nReturn values\nCalling the function generates a return value, which we usually assign to a variable or use\nas part of an expression.\ne = math.exp(1.0)\nheight = radius * math.sin(radians)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_162",
    "text": "6.1\nReturn values\nCalling the function generates a return value, which we usually assign to a variable or use\nas part of an expression.\ne = math.exp(1.0)\nheight = radius * math.sin(radians)\nThe functions we have written so far are void. Speaking casually, they have no return\nvalue; more precisely, their return value is None.\nIn this chapter, we are (\ufb01nally) going to write fruitful functions. The \ufb01rst example is area,\nwhich returns the area of a circle with the given radius:\ndef area(radius):\na = math.pi * radius**2\nreturn a\nWe have seen the return statement before, but in a fruitful function the return statement\nincludes an expression. This statement means: \u201cReturn immediately from this function\nand use the following expression as a return value.\u201d The expression can be arbitrarily\ncomplicated, so we could have written this function more concisely:\ndef area(radius):\nreturn math.pi * radius**2\nOn the other hand, temporary variables like a can make debugging easier.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_163",
    "text": "complicated, so we could have written this function more concisely:\ndef area(radius):\nreturn math.pi * radius**2\nOn the other hand, temporary variables like a can make debugging easier.\nSometimes it is useful to have multiple return statements, one in each branch of a condi-\ntional:\n52\nChapter 6. Fruitful functions\ndef absolute_value(x):\nif x < 0:\nreturn -x\nelse:\nreturn x\nSince these return statements are in an alternative conditional, only one runs.\nAs soon as a return statement runs, the function terminates without executing any subse-\nquent statements. Code that appears after a return statement, or any other place the \ufb02ow\nof execution can never reach, is called dead code.\nIn a fruitful function, it is a good idea to ensure that every possible path through the pro-\ngram hits a return statement. For example:\ndef absolute_value(x):\nif x < 0:\nreturn -x\nif x > 0:\nreturn x\nThis function is incorrect because if x happens to be 0, neither condition is true, and the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_164",
    "text": "gram hits a return statement. For example:\ndef absolute_value(x):\nif x < 0:\nreturn -x\nif x > 0:\nreturn x\nThis function is incorrect because if x happens to be 0, neither condition is true, and the\nfunction ends without hitting a return statement. If the \ufb02ow of execution gets to the end\nof a function, the return value is None, which is not the absolute value of 0.\n>>> print(absolute_value(0))\nNone\nBy the way, Python provides a built-in function called abs that computes absolute values.\nAs an exercise, write a compare function that takes two values, x and y, and returns 1 if x\n> y, 0 if x == y, and -1 if x < y.\n6.2\nIncremental development\nAs you write larger functions, you might \ufb01nd yourself spending more time debugging.\nTo deal with increasingly complex programs, you might want to try a process called in-\ncremental development. The goal of incremental development is to avoid long debugging\nsessions by adding and testing only a small amount of code at a time.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_165",
    "text": "cremental development. The goal of incremental development is to avoid long debugging\nsessions by adding and testing only a small amount of code at a time.\nAs an example, suppose you want to \ufb01nd the distance between two points, given by the\ncoordinates (x1, y1) and (x2, y2). By the Pythagorean theorem, the distance is:\ndistance =\nq\n(x2 \u2212x1)2 + (y2 \u2212y1)2\nThe \ufb01rst step is to consider what a distance function should look like in Python. In other\nwords, what are the inputs (parameters) and what is the output (return value)?\nIn this case, the inputs are two points, which you can represent using four numbers. The\nreturn value is the distance represented by a \ufb02oating-point value.\nImmediately you can write an outline of the function:\ndef distance(x1, y1, x2, y2):\nreturn 0.0\n6.2. Incremental development\n53\nObviously, this version doesn\u2019t compute distances; it always returns zero. But it is syn-\ntactically correct, and it runs, which means that you can test it before you make it more",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_166",
    "text": "53\nObviously, this version doesn\u2019t compute distances; it always returns zero. But it is syn-\ntactically correct, and it runs, which means that you can test it before you make it more\ncomplicated.\nTo test the new function, call it with sample arguments:\n>>> distance(1, 2, 4, 6)\n0.0\nI chose these values so that the horizontal distance is 3 and the vertical distance is 4; that\nway, the result is 5, the hypotenuse of a 3-4-5 right triangle. When testing a function, it is\nuseful to know the right answer.\nAt this point we have con\ufb01rmed that the function is syntactically correct, and we can start\nadding code to the body. A reasonable next step is to \ufb01nd the differences x2 \u2212x1 and\ny2 \u2212y1. The next version stores those values in temporary variables and prints them.\ndef distance(x1, y1, x2, y2):\ndx = x2 - x1\ndy = y2 - y1\nprint('dx is', dx)\nprint('dy is', dy)\nreturn 0.0\nIf the function is working, it should display dx is 3 and dy is 4. If so, we know that the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_167",
    "text": "def distance(x1, y1, x2, y2):\ndx = x2 - x1\ndy = y2 - y1\nprint('dx is', dx)\nprint('dy is', dy)\nreturn 0.0\nIf the function is working, it should display dx is 3 and dy is 4. If so, we know that the\nfunction is getting the right arguments and performing the \ufb01rst computation correctly. If\nnot, there are only a few lines to check.\nNext we compute the sum of squares of dx and dy:\ndef distance(x1, y1, x2, y2):\ndx = x2 - x1\ndy = y2 - y1\ndsquared = dx**2 + dy**2\nprint('dsquared is: ', dsquared)\nreturn 0.0\nAgain, you would run the program at this stage and check the output (which should be\n25). Finally, you can use math.sqrt to compute and return the result:\ndef distance(x1, y1, x2, y2):\ndx = x2 - x1\ndy = y2 - y1\ndsquared = dx**2 + dy**2\nresult = math.sqrt(dsquared)\nreturn result\nIf that works correctly, you are done. Otherwise, you might want to print the value of\nresult before the return statement.\nThe \ufb01nal version of the function doesn\u2019t display anything when it runs; it only returns",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_168",
    "text": "result before the return statement.\nThe \ufb01nal version of the function doesn\u2019t display anything when it runs; it only returns\na value. The print statements we wrote are useful for debugging, but once you get the\nfunction working, you should remove them. Code like that is called scaffolding because it\nis helpful for building the program but is not part of the \ufb01nal product.\nWhen you start out, you should add only a line or two of code at a time. As you gain more\nexperience, you might \ufb01nd yourself writing and debugging bigger chunks. Either way,\nincremental development can save you a lot of debugging time.\nThe key aspects of the process are:\n54\nChapter 6. Fruitful functions\n1. Start with a working program and make small incremental changes. At any point, if\nthere is an error, you should have a good idea where it is.\n2. Use variables to hold intermediate values so you can display and check them.\n3. Once the program is working, you might want to remove some of the scaffolding or",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_169",
    "text": "2. Use variables to hold intermediate values so you can display and check them.\n3. Once the program is working, you might want to remove some of the scaffolding or\nconsolidate multiple statements into compound expressions, but only if it does not\nmake the program dif\ufb01cult to read.\nAs an exercise, use incremental development to write a function called hypotenuse that\nreturns the length of the hypotenuse of a right triangle given the lengths of the other two\nlegs as arguments. Record each stage of the development process as you go.\n6.3\nComposition\nAs you should expect by now, you can call one function from within another. As an exam-\nple, we\u2019ll write a function that takes two points, the center of the circle and a point on the\nperimeter, and computes the area of the circle.\nAssume that the center point is stored in the variables xc and yc, and the perimeter point is\nin xp and yp. The \ufb01rst step is to \ufb01nd the radius of the circle, which is the distance between",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_170",
    "text": "Assume that the center point is stored in the variables xc and yc, and the perimeter point is\nin xp and yp. The \ufb01rst step is to \ufb01nd the radius of the circle, which is the distance between\nthe two points. We just wrote a function, distance, that does that:\nradius = distance(xc, yc, xp, yp)\nThe next step is to \ufb01nd the area of a circle with that radius; we just wrote that, too:\nresult = area(radius)\nEncapsulating these steps in a function, we get:\ndef circle_area(xc, yc, xp, yp):\nradius = distance(xc, yc, xp, yp)\nresult = area(radius)\nreturn result\nThe temporary variables radius and result are useful for development and debugging,\nbut once the program is working, we can make it more concise by composing the function\ncalls:\ndef circle_area(xc, yc, xp, yp):\nreturn area(distance(xc, yc, xp, yp))\n6.4\nBoolean functions\nFunctions can return booleans, which is often convenient for hiding complicated tests in-\nside functions. For example:\ndef is_divisible(x, y):\nif x % y == 0:\nreturn True\nelse:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_171",
    "text": "6.4\nBoolean functions\nFunctions can return booleans, which is often convenient for hiding complicated tests in-\nside functions. For example:\ndef is_divisible(x, y):\nif x % y == 0:\nreturn True\nelse:\nreturn False\n6.5. More recursion\n55\nIt is common to give boolean functions names that sound like yes/no questions;\nis_divisible returns either True or False to indicate whether x is divisible by y.\nHere is an example:\n>>> is_divisible(6, 4)\nFalse\n>>> is_divisible(6, 3)\nTrue\nThe result of the == operator is a boolean, so we can write the function more concisely by\nreturning it directly:\ndef is_divisible(x, y):\nreturn x % y == 0\nBoolean functions are often used in conditional statements:\nif is_divisible(x, y):\nprint('x is divisible by y')\nIt might be tempting to write something like:\nif is_divisible(x, y) == True:\nprint('x is divisible by y')\nBut the extra comparison is unnecessary.\nAs an exercise, write a function is_between(x, y, z) that returns True if x \u2264y \u2264z or\nFalse otherwise.\n6.5",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_172",
    "text": "print('x is divisible by y')\nBut the extra comparison is unnecessary.\nAs an exercise, write a function is_between(x, y, z) that returns True if x \u2264y \u2264z or\nFalse otherwise.\n6.5\nMore recursion\nWe have only covered a small subset of Python, but you might be interested to know that\nthis subset is a complete programming language, which means that anything that can be\ncomputed can be expressed in this language. Any program ever written could be rewritten\nusing only the language features you have learned so far (actually, you would need a few\ncommands to control devices like the mouse, disks, etc., but that\u2019s all).\nProving that claim is a nontrivial exercise \ufb01rst accomplished by Alan Turing, one of the\n\ufb01rst computer scientists (some would argue that he was a mathematician, but a lot of early\ncomputer scientists started as mathematicians). Accordingly, it is known as the Turing\nThesis. For a more complete (and accurate) discussion of the Turing Thesis, I recommend",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_173",
    "text": "computer scientists started as mathematicians). Accordingly, it is known as the Turing\nThesis. For a more complete (and accurate) discussion of the Turing Thesis, I recommend\nMichael Sipser\u2019s book Introduction to the Theory of Computation.\nTo give you an idea of what you can do with the tools you have learned so far, we\u2019ll eval-\nuate a few recursively de\ufb01ned mathematical functions. A recursive de\ufb01nition is similar to\na circular de\ufb01nition, in the sense that the de\ufb01nition contains a reference to the thing being\nde\ufb01ned. A truly circular de\ufb01nition is not very useful:\nvorpal: An adjective used to describe something that is vorpal.\nIf you saw that de\ufb01nition in the dictionary, you might be annoyed. On the other hand,\nif you looked up the de\ufb01nition of the factorial function, denoted with the symbol !, you\nmight get something like this:\n0! = 1\nn! = n(n \u22121)!\n56\nChapter 6. Fruitful functions\nThis de\ufb01nition says that the factorial of 0 is 1, and the factorial of any other value, n, is n",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_174",
    "text": "might get something like this:\n0! = 1\nn! = n(n \u22121)!\n56\nChapter 6. Fruitful functions\nThis de\ufb01nition says that the factorial of 0 is 1, and the factorial of any other value, n, is n\nmultiplied by the factorial of n \u22121.\nSo 3! is 3 times 2!, which is 2 times 1!, which is 1 times 0!. Putting it all together, 3! equals 3\ntimes 2 times 1 times 1, which is 6.\nIf you can write a recursive de\ufb01nition of something, you can write a Python program to\nevaluate it. The \ufb01rst step is to decide what the parameters should be. In this case it should\nbe clear that factorial takes an integer:\ndef factorial(n):\nIf the argument happens to be 0, all we have to do is return 1:\ndef factorial(n):\nif n == 0:\nreturn 1\nOtherwise, and this is the interesting part, we have to make a recursive call to \ufb01nd the\nfactorial of n \u22121 and then multiply it by n:\ndef factorial(n):\nif n == 0:\nreturn 1\nelse:\nrecurse = factorial(n-1)\nresult = n * recurse\nreturn result",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_175",
    "text": "factorial of n \u22121 and then multiply it by n:\ndef factorial(n):\nif n == 0:\nreturn 1\nelse:\nrecurse = factorial(n-1)\nresult = n * recurse\nreturn result\nThe \ufb02ow of execution for this program is similar to the \ufb02ow of countdown in Section 5.8. If\nwe call factorial with the value 3:\nSince 3 is not 0, we take the second branch and calculate the factorial of n-1...\nSince 2 is not 0, we take the second branch and calculate the factorial of n-1...\nSince 1 is not 0, we take the second branch and calculate the factorial\nof n-1...\nSince 0 equals 0, we take the \ufb01rst branch and return 1 without\nmaking any more recursive calls.\nThe return value, 1, is multiplied by n, which is 1, and the result is\nreturned.\nThe return value, 1, is multiplied by n, which is 2, and the result is returned.\nThe return value (2) is multiplied by n, which is 3, and the result, 6, becomes the return\nvalue of the function call that started the whole process.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_176",
    "text": "The return value (2) is multiplied by n, which is 3, and the result, 6, becomes the return\nvalue of the function call that started the whole process.\nFigure 6.1 shows what the stack diagram looks like for this sequence of function calls.\nThe return values are shown being passed back up the stack. In each frame, the return\nvalue is the value of result, which is the product of n and recurse.\nIn the last frame, the local variables recurse and result do not exist, because the branch\nthat creates them does not run.\n6.6. Leap of faith\n57\nn\n3\nrecurse\n2\nrecurse\n1\nrecurse\n1\n__main__\nfactorial\nn\n2\nn\n1\nn\n0\nfactorial\nfactorial\nfactorial\n1\n1\n2\n6\n1\nresult\n2\n6\nresult\nresult\nFigure 6.1: Stack diagram.\n6.6\nLeap of faith\nFollowing the \ufb02ow of execution is one way to read programs, but it can quickly become\noverwhelming. An alternative is what I call the \u201cleap of faith\u201d. When you come to a\nfunction call, instead of following the \ufb02ow of execution, you assume that the function works",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_177",
    "text": "overwhelming. An alternative is what I call the \u201cleap of faith\u201d. When you come to a\nfunction call, instead of following the \ufb02ow of execution, you assume that the function works\ncorrectly and returns the right result.\nIn fact, you are already practicing this leap of faith when you use built-in functions. When\nyou call math.cos or math.exp, you don\u2019t examine the bodies of those functions. You just\nassume that they work because the people who wrote the built-in functions were good\nprogrammers.\nThe same is true when you call one of your own functions. For example, in Section 6.4, we\nwrote a function called is_divisible that determines whether one number is divisible by\nanother. Once we have convinced ourselves that this function is correct\u2014by examining the\ncode and testing\u2014we can use the function without looking at the body again.\nThe same is true of recursive programs. When you get to the recursive call, instead of",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_178",
    "text": "code and testing\u2014we can use the function without looking at the body again.\nThe same is true of recursive programs. When you get to the recursive call, instead of\nfollowing the \ufb02ow of execution, you should assume that the recursive call works (returns\nthe correct result) and then ask yourself, \u201cAssuming that I can \ufb01nd the factorial of n \u22121,\ncan I compute the factorial of n?\u201d It is clear that you can, by multiplying by n.\nOf course, it\u2019s a bit strange to assume that the function works correctly when you haven\u2019t\n\ufb01nished writing it, but that\u2019s why it\u2019s called a leap of faith!\n6.7\nOne more example\nAfter factorial, the most common example of a recursively de\ufb01ned mathematical func-\ntion is fibonacci, which has the following de\ufb01nition (see http://en.wikipedia.org/\nwiki/Fibonacci_number):\n\ufb01bonacci(0) = 0\n\ufb01bonacci(1) = 1\n\ufb01bonacci(n) = \ufb01bonacci(n \u22121) + \ufb01bonacci(n \u22122)\nTranslated into Python, it looks like this:\n58\nChapter 6. Fruitful functions\ndef fibonacci(n):\nif n == 0:\nreturn 0\nelif\nn == 1:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_179",
    "text": "\ufb01bonacci(1) = 1\n\ufb01bonacci(n) = \ufb01bonacci(n \u22121) + \ufb01bonacci(n \u22122)\nTranslated into Python, it looks like this:\n58\nChapter 6. Fruitful functions\ndef fibonacci(n):\nif n == 0:\nreturn 0\nelif\nn == 1:\nreturn 1\nelse:\nreturn fibonacci(n-1) + fibonacci(n-2)\nIf you try to follow the \ufb02ow of execution here, even for fairly small values of n, your head\nexplodes. But according to the leap of faith, if you assume that the two recursive calls work\ncorrectly, then it is clear that you get the right result by adding them together.\n6.8\nChecking types\nWhat happens if we call factorial and give it 1.5 as an argument?\n>>> factorial(1.5)\nRuntimeError: Maximum recursion depth exceeded\nIt looks like an in\ufb01nite recursion. How can that be? The function has a base case\u2014when n\n== 0. But if n is not an integer, we can miss the base case and recurse forever.\nIn the \ufb01rst recursive call, the value of n is 0.5. In the next, it is -0.5. From there, it gets\nsmaller (more negative), but it will never be 0.\nWe have two choices.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_180",
    "text": "In the \ufb01rst recursive call, the value of n is 0.5. In the next, it is -0.5. From there, it gets\nsmaller (more negative), but it will never be 0.\nWe have two choices.\nWe can try to generalize the factorial function to work with\n\ufb02oating-point numbers, or we can make factorial check the type of its argument. The\n\ufb01rst option is called the gamma function and it\u2019s a little beyond the scope of this book. So\nwe\u2019ll go for the second.\nWe can use the built-in function isinstance to verify the type of the argument. While\nwe\u2019re at it, we can also make sure the argument is positive:\ndef factorial(n):\nif not isinstance(n, int):\nprint('Factorial is only defined for integers.')\nreturn None\nelif n < 0:\nprint('Factorial is not defined for negative integers.')\nreturn None\nelif n == 0:\nreturn 1\nelse:\nreturn n * factorial(n-1)\nThe \ufb01rst base case handles nonintegers; the second handles negative integers. In both\ncases, the program prints an error message and returns None to indicate that something",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_181",
    "text": "return n * factorial(n-1)\nThe \ufb01rst base case handles nonintegers; the second handles negative integers. In both\ncases, the program prints an error message and returns None to indicate that something\nwent wrong:\n>>> print(factorial('fred'))\nFactorial is only defined for integers.\nNone\n>>> print(factorial(-2))\nFactorial is not defined for negative integers.\nNone\n6.9. Debugging\n59\nIf we get past both checks, we know that n is a non-negative integer, so we can prove that\nthe recursion terminates.\nThis program demonstrates a pattern sometimes called a guardian. The \ufb01rst two condi-\ntionals act as guardians, protecting the code that follows from values that might cause an\nerror. The guardians make it possible to prove the correctness of the code.\nIn Section 11.4 we will see a more \ufb02exible alternative to printing an error message: raising\nan exception.\n6.9\nDebugging\nBreaking a large program into smaller functions creates natural checkpoints for debugging.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_182",
    "text": "an exception.\n6.9\nDebugging\nBreaking a large program into smaller functions creates natural checkpoints for debugging.\nIf a function is not working, there are three possibilities to consider:\n\u2022 There is something wrong with the arguments the function is getting; a precondition\nis violated.\n\u2022 There is something wrong with the function; a postcondition is violated.\n\u2022 There is something wrong with the return value or the way it is being used.\nTo rule out the \ufb01rst possibility, you can add a print statement at the beginning of the\nfunction and display the values of the parameters (and maybe their types). Or you can\nwrite code that checks the preconditions explicitly.\nIf the parameters look good, add a print statement before each return statement and\ndisplay the return value. If possible, check the result by hand. Consider calling the function\nwith values that make it easy to check the result (as in Section 6.2).",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_183",
    "text": "display the return value. If possible, check the result by hand. Consider calling the function\nwith values that make it easy to check the result (as in Section 6.2).\nIf the function seems to be working, look at the function call to make sure the return value\nis being used correctly (or used at all!).\nAdding print statements at the beginning and end of a function can help make the \ufb02ow of\nexecution more visible. For example, here is a version of factorial with print statements:\ndef factorial(n):\nspace = ' ' * (4 * n)\nprint(space, 'factorial', n)\nif n == 0:\nprint(space, 'returning 1')\nreturn 1\nelse:\nrecurse = factorial(n-1)\nresult = n * recurse\nprint(space, 'returning', result)\nreturn result\nspace is a string of space characters that controls the indentation of the output. Here is the\nresult of factorial(4) :\n60\nChapter 6. Fruitful functions\nfactorial 4\nfactorial 3\nfactorial 2\nfactorial 1\nfactorial 0\nreturning 1\nreturning 1\nreturning 2\nreturning 6\nreturning 24",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_184",
    "text": "result of factorial(4) :\n60\nChapter 6. Fruitful functions\nfactorial 4\nfactorial 3\nfactorial 2\nfactorial 1\nfactorial 0\nreturning 1\nreturning 1\nreturning 2\nreturning 6\nreturning 24\nIf you are confused about the \ufb02ow of execution, this kind of output can be helpful. It takes\nsome time to develop effective scaffolding, but a little bit of scaffolding can save a lot of\ndebugging.\n6.10\nGlossary\ntemporary variable: A variable used to store an intermediate value in a complex calcula-\ntion.\ndead code: Part of a program that can never run, often because it appears after a return\nstatement.\nincremental development: A program development plan intended to avoid debugging by\nadding and testing only a small amount of code at a time.\nscaffolding: Code that is used during program development but is not part of the \ufb01nal\nversion.\nguardian: A programming pattern that uses a conditional statement to check for and han-\ndle circumstances that might cause an error.\n6.11\nExercises",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_185",
    "text": "version.\nguardian: A programming pattern that uses a conditional statement to check for and han-\ndle circumstances that might cause an error.\n6.11\nExercises\nExercise 6.1. Draw a stack diagram for the following program. What does the program print?\ndef b(z):\nprod = a(z, z)\nprint(z, prod)\nreturn prod\ndef a(x, y):\nx = x + 1\nreturn x * y\ndef c(x, y, z):\ntotal = x + y + z\nsquare = b(total)**2\nreturn square\n6.11. Exercises\n61\nx = 1\ny = x + 1\nprint(c(x, y+3, x+y))\nExercise 6.2. The Ackermann function, A(m, n), is de\ufb01ned:\nA(m, n) =\n\uf8f1\n\uf8f4\n\uf8f2\n\uf8f4\n\uf8f3\nn + 1\nif m = 0\nA(m \u22121, 1)\nif m > 0 and n = 0\nA(m \u22121, A(m, n \u22121))\nif m > 0 and n > 0.\nSee http: // en. wikipedia. org/ wiki/ Ackermann_ function . Write a function named ack\nthat evaluates the Ackermann function. Use your function to evaluate ack(3, 4), which should be\n125. What happens for larger values of m and n? Solution: https: // thinkpython. com/ code/\nackermann. py .",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_186",
    "text": "125. What happens for larger values of m and n? Solution: https: // thinkpython. com/ code/\nackermann. py .\nExercise 6.3. A palindrome is a word that is spelled the same backward and forward, like \u201cnoon\u201d\nand \u201credivider\u201d. Recursively, a word is a palindrome if the \ufb01rst and last letters are the same and the\nmiddle is a palindrome.\nThe following are functions that take a string argument and return the \ufb01rst, last, and middle letters:\ndef first(word):\nreturn word[0]\ndef last(word):\nreturn word[-1]\ndef middle(word):\nreturn word[1:-1]\nWe\u2019ll see how they work in Chapter 8.\n1. Type these functions into a \ufb01le named palindrome.py and test them out. What happens if\nyou call middle with a string with two letters? One letter? What about the empty string,\nwhich is written '' and contains no letters?\n2. Write a function called is_palindrome that takes a string argument and returns True if it\nis a palindrome and False otherwise. Remember that you can use the built-in function len",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_187",
    "text": "2. Write a function called is_palindrome that takes a string argument and returns True if it\nis a palindrome and False otherwise. Remember that you can use the built-in function len\nto check the length of a string.\nSolution: https: // thinkpython. com/ code/ palindrome_ soln. py .\nExercise 6.4. A number, a, is a power of b if it is divisible by b and a/b is a power of b. Write a\nfunction called is_power that takes parameters a and b and returns True if a is a power of b. Note:\nyou will have to think about the base case.\nExercise 6.5. The greatest common divisor (GCD) of a and b is the largest number that divides\nboth of them with no remainder.\nOne way to \ufb01nd the GCD of two numbers is based on the observation that if r is the remainder when\na is divided by b, then gcd(a, b) = gcd(b, r). As a base case, we can use gcd(a, 0) = a.\nWrite a function called gcd that takes parameters a and b and returns their greatest common divisor.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_188",
    "text": "a is divided by b, then gcd(a, b) = gcd(b, r). As a base case, we can use gcd(a, 0) = a.\nWrite a function called gcd that takes parameters a and b and returns their greatest common divisor.\nCredit: This exercise is based on an example from Abelson and Sussman\u2019s Structure and Interpre-\ntation of Computer Programs.\n62\nChapter 6. Fruitful functions\nChapter 7\nIteration\nThis chapter is about iteration, which is the ability to run a block of statements repeatedly.\nWe saw a kind of iteration, using recursion, in Section 5.8. We saw another kind, using a\nfor loop, in Section 4.2. In this chapter we\u2019ll see yet another kind, using a while statement.\nBut \ufb01rst I want to say a little more about variable assignment.\n7.1\nReassignment\nAs you may have discovered, it is legal to make more than one assignment to the same\nvariable. A new assignment makes an existing variable refer to a new value (and stop\nreferring to the old value).\n>>> x = 5\n>>> x\n5\n>>> x = 7\n>>> x\n7",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_189",
    "text": "variable. A new assignment makes an existing variable refer to a new value (and stop\nreferring to the old value).\n>>> x = 5\n>>> x\n5\n>>> x = 7\n>>> x\n7\nThe \ufb01rst time we display x, its value is 5; the second time, its value is 7.\nFigure 7.1 shows what reassignment looks like in a state diagram.\nAt this point I want to address a common source of confusion. Because Python uses the\nequal sign (=) for assignment, it is tempting to interpret a statement like a = b as a mathe-\nmatical proposition of equality; that is, the claim that a and b are equal. But this interpre-\ntation is wrong.\nFirst, equality is a symmetric relationship and assignment is not. For example, in math-\nematics, if a = 7 then 7 = a. But in Python, the statement a = 7 is legal and 7 = a is\nnot.\nAlso, in mathematics, a proposition of equality is either true or false for all time. If a =\nb now, then a will always equal b. In Python, an assignment statement can make two\nvariables equal, but they don\u2019t have to stay that way:\n64",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_190",
    "text": "b now, then a will always equal b. In Python, an assignment statement can make two\nvariables equal, but they don\u2019t have to stay that way:\n64\nChapter 7. Iteration\n7\n5\nx\nFigure 7.1: State diagram.\n>>> a = 5\n>>> b = a\n# a and b are now equal\n>>> a = 3\n# a and b are no longer equal\n>>> b\n5\nThe third line changes the value of a but does not change the value of b, so they are no\nlonger equal.\nReassigning variables is often useful, but you should use it with caution. If the values of\nvariables change frequently, it can make the code dif\ufb01cult to read and debug.\n7.2\nUpdating variables\nA common kind of reassignment is an update, where the new value of the variable depends\non the old.\n>>> x = x + 1\nThis means \u201cget the current value of x, add one, and then update x with the new value.\u201d\nIf you try to update a variable that doesn\u2019t exist, you get an error, because Python evaluates\nthe right side before it assigns a value to x:\n>>> x = x + 1\nNameError: name 'x' is not defined",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_191",
    "text": "If you try to update a variable that doesn\u2019t exist, you get an error, because Python evaluates\nthe right side before it assigns a value to x:\n>>> x = x + 1\nNameError: name 'x' is not defined\nBefore you can update a variable, you have to initialize it, usually with a simple assign-\nment:\n>>> x = 0\n>>> x = x + 1\nUpdating a variable by adding 1 is called an increment; subtracting 1 is called a decrement.\n7.3\nThe while statement\nComputers are often used to automate repetitive tasks. Repeating identical or similar tasks\nwithout making errors is something that computers do well and people do poorly. In a\ncomputer program, repetition is also called iteration.\nWe have already seen two functions, countdown and print_n, that iterate using recursion.\nBecause iteration is so common, Python provides language features to make it easier. One\nis the for statement we saw in Section 4.2. We\u2019ll get back to that later.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_192",
    "text": "Because iteration is so common, Python provides language features to make it easier. One\nis the for statement we saw in Section 4.2. We\u2019ll get back to that later.\nAnother is the while statement. Here is a version of countdown that uses a while statement:\n7.3. The while statement\n65\ndef countdown(n):\nwhile n > 0:\nprint(n)\nn = n - 1\nprint('Blastoff!')\nYou can almost read the while statement as if it were English. It means, \u201cWhile n is greater\nthan 0, display the value of n and then decrement n. When you get to 0, display the word\nBlastoff!\u201d\nMore formally, here is the \ufb02ow of execution for a while statement:\n1. Determine whether the condition is true or false.\n2. If false, exit the while statement and continue execution at the next statement.\n3. If the condition is true, run the body and then go back to step 1.\nThis type of \ufb02ow is called a loop because the third step loops back around to the top.\nThe body of the loop should change the value of one or more variables so that the condition",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_193",
    "text": "This type of \ufb02ow is called a loop because the third step loops back around to the top.\nThe body of the loop should change the value of one or more variables so that the condition\nbecomes false eventually and the loop terminates. Otherwise the loop will repeat forever,\nwhich is called an in\ufb01nite loop. An endless source of amusement for computer scientists\nis the observation that the directions on shampoo, \u201cLather, rinse, repeat\u201d, are an in\ufb01nite\nloop.\nIn the case of countdown, we can prove that the loop terminates: if n is zero or negative, the\nloop never runs. Otherwise, n gets smaller each time through the loop, so eventually we\nhave to get to 0.\nFor some other loops, it is not so easy to tell. For example:\ndef sequence(n):\nwhile n != 1:\nprint(n)\nif n % 2 == 0:\n# n is even\nn = n / 2\nelse:\n# n is odd\nn = n*3 + 1\nThe condition for this loop is n != 1, so the loop will continue until n is 1, which makes\nthe condition false.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_194",
    "text": "while n != 1:\nprint(n)\nif n % 2 == 0:\n# n is even\nn = n / 2\nelse:\n# n is odd\nn = n*3 + 1\nThe condition for this loop is n != 1, so the loop will continue until n is 1, which makes\nthe condition false.\nEach time through the loop, the program outputs the value of n and then checks whether\nit is even or odd. If it is even, n is divided by 2. If it is odd, the value of n is replaced with\nn*3 + 1. For example, if the argument passed to sequence is 3, the resulting values of n\nare 3, 10, 5, 16, 8, 4, 2, 1.\nSince n sometimes increases and sometimes decreases, there is no obvious proof that n will\never reach 1, or that the program terminates. For some particular values of n, we can prove\ntermination. For example, if the starting value is a power of two, n will be even every\ntime through the loop until it reaches 1. The previous example ends with such a sequence,\nstarting with 16.\nThe hard question is whether we can prove that this program terminates for all posi-\ntive values of n.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_195",
    "text": "starting with 16.\nThe hard question is whether we can prove that this program terminates for all posi-\ntive values of n.\nSo far, no one has been able to prove it or disprove it!\n(See http:\n//en.wikipedia.org/wiki/Collatz_conjecture.)\n66\nChapter 7. Iteration\nAs an exercise, rewrite the function print_n from Section 5.8 using iteration instead of\nrecursion.\n7.4\nbreak\nSometimes you don\u2019t know it\u2019s time to end a loop until you get half way through the body.\nIn that case you can use the break statement to jump out of the loop.\nFor example, suppose you want to take input from the user until they type done. You could\nwrite:\nwhile True:\nline = input('> ')\nif line == 'done':\nbreak\nprint(line)\nprint('Done!')\nThe loop condition is True, which is always true, so the loop runs until it hits the break\nstatement.\nEach time through, it prompts the user with an angle bracket. If the user types done, the\nbreak statement exits the loop. Otherwise the program echoes whatever the user types and",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_196",
    "text": "statement.\nEach time through, it prompts the user with an angle bracket. If the user types done, the\nbreak statement exits the loop. Otherwise the program echoes whatever the user types and\ngoes back to the top of the loop. Here\u2019s a sample run:\n> not done\nnot done\n> done\nDone!\nThis way of writing while loops is common because you can check the condition anywhere\nin the loop (not just at the top) and you can express the stop condition af\ufb01rmatively (\u201cstop\nwhen this happens\u201d) rather than negatively (\u201ckeep going until that happens\u201d).\n7.5\nSquare roots\nLoops are often used in programs that compute numerical results by starting with an ap-\nproximate answer and iteratively improving it.\nFor example, one way of computing square roots is Newton\u2019s method. Suppose that you\nwant to know the square root of a. If you start with almost any estimate, x, you can com-\npute a better estimate with the following formula:\ny = x + a/x\n2\nFor example, if a is 4 and x is 3:\n>>> a = 4\n>>> x = 3",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_197",
    "text": "pute a better estimate with the following formula:\ny = x + a/x\n2\nFor example, if a is 4 and x is 3:\n>>> a = 4\n>>> x = 3\n>>> y = (x + a/x) / 2\n>>> y\n2.16666666667\n7.6. Algorithms\n67\nThe result is closer to the correct answer (\n\u221a\n4 = 2). If we repeat the process with the new\nestimate, it gets even closer:\n>>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.00641025641\nAfter a few more updates, the estimate is almost exact:\n>>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.00001024003\n>>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.00000000003\nIn general we don\u2019t know ahead of time how many steps it takes to get to the right answer,\nbut we know when we get there because the estimate stops changing:\n>>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.0\n>>> x = y\n>>> y = (x + a/x) / 2\n>>> y\n2.0\nWhen y == x, we can stop. Here is a loop that starts with an initial estimate, x, and im-\nproves it until it stops changing:\nwhile True:\nprint(x)\ny = (x + a/x) / 2\nif y == x:\nbreak\nx = y",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_198",
    "text": ">>> y\n2.0\nWhen y == x, we can stop. Here is a loop that starts with an initial estimate, x, and im-\nproves it until it stops changing:\nwhile True:\nprint(x)\ny = (x + a/x) / 2\nif y == x:\nbreak\nx = y\nFor most values of a this works \ufb01ne, but in general it is dangerous to test float equality.\nFloating-point values are only approximately right: most rational numbers, like 1/3, and\nirrational numbers, like\n\u221a\n2, can\u2019t be represented exactly with a float.\nRather than checking whether x and y are exactly equal, it is safer to use the built-in func-\ntion abs to compute the absolute value, or magnitude, of the difference between them:\nif abs(y-x) < epsilon:\nbreak\nWhere epsilon has a value like 0.0000001 that determines how close is close enough.\n7.6\nAlgorithms\nNewton\u2019s method is an example of an algorithm: it is a mechanical process for solving a\ncategory of problems (in this case, computing square roots).\n68\nChapter 7. Iteration",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_199",
    "text": "7.6\nAlgorithms\nNewton\u2019s method is an example of an algorithm: it is a mechanical process for solving a\ncategory of problems (in this case, computing square roots).\n68\nChapter 7. Iteration\nTo understand what an algorithm is, it might help to start with something that is not an\nalgorithm. When you learned to multiply single-digit numbers, you probably memorized\nthe multiplication table. In effect, you memorized 100 speci\ufb01c solutions. That kind of\nknowledge is not algorithmic.\nBut if you were \u201clazy\u201d, you might have learned a few tricks. For example, to \ufb01nd the\nproduct of n and 9, you can write n \u22121 as the \ufb01rst digit and 10 \u2212n as the second digit.\nThis trick is a general solution for multiplying any single-digit number by 9. That\u2019s an\nalgorithm!\nSimilarly, the techniques you learned for addition with carrying, subtraction with borrow-\ning, and long division are all algorithms. One of the characteristics of algorithms is that",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_200",
    "text": "algorithm!\nSimilarly, the techniques you learned for addition with carrying, subtraction with borrow-\ning, and long division are all algorithms. One of the characteristics of algorithms is that\nthey do not require any intelligence to carry out. They are mechanical processes where\neach step follows from the last according to a simple set of rules.\nExecuting algorithms is boring, but designing them is interesting, intellectually challeng-\ning, and a central part of computer science.\nSome of the things that people do naturally, without dif\ufb01culty or conscious thought, are\nthe hardest to express algorithmically. Understanding natural language is a good example.\nWe all do it, but so far no one has been able to explain how we do it, at least not in the form\nof an algorithm.\n7.7\nDebugging\nAs you start writing bigger programs, you might \ufb01nd yourself spending more time debug-\nging. More code means more chances to make an error and more places for bugs to hide.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_201",
    "text": "7.7\nDebugging\nAs you start writing bigger programs, you might \ufb01nd yourself spending more time debug-\nging. More code means more chances to make an error and more places for bugs to hide.\nOne way to cut your debugging time is \u201cdebugging by bisection\u201d. For example, if there\nare 100 lines in your program and you check them one at a time, it would take 100 steps.\nInstead, try to break the problem in half. Look at the middle of the program, or near it, for\nan intermediate value you can check. Add a print statement (or something else that has a\nveri\ufb01able effect) and run the program.\nIf the mid-point check is incorrect, there must be a problem in the \ufb01rst half of the program.\nIf it is correct, the problem is in the second half.\nEvery time you perform a check like this, you halve the number of lines you have to search.\nAfter six steps (which is fewer than 100), you would be down to one or two lines of code,\nat least in theory.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_202",
    "text": "After six steps (which is fewer than 100), you would be down to one or two lines of code,\nat least in theory.\nIn practice it is not always clear what the \u201cmiddle of the program\u201d is and not always pos-\nsible to check it. It doesn\u2019t make sense to count lines and \ufb01nd the exact midpoint. Instead,\nthink about places in the program where there might be errors and places where it is easy\nto put a check. Then choose a spot where you think the chances are about the same that\nthe bug is before or after the check.\n7.8\nGlossary\nreassignment: Assigning a new value to a variable that already exists.\n7.9. Exercises\n69\nupdate: An assignment where the new value of the variable depends on the old.\ninitialization: An assignment that gives an initial value to a variable that will be updated.\nincrement: An update that increases the value of a variable (often by one).\ndecrement: An update that decreases the value of a variable.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_203",
    "text": "increment: An update that increases the value of a variable (often by one).\ndecrement: An update that decreases the value of a variable.\niteration: Repeated execution of a set of statements using either a recursive function call\nor a loop.\nin\ufb01nite loop: A loop in which the terminating condition is never satis\ufb01ed.\nalgorithm: A general process for solving a category of problems.\n7.9\nExercises\nExercise 7.1. Copy the loop from Section 7.5 and encapsulate it in a function called mysqrt that\ntakes a as a parameter, chooses a reasonable value of x, and returns an estimate of the square root of\na.\nTo test it, write a function named test_square_root that prints a table like this:\na\nmysqrt(a)\nmath.sqrt(a)\ndiff\n-\n---------\n------------\n----\n1.0 1.0\n1.0\n0.0\n2.0 1.41421356237 1.41421356237 2.22044604925e-16\n3.0 1.73205080757 1.73205080757 0.0\n4.0 2.0\n2.0\n0.0\n5.0 2.2360679775\n2.2360679775\n0.0\n6.0 2.44948974278 2.44948974278 0.0\n7.0 2.64575131106 2.64575131106 0.0",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_204",
    "text": "3.0 1.73205080757 1.73205080757 0.0\n4.0 2.0\n2.0\n0.0\n5.0 2.2360679775\n2.2360679775\n0.0\n6.0 2.44948974278 2.44948974278 0.0\n7.0 2.64575131106 2.64575131106 0.0\n8.0 2.82842712475 2.82842712475 4.4408920985e-16\n9.0 3.0\n3.0\n0.0\nThe \ufb01rst column is a number, a; the second column is the square root of a computed with mysqrt;\nthe third column is the square root computed by math.sqrt; the fourth column is the absolute value\nof the difference between the two estimates.\nExercise 7.2. The built-in function eval takes a string and evaluates it using the Python inter-\npreter. For example:\n>>> eval('1 + 2 * 3')\n7\n>>> import math\n>>> eval('math.sqrt(5)')\n2.2360679774997898\n>>> eval('type(math.pi)')\n<class 'float'>\nWrite a function called eval_loop that iteratively prompts the user, takes the resulting input and\nevaluates it using eval, and prints the result.\nIt should continue until the user enters 'done', and then return the value of the last expression it\nevaluated.\n70\nChapter 7. Iteration",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_205",
    "text": "evaluates it using eval, and prints the result.\nIt should continue until the user enters 'done', and then return the value of the last expression it\nevaluated.\n70\nChapter 7. Iteration\nExercise 7.3. The mathematician Srinivasa Ramanujan found an in\ufb01nite series that can be used to\ngenerate a numerical approximation of 1/\u03c0:\n1\n\u03c0 = 2\n\u221a\n2\n9801\n\u221e\n\u2211\nk=0\n(4k)!(1103 + 26390k)\n(k!)43964k\nWrite a function called estimate_pi that uses this formula to compute and return an estimate of\n\u03c0. It should use a while loop to compute terms of the summation until the last term is smaller than\n1e-15 (which is Python notation for 10\u221215). You can check the result by comparing it to math.pi.\nSolution: https: // thinkpython. com/ code/ pi. py .\nChapter 8\nStrings\nStrings are not like integers, \ufb02oats, and booleans. A string is a sequence, which means it is\nan ordered collection of other values. In this chapter you\u2019ll see how to access the characters",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_206",
    "text": "Strings\nStrings are not like integers, \ufb02oats, and booleans. A string is a sequence, which means it is\nan ordered collection of other values. In this chapter you\u2019ll see how to access the characters\nthat make up a string, and you\u2019ll learn about some of the methods strings provide.\n8.1\nA string is a sequence\nA string is a sequence of characters. You can access the characters one at a time with the\nbracket operator:\n>>> fruit = 'banana'\n>>> letter = fruit[1]\nThe second statement selects character number 1 from fruit and assigns it to letter.\nThe expression in brackets is called an index. The index indicates which character in the\nsequence you want (hence the name).\nBut you might not get what you expect:\n>>> letter\n'a'\nFor most people, the \ufb01rst letter of 'banana' is b, not a. But for computer scientists, the\nindex is an offset from the beginning of the string, and the offset of the \ufb01rst letter is zero.\n>>> letter = fruit[0]\n>>> letter\n'b'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_207",
    "text": "index is an offset from the beginning of the string, and the offset of the \ufb01rst letter is zero.\n>>> letter = fruit[0]\n>>> letter\n'b'\nSo b is the 0th letter (\u201czero-eth\u201d) of 'banana', a is the 1th letter (\u201cone-eth\u201d), and n is the 2th\nletter (\u201ctwo-eth\u201d).\nAs an index you can use an expression that contains variables and operators:\n>>> i = 1\n>>> fruit[i]\n'a'\n>>> fruit[i+1]\n'n'\n72\nChapter 8. Strings\nBut the value of the index has to be an integer. Otherwise you get:\n>>> letter = fruit[1.5]\nTypeError: string indices must be integers\n8.2\nlen\nlen is a built-in function that returns the number of characters in a string:\n>>> fruit = 'banana'\n>>> len(fruit)\n6\nTo get the last letter of a string, you might be tempted to try something like this:\n>>> length = len(fruit)\n>>> last = fruit[length]\nIndexError: string index out of range\nThe reason for the IndexError is that there is no letter in \u2019banana\u2019 with the index 6. Since",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_208",
    "text": ">>> length = len(fruit)\n>>> last = fruit[length]\nIndexError: string index out of range\nThe reason for the IndexError is that there is no letter in \u2019banana\u2019 with the index 6. Since\nwe started counting at zero, the six letters are numbered 0 to 5. To get the last character,\nyou have to subtract 1 from length:\n>>> last = fruit[length-1]\n>>> last\n'a'\nOr you can use negative indices, which count backward from the end of the string. The\nexpression fruit[-1] yields the last letter, fruit[-2] yields the second to last, and so on.\n8.3\nTraversal with a for loop\nA lot of computations involve processing a string one character at a time. Often they start\nat the beginning, select each character in turn, do something to it, and continue until the\nend. This pattern of processing is called a traversal. One way to write a traversal is with a\nwhile loop:\nindex = 0\nwhile index < len(fruit):\nletter = fruit[index]\nprint(letter)\nindex = index + 1",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_209",
    "text": "end. This pattern of processing is called a traversal. One way to write a traversal is with a\nwhile loop:\nindex = 0\nwhile index < len(fruit):\nletter = fruit[index]\nprint(letter)\nindex = index + 1\nThis loop traverses the string and displays each letter on a line by itself. The loop condition\nis index < len(fruit), so when index is equal to the length of the string, the condition is\nfalse, and the body of the loop doesn\u2019t run. The last character accessed is the one with the\nindex len(fruit)-1, which is the last character in the string.\nAs an exercise, write a function that takes a string as an argument and displays the letters\nbackward, one per line.\nAnother way to write a traversal is with a for loop:\nfor letter in fruit:\nprint(letter)\n8.4. String slices\n73\nfruit\nb a n\nn\na\na \u2019\n0\n1\n2\n3\n4\n5\n6\nindex\n\u2019\nFigure 8.1: Slice indices.\nEach time through the loop, the next character in the string is assigned to the variable\nletter. The loop continues until no characters are left.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_210",
    "text": "a\na \u2019\n0\n1\n2\n3\n4\n5\n6\nindex\n\u2019\nFigure 8.1: Slice indices.\nEach time through the loop, the next character in the string is assigned to the variable\nletter. The loop continues until no characters are left.\nThe following example shows how to use concatenation (string addition) and a for loop\nto generate an abecedarian series (that is, in alphabetical order). In Robert McCloskey\u2019s\nbook Make Way for Ducklings, the names of the ducklings are Jack, Kack, Lack, Mack, Nack,\nOuack, Pack, and Quack. This loop outputs these names in order:\nprefixes = 'JKLMNOPQ'\nsuffix = 'ack'\nfor letter in prefixes:\nprint(letter + suffix)\nThe output is:\nJack\nKack\nLack\nMack\nNack\nOack\nPack\nQack\nOf course, that\u2019s not quite right because \u201cOuack\u201d and \u201cQuack\u201d are misspelled. As an\nexercise, modify the program to \ufb01x this error.\n8.4\nString slices\nA segment of a string is called a slice. Selecting a slice is similar to selecting a character:\n>>> s = 'Monty Python'\n>>> s[0:5]\n'Monty'\n>>> s[6:12]\n'Python'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_211",
    "text": "8.4\nString slices\nA segment of a string is called a slice. Selecting a slice is similar to selecting a character:\n>>> s = 'Monty Python'\n>>> s[0:5]\n'Monty'\n>>> s[6:12]\n'Python'\nThe operator [n:m] returns the part of the string from the \u201cn-eth\u201d character to the \u201cm-eth\u201d\ncharacter, including the \ufb01rst but excluding the last. This behavior is counterintuitive, but\nit might help to imagine the indices pointing between the characters, as in Figure 8.1.\nIf you omit the \ufb01rst index (before the colon), the slice starts at the beginning of the string.\nIf you omit the second index, the slice goes to the end of the string:\n>>> fruit = 'banana'\n>>> fruit[:3]\n74\nChapter 8. Strings\n'ban'\n>>> fruit[3:]\n'ana'\nIf the \ufb01rst index is greater than or equal to the second the result is an empty string, repre-\nsented by two quotation marks:\n>>> fruit = 'banana'\n>>> fruit[3:3]\n''\nAn empty string contains no characters and has length 0, but other than that, it is the same\nas any other string.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_212",
    "text": "sented by two quotation marks:\n>>> fruit = 'banana'\n>>> fruit[3:3]\n''\nAn empty string contains no characters and has length 0, but other than that, it is the same\nas any other string.\nContinuing this example, what do you think fruit[:] means? Try it and see.\n8.5\nStrings are immutable\nIt is tempting to use the [] operator on the left side of an assignment, with the intention of\nchanging a character in a string. For example:\n>>> greeting = 'Hello, world!'\n>>> greeting[0] = 'J'\nTypeError: 'str' object does not support item assignment\nThe \u201cobject\u201d in this case is the string and the \u201citem\u201d is the character you tried to assign.\nFor now, an object is the same thing as a value, but we will re\ufb01ne that de\ufb01nition later\n(Section 10.10).\nThe reason for the error is that strings are immutable, which means you can\u2019t change an\nexisting string. The best you can do is create a new string that is a variation on the original:\n>>> greeting = 'Hello, world!'\n>>> new_greeting = 'J' + greeting[1:]",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_213",
    "text": "existing string. The best you can do is create a new string that is a variation on the original:\n>>> greeting = 'Hello, world!'\n>>> new_greeting = 'J' + greeting[1:]\n>>> new_greeting\n'Jello, world!'\nThis example concatenates a new \ufb01rst letter onto a slice of greeting. It has no effect on the\noriginal string.\n8.6\nSearching\nWhat does the following function do?\ndef find(word, letter):\nindex = 0\nwhile index < len(word):\nif word[index] == letter:\nreturn index\nindex = index + 1\nreturn -1\n8.7. Looping and counting\n75\nIn a sense, find is the inverse of the [] operator. Instead of taking an index and extracting\nthe corresponding character, it takes a character and \ufb01nds the index where that character\nappears. If the character is not found, the function returns -1.\nThis is the \ufb01rst example we have seen of a return statement inside a loop. If word[index]\n== letter, the function breaks out of the loop and returns immediately.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_214",
    "text": "This is the \ufb01rst example we have seen of a return statement inside a loop. If word[index]\n== letter, the function breaks out of the loop and returns immediately.\nIf the character doesn\u2019t appear in the string, the program exits the loop normally and re-\nturns -1.\nThis pattern of computation\u2014traversing a sequence and returning when we \ufb01nd what we\nare looking for\u2014is called a search.\nAs an exercise, modify find so that it has a third parameter, the index in word where it\nshould start looking.\n8.7\nLooping and counting\nThe following program counts the number of times the letter a appears in a string:\nword = 'banana'\ncount = 0\nfor letter in word:\nif letter == 'a':\ncount = count + 1\nprint(count)\nThis program demonstrates another pattern of computation called a counter. The variable\ncount is initialized to 0 and then incremented each time an a is found. When the loop exits,\ncount contains the result\u2014the total number of a\u2019s.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_215",
    "text": "count is initialized to 0 and then incremented each time an a is found. When the loop exits,\ncount contains the result\u2014the total number of a\u2019s.\nAs an exercise, encapsulate this code in a function named count, and generalize it so that\nit accepts the string and the letter as arguments.\nThen rewrite the function so that instead of traversing the string, it uses the three-\nparameter version of find from the previous section.\n8.8\nString methods\nStrings provide methods that perform a variety of useful operations. A method is similar\nto a function\u2014it takes arguments and returns a value\u2014but the syntax is different. For\nexample, the method upper takes a string and returns a new string with all uppercase\nletters.\nInstead of the function syntax upper(word), it uses the method syntax word.upper().\n>>> word = 'banana'\n>>> new_word = word.upper()\n>>> new_word\n'BANANA'\n76\nChapter 8. Strings\nThis form of dot notation speci\ufb01es the name of the method, upper, and the name of the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_216",
    "text": ">>> word = 'banana'\n>>> new_word = word.upper()\n>>> new_word\n'BANANA'\n76\nChapter 8. Strings\nThis form of dot notation speci\ufb01es the name of the method, upper, and the name of the\nstring to apply the method to, word. The empty parentheses indicate that this method\ntakes no arguments.\nA method call is called an invocation; in this case, we would say that we are invoking\nupper on word.\nAs it turns out, there is a string method named find that is remarkably similar to the\nfunction we wrote:\n>>> word = 'banana'\n>>> index = word.find('a')\n>>> index\n1\nIn this example, we invoke find on word and pass the letter we are looking for as a param-\neter.\nActually, the find method is more general than our function; it can \ufb01nd substrings, not just\ncharacters:\n>>> word.find('na')\n2\nBy default, find starts at the beginning of the string, but it can take a second argument, the\nindex where it should start:\n>>> word.find('na', 3)\n4",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_217",
    "text": "characters:\n>>> word.find('na')\n2\nBy default, find starts at the beginning of the string, but it can take a second argument, the\nindex where it should start:\n>>> word.find('na', 3)\n4\nThis is an example of an optional argument; find can also take a third argument, the index\nwhere it should stop:\n>>> name = 'bob'\n>>> name.find('b', 1, 2)\n-1\nThis search fails because b does not appear in the index range from 1 to 2, not including 2.\nSearching up to, but not including, the second index makes find consistent with the slice\noperator.\n8.9\nThe in operator\nThe word in is a boolean operator that takes two strings and returns True if the \ufb01rst ap-\npears as a substring in the second:\n>>> 'a' in 'banana'\nTrue\n>>> 'seed' in 'banana'\nFalse\nFor example, the following function prints all the letters from word1 that also appear in\nword2:\ndef in_both(word1, word2):\nfor letter in word1:\nif letter in word2:\nprint(letter)\n8.10. String comparison\n77",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_218",
    "text": "word2:\ndef in_both(word1, word2):\nfor letter in word1:\nif letter in word2:\nprint(letter)\n8.10. String comparison\n77\nWith well-chosen variable names, Python sometimes reads like English. You could read\nthis loop, \u201cfor (each) letter in (the \ufb01rst) word, if (the) letter (appears) in (the second) word,\nprint (the) letter.\u201d\nHere\u2019s what you get if you compare apples and oranges:\n>>> in_both('apples', 'oranges')\na\ne\ns\n8.10\nString comparison\nThe relational operators work on strings. To see if two strings are equal:\nif word == 'banana':\nprint('All right, bananas.')\nOther relational operations are useful for putting words in alphabetical order:\nif word < 'banana':\nprint('Your word, ' + word + ', comes before banana.')\nelif word > 'banana':\nprint('Your word, ' + word + ', comes after banana.')\nelse:\nprint('All right, bananas.')\nPython does not handle uppercase and lowercase letters the same way people do. All the\nuppercase letters come before all the lowercase letters, so:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_219",
    "text": "else:\nprint('All right, bananas.')\nPython does not handle uppercase and lowercase letters the same way people do. All the\nuppercase letters come before all the lowercase letters, so:\nYour word, Pineapple, comes before banana.\nA common way to address this problem is to convert strings to a standard format, such as\nall lowercase, before performing the comparison. Keep that in mind in case you have to\ndefend yourself against a man armed with a Pineapple.\n8.11\nDebugging\nWhen you use indices to traverse the values in a sequence, it is tricky to get the beginning\nand end of the traversal right. Here is a function that is supposed to compare two words\nand return True if one of the words is the reverse of the other, but it contains two errors:\ndef is_reverse(word1, word2):\nif len(word1) != len(word2):\nreturn False\ni = 0\nj = len(word2)\nwhile j > 0:\nif word1[i] != word2[j]:\nreturn False\ni = i+1\n78\nChapter 8. Strings\nj = j-1\nreturn True",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_220",
    "text": "def is_reverse(word1, word2):\nif len(word1) != len(word2):\nreturn False\ni = 0\nj = len(word2)\nwhile j > 0:\nif word1[i] != word2[j]:\nreturn False\ni = i+1\n78\nChapter 8. Strings\nj = j-1\nreturn True\nThe \ufb01rst if statement checks whether the words are the same length. If not, we can return\nFalse immediately. Otherwise, for the rest of the function, we can assume that the words\nare the same length. This is an example of the guardian pattern in Section 6.8.\ni and j are indices: i traverses word1 forward while j traverses word2 backward. If we\n\ufb01nd two letters that don\u2019t match, we can return False immediately. If we get through the\nwhole loop and all the letters match, we return True.\nIf we test this function with the words \u201cpots\u201d and \u201cstop\u201d, we expect the return value True,\nbut we get an IndexError:\n>>> is_reverse('pots', 'stop')\n...\nFile \"reverse.py\", line 15, in is_reverse\nif word1[i] != word2[j]:\nIndexError: string index out of range",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_221",
    "text": "but we get an IndexError:\n>>> is_reverse('pots', 'stop')\n...\nFile \"reverse.py\", line 15, in is_reverse\nif word1[i] != word2[j]:\nIndexError: string index out of range\nFor debugging this kind of error, my \ufb01rst move is to print the values of the indices imme-\ndiately before the line where the error appears.\nwhile j > 0:\nprint(i, j)\n# print here\nif word1[i] != word2[j]:\nreturn False\ni = i+1\nj = j-1\nNow when I run the program again, I get more information:\n>>> is_reverse('pots', 'stop')\n0 4\n...\nIndexError: string index out of range\nThe \ufb01rst time through the loop, the value of j is 4, which is out of range for the\nstring 'pots'. The index of the last character is 3, so the initial value for j should be\nlen(word2)-1.\nIf I \ufb01x that error and run the program again, I get:\n>>> is_reverse('pots', 'stop')\n0 3\n1 2\n2 1\nTrue\nThis time we get the right answer, but it looks like the loop only ran three times, which is",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_222",
    "text": "If I \ufb01x that error and run the program again, I get:\n>>> is_reverse('pots', 'stop')\n0 3\n1 2\n2 1\nTrue\nThis time we get the right answer, but it looks like the loop only ran three times, which is\nsuspicious. To get a better idea of what is happening, it is useful to draw a state diagram.\nDuring the \ufb01rst iteration, the frame for is_reverse is shown in Figure 8.2.\nI took some license by arranging the variables in the frame and adding dotted lines to show\nthat the values of i and j indicate characters in word1 and word2.\nStarting with this diagram, run the program on paper, changing the values of i and j\nduring each iteration. Find and \ufb01x the second error in this function.\n8.12. Glossary\n79\ni\n0\nj\n3\nword1\n\u2019pots\u2019\nword2\n\u2019stop\u2019\nFigure 8.2: State diagram.\n8.12\nGlossary\nobject: Something a variable can refer to. For now, you can use \u201cobject\u201d and \u201cvalue\u201d\ninterchangeably.\nsequence: An ordered collection of values where each value is identi\ufb01ed by an integer\nindex.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_223",
    "text": "object: Something a variable can refer to. For now, you can use \u201cobject\u201d and \u201cvalue\u201d\ninterchangeably.\nsequence: An ordered collection of values where each value is identi\ufb01ed by an integer\nindex.\nitem: One of the values in a sequence.\nindex: An integer value used to select an item in a sequence, such as a character in a string.\nIn Python indices start from 0.\nslice: A part of a string speci\ufb01ed by a range of indices.\nempty string: A string with no characters and length 0, represented by two quotation\nmarks.\nimmutable: The property of a sequence whose items cannot be changed.\ntraverse: To iterate through the items in a sequence, performing a similar operation on\neach.\nsearch: A pattern of traversal that stops when it \ufb01nds what it is looking for.\ncounter: A variable used to count something, usually initialized to zero and then incre-\nmented.\ninvocation: A statement that calls a method.\noptional argument: A function or method argument that is not required.\n8.13\nExercises",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_224",
    "text": "mented.\ninvocation: A statement that calls a method.\noptional argument: A function or method argument that is not required.\n8.13\nExercises\nExercise 8.1. Read the documentation of the string methods at http: // docs. python. org/ 3/\nlibrary/ stdtypes. html# string-methods . You might want to experiment with some of them\nto make sure you understand how they work. strip and replace are particularly useful.\nThe\ndocumentation\nuses\na\nsyntax\nthat\nmight\nbe\nconfusing.\nFor\nexample,\nin\nfind(sub[, start[, end]]), the brackets indicate optional arguments. So sub is required, but\nstart is optional, and if you include start, then end is optional.\nExercise 8.2. There is a string method called count that is similar to the function in Section 8.7.\nRead the documentation of this method and write an invocation that counts the number of a\u2019s in\n'banana'.\nExercise 8.3. A string slice can take a third index that speci\ufb01es the \u201cstep size\u201d; that is, the number",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_225",
    "text": "'banana'.\nExercise 8.3. A string slice can take a third index that speci\ufb01es the \u201cstep size\u201d; that is, the number\nof spaces between successive characters. A step size of 2 means every other character; 3 means every\nthird, etc.\n80\nChapter 8. Strings\n>>> fruit = 'banana'\n>>> fruit[0:5:2]\n'bnn'\nA step size of -1 goes through the word backwards, so the slice [::-1] generates a reversed string.\nUse this idiom to write a one-line version of is_palindrome from Exercise 6.3.\nExercise 8.4. The following functions are all intended to check whether a string contains any\nlowercase letters, but at least some of them are wrong. For each function, describe what the function\nactually does (assuming that the parameter is a string).\ndef any_lowercase1(s):\nfor c in s:\nif c.islower():\nreturn True\nelse:\nreturn False\ndef any_lowercase2(s):\nfor c in s:\nif 'c'.islower():\nreturn 'True'\nelse:\nreturn 'False'\ndef any_lowercase3(s):\nfor c in s:\nflag = c.islower()\nreturn flag\ndef any_lowercase4(s):\nflag = False",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_226",
    "text": "def any_lowercase2(s):\nfor c in s:\nif 'c'.islower():\nreturn 'True'\nelse:\nreturn 'False'\ndef any_lowercase3(s):\nfor c in s:\nflag = c.islower()\nreturn flag\ndef any_lowercase4(s):\nflag = False\nfor c in s:\nflag = flag or c.islower()\nreturn flag\ndef any_lowercase5(s):\nfor c in s:\nif not c.islower():\nreturn False\nreturn True\nExercise 8.5. A Caesar cypher is a weak form of encryption that involves \u201crotating\u201d each letter by\na \ufb01xed number of places. To rotate a letter means to shift it through the alphabet, wrapping around\nto the beginning if necessary, so \u2019A\u2019 rotated by 3 is \u2019D\u2019 and \u2019Z\u2019 rotated by 1 is \u2019A\u2019.\nTo rotate a word, rotate each letter by the same amount. For example, \u201ccheer\u201d rotated by 7 is \u201cjolly\u201d\nand \u201cmelon\u201d rotated by -10 is \u201ccubed\u201d. In the movie 2001: A Space Odyssey, the ship computer\nis called HAL, which is IBM rotated by -1.\nWrite a function called rotate_word that takes a string and an integer as parameters, and returns",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_227",
    "text": "is called HAL, which is IBM rotated by -1.\nWrite a function called rotate_word that takes a string and an integer as parameters, and returns\na new string that contains the letters from the original string rotated by the given amount.\nYou might want to use the built-in function ord, which converts a character to a numeric code, and\n8.13. Exercises\n81\nchr, which converts numeric codes to characters. Letters of the alphabet are encoded in alphabetical\norder, so for example:\n>>> ord('c') - ord('a')\n2\nBecause 'c' is the two-eth letter of the alphabet. But beware: the numeric codes for upper case\nletters are different.\nPotentially offensive jokes on the Internet are sometimes encoded in ROT13, which is a Caesar\ncypher with rotation 13. If you are not easily offended, \ufb01nd and decode some of them. Solution:\nhttps: // thinkpython. com/ code/ rotate. py .\n82\nChapter 8. Strings\nChapter 9\nCase study: word play\nThis chapter presents the second case study, which involves solving word puzzles by",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_228",
    "text": "https: // thinkpython. com/ code/ rotate. py .\n82\nChapter 8. Strings\nChapter 9\nCase study: word play\nThis chapter presents the second case study, which involves solving word puzzles by\nsearching for words that have certain properties. For example, we\u2019ll \ufb01nd the longest palin-\ndromes in English and search for words whose letters appear in alphabetical order. And\nI will present another program development plan: reduction to a previously solved prob-\nlem.\n9.1\nReading word lists\nFor the exercises in this chapter we need a list of English words. There are lots of word\nlists available on the Web, but the one most suitable for our purpose is one of the word lists\ncollected and contributed to the public domain by Grady Ward as part of the Moby lexi-\ncon project (see http://wikipedia.org/wiki/Moby_Project). It is a list of 113,809 of\ufb01cial\ncrosswords; that is, words that are considered valid in crossword puzzles and other word",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_229",
    "text": "con project (see http://wikipedia.org/wiki/Moby_Project). It is a list of 113,809 of\ufb01cial\ncrosswords; that is, words that are considered valid in crossword puzzles and other word\ngames. In the Moby collection, the \ufb01lename is 113809of.fic; you can download a copy,\nwith the simpler name words.txt, from https://thinkpython.com/code/words.txt.\nThis \ufb01le is in plain text, so you can open it with a text editor, but you can also read it from\nPython. The built-in function open takes the name of the \ufb01le as a parameter and returns a\n\ufb01le object you can use to read the \ufb01le.\n>>> fin = open('words.txt')\nfin is a common name for a \ufb01le object used for input. The \ufb01le object provides several\nmethods for reading, including readline, which reads characters from the \ufb01le until it gets\nto a newline and returns the result as a string:\n>>> fin.readline()\n'aa\\n'\nThe \ufb01rst word in this particular list is \u201caa\u201d, which is a kind of lava. The sequence \\n",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_230",
    "text": "to a newline and returns the result as a string:\n>>> fin.readline()\n'aa\\n'\nThe \ufb01rst word in this particular list is \u201caa\u201d, which is a kind of lava. The sequence \\n\nrepresents the newline character that separates this word from the next.\nThe \ufb01le object keeps track of where it is in the \ufb01le, so if you call readline again, you get\nthe next word:\n>>> fin.readline()\n'aah\\n'\n84\nChapter 9. Case study: word play\nThe next word is \u201caah\u201d, which is a perfectly legitimate word, so stop looking at me like\nthat. Or, if it\u2019s the newline character that\u2019s bothering you, we can get rid of it with the\nstring method strip:\n>>> line = fin.readline()\n>>> word = line.strip()\n>>> word\n'aahed'\nYou can also use a \ufb01le object as part of a for loop. This program reads words.txt and\nprints each word, one per line:\nfin = open('words.txt')\nfor line in fin:\nword = line.strip()\nprint(word)\n9.2\nExercises\nThere are solutions to these exercises in the next section. You should at least attempt each",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_231",
    "text": "fin = open('words.txt')\nfor line in fin:\nword = line.strip()\nprint(word)\n9.2\nExercises\nThere are solutions to these exercises in the next section. You should at least attempt each\none before you read the solutions.\nExercise 9.1. Write a program that reads words.txt and prints only the words with more than 20\ncharacters (not counting whitespace).\nExercise 9.2. In 1939 Ernest Vincent Wright published a 50,000 word novel called Gadsby that\ndoes not contain the letter \u201ce\u201d. Since \u201ce\u201d is the most common letter in English, that\u2019s not easy to\ndo.\nIn fact, it is dif\ufb01cult to construct a solitary thought without using that most common symbol. It is\nslow going at \ufb01rst, but with caution and hours of training you can gradually gain facility.\nAll right, I\u2019ll stop now.\nWrite a function called has_no_e that returns True if the given word doesn\u2019t have the letter \u201ce\u201d in\nit.\nWrite a program that reads words.txt and prints only the words that have no \u201ce\u201d. Compute the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_232",
    "text": "Write a function called has_no_e that returns True if the given word doesn\u2019t have the letter \u201ce\u201d in\nit.\nWrite a program that reads words.txt and prints only the words that have no \u201ce\u201d. Compute the\npercentage of words in the list that have no \u201ce\u201d.\nExercise 9.3. Write a function named avoids that takes a word and a string of forbidden letters,\nand that returns True if the word doesn\u2019t use any of the forbidden letters.\nWrite a program that prompts the user to enter a string of forbidden letters and then prints the\nnumber of words that don\u2019t contain any of them. Can you \ufb01nd a combination of 5 forbidden letters\nthat excludes the smallest number of words?\nExercise 9.4. Write a function named uses_only that takes a word and a string of letters, and\nthat returns True if the word contains only letters in the list. Can you make a sentence using only\nthe letters acefhlo? Other than \u201cHoe alfalfa\u201d?\nExercise 9.5. Write a function named uses_all that takes a word and a string of required letters,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_233",
    "text": "the letters acefhlo? Other than \u201cHoe alfalfa\u201d?\nExercise 9.5. Write a function named uses_all that takes a word and a string of required letters,\nand that returns True if the word uses all the required letters at least once. How many words are\nthere that use all the vowels aeiou? How about aeiouy?\nExercise 9.6. Write a function called is_abecedarian that returns True if the letters in a word\nappear in alphabetical order (double letters are ok). How many abecedarian words are there?\n9.3. Search\n85\n9.3\nSearch\nAll of the exercises in the previous section have something in common; they can be solved\nwith the search pattern we saw in Section 8.6. The simplest example is:\ndef has_no_e(word):\nfor letter in word:\nif letter == 'e':\nreturn False\nreturn True\nThe for loop traverses the characters in word. If we \ufb01nd the letter \u201ce\u201d, we can immediately\nreturn False; otherwise we have to go to the next letter. If we exit the loop normally, that\nmeans we didn\u2019t \ufb01nd an \u201ce\u201d, so we return True.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_234",
    "text": "return False; otherwise we have to go to the next letter. If we exit the loop normally, that\nmeans we didn\u2019t \ufb01nd an \u201ce\u201d, so we return True.\nYou could write this function more concisely using the in operator, but I started with this\nversion because it demonstrates the logic of the search pattern.\navoids is a more general version of has_no_e but it has the same structure:\ndef avoids(word, forbidden):\nfor letter in word:\nif letter in forbidden:\nreturn False\nreturn True\nWe can return False as soon as we \ufb01nd a forbidden letter; if we get to the end of the loop,\nwe return True.\nuses_only is similar except that the sense of the condition is reversed:\ndef uses_only(word, available):\nfor letter in word:\nif letter not in available:\nreturn False\nreturn True\nInstead of a list of forbidden letters, we have a list of available letters. If we \ufb01nd a letter in\nword that is not in available, we can return False.\nuses_all is similar except that we reverse the role of the word and the string of letters:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_235",
    "text": "word that is not in available, we can return False.\nuses_all is similar except that we reverse the role of the word and the string of letters:\ndef uses_all(word, required):\nfor letter in required:\nif letter not in word:\nreturn False\nreturn True\nInstead of traversing the letters in word, the loop traverses the required letters. If any of the\nrequired letters do not appear in the word, we can return False.\nIf you were really thinking like a computer scientist, you would have recognized that\nuses_all was an instance of a previously solved problem, and you would have written:\ndef uses_all(word, required):\nreturn uses_only(required, word)\nThis is an example of a program development plan called reduction to a previously solved\nproblem, which means that you recognize the problem you are working on as an instance\nof a solved problem and apply an existing solution.\n86\nChapter 9. Case study: word play\n9.4\nLooping with indices",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_236",
    "text": "problem, which means that you recognize the problem you are working on as an instance\nof a solved problem and apply an existing solution.\n86\nChapter 9. Case study: word play\n9.4\nLooping with indices\nI wrote the functions in the previous section with for loops because I only needed the\ncharacters in the strings; I didn\u2019t have to do anything with the indices.\nFor is_abecedarian we have to compare adjacent letters, which is a little tricky with a for\nloop:\ndef is_abecedarian(word):\nprevious = word[0]\nfor c in word:\nif c < previous:\nreturn False\nprevious = c\nreturn True\nAn alternative is to use recursion:\ndef is_abecedarian(word):\nif len(word) <= 1:\nreturn True\nif word[0] > word[1]:\nreturn False\nreturn is_abecedarian(word[1:])\nAnother option is to use a while loop:\ndef is_abecedarian(word):\ni = 0\nwhile i < len(word)-1:\nif word[i+1] < word[i]:\nreturn False\ni = i+1\nreturn True\nThe loop starts at i=0 and ends when i=len(word)-1. Each time through the loop, it com-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_237",
    "text": "def is_abecedarian(word):\ni = 0\nwhile i < len(word)-1:\nif word[i+1] < word[i]:\nreturn False\ni = i+1\nreturn True\nThe loop starts at i=0 and ends when i=len(word)-1. Each time through the loop, it com-\npares the ith character (which you can think of as the current character) to the i + 1th\ncharacter (which you can think of as the next).\nIf the next character is less than (alphabetically before) the current one, then we have dis-\ncovered a break in the abecedarian trend, and we return False.\nIf we get to the end of the loop without \ufb01nding a fault, then the word passes the test. To\nconvince yourself that the loop ends correctly, consider an example like 'flossy'. The\nlength of the word is 6, so the last time the loop runs is when i is 4, which is the index of\nthe second-to-last character. On the last iteration, it compares the second-to-last character\nto the last, which is what we want.\nHere is a version of is_palindrome (see Exercise 6.3) that uses two indices; one starts at",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_238",
    "text": "to the last, which is what we want.\nHere is a version of is_palindrome (see Exercise 6.3) that uses two indices; one starts at\nthe beginning and goes up; the other starts at the end and goes down.\ndef is_palindrome(word):\ni = 0\nj = len(word)-1\nwhile i<j:\nif word[i] != word[j]:\n9.5. Debugging\n87\nreturn False\ni = i+1\nj = j-1\nreturn True\nOr we could reduce to a previously solved problem and write:\ndef is_palindrome(word):\nreturn is_reverse(word, word)\nUsing is_reverse from Section 8.11.\n9.5\nDebugging\nTesting programs is hard. The functions in this chapter are relatively easy to test because\nyou can check the results by hand. Even so, it is somewhere between dif\ufb01cult and impos-\nsible to choose a set of words that test for all possible errors.\nTaking has_no_e as an example, there are two obvious cases to check: words that have an\n\u2018e\u2019 should return False, and words that don\u2019t should return True. You should have no\ntrouble coming up with one of each.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_239",
    "text": "\u2018e\u2019 should return False, and words that don\u2019t should return True. You should have no\ntrouble coming up with one of each.\nWithin each case, there are some less obvious subcases. Among the words that have an\n\u201ce\u201d, you should test words with an \u201ce\u201d at the beginning, the end, and somewhere in the\nmiddle. You should test long words, short words, and very short words, like the empty\nstring. The empty string is an example of a special case, which is one of the non-obvious\ncases where errors often lurk.\nIn addition to the test cases you generate, you can also test your program with a word list\nlike words.txt. By scanning the output, you might be able to catch errors, but be careful:\nyou might catch one kind of error (words that should not be included, but are) and not\nanother (words that should be included, but aren\u2019t).\nIn general, testing can help you \ufb01nd bugs, but it is not easy to generate a good set of\ntest cases, and even if you do, you can\u2019t be sure your program is correct. According to a",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_240",
    "text": "In general, testing can help you \ufb01nd bugs, but it is not easy to generate a good set of\ntest cases, and even if you do, you can\u2019t be sure your program is correct. According to a\nlegendary computer scientist:\nProgram testing can be used to show the presence of bugs, but never to show\ntheir absence!\n\u2014 Edsger W. Dijkstra\n9.6\nGlossary\n\ufb01le object: A value that represents an open \ufb01le.\nreduction to a previously solved problem: A way of solving a problem by expressing it\nas an instance of a previously solved problem.\nspecial case: A test case that is atypical or non-obvious (and less likely to be handled cor-\nrectly).\n88\nChapter 9. Case study: word play\n9.7\nExercises\nExercise 9.7. This question is based on a Puzzler that was broadcast on the radio program Car\nTalk (http: // www. cartalk. com/ content/ puzzlers ):\nGive me a word with three consecutive double letters. I\u2019ll give you a couple of words\nthat almost qualify, but don\u2019t. For example, the word committee, c-o-m-m-i-t-t-e-e. It",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_241",
    "text": "Give me a word with three consecutive double letters. I\u2019ll give you a couple of words\nthat almost qualify, but don\u2019t. For example, the word committee, c-o-m-m-i-t-t-e-e. It\nwould be great except for the \u2018i\u2019 that sneaks in there. Or Mississippi: M-i-s-s-i-s-s-i-\np-p-i. If you could take out those i\u2019s it would work. But there is a word that has three\nconsecutive pairs of letters and to the best of my knowledge this may be the only word.\nOf course there are probably 500 more but I can only think of one. What is the word?\nWrite a program to \ufb01nd it. Solution: https: // thinkpython. com/ code/ cartalk1. py .\nExercise 9.8. Here\u2019s another Car Talk Puzzler (http: // www. cartalk. com/ content/\npuzzlers ):\n\u201cI was driving on the highway the other day and I happened to notice my odometer.\nLike most odometers, it shows six digits, in whole miles only. So, if my car had 300,000\nmiles, for example, I\u2019d see 3-0-0-0-0-0.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_242",
    "text": "Like most odometers, it shows six digits, in whole miles only. So, if my car had 300,000\nmiles, for example, I\u2019d see 3-0-0-0-0-0.\n\u201cNow, what I saw that day was very interesting. I noticed that the last 4 digits were\npalindromic; that is, they read the same forward as backward. For example, 5-4-4-5 is a\npalindrome, so my odometer could have read 3-1-5-4-4-5.\n\u201cOne mile later, the last 5 numbers were palindromic. For example, it could have read\n3-6-5-4-5-6. One mile after that, the middle 4 out of 6 numbers were palindromic. And\nyou ready for this? One mile later, all 6 were palindromic!\n\u201cThe question is, what was on the odometer when I \ufb01rst looked?\u201d\nWrite a Python program that tests all the six-digit numbers and prints any numbers that satisfy\nthese requirements. Solution: https: // thinkpython. com/ code/ cartalk2. py .\nExercise 9.9. Here\u2019s another Car Talk Puzzler you can solve with a search (http: // www.\ncartalk. com/ content/ puzzlers ):",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_243",
    "text": "Exercise 9.9. Here\u2019s another Car Talk Puzzler you can solve with a search (http: // www.\ncartalk. com/ content/ puzzlers ):\n\u201cRecently I had a visit with my mom and we realized that the two digits that make\nup my age when reversed resulted in her age. For example, if she\u2019s 73, I\u2019m 37. We\nwondered how often this has happened over the years but we got sidetracked with other\ntopics and we never came up with an answer.\n\u201cWhen I got home I \ufb01gured out that the digits of our ages have been reversible six times\nso far. I also \ufb01gured out that if we\u2019re lucky it would happen again in a few years, and\nif we\u2019re really lucky it would happen one more time after that. In other words, it would\nhave happened 8 times over all. So the question is, how old am I now?\u201d\nWrite a Python program that searches for solutions to this Puzzler. Hint: you might \ufb01nd the string\nmethod zfill useful.\nSolution: https: // thinkpython. com/ code/ cartalk3. py .\nChapter 10\nLists",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_244",
    "text": "Write a Python program that searches for solutions to this Puzzler. Hint: you might \ufb01nd the string\nmethod zfill useful.\nSolution: https: // thinkpython. com/ code/ cartalk3. py .\nChapter 10\nLists\nThis chapter presents one of Python\u2019s most useful built-in types, lists. You will also learn\nmore about objects and what can happen when you have more than one name for the same\nobject.\n10.1\nA list is a sequence\nLike a string, a list is a sequence of values. In a string, the values are characters; in a list,\nthey can be any type. The values in a list are called elements or sometimes items.\nThere are several ways to create a new list; the simplest is to enclose the elements in square\nbrackets ([ and ]):\n[10, 20, 30, 40]\n['crunchy frog', 'ram bladder', 'lark vomit']\nThe \ufb01rst example is a list of four integers. The second is a list of three strings. The elements\nof a list don\u2019t have to be the same type. The following list contains a string, a \ufb02oat, an\ninteger, and (lo!) another list:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_245",
    "text": "of a list don\u2019t have to be the same type. The following list contains a string, a \ufb02oat, an\ninteger, and (lo!) another list:\n['spam', 2.0, 5, [10, 20]]\nA list within another list is nested.\nA list that contains no elements is called an empty list; you can create one with empty\nbrackets, [].\nAs you might expect, you can assign list values to variables:\n>>> cheeses = ['Cheddar', 'Edam', 'Gouda']\n>>> numbers = [42, 123]\n>>> empty = []\n>>> print(cheeses, numbers, empty)\n['Cheddar', 'Edam', 'Gouda'] [42, 123] []\n90\nChapter 10. Lists\n0\n1\nlist\nnumbers\n123\n5\nlist\nempty\n0\n1\n2\n\u2019Cheddar\u2019\n\u2019Edam\u2019\n\u2019Gouda\u2019\nlist\ncheeses\n42\nFigure 10.1: State diagram.\n10.2\nLists are mutable\nThe syntax for accessing the elements of a list is the same as for accessing the characters\nof a string\u2014the bracket operator. The expression inside the brackets speci\ufb01es the index.\nRemember that the indices start at 0:\n>>> cheeses[0]\n'Cheddar'\nUnlike strings, lists are mutable. When the bracket operator appears on the left side of an",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_246",
    "text": "Remember that the indices start at 0:\n>>> cheeses[0]\n'Cheddar'\nUnlike strings, lists are mutable. When the bracket operator appears on the left side of an\nassignment, it identi\ufb01es the element of the list that will be assigned.\n>>> numbers = [42, 123]\n>>> numbers[1] = 5\n>>> numbers\n[42, 5]\nThe one-eth element of numbers, which used to be 123, is now 5.\nFigure 10.1 shows the state diagram for cheeses, numbers and empty.\nLists are represented by boxes with the word \u201clist\u201d outside and the elements of the list\ninside. cheeses refers to a list with three elements indexed 0, 1 and 2. numbers contains\ntwo elements; the diagram shows that the value of the second element has been reassigned\nfrom 123 to 5. empty refers to a list with no elements.\nList indices work the same way as string indices:\n\u2022 Any integer expression can be used as an index.\n\u2022 If you try to read or write an element that does not exist, you get an IndexError.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_247",
    "text": "List indices work the same way as string indices:\n\u2022 Any integer expression can be used as an index.\n\u2022 If you try to read or write an element that does not exist, you get an IndexError.\n\u2022 If an index has a negative value, it counts backward from the end of the list.\nThe in operator also works on lists.\n>>> cheeses = ['Cheddar', 'Edam', 'Gouda']\n>>> 'Edam' in cheeses\nTrue\n>>> 'Brie' in cheeses\nFalse\n10.3. Traversing a list\n91\n10.3\nTraversing a list\nThe most common way to traverse the elements of a list is with a for loop. The syntax is\nthe same as for strings:\nfor cheese in cheeses:\nprint(cheese)\nThis works well if you only need to read the elements of the list. But if you want to write\nor update the elements, you need the indices. A common way to do that is to combine the\nbuilt-in functions range and len:\nfor i in range(len(numbers)):\nnumbers[i] = numbers[i] * 2\nThis loop traverses the list and updates each element. len returns the number of elements",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_248",
    "text": "built-in functions range and len:\nfor i in range(len(numbers)):\nnumbers[i] = numbers[i] * 2\nThis loop traverses the list and updates each element. len returns the number of elements\nin the list. range returns a list of indices from 0 to n \u22121, where n is the length of the list.\nEach time through the loop i gets the index of the next element. The assignment statement\nin the body uses i to read the old value of the element and to assign the new value.\nA for loop over an empty list never runs the body:\nfor x in []:\nprint('This never happens.')\nAlthough a list can contain another list, the nested list still counts as a single element. The\nlength of this list is four:\n['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]\n10.4\nList operations\nThe + operator concatenates lists:\n>>> a = [1, 2, 3]\n>>> b = [4, 5, 6]\n>>> c = a + b\n>>> c\n[1, 2, 3, 4, 5, 6]\nThe * operator repeats a list a given number of times:\n>>> [0] * 4\n[0, 0, 0, 0]\n>>> [1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_249",
    "text": ">>> a = [1, 2, 3]\n>>> b = [4, 5, 6]\n>>> c = a + b\n>>> c\n[1, 2, 3, 4, 5, 6]\nThe * operator repeats a list a given number of times:\n>>> [0] * 4\n[0, 0, 0, 0]\n>>> [1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\nThe \ufb01rst example repeats [0] four times. The second example repeats the list [1, 2, 3]\nthree times.\n10.5\nList slices\nThe slice operator also works on lists:\n92\nChapter 10. Lists\n>>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> t[1:3]\n['b', 'c']\n>>> t[:4]\n['a', 'b', 'c', 'd']\n>>> t[3:]\n['d', 'e', 'f']\nIf you omit the \ufb01rst index, the slice starts at the beginning. If you omit the second, the slice\ngoes to the end. So if you omit both, the slice is a copy of the whole list.\n>>> t[:]\n['a', 'b', 'c', 'd', 'e', 'f']\nSince lists are mutable, it is often useful to make a copy before performing operations that\nmodify lists.\nA slice operator on the left side of an assignment can update multiple elements:\n>>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> t[1:3] = ['x', 'y']\n>>> t\n['a', 'x', 'y', 'd', 'e', 'f']",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_250",
    "text": "modify lists.\nA slice operator on the left side of an assignment can update multiple elements:\n>>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> t[1:3] = ['x', 'y']\n>>> t\n['a', 'x', 'y', 'd', 'e', 'f']\n10.6\nList methods\nPython provides methods that operate on lists. For example, append adds a new element\nto the end of a list:\n>>> t = ['a', 'b', 'c']\n>>> t.append('d')\n>>> t\n['a', 'b', 'c', 'd']\nextend takes a list as an argument and appends all of the elements:\n>>> t1 = ['a', 'b', 'c']\n>>> t2 = ['d', 'e']\n>>> t1.extend(t2)\n>>> t1\n['a', 'b', 'c', 'd', 'e']\nThis example leaves t2 unmodi\ufb01ed.\nsort arranges the elements of the list from low to high:\n>>> t = ['d', 'c', 'e', 'b', 'a']\n>>> t.sort()\n>>> t\n['a', 'b', 'c', 'd', 'e']\nMost list methods are void; they modify the list and return None. If you accidentally write\nt = t.sort(), you will be disappointed with the result.\n10.7. Map, \ufb01lter and reduce\n93\n10.7\nMap, \ufb01lter and reduce\nTo add up all the numbers in a list, you can use a loop like this:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_251",
    "text": "t = t.sort(), you will be disappointed with the result.\n10.7. Map, \ufb01lter and reduce\n93\n10.7\nMap, \ufb01lter and reduce\nTo add up all the numbers in a list, you can use a loop like this:\ndef add_all(t):\ntotal = 0\nfor x in t:\ntotal += x\nreturn total\ntotal is initialized to 0. Each time through the loop, x gets one element from the list.\nThe += operator provides a short way to update a variable. This augmented assignment\nstatement,\ntotal += x\nis equivalent to\ntotal = total + x\nAs the loop runs, total accumulates the sum of the elements; a variable used this way is\nsometimes called an accumulator.\nAdding up the elements of a list is such a common operation that Python provides it as a\nbuilt-in function, sum:\n>>> t = [1, 2, 3]\n>>> sum(t)\n6\nAn operation like this that combines a sequence of elements into a single value is some-\ntimes called reduce.\nSometimes you want to traverse one list while building another. For example, the following",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_252",
    "text": "An operation like this that combines a sequence of elements into a single value is some-\ntimes called reduce.\nSometimes you want to traverse one list while building another. For example, the following\nfunction takes a list of strings and returns a new list that contains capitalized strings:\ndef capitalize_all(t):\nres = []\nfor s in t:\nres.append(s.capitalize())\nreturn res\nres is initialized with an empty list; each time through the loop, we append the next ele-\nment. So res is another kind of accumulator.\nAn operation like capitalize_all is sometimes called a map because it \u201cmaps\u201d a function\n(in this case the method capitalize) onto each of the elements in a sequence.\nAnother common operation is to select some of the elements from a list and return a sublist.\nFor example, the following function takes a list of strings and returns a list that contains\nonly the uppercase strings:\ndef only_upper(t):\nres = []\nfor s in t:\nif s.isupper():\nres.append(s)\nreturn res\n94\nChapter 10. Lists",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_253",
    "text": "only the uppercase strings:\ndef only_upper(t):\nres = []\nfor s in t:\nif s.isupper():\nres.append(s)\nreturn res\n94\nChapter 10. Lists\nisupper is a string method that returns True if the string contains only upper case letters.\nAn operation like only_upper is called a \ufb01lter because it selects some of the elements and\n\ufb01lters out the others.\nMost common list operations can be expressed as a combination of map, \ufb01lter and reduce.\n10.8\nDeleting elements\nThere are several ways to delete elements from a list. If you know the index of the element\nyou want, you can use pop:\n>>> t = ['a', 'b', 'c']\n>>> x = t.pop(1)\n>>> t\n['a', 'c']\n>>> x\n'b'\npop modi\ufb01es the list and returns the element that was removed. If you don\u2019t provide an\nindex, it deletes and returns the last element.\nIf you don\u2019t need the removed value, you can use the del operator:\n>>> t = ['a', 'b', 'c']\n>>> del t[1]\n>>> t\n['a', 'c']\nIf you know the element you want to remove (but not the index), you can use remove:\n>>> t = ['a', 'b', 'c']",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_254",
    "text": ">>> t = ['a', 'b', 'c']\n>>> del t[1]\n>>> t\n['a', 'c']\nIf you know the element you want to remove (but not the index), you can use remove:\n>>> t = ['a', 'b', 'c']\n>>> t.remove('b')\n>>> t\n['a', 'c']\nThe return value from remove is None.\nTo remove more than one element, you can use del with a slice index:\n>>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> del t[1:5]\n>>> t\n['a', 'f']\nAs usual, the slice selects all the elements up to but not including the second index.\n10.9\nLists and strings\nA string is a sequence of characters and a list is a sequence of values, but a list of characters\nis not the same as a string. To convert from a string to a list of characters, you can use list:\n>>> s = 'spam'\n>>> t = list(s)\n>>> t\n['s', 'p', 'a', 'm']\n10.10. Objects and values\n95\na\nb\n\u2019banana\u2019\na\nb\n\u2019banana\u2019\n\u2019banana\u2019\nFigure 10.2: State diagram.\nBecause list is the name of a built-in function, you should avoid using it as a variable\nname. I also avoid l because it looks too much like 1. So that\u2019s why I use t.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_255",
    "text": "Figure 10.2: State diagram.\nBecause list is the name of a built-in function, you should avoid using it as a variable\nname. I also avoid l because it looks too much like 1. So that\u2019s why I use t.\nThe list function breaks a string into individual letters. If you want to break a string into\nwords, you can use the split method:\n>>> s = 'pining for the fjords'\n>>> t = s.split()\n>>> t\n['pining', 'for', 'the', 'fjords']\nAn optional argument called a delimiter speci\ufb01es which characters to use as word bound-\naries. The following example uses a hyphen as a delimiter:\n>>> s = 'spam-spam-spam'\n>>> delimiter = '-'\n>>> t = s.split(delimiter)\n>>> t\n['spam', 'spam', 'spam']\njoin is the inverse of split. It takes a list of strings and concatenates the elements. join is\na string method, so you have to invoke it on the delimiter and pass the list as a parameter:\n>>> t = ['pining', 'for', 'the', 'fjords']\n>>> delimiter = ' '\n>>> s = delimiter.join(t)\n>>> s\n'pining for the fjords'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_256",
    "text": ">>> t = ['pining', 'for', 'the', 'fjords']\n>>> delimiter = ' '\n>>> s = delimiter.join(t)\n>>> s\n'pining for the fjords'\nIn this case the delimiter is a space character, so join puts a space between words. To\nconcatenate strings without spaces, you can use the empty string, '', as a delimiter.\n10.10\nObjects and values\nIf we run these assignment statements:\na = 'banana'\nb = 'banana'\nWe know that a and b both refer to a string, but we don\u2019t know whether they refer to the\nsame string. There are two possible states, shown in Figure 10.2.\nIn one case, a and b refer to two different objects that have the same value. In the second\ncase, they refer to the same object.\nTo check whether two variables refer to the same object, you can use the is operator.\n96\nChapter 10. Lists\na\nb\n[ 1, 2, 3 ]\n[ 1, 2, 3 ]\nFigure 10.3: State diagram.\na\nb\n[ 1, 2, 3 ]\nFigure 10.4: State diagram.\n>>> a = 'banana'\n>>> b = 'banana'\n>>> a is b\nTrue",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_257",
    "text": "96\nChapter 10. Lists\na\nb\n[ 1, 2, 3 ]\n[ 1, 2, 3 ]\nFigure 10.3: State diagram.\na\nb\n[ 1, 2, 3 ]\nFigure 10.4: State diagram.\n>>> a = 'banana'\n>>> b = 'banana'\n>>> a is b\nTrue\nIn this example, Python only created one string object, and both a and b refer to it. But\nwhen you create two lists, you get two objects:\n>>> a = [1, 2, 3]\n>>> b = [1, 2, 3]\n>>> a is b\nFalse\nSo the state diagram looks like Figure 10.3.\nIn this case we would say that the two lists are equivalent, because they have the same el-\nements, but not identical, because they are not the same object. If two objects are identical,\nthey are also equivalent, but if they are equivalent, they are not necessarily identical.\nUntil now, we have been using \u201cobject\u201d and \u201cvalue\u201d interchangeably, but it is more precise\nto say that an object has a value. If you evaluate [1, 2, 3], you get a list object whose\nvalue is a sequence of integers. If another list has the same elements, we say it has the\nsame value, but it is not the same object.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_258",
    "text": "value is a sequence of integers. If another list has the same elements, we say it has the\nsame value, but it is not the same object.\n10.11\nAliasing\nIf a refers to an object and you assign b = a, then both variables refer to the same object:\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b is a\nTrue\nThe state diagram looks like Figure 10.4.\nThe association of a variable with an object is called a reference. In this example, there are\ntwo references to the same object.\nAn object with more than one reference has more than one name, so we say that the object\nis aliased.\nIf the aliased object is mutable, changes made with one alias affect the other:\n10.12. List arguments\n97\n0\n1\n2\n\u2019a\u2019\n\u2019b\u2019\n\u2019c\u2019\nlist\nt\nletters\ndelete_head\n__main__\nFigure 10.5: Stack diagram.\n>>> b[0] = 42\n>>> a\n[42, 2, 3]\nAlthough this behavior can be useful, it is error-prone. In general, it is safer to avoid\naliasing when you are working with mutable objects.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_259",
    "text": "Figure 10.5: Stack diagram.\n>>> b[0] = 42\n>>> a\n[42, 2, 3]\nAlthough this behavior can be useful, it is error-prone. In general, it is safer to avoid\naliasing when you are working with mutable objects.\nFor immutable objects like strings, aliasing is not as much of a problem. In this example:\na = 'banana'\nb = 'banana'\nIt almost never makes a difference whether a and b refer to the same string or not.\n10.12\nList arguments\nWhen you pass a list to a function, the function gets a reference to the list. If the function\nmodi\ufb01es the list, the caller sees the change. For example, delete_head removes the \ufb01rst\nelement from a list:\ndef delete_head(t):\ndel t[0]\nHere\u2019s how it is used:\n>>> letters = ['a', 'b', 'c']\n>>> delete_head(letters)\n>>> letters\n['b', 'c']\nThe parameter t and the variable letters are aliases for the same object. The stack diagram\nlooks like Figure 10.5.\nSince the list is shared by two frames, I drew it between them.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_260",
    "text": "['b', 'c']\nThe parameter t and the variable letters are aliases for the same object. The stack diagram\nlooks like Figure 10.5.\nSince the list is shared by two frames, I drew it between them.\nIt is important to distinguish between operations that modify lists and operations that cre-\nate new lists. For example, the append method modi\ufb01es a list, but the + operator creates a\nnew list.\nHere\u2019s an example using append:\n>>> t1 = [1, 2]\n>>> t2 = t1.append(3)\n>>> t1\n[1, 2, 3]\n>>> t2\nNone\n98\nChapter 10. Lists\nThe return value from append is None.\nHere\u2019s an example using the + operator:\n>>> t3 = t1 + [4]\n>>> t1\n[1, 2, 3]\n>>> t3\n[1, 2, 3, 4]\nThe result of the operator is a new list, and the original list is unchanged.\nThis difference is important when you write functions that are supposed to modify lists.\nFor example, this function does not delete the head of a list:\ndef bad_delete_head(t):\nt = t[1:]\n# WRONG!",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_261",
    "text": "This difference is important when you write functions that are supposed to modify lists.\nFor example, this function does not delete the head of a list:\ndef bad_delete_head(t):\nt = t[1:]\n# WRONG!\nThe slice operator creates a new list and the assignment makes t refer to it, but that doesn\u2019t\naffect the caller.\n>>> t4 = [1, 2, 3]\n>>> bad_delete_head(t4)\n>>> t4\n[1, 2, 3]\nAt the beginning of bad_delete_head, t and t4 refer to the same list. At the end, t refers\nto a new list, but t4 still refers to the original, unmodi\ufb01ed list.\nAn alternative is to write a function that creates and returns a new list. For example, tail\nreturns all but the \ufb01rst element of a list:\ndef tail(t):\nreturn t[1:]\nThis function leaves the original list unmodi\ufb01ed. Here\u2019s how it is used:\n>>> letters = ['a', 'b', 'c']\n>>> rest = tail(letters)\n>>> rest\n['b', 'c']\n10.13\nDebugging\nCareless use of lists (and other mutable objects) can lead to long hours of debugging. Here\nare some common pitfalls and ways to avoid them:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_262",
    "text": ">>> rest\n['b', 'c']\n10.13\nDebugging\nCareless use of lists (and other mutable objects) can lead to long hours of debugging. Here\nare some common pitfalls and ways to avoid them:\n1. Most list methods modify the argument and return None. This is the opposite of the\nstring methods, which return a new string and leave the original alone.\nIf you are used to writing string code like this:\nword = word.strip()\nIt is tempting to write list code like this:\n10.13. Debugging\n99\nt = t.sort()\n# WRONG!\nBecause sort returns None, the next operation you perform with t is likely to fail.\nBefore using list methods and operators, you should read the documentation care-\nfully and then test them in interactive mode.\n2. Pick an idiom and stick with it.\nPart of the problem with lists is that there are too many ways to do things. For exam-\nple, to remove an element from a list, you can use pop, remove, del, or even a slice\nassignment.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_263",
    "text": "Part of the problem with lists is that there are too many ways to do things. For exam-\nple, to remove an element from a list, you can use pop, remove, del, or even a slice\nassignment.\nTo add an element, you can use the append method or the + operator. Assuming that\nt is a list and x is a list element, these are correct:\nt.append(x)\nt = t + [x]\nt += [x]\nAnd these are wrong:\nt.append([x])\n# WRONG!\nt = t.append(x)\n# WRONG!\nt + [x]\n# WRONG!\nt = t + x\n# WRONG!\nTry out each of these examples in interactive mode to make sure you understand\nwhat they do. Notice that only the last one causes a runtime error; the other three are\nlegal, but they do the wrong thing.\n3. Make copies to avoid aliasing.\nIf you want to use a method like sort that modi\ufb01es the argument, but you need to\nkeep the original list as well, you can make a copy.\n>>> t = [3, 1, 2]\n>>> t2 = t[:]\n>>> t2.sort()\n>>> t\n[3, 1, 2]\n>>> t2\n[1, 2, 3]\nIn this example you could also use the built-in function sorted, which returns a new,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_264",
    "text": ">>> t = [3, 1, 2]\n>>> t2 = t[:]\n>>> t2.sort()\n>>> t\n[3, 1, 2]\n>>> t2\n[1, 2, 3]\nIn this example you could also use the built-in function sorted, which returns a new,\nsorted list and leaves the original alone.\n>>> t2 = sorted(t)\n>>> t\n[3, 1, 2]\n>>> t2\n[1, 2, 3]\n100\nChapter 10. Lists\n10.14\nGlossary\nlist: A sequence of values.\nelement: One of the values in a list (or other sequence), also called items.\nnested list: A list that is an element of another list.\naccumulator: A variable used in a loop to add up or accumulate a result.\naugmented assignment: A statement that updates the value of a variable using an opera-\ntor like +=.\nreduce: A processing pattern that traverses a sequence and accumulates the elements into\na single result.\nmap: A processing pattern that traverses a sequence and performs an operation on each\nelement.\n\ufb01lter: A processing pattern that traverses a list and selects the elements that satisfy some\ncriterion.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_265",
    "text": "map: A processing pattern that traverses a sequence and performs an operation on each\nelement.\n\ufb01lter: A processing pattern that traverses a list and selects the elements that satisfy some\ncriterion.\nobject: Something a variable can refer to. An object has a type and a value.\nequivalent: Having the same value.\nidentical: Being the same object (which implies equivalence).\nreference: The association between a variable and its value.\naliasing: A circumstance where two or more variables refer to the same object.\ndelimiter: A character or string used to indicate where a string should be split.\n10.15\nExercises\nYou can download solutions to these exercises from https://thinkpython.com/code/\nlist_exercises.py.\nExercise 10.1. Write a function called nested_sum that takes a list of lists of integers and adds up\nthe elements from all of the nested lists. For example:\n>>> t = [[1, 2], [3], [4, 5, 6]]\n>>> nested_sum(t)\n21",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_266",
    "text": "the elements from all of the nested lists. For example:\n>>> t = [[1, 2], [3], [4, 5, 6]]\n>>> nested_sum(t)\n21\nExercise 10.2. Write a function called cumsum that takes a list of numbers and returns the cumu-\nlative sum; that is, a new list where the ith element is the sum of the \ufb01rst i + 1 elements from the\noriginal list. For example:\n>>> t = [1, 2, 3]\n>>> cumsum(t)\n[1, 3, 6]\nExercise 10.3. Write a function called middle that takes a list and returns a new list that contains\nall but the \ufb01rst and last elements. For example:\n>>> t = [1, 2, 3, 4]\n>>> middle(t)\n[2, 3]\n10.15. Exercises\n101\nExercise 10.4. Write a function called chop that takes a list, modi\ufb01es it by removing the \ufb01rst and\nlast elements, and returns None. For example:\n>>> t = [1, 2, 3, 4]\n>>> chop(t)\n>>> t\n[2, 3]\nExercise 10.5. Write a function called is_sorted that takes a list as a parameter and returns True\nif the list is sorted in ascending order and False otherwise. For example:\n>>> is_sorted([1, 2, 2])\nTrue",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_267",
    "text": "if the list is sorted in ascending order and False otherwise. For example:\n>>> is_sorted([1, 2, 2])\nTrue\n>>> is_sorted(['b', 'a'])\nFalse\nExercise 10.6. Two words are anagrams if you can rearrange the letters from one to spell the other.\nWrite a function called is_anagram that takes two strings and returns True if they are anagrams.\nExercise 10.7. Write a function called has_duplicates that takes a list and returns True if there\nis any element that appears more than once. It should not modify the original list.\nExercise 10.8. This exercise pertains to the so-called Birthday Paradox, which you can read about\nat http: // en. wikipedia. org/ wiki/ Birthday_ paradox .\nIf there are 23 students in your class, what are the chances that two of them have the same birthday?\nYou can estimate this probability by generating random samples of 23 birthdays and checking for\nmatches. Hint: you can generate random birthdays with the randint function in the random\nmodule.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_268",
    "text": "You can estimate this probability by generating random samples of 23 birthdays and checking for\nmatches. Hint: you can generate random birthdays with the randint function in the random\nmodule.\nYou can download my solution from https: // thinkpython. com/ code/ birthday. py .\nExercise 10.9. Write a function that reads the \ufb01le words.txt and builds a list with one element\nper word. Write two versions of this function, one using the append method and the other using\nthe idiom t = t + [x]. Which one takes longer to run? Why?\nSolution: https: // thinkpython. com/ code/ wordlist. py .\nExercise 10.10. To check whether a word is in the word list, you could use the in operator, but it\nwould be slow because it searches through the words in order.\nBecause the words are in alphabetical order, we can speed things up with a bisection search (also\nknown as binary search), which is similar to what you do when you look a word up in the dictionary",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_269",
    "text": "Because the words are in alphabetical order, we can speed things up with a bisection search (also\nknown as binary search), which is similar to what you do when you look a word up in the dictionary\n(the book, not the data structure). You start in the middle and check to see whether the word you are\nlooking for comes before the word in the middle of the list. If so, you search the \ufb01rst half of the list\nthe same way. Otherwise you search the second half.\nEither way, you cut the remaining search space in half. If the word list has 113,809 words, it will\ntake about 17 steps to \ufb01nd the word or conclude that it\u2019s not there.\nWrite a function called in_bisect that takes a sorted list and a target value and returns True if\nthe word is in the list and False if it\u2019s not.\nOr you could read the documentation of the bisect module and use that! Solution: https:\n// thinkpython. com/ code/ inlist. py .\nExercise 10.11. Two words are a \u201creverse pair\u201d if each is the reverse of the other. Write a program",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_270",
    "text": "// thinkpython. com/ code/ inlist. py .\nExercise 10.11. Two words are a \u201creverse pair\u201d if each is the reverse of the other. Write a program\nthat \ufb01nds all the reverse pairs in the word list. Solution: https: // thinkpython. com/ code/\nreverse_ pair. py .\nExercise 10.12. Two words \u201cinterlock\u201d if taking alternating letters from each forms a new\nword.\nFor example, \u201cshoe\u201d and \u201ccold\u201d interlock to form \u201cschooled\u201d.\nSolution: https: //\n102\nChapter 10. Lists\nthinkpython. com/ code/ interlock. py . Credit: This exercise is inspired by an example at\nhttp: // puzzlers. org .\n1. Write a program that \ufb01nds all pairs of words that interlock. Hint: don\u2019t enumerate all pairs!\n2. Can you \ufb01nd any words that are three-way interlocked; that is, every third letter forms a\nword, starting from the \ufb01rst, second or third?\nChapter 11\nDictionaries\nThis chapter presents another built-in type called a dictionary. Dictionaries are one of",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_271",
    "text": "word, starting from the \ufb01rst, second or third?\nChapter 11\nDictionaries\nThis chapter presents another built-in type called a dictionary. Dictionaries are one of\nPython\u2019s best features; they are the building blocks of many ef\ufb01cient and elegant algo-\nrithms.\n11.1\nA dictionary is a mapping\nA dictionary is like a list, but more general. In a list, the indices have to be integers; in a\ndictionary they can be (almost) any type.\nA dictionary contains a collection of indices, which are called keys, and a collection of\nvalues. Each key is associated with a single value. The association of a key and a value is\ncalled a key-value pair or sometimes an item.\nIn mathematical language, a dictionary represents a mapping from keys to values, so you\ncan also say that each key \u201cmaps to\u201d a value. As an example, we\u2019ll build a dictionary that\nmaps from English to Spanish words, so the keys and the values are all strings.\nThe function dict creates a new dictionary with no items. Because dict is the name of a",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_272",
    "text": "maps from English to Spanish words, so the keys and the values are all strings.\nThe function dict creates a new dictionary with no items. Because dict is the name of a\nbuilt-in function, you should avoid using it as a variable name.\n>>> eng2sp = dict()\n>>> eng2sp\n{}\nThe squiggly-brackets, {}, represent an empty dictionary. To add items to the dictionary,\nyou can use square brackets:\n>>> eng2sp['one'] = 'uno'\nThis line creates an item that maps from the key 'one' to the value 'uno'. If we print the\ndictionary again, we see a key-value pair with a colon between the key and value:\n>>> eng2sp\n{'one': 'uno'}\nThis output format is also an input format. For example, you can create a new dictionary\nwith three items:\n104\nChapter 11. Dictionaries\n>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}\nBut if you print eng2sp, you might be surprised:\n>>> eng2sp\n{'one': 'uno', 'three': 'tres', 'two': 'dos'}\nThe order of the key-value pairs might not be the same. If you type the same example",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_273",
    "text": "But if you print eng2sp, you might be surprised:\n>>> eng2sp\n{'one': 'uno', 'three': 'tres', 'two': 'dos'}\nThe order of the key-value pairs might not be the same. If you type the same example\non your computer, you might get a different result. In general, the order of items in a\ndictionary is unpredictable.\nBut that\u2019s not a problem because the elements of a dictionary are never indexed with inte-\nger indices. Instead, you use the keys to look up the corresponding values:\n>>> eng2sp['two']\n'dos'\nThe key 'two' always maps to the value 'dos' so the order of the items doesn\u2019t matter.\nIf the key isn\u2019t in the dictionary, you get an exception:\n>>> eng2sp['four']\nKeyError: 'four'\nThe len function works on dictionaries; it returns the number of key-value pairs:\n>>> len(eng2sp)\n3\nThe in operator works on dictionaries, too; it tells you whether something appears as a key\nin the dictionary (appearing as a value is not good enough).\n>>> 'one' in eng2sp\nTrue\n>>> 'uno' in eng2sp\nFalse",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_274",
    "text": "in the dictionary (appearing as a value is not good enough).\n>>> 'one' in eng2sp\nTrue\n>>> 'uno' in eng2sp\nFalse\nTo see whether something appears as a value in a dictionary, you can use the method\nvalues, which returns a collection of values, and then use the in operator:\n>>> vals = eng2sp.values()\n>>> 'uno' in vals\nTrue\nThe in operator uses different algorithms for lists and dictionaries. For lists, it searches the\nelements of the list in order, as in Section 8.6. As the list gets longer, the search time gets\nlonger in direct proportion.\nPython dictionaries use a data structure called a hashtable that has a remarkable property:\nthe in operator takes about the same amount of time no matter how many items are in the\ndictionary. I explain how that\u2019s possible in Section B.4, but the explanation might not make\nsense until you\u2019ve read a few more chapters.\n11.2\nDictionary as a collection of counters\nSuppose you are given a string and you want to count how many times each letter appears.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_275",
    "text": "sense until you\u2019ve read a few more chapters.\n11.2\nDictionary as a collection of counters\nSuppose you are given a string and you want to count how many times each letter appears.\nThere are several ways you could do it:\n11.2. Dictionary as a collection of counters\n105\n1. You could create 26 variables, one for each letter of the alphabet. Then you could tra-\nverse the string and, for each character, increment the corresponding counter, proba-\nbly using a chained conditional.\n2. You could create a list with 26 elements. Then you could convert each character to\na number (using the built-in function ord), use the number as an index into the list,\nand increment the appropriate counter.\n3. You could create a dictionary with characters as keys and counters as the correspond-\ning values. The \ufb01rst time you see a character, you would add an item to the dictionary.\nAfter that you would increment the value of an existing item.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_276",
    "text": "ing values. The \ufb01rst time you see a character, you would add an item to the dictionary.\nAfter that you would increment the value of an existing item.\nEach of these options performs the same computation, but each of them implements that\ncomputation in a different way.\nAn implementation is a way of performing a computation; some implementations are\nbetter than others. For example, an advantage of the dictionary implementation is that we\ndon\u2019t have to know ahead of time which letters appear in the string and we only have to\nmake room for the letters that do appear.\nHere is what the code might look like:\ndef histogram(s):\nd = dict()\nfor c in s:\nif c not in d:\nd[c] = 1\nelse:\nd[c] += 1\nreturn d\nThe name of the function is histogram, which is a statistical term for a collection of counters\n(or frequencies).\nThe \ufb01rst line of the function creates an empty dictionary. The for loop traverses the string.\nEach time through the loop, if the character c is not in the dictionary, we create a new item",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_277",
    "text": "The \ufb01rst line of the function creates an empty dictionary. The for loop traverses the string.\nEach time through the loop, if the character c is not in the dictionary, we create a new item\nwith key c and the initial value 1 (since we have seen this letter once). If c is already in the\ndictionary we increment d[c].\nHere\u2019s how it works:\n>>> h = histogram('brontosaurus')\n>>> h\n{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}\nThe histogram indicates that the letters 'a' and 'b' appear once; 'o' appears twice, and\nso on.\nDictionaries have a method called get that takes a key and a default value. If the key\nappears in the dictionary, get returns the corresponding value; otherwise it returns the\ndefault value. For example:\n>>> h = histogram('a')\n>>> h\n{'a': 1}\n>>> h.get('a', 0)\n106\nChapter 11. Dictionaries\n1\n>>> h.get('c', 0)\n0\nAs an exercise, use get to write histogram more concisely. You should be able to eliminate\nthe if statement.\n11.3\nLooping and dictionaries",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_278",
    "text": "106\nChapter 11. Dictionaries\n1\n>>> h.get('c', 0)\n0\nAs an exercise, use get to write histogram more concisely. You should be able to eliminate\nthe if statement.\n11.3\nLooping and dictionaries\nIf you use a dictionary in a for statement, it traverses the keys of the dictionary. For exam-\nple, print_hist prints each key and the corresponding value:\ndef print_hist(h):\nfor c in h:\nprint(c, h[c])\nHere\u2019s what the output looks like:\n>>> h = histogram('parrot')\n>>> print_hist(h)\na 1\np 1\nr 2\nt 1\no 1\nAgain, the keys are in no particular order. To traverse the keys in sorted order, you can use\nthe built-in function sorted:\n>>> for key in sorted(h):\n...\nprint(key, h[key])\na 1\no 1\np 1\nr 2\nt 1\n11.4\nReverse lookup\nGiven a dictionary d and a key k, it is easy to \ufb01nd the corresponding value v = d[k]. This\noperation is called a lookup.\nBut what if you have v and you want to \ufb01nd k? You have two problems: \ufb01rst, there might\nbe more than one key that maps to the value v. Depending on the application, you might",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_279",
    "text": "But what if you have v and you want to \ufb01nd k? You have two problems: \ufb01rst, there might\nbe more than one key that maps to the value v. Depending on the application, you might\nbe able to pick one, or you might have to make a list that contains all of them. Second,\nthere is no simple syntax to do a reverse lookup; you have to search.\nHere is a function that takes a value and returns the \ufb01rst key that maps to that value:\ndef reverse_lookup(d, v):\nfor k in d:\nif d[k] == v:\nreturn k\nraise LookupError()\n11.5. Dictionaries and lists\n107\nThis function is yet another example of the search pattern, but it uses a feature we haven\u2019t\nseen before, raise.\nThe raise statement causes an exception; in this case it causes a\nLookupError, which is a built-in exception used to indicate that a lookup operation failed.\nIf we get to the end of the loop, that means v doesn\u2019t appear in the dictionary as a value, so\nwe raise an exception.\nHere is an example of a successful reverse lookup:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_280",
    "text": "If we get to the end of the loop, that means v doesn\u2019t appear in the dictionary as a value, so\nwe raise an exception.\nHere is an example of a successful reverse lookup:\n>>> h = histogram('parrot')\n>>> key = reverse_lookup(h, 2)\n>>> key\n'r'\nAnd an unsuccessful one:\n>>> key = reverse_lookup(h, 3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 5, in reverse_lookup\nLookupError\nThe effect when you raise an exception is the same as when Python raises one: it prints a\ntraceback and an error message.\nWhen you raise an exception, you can provide a detailed error message as an optional\nargument. For example:\n>>> raise LookupError('value does not appear in the dictionary')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nLookupError: value does not appear in the dictionary\nA reverse lookup is much slower than a forward lookup; if you have to do it often, or if the\ndictionary gets big, the performance of your program will suffer.\n11.5",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_281",
    "text": "A reverse lookup is much slower than a forward lookup; if you have to do it often, or if the\ndictionary gets big, the performance of your program will suffer.\n11.5\nDictionaries and lists\nLists can appear as values in a dictionary. For example, if you are given a dictionary that\nmaps from letters to frequencies, you might want to invert it; that is, create a dictionary\nthat maps from frequencies to letters. Since there might be several letters with the same\nfrequency, each value in the inverted dictionary should be a list of letters.\nHere is a function that inverts a dictionary:\ndef invert_dict(d):\ninverse = dict()\nfor key in d:\nval = d[key]\nif val not in inverse:\ninverse[val] = [key]\nelse:\ninverse[val].append(key)\nreturn inverse\n108\nChapter 11. Dictionaries\n\u2019a\u2019\n1\n1\ndict\nhist\n\u2019p\u2019\n1\n\u2019o\u2019\n1\n\u2019r\u2019\n2\n\u2019t\u2019\n0\n1\n\u2019a\u2019\n\u2019p\u2019\nlist\n2\n\u2019t\u2019\n\u2019o\u2019\n3\n1\ndict\ninv\n2\n0\nlist\n\u2019r\u2019\nFigure 11.1: State diagram.\nEach time through the loop, key gets a key from d and val gets the corresponding value.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_282",
    "text": "dict\nhist\n\u2019p\u2019\n1\n\u2019o\u2019\n1\n\u2019r\u2019\n2\n\u2019t\u2019\n0\n1\n\u2019a\u2019\n\u2019p\u2019\nlist\n2\n\u2019t\u2019\n\u2019o\u2019\n3\n1\ndict\ninv\n2\n0\nlist\n\u2019r\u2019\nFigure 11.1: State diagram.\nEach time through the loop, key gets a key from d and val gets the corresponding value.\nIf val is not in inverse, that means we haven\u2019t seen it before, so we create a new item and\ninitialize it with a singleton (a list that contains a single element). Otherwise we have seen\nthis value before, so we append the corresponding key to the list.\nHere is an example:\n>>> hist = histogram('parrot')\n>>> hist\n{'a': 1, 'p': 1, 'r': 2, 't': 1, 'o': 1}\n>>> inverse = invert_dict(hist)\n>>> inverse\n{1: ['a', 'p', 't', 'o'], 2: ['r']}\nFigure 11.1 is a state diagram showing hist and inverse. A dictionary is represented as a\nbox with the type dict above it and the key-value pairs inside. If the values are integers,\n\ufb02oats or strings, I draw them inside the box, but I usually draw lists outside the box, just\nto keep the diagram simple.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_283",
    "text": "\ufb02oats or strings, I draw them inside the box, but I usually draw lists outside the box, just\nto keep the diagram simple.\nLists can be values in a dictionary, as this example shows, but they cannot be keys. Here\u2019s\nwhat happens if you try:\n>>> t = [1, 2, 3]\n>>> d = dict()\n>>> d[t] = 'oops'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nTypeError: list objects are unhashable\nI mentioned earlier that a dictionary is implemented using a hashtable and that means that\nthe keys have to be hashable.\nA hash is a function that takes a value (of any kind) and returns an integer. Dictionaries\nuse these integers, called hash values, to store and look up key-value pairs.\nThis system works \ufb01ne if the keys are immutable. But if the keys are mutable, like lists,\nbad things happen. For example, when you create a key-value pair, Python hashes the key\nand stores it in the corresponding location. If you modify the key and then hash it again, it",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_284",
    "text": "bad things happen. For example, when you create a key-value pair, Python hashes the key\nand stores it in the corresponding location. If you modify the key and then hash it again, it\nwould go to a different location. In that case you might have two entries for the same key,\nor you might not be able to \ufb01nd a key. Either way, the dictionary wouldn\u2019t work correctly.\nThat\u2019s why keys have to be hashable, and why mutable types like lists aren\u2019t. The simplest\nway to get around this limitation is to use tuples, which we will see in the next chapter.\n11.6. Memos\n109\nfibonacci\nn\n4\nfibonacci\nn\n3\nfibonacci\nn\n2\nfibonacci\nn\n0\nfibonacci\nn\n1\nfibonacci\nn\n1\nfibonacci\nn\n2\nfibonacci\nn\n0\nfibonacci\nn\n1\nFigure 11.2: Call graph.\nSince dictionaries are mutable, they can\u2019t be used as keys, but they can be used as values.\n11.6\nMemos\nIf you played with the fibonacci function from Section 6.7, you might have noticed that\nthe bigger the argument you provide, the longer the function takes to run. Furthermore,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_285",
    "text": "11.6\nMemos\nIf you played with the fibonacci function from Section 6.7, you might have noticed that\nthe bigger the argument you provide, the longer the function takes to run. Furthermore,\nthe run time increases quickly.\nTo understand why, consider Figure 11.2, which shows the call graph for fibonacci with\nn=4:\nA call graph shows a set of function frames, with lines connecting each frame to the frames\nof the functions it calls. At the top of the graph, fibonacci with n=4 calls fibonacci with\nn=3 and n=2. In turn, fibonacci with n=3 calls fibonacci with n=2 and n=1. And so on.\nCount how many times fibonacci(0) and fibonacci(1) are called. This is an inef\ufb01cient\nsolution to the problem, and it gets worse as the argument gets bigger.\nOne solution is to keep track of values that have already been computed by storing them\nin a dictionary. A previously computed value that is stored for later use is called a memo.\nHere is a \u201cmemoized\u201d version of fibonacci:\nknown = {0:0, 1:1}\ndef fibonacci(n):",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_286",
    "text": "in a dictionary. A previously computed value that is stored for later use is called a memo.\nHere is a \u201cmemoized\u201d version of fibonacci:\nknown = {0:0, 1:1}\ndef fibonacci(n):\nif n in known:\nreturn known[n]\nres = fibonacci(n-1) + fibonacci(n-2)\nknown[n] = res\nreturn res\nknown is a dictionary that keeps track of the Fibonacci numbers we already know. It starts\nwith two items: 0 maps to 0 and 1 maps to 1.\n110\nChapter 11. Dictionaries\nWhenever fibonacci is called, it checks known. If the result is already there, it can return\nimmediately. Otherwise it has to compute the new value, add it to the dictionary, and\nreturn it.\nIf you run this version of fibonacci and compare it with the original, you will \ufb01nd that it\nis much faster.\n11.7\nGlobal variables\nIn the previous example, known is created outside the function, so it belongs to the special\nframe called __main__. Variables in __main__ are sometimes called global because they",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_287",
    "text": "11.7\nGlobal variables\nIn the previous example, known is created outside the function, so it belongs to the special\nframe called __main__. Variables in __main__ are sometimes called global because they\ncan be accessed from any function. Unlike local variables, which disappear when their\nfunction ends, global variables persist from one function call to the next.\nIt is common to use global variables for \ufb02ags; that is, boolean variables that indicate (\u201c\ufb02ag\u201d)\nwhether a condition is true. For example, some programs use a \ufb02ag named verbose to\ncontrol the level of detail in the output:\nverbose = True\ndef example1():\nif verbose:\nprint('Running example1')\nIf you try to reassign a global variable, you might be surprised. The following example is\nsupposed to keep track of whether the function has been called:\nbeen_called = False\ndef example2():\nbeen_called = True\n# WRONG\nBut if you run it you will see that the value of been_called doesn\u2019t change. The problem",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_288",
    "text": "been_called = False\ndef example2():\nbeen_called = True\n# WRONG\nBut if you run it you will see that the value of been_called doesn\u2019t change. The problem\nis that example2 creates a new local variable named been_called. The local variable goes\naway when the function ends, and has no effect on the global variable.\nTo reassign a global variable inside a function you have to declare the global variable before\nyou use it:\nbeen_called = False\ndef example2():\nglobal been_called\nbeen_called = True\nThe global statement tells the interpreter something like, \u201cIn this function, when I say\nbeen_called, I mean the global variable; don\u2019t create a local one.\u201d\nHere\u2019s an example that tries to update a global variable:\ncount = 0\ndef example3():\ncount = count + 1\n# WRONG\nIf you run it you get:\n11.8. Debugging\n111\nUnboundLocalError: local variable 'count' referenced before assignment\nPython assumes that count is local, and under that assumption you are reading it before",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_289",
    "text": "11.8. Debugging\n111\nUnboundLocalError: local variable 'count' referenced before assignment\nPython assumes that count is local, and under that assumption you are reading it before\nwriting it. The solution, again, is to declare count global.\ndef example3():\nglobal count\ncount += 1\nIf a global variable refers to a mutable value, you can modify the value without declaring\nthe variable:\nknown = {0:0, 1:1}\ndef example4():\nknown[2] = 1\nSo you can add, remove and replace elements of a global list or dictionary, but if you want\nto reassign the variable, you have to declare it:\ndef example5():\nglobal known\nknown = dict()\nGlobal variables can be useful, but if you have a lot of them, and you modify them fre-\nquently, they can make programs hard to debug.\n11.8\nDebugging\nAs you work with bigger datasets it can become unwieldy to debug by printing and check-\ning the output by hand. Here are some suggestions for debugging large datasets:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_290",
    "text": "11.8\nDebugging\nAs you work with bigger datasets it can become unwieldy to debug by printing and check-\ning the output by hand. Here are some suggestions for debugging large datasets:\nScale down the input: If possible, reduce the size of the dataset. For example if the pro-\ngram reads a text \ufb01le, start with just the \ufb01rst 10 lines, or with the smallest example\nyou can \ufb01nd. You can either edit the \ufb01les themselves, or (better) modify the program\nso it reads only the \ufb01rst n lines.\nIf there is an error, you can reduce n to the smallest value that manifests the error, and\nthen increase it gradually as you \ufb01nd and correct errors.\nCheck summaries and types: Instead of printing and checking the entire dataset, consider\nprinting summaries of the data: for example, the number of items in a dictionary or\nthe total of a list of numbers.\nA common cause of runtime errors is a value that is not the right type. For debugging\nthis kind of error, it is often enough to print the type of a value.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_291",
    "text": "the total of a list of numbers.\nA common cause of runtime errors is a value that is not the right type. For debugging\nthis kind of error, it is often enough to print the type of a value.\nWrite self-checks: Sometimes you can write code to check for errors automatically. For\nexample, if you are computing the average of a list of numbers, you could check that\nthe result is not greater than the largest element in the list or less than the smallest.\nThis is called a \u201csanity check\u201d because it detects results that are \u201cinsane\u201d.\nAnother kind of check compares the results of two different computations to see if\nthey are consistent. This is called a \u201cconsistency check\u201d.\n112\nChapter 11. Dictionaries\nFormat the output: Formatting debugging output can make it easier to spot an error. We\nsaw an example in Section 6.9. Another tool you might \ufb01nd useful is the pprint mod-\nule, which provides a pprint function that displays built-in types in a more human-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_292",
    "text": "saw an example in Section 6.9. Another tool you might \ufb01nd useful is the pprint mod-\nule, which provides a pprint function that displays built-in types in a more human-\nreadable format (pprint stands for \u201cpretty print\u201d).\nAgain, time you spend building scaffolding can reduce the time you spend debugging.\n11.9\nGlossary\nmapping: A relationship in which each element of one set corresponds to an element of\nanother set.\ndictionary: A mapping from keys to their corresponding values.\nkey-value pair: The representation of the mapping from a key to a value.\nitem: In a dictionary, another name for a key-value pair.\nkey: An object that appears in a dictionary as the \ufb01rst part of a key-value pair.\nvalue: An object that appears in a dictionary as the second part of a key-value pair. This is\nmore speci\ufb01c than our previous use of the word \u201cvalue\u201d.\nimplementation: A way of performing a computation.\nhashtable: The algorithm used to implement Python dictionaries.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_293",
    "text": "more speci\ufb01c than our previous use of the word \u201cvalue\u201d.\nimplementation: A way of performing a computation.\nhashtable: The algorithm used to implement Python dictionaries.\nhash function: A function used by a hashtable to compute the location for a key.\nhashable: A type that has a hash function. Immutable types like integers, \ufb02oats and strings\nare hashable; mutable types like lists and dictionaries are not.\nlookup: A dictionary operation that takes a key and \ufb01nds the corresponding value.\nreverse lookup: A dictionary operation that takes a value and \ufb01nds one or more keys that\nmap to it.\nraise statement: A statement that (deliberately) raises an exception.\nsingleton: A list (or other sequence) with a single element.\ncall graph: A diagram that shows every frame created during the execution of a program,\nwith an arrow from each caller to each callee.\nmemo: A computed value stored to avoid unnecessary future computation.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_294",
    "text": "with an arrow from each caller to each callee.\nmemo: A computed value stored to avoid unnecessary future computation.\nglobal variable: A variable de\ufb01ned outside a function. Global variables can be accessed\nfrom any function.\nglobal statement: A statement that declares a variable name global.\n\ufb02ag: A boolean variable used to indicate whether a condition is true.\ndeclaration: A statement like global that tells the interpreter something about a variable.\n11.10. Exercises\n113\n11.10\nExercises\nExercise 11.1. Write a function that reads the words in words.txt and stores them as keys in a\ndictionary. It doesn\u2019t matter what the values are. Then you can use the in operator as a fast way to\ncheck whether a string is in the dictionary.\nIf you did Exercise 10.10, you can compare the speed of this implementation with the list in operator\nand the bisection search.\nExercise 11.2. Read the documentation of the dictionary method setdefault and use it to write a",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_295",
    "text": "and the bisection search.\nExercise 11.2. Read the documentation of the dictionary method setdefault and use it to write a\nmore concise version of invert_dict. Solution: https: // thinkpython. com/ code/ invert_\ndict. py .\nExercise 11.3. Memoize the Ackermann function from Exercise 6.2 and see if memoization\nmakes it possible to evaluate the function with bigger arguments. Hint: no. Solution: https:\n// thinkpython. com/ code/ ackermann_ memo. py .\nExercise 11.4. If you did Exercise 10.7, you already have a function named has_duplicates that\ntakes a list as a parameter and returns True if there is any object that appears more than once in the\nlist.\nUse a dictionary to write a faster, simpler version of has_duplicates. Solution: https: //\nthinkpython. com/ code/ has_ duplicates. py .\nExercise 11.5. Two words are \u201crotate pairs\u201d if you can rotate one of them and get the other (see\nrotate_word in Exercise 8.5).\nWrite a program that reads a wordlist and \ufb01nds all the rotate pairs.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_296",
    "text": "Exercise 11.5. Two words are \u201crotate pairs\u201d if you can rotate one of them and get the other (see\nrotate_word in Exercise 8.5).\nWrite a program that reads a wordlist and \ufb01nds all the rotate pairs.\nSolution: https: //\nthinkpython. com/ code/ rotate_ pairs. py .\nExercise 11.6. Here\u2019s another Puzzler from Car Talk (http: // www. cartalk. com/ content/\npuzzlers ):\nThis was sent in by a fellow named Dan O\u2019Leary. He came upon a common one-syllable,\n\ufb01ve-letter word recently that has the following unique property. When you remove the\n\ufb01rst letter, the remaining letters form a homophone of the original word, that is a word\nthat sounds exactly the same. Replace the \ufb01rst letter, that is, put it back and remove\nthe second letter and the result is yet another homophone of the original word. And the\nquestion is, what\u2019s the word?\nNow I\u2019m going to give you an example that doesn\u2019t work. Let\u2019s look at the \ufb01ve-letter\nword, \u2018wrack.\u2019 W-R-A-C-K, you know like to \u2018wrack with pain.\u2019 If I remove the \ufb01rst",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_297",
    "text": "question is, what\u2019s the word?\nNow I\u2019m going to give you an example that doesn\u2019t work. Let\u2019s look at the \ufb01ve-letter\nword, \u2018wrack.\u2019 W-R-A-C-K, you know like to \u2018wrack with pain.\u2019 If I remove the \ufb01rst\nletter, I am left with a four-letter word, \u2019R-A-C-K.\u2019 As in, \u2018Holy cow, did you see the\nrack on that buck! It must have been a nine-pointer!\u2019 It\u2019s a perfect homophone. If you\nput the \u2018w\u2019 back, and remove the \u2018r,\u2019 instead, you\u2019re left with the word, \u2018wack,\u2019 which is\na real word, it\u2019s just not a homophone of the other two words.\nBut there is, however, at least one word that Dan and we know of, which will yield two\nhomophones if you remove either of the \ufb01rst two letters to make two, new four-letter\nwords. The question is, what\u2019s the word?\nYou can use the dictionary from Exercise 11.1 to check whether a string is in the word list.\nTo\ncheck\nwhether\ntwo\nwords\nare\nhomophones,\nyou\ncan\nuse\nthe\nCMU\nPronouncing\nDictionary.\nYou can download it from http: // www. speech. cs. cmu. edu/ cgi-bin/\ncmudict",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_298",
    "text": "To\ncheck\nwhether\ntwo\nwords\nare\nhomophones,\nyou\ncan\nuse\nthe\nCMU\nPronouncing\nDictionary.\nYou can download it from http: // www. speech. cs. cmu. edu/ cgi-bin/\ncmudict\nor from https: // thinkpython. com/ code/ c06d\nand you can also down-\nload https: // thinkpython. com/ code/ pronounce. py , which provides a function named\nread_dictionary that reads the pronouncing dictionary and returns a Python dictionary that\nmaps from each word to a string that describes its primary pronunciation.\n114\nChapter 11. Dictionaries\nWrite a program that lists all the words that solve the Puzzler. Solution: https: // thinkpython.\ncom/ code/ homophone. py .\nChapter 12\nTuples\nThis chapter presents one more built-in type, the tuple, and then shows how lists, dictionar-\nies, and tuples work together. I also present a useful feature for variable-length argument\nlists, the gather and scatter operators.\nOne note: there is no consensus on how to pronounce \u201ctuple\u201d. Some people say \u201ctuh-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_299",
    "text": "lists, the gather and scatter operators.\nOne note: there is no consensus on how to pronounce \u201ctuple\u201d. Some people say \u201ctuh-\nple\u201d, which rhymes with \u201csupple\u201d. But in the context of programming, most people say\n\u201ctoo-ple\u201d, which rhymes with \u201cquadruple\u201d.\n12.1\nTuples are immutable\nA tuple is a sequence of values. The values can be any type, and they are indexed by\nintegers, so in that respect tuples are a lot like lists. The important difference is that tuples\nare immutable.\nSyntactically, a tuple is a comma-separated list of values:\n>>> t = 'a', 'b', 'c', 'd', 'e'\nAlthough it is not necessary, it is common to enclose tuples in parentheses:\n>>> t = ('a', 'b', 'c', 'd', 'e')\nTo create a tuple with a single element, you have to include a \ufb01nal comma:\n>>> t1 = 'a',\n>>> type(t1)\n<class 'tuple'>\nA value in parentheses is not a tuple:\n>>> t2 = ('a')\n>>> type(t2)\n<class 'str'>\nAnother way to create a tuple is the built-in function tuple. With no argument, it creates\nan empty tuple:\n>>> t = tuple()",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_300",
    "text": ">>> t2 = ('a')\n>>> type(t2)\n<class 'str'>\nAnother way to create a tuple is the built-in function tuple. With no argument, it creates\nan empty tuple:\n>>> t = tuple()\n>>> t\n()\n116\nChapter 12. Tuples\nIf the argument is a sequence (string, list or tuple), the result is a tuple with the elements of\nthe sequence:\n>>> t = tuple('lupins')\n>>> t\n('l', 'u', 'p', 'i', 'n', 's')\nBecause tuple is the name of a built-in function, you should avoid using it as a variable\nname.\nMost list operators also work on tuples. The bracket operator indexes an element:\n>>> t = ('a', 'b', 'c', 'd', 'e')\n>>> t[0]\n'a'\nAnd the slice operator selects a range of elements.\n>>> t[1:3]\n('b', 'c')\nBut if you try to modify one of the elements of the tuple, you get an error:\n>>> t[0] = 'A'\nTypeError: object doesn't support item assignment\nBecause tuples are immutable, you can\u2019t modify the elements. But you can replace one\ntuple with another:\n>>> t = ('A',) + t[1:]\n>>> t\n('A', 'b', 'c', 'd', 'e')",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_301",
    "text": "Because tuples are immutable, you can\u2019t modify the elements. But you can replace one\ntuple with another:\n>>> t = ('A',) + t[1:]\n>>> t\n('A', 'b', 'c', 'd', 'e')\nThis statement makes a new tuple and then makes t refer to it.\nThe relational operators work with tuples and other sequences; Python starts by comparing\nthe \ufb01rst element from each sequence. If they are equal, it goes on to the next elements, and\nso on, until it \ufb01nds elements that differ. Subsequent elements are not considered (even if\nthey are really big).\n>>> (0, 1, 2) < (0, 3, 4)\nTrue\n>>> (0, 1, 2000000) < (0, 3, 4)\nTrue\n12.2\nTuple assignment\nIt is often useful to swap the values of two variables. With conventional assignments, you\nhave to use a temporary variable. For example, to swap a and b:\n>>> temp = a\n>>> a = b\n>>> b = temp\nThis solution is cumbersome; tuple assignment is more elegant:\n>>> a, b = b, a\n12.3. Tuples as return values\n117",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_302",
    "text": ">>> temp = a\n>>> a = b\n>>> b = temp\nThis solution is cumbersome; tuple assignment is more elegant:\n>>> a, b = b, a\n12.3. Tuples as return values\n117\nThe left side is a tuple of variables; the right side is a tuple of expressions. Each value\nis assigned to its respective variable. All the expressions on the right side are evaluated\nbefore any of the assignments.\nThe number of variables on the left and the number of values on the right have to be the\nsame:\n>>> a, b = 1, 2, 3\nValueError: too many values to unpack\nMore generally, the right side can be any kind of sequence (string, list or tuple). For exam-\nple, to split an email address into a user name and a domain, you could write:\n>>> addr = 'monty@python.org'\n>>> uname, domain = addr.split('@')\nThe return value from split is a list with two elements; the \ufb01rst element is assigned to\nuname, the second to domain.\n>>> uname\n'monty'\n>>> domain\n'python.org'\n12.3\nTuples as return values",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_303",
    "text": "The return value from split is a list with two elements; the \ufb01rst element is assigned to\nuname, the second to domain.\n>>> uname\n'monty'\n>>> domain\n'python.org'\n12.3\nTuples as return values\nStrictly speaking, a function can only return one value, but if the value is a tuple, the effect\nis the same as returning multiple values. For example, if you want to divide two integers\nand compute the quotient and remainder, it is inef\ufb01cient to compute x//y and then x%y. It\nis better to compute them both at the same time.\nThe built-in function divmod takes two arguments and returns a tuple of two values, the\nquotient and remainder. You can store the result as a tuple:\n>>> t = divmod(7, 3)\n>>> t\n(2, 1)\nOr use tuple assignment to store the elements separately:\n>>> quot, rem = divmod(7, 3)\n>>> quot\n2\n>>> rem\n1\nHere is an example of a function that returns a tuple:\ndef min_max(t):\nreturn min(t), max(t)\nmax and min are built-in functions that \ufb01nd the largest and smallest elements of a sequence.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_304",
    "text": "2\n>>> rem\n1\nHere is an example of a function that returns a tuple:\ndef min_max(t):\nreturn min(t), max(t)\nmax and min are built-in functions that \ufb01nd the largest and smallest elements of a sequence.\nmin_max computes both and returns a tuple of two values.\n118\nChapter 12. Tuples\n12.4\nVariable-length argument tuples\nFunctions can take a variable number of arguments. A parameter name that begins with\n* gathers arguments into a tuple. For example, printall takes any number of arguments\nand prints them:\ndef printall(*args):\nprint(args)\nThe gather parameter can have any name you like, but args is conventional. Here\u2019s how\nthe function works:\n>>> printall(1, 2.0, '3')\n(1, 2.0, '3')\nThe complement of gather is scatter. If you have a sequence of values and you want to pass\nit to a function as multiple arguments, you can use the * operator. For example, divmod\ntakes exactly two arguments; it doesn\u2019t work with a tuple:\n>>> t = (7, 3)\n>>> divmod(t)\nTypeError: divmod expected 2 arguments, got 1",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_305",
    "text": "takes exactly two arguments; it doesn\u2019t work with a tuple:\n>>> t = (7, 3)\n>>> divmod(t)\nTypeError: divmod expected 2 arguments, got 1\nBut if you scatter the tuple, it works:\n>>> divmod(*t)\n(2, 1)\nMany of the built-in functions use variable-length argument tuples. For example, max and\nmin can take any number of arguments:\n>>> max(1, 2, 3)\n3\nBut sum does not.\n>>> sum(1, 2, 3)\nTypeError: sum expected at most 2 arguments, got 3\nAs an exercise, write a function called sum_all that takes any number of arguments and\nreturns their sum.\n12.5\nLists and tuples\nzip is a built-in function that takes two or more sequences and interleaves them. The name\nof the function refers to a zipper, which interleaves two rows of teeth.\nThis example zips a string and a list:\n>>> s = 'abc'\n>>> t = [0, 1, 2]\n>>> zip(s, t)\n<zip object at 0x7f7d0a9e7c48>\nThe result is a zip object that knows how to iterate through the pairs. The most common\nuse of zip is in a for loop:\n12.5. Lists and tuples\n119",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_306",
    "text": ">>> zip(s, t)\n<zip object at 0x7f7d0a9e7c48>\nThe result is a zip object that knows how to iterate through the pairs. The most common\nuse of zip is in a for loop:\n12.5. Lists and tuples\n119\n>>> for pair in zip(s, t):\n...\nprint(pair)\n...\n('a', 0)\n('b', 1)\n('c', 2)\nA zip object is a kind of iterator, which is any object that iterates through a sequence.\nIterators are similar to lists in some ways, but unlike lists, you can\u2019t use an index to select\nan element from an iterator.\nIf you want to use list operators and methods, you can use a zip object to make a list:\n>>> list(zip(s, t))\n[('a', 0), ('b', 1), ('c', 2)]\nThe result is a list of tuples; in this example, each tuple contains a character from the string\nand the corresponding element from the list.\nIf the sequences are not the same length, the result has the length of the shorter one.\n>>> list(zip('Anne', 'Elk'))\n[('A', 'E'), ('n', 'l'), ('n', 'k')]\nYou can use tuple assignment in a for loop to traverse a list of tuples:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_307",
    "text": ">>> list(zip('Anne', 'Elk'))\n[('A', 'E'), ('n', 'l'), ('n', 'k')]\nYou can use tuple assignment in a for loop to traverse a list of tuples:\nt = [('a', 0), ('b', 1), ('c', 2)]\nfor letter, number in t:\nprint(number, letter)\nEach time through the loop, Python selects the next tuple in the list and assigns the ele-\nments to letter and number. The output of this loop is:\n0 a\n1 b\n2 c\nIf you combine zip, for and tuple assignment, you get a useful idiom for traversing two\n(or more) sequences at the same time. For example, has_match takes two sequences, t1\nand t2, and returns True if there is an index i such that t1[i] == t2[i]:\ndef has_match(t1, t2):\nfor x, y in zip(t1, t2):\nif x == y:\nreturn True\nreturn False\nIf you need to traverse the elements of a sequence and their indices, you can use the built-in\nfunction enumerate:\nfor index, element in enumerate('abc'):\nprint(index, element)\nThe result from enumerate is an enumerate object, which iterates a sequence of pairs; each",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_308",
    "text": "function enumerate:\nfor index, element in enumerate('abc'):\nprint(index, element)\nThe result from enumerate is an enumerate object, which iterates a sequence of pairs; each\npair contains an index (starting from 0) and an element from the given sequence. In this\nexample, the output is\n0 a\n1 b\n2 c\nAgain.\n120\nChapter 12. Tuples\n12.6\nDictionaries and tuples\nDictionaries have a method called items that returns a sequence of tuples, where each\ntuple is a key-value pair.\n>>> d = {'a':0, 'b':1, 'c':2}\n>>> t = d.items()\n>>> t\ndict_items([('c', 2), ('a', 0), ('b', 1)])\nThe result is a dict_items object, which is an iterator that iterates the key-value pairs. You\ncan use it in a for loop like this:\n>>> for key, value in d.items():\n...\nprint(key, value)\n...\nc 2\na 0\nb 1\nAs you should expect from a dictionary, the items are in no particular order.\nGoing in the other direction, you can use a list of tuples to initialize a new dictionary:\n>>> t = [('a', 0), ('c', 2), ('b', 1)]\n>>> d = dict(t)\n>>> d",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_309",
    "text": "Going in the other direction, you can use a list of tuples to initialize a new dictionary:\n>>> t = [('a', 0), ('c', 2), ('b', 1)]\n>>> d = dict(t)\n>>> d\n{'a': 0, 'c': 2, 'b': 1}\nCombining dict with zip yields a concise way to create a dictionary:\n>>> d = dict(zip('abc', range(3)))\n>>> d\n{'a': 0, 'c': 2, 'b': 1}\nThe dictionary method update also takes a list of tuples and adds them, as key-value pairs,\nto an existing dictionary.\nIt is common to use tuples as keys in dictionaries (primarily because you can\u2019t use lists). For\nexample, a telephone directory might map from last-name, \ufb01rst-name pairs to telephone\nnumbers. Assuming that we have de\ufb01ned last, first and number, we could write:\ndirectory[last, first] = number\nThe expression in brackets is a tuple. We could use tuple assignment to traverse this dic-\ntionary.\nfor last, first in directory:\nprint(first, last, directory[last,first])\nThis loop traverses the keys in directory, which are tuples. It assigns the elements of each",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_310",
    "text": "tionary.\nfor last, first in directory:\nprint(first, last, directory[last,first])\nThis loop traverses the keys in directory, which are tuples. It assigns the elements of each\ntuple to last and first, then prints the name and corresponding telephone number.\nThere are two ways to represent tuples in a state diagram. The more detailed version\nshows the indices and elements just as they appear in a list.\nFor example, the tuple\n('Cleese', 'John') would appear as in Figure 12.1.\nBut in a larger diagram you might want to leave out the details. For example, a diagram of\nthe telephone directory might appear as in Figure 12.2.\nHere the tuples are shown using Python syntax as a graphical shorthand. The telephone\nnumber in the diagram is the complaints line for the BBC, so please don\u2019t call it.\n12.7. Sequences of sequences\n121\n0\n1\n\u2019Cleese\u2019\n\u2019John\u2019\ntuple\nFigure 12.1: State diagram.\n(\u2019Cleese\u2019, \u2019John\u2019)\n\u201908700 100 222\u2019\n\u201908700 100 222\u2019\n\u201908700 100 222\u2019\n\u201908700 100 222\u2019\n\u201908700 100 222\u2019\n(\u2019Chapman\u2019, \u2019Graham\u2019)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_311",
    "text": "121\n0\n1\n\u2019Cleese\u2019\n\u2019John\u2019\ntuple\nFigure 12.1: State diagram.\n(\u2019Cleese\u2019, \u2019John\u2019)\n\u201908700 100 222\u2019\n\u201908700 100 222\u2019\n\u201908700 100 222\u2019\n\u201908700 100 222\u2019\n\u201908700 100 222\u2019\n(\u2019Chapman\u2019, \u2019Graham\u2019)\n(\u2019Idle\u2019, \u2019Eric\u2019)\n(\u2019Jones\u2019, \u2019Terry\u2019)\n(\u2019Gilliam\u2019, \u2019Terry\u2019)\n(\u2019Palin\u2019, \u2019Michael\u2019)\n\u201908700 100 222\u2019\ndict\nFigure 12.2: State diagram.\n12.7\nSequences of sequences\nI have focused on lists of tuples, but almost all of the examples in this chapter also work\nwith lists of lists, tuples of tuples, and tuples of lists. To avoid enumerating the possible\ncombinations, it is sometimes easier to talk about sequences of sequences.\nIn many contexts, the different kinds of sequences (strings, lists and tuples) can be used\ninterchangeably. So how should you choose one over the others?\nTo start with the obvious, strings are more limited than other sequences because the ele-\nments have to be characters. They are also immutable. If you need the ability to change the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_312",
    "text": "To start with the obvious, strings are more limited than other sequences because the ele-\nments have to be characters. They are also immutable. If you need the ability to change the\ncharacters in a string (as opposed to creating a new string), you might want to use a list of\ncharacters instead.\nLists are more common than tuples, mostly because they are mutable. But there are a few\ncases where you might prefer tuples:\n1. In some contexts, like a return statement, it is syntactically simpler to create a tuple\nthan a list.\n2. If you want to use a sequence as a dictionary key, you have to use an immutable type\nlike a tuple or string.\n3. If you are passing a sequence as an argument to a function, using tuples reduces the\npotential for unexpected behavior due to aliasing.\nBecause tuples are immutable, they don\u2019t provide methods like sort and reverse, which\nmodify existing lists. But Python provides the built-in function sorted, which takes any",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_313",
    "text": "Because tuples are immutable, they don\u2019t provide methods like sort and reverse, which\nmodify existing lists. But Python provides the built-in function sorted, which takes any\nsequence and returns a new list with the same elements in sorted order, and reversed,\nwhich takes a sequence and returns an iterator that traverses the list in reverse order.\n122\nChapter 12. Tuples\n12.8\nDebugging\nLists, dictionaries and tuples are examples of data structures; in this chapter we are starting\nto see compound data structures, like lists of tuples, or dictionaries that contain tuples as\nkeys and lists as values. Compound data structures are useful, but they are prone to what\nI call shape errors; that is, errors caused when a data structure has the wrong type, size, or\nstructure. For example, if you are expecting a list with one integer and I give you a plain\nold integer (not in a list), it won\u2019t work.\nTo help debug these kinds of errors, I have written a module called structshape that",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_314",
    "text": "old integer (not in a list), it won\u2019t work.\nTo help debug these kinds of errors, I have written a module called structshape that\nprovides a function, also called structshape, that takes any kind of data structure as\nan argument and returns a string that summarizes its shape. You can download it from\nhttps://thinkpython.com/code/structshape.py\nHere\u2019s the result for a simple list:\n>>> from structshape import structshape\n>>> t = [1, 2, 3]\n>>> structshape(t)\n'list of 3 int'\nA fancier program might write \u201clist of 3 ints\u201d, but it was easier not to deal with plurals.\nHere\u2019s a list of lists:\n>>> t2 = [[1,2], [3,4], [5,6]]\n>>> structshape(t2)\n'list of 3 list of 2 int'\nIf the elements of the list are not the same type, structshape groups them, in order, by\ntype:\n>>> t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]\n>>> structshape(t3)\n'list of (3 int, float, 2 str, 2 list of int, int)'\nHere\u2019s a list of tuples:\n>>> s = 'abc'\n>>> lt = list(zip(t, s))\n>>> structshape(lt)\n'list of 3 tuple of (int, str)'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_315",
    "text": ">>> structshape(t3)\n'list of (3 int, float, 2 str, 2 list of int, int)'\nHere\u2019s a list of tuples:\n>>> s = 'abc'\n>>> lt = list(zip(t, s))\n>>> structshape(lt)\n'list of 3 tuple of (int, str)'\nAnd here\u2019s a dictionary with 3 items that map integers to strings.\n>>> d = dict(lt)\n>>> structshape(d)\n'dict of 3 int->str'\nIf you are having trouble keeping track of your data structures, structshape can help.\n12.9\nGlossary\ntuple: An immutable sequence of elements.\ntuple assignment: An assignment with a sequence on the right side and a tuple of vari-\nables on the left. The right side is evaluated and then its elements are assigned to the\nvariables on the left.\n12.10. Exercises\n123\ngather: An operation that collects multiple arguments into a tuple.\nscatter: An operation that makes a sequence behave like multiple arguments.\nzip object: The result of calling a built-in function zip; an object that iterates through a\nsequence of tuples.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_316",
    "text": "scatter: An operation that makes a sequence behave like multiple arguments.\nzip object: The result of calling a built-in function zip; an object that iterates through a\nsequence of tuples.\niterator: An object that can iterate through a sequence, but which does not provide list\noperators and methods.\ndata structure: A collection of related values, often organized in lists, dictionaries, tuples,\netc.\nshape error: An error caused because a value has the wrong shape; that is, the wrong type\nor size.\n12.10\nExercises\nExercise 12.1. Write a function called most_frequent that takes a string and prints the let-\nters in decreasing order of frequency. Find text samples from several different languages and see\nhow letter frequency varies between languages. Compare your results with the tables at http:\n// en. wikipedia. org/ wiki/ Letter_ frequencies .\nSolution: https: // thinkpython.\ncom/ code/ most_ frequent. py .\nExercise 12.2. More anagrams!",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_317",
    "text": "// en. wikipedia. org/ wiki/ Letter_ frequencies .\nSolution: https: // thinkpython.\ncom/ code/ most_ frequent. py .\nExercise 12.2. More anagrams!\n1. Write a program that reads a word list from a \ufb01le (see Section 9.1) and prints all the sets of\nwords that are anagrams.\nHere is an example of what the output might look like:\n['deltas', 'desalt', 'lasted', 'salted', 'slated', 'staled']\n['retainers', 'ternaries']\n['generating', 'greatening']\n['resmelts', 'smelters', 'termless']\nHint: you might want to build a dictionary that maps from a collection of letters to a list\nof words that can be spelled with those letters. The question is, how can you represent the\ncollection of letters in a way that can be used as a key?\n2. Modify the previous program so that it prints the longest list of anagrams \ufb01rst, followed by\nthe second longest, and so on.\n3. In Scrabble a \u201cbingo\u201d is when you play all seven tiles in your rack, along with a letter on",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_318",
    "text": "the second longest, and so on.\n3. In Scrabble a \u201cbingo\u201d is when you play all seven tiles in your rack, along with a letter on\nthe board, to form an eight-letter word. What collection of 8 letters forms the most possible\nbingos?\nSolution: https: // thinkpython. com/ code/ anagram_ sets. py .\nExercise 12.3. Two words form a \u201cmetathesis pair\u201d if you can transform one into the other by\nswapping two letters; for example, \u201cconverse\u201d and \u201cconserve\u201d. Write a program that \ufb01nds all of\nthe metathesis pairs in the dictionary. Hint: don\u2019t test all pairs of words, and don\u2019t test all possible\nswaps. Solution: https: // thinkpython. com/ code/ metathesis. py . Credit: This exercise\nis inspired by an example at http: // puzzlers. org .\n124\nChapter 12. Tuples\nExercise 12.4. Here\u2019s another Car Talk Puzzler (http: // www. cartalk. com/ content/\npuzzlers ):\nWhat is the longest English word, that remains a valid English word, as you remove its\nletters one at a time?",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_319",
    "text": "puzzlers ):\nWhat is the longest English word, that remains a valid English word, as you remove its\nletters one at a time?\nNow, letters can be removed from either end, or the middle, but you can\u2019t rearrange any\nof the letters. Every time you drop a letter, you wind up with another English word. If\nyou do that, you\u2019re eventually going to wind up with one letter and that too is going\nto be an English word\u2014one that\u2019s found in the dictionary. I want to know what\u2019s the\nlongest word and how many letters does it have?\nI\u2019m going to give you a little modest example: Sprite. Ok? You start off with sprite,\nyou take a letter off, one from the interior of the word, take the r away, and we\u2019re left\nwith the word spite, then we take the e off the end, we\u2019re left with spit, we take the s off,\nwe\u2019re left with pit, it, and I.\nWrite a program to \ufb01nd all words that can be reduced in this way, and then \ufb01nd the longest one.\nThis exercise is a little more challenging than most, so here are some suggestions:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_320",
    "text": "Write a program to \ufb01nd all words that can be reduced in this way, and then \ufb01nd the longest one.\nThis exercise is a little more challenging than most, so here are some suggestions:\n1. You might want to write a function that takes a word and computes a list of all the words that\ncan be formed by removing one letter. These are the \u201cchildren\u201d of the word.\n2. Recursively, a word is reducible if any of its children are reducible. As a base case, you can\nconsider the empty string reducible.\n3. The wordlist I provided, words.txt, doesn\u2019t contain single letter words. So you might want\nto add \u201cI\u201d, \u201ca\u201d, and the empty string.\n4. To improve the performance of your program, you might want to memoize the words that are\nknown to be reducible.\nSolution: https: // thinkpython. com/ code/ reducible. py .\nChapter 13\nCase study: data structure\nselection\nAt this point you have learned about Python\u2019s core data structures, and you have seen",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_321",
    "text": "Solution: https: // thinkpython. com/ code/ reducible. py .\nChapter 13\nCase study: data structure\nselection\nAt this point you have learned about Python\u2019s core data structures, and you have seen\nsome of the algorithms that use them. If you would like to know more about algorithms,\nthis might be a good time to read Chapter B. But you don\u2019t have to read it before you go\non; you can read it whenever you are interested.\nThis chapter presents a case study with exercises that let you think about choosing data\nstructures and practice using them.\n13.1\nWord frequency analysis\nAs usual, you should at least attempt the exercises before you read my solutions.\nExercise 13.1. Write a program that reads a \ufb01le, breaks each line into words, strips whitespace and\npunctuation from the words, and converts them to lowercase.\nHint: The string module provides a string named whitespace, which contains space, tab, new-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_322",
    "text": "punctuation from the words, and converts them to lowercase.\nHint: The string module provides a string named whitespace, which contains space, tab, new-\nline, etc., and punctuation which contains the punctuation characters. Let\u2019s see if we can make\nPython swear:\n>>> import string\n>>> string.punctuation\n'!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\nAlso, you might consider using the string methods strip, replace and translate.\nExercise 13.2. Go to Project Gutenberg (http: // gutenberg. org ) and download your favorite\nout-of-copyright book in plain text format.\nModify your program from the previous exercise to read the book you downloaded, skip over the\nheader information at the beginning of the \ufb01le, and process the rest of the words as before.\nThen modify the program to count the total number of words in the book, and the number of times\neach word is used.\nPrint the number of different words used in the book. Compare different books by different authors,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_323",
    "text": "each word is used.\nPrint the number of different words used in the book. Compare different books by different authors,\nwritten in different eras. Which author uses the most extensive vocabulary?\n126\nChapter 13. Case study: data structure selection\nExercise 13.3. Modify the program from the previous exercise to print the 20 most frequently used\nwords in the book.\nExercise 13.4. Modify the previous program to read a word list (see Section 9.1) and then print all\nthe words in the book that are not in the word list. How many of them are typos? How many of\nthem are common words that should be in the word list, and how many of them are really obscure?\n13.2\nRandom numbers\nGiven the same inputs, most computer programs generate the same outputs every time,\nso they are said to be deterministic. Determinism is usually a good thing, since we expect\nthe same calculation to yield the same result. For some applications, though, we want the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_324",
    "text": "so they are said to be deterministic. Determinism is usually a good thing, since we expect\nthe same calculation to yield the same result. For some applications, though, we want the\ncomputer to be unpredictable. Games are an obvious example, but there are more.\nMaking a program truly nondeterministic turns out to be dif\ufb01cult, but there are ways to\nmake it at least seem nondeterministic. One of them is to use algorithms that generate\npseudorandom numbers. Pseudorandom numbers are not truly random because they are\ngenerated by a deterministic computation, but just by looking at the numbers it is all but\nimpossible to distinguish them from random.\nThe random module provides functions that generate pseudorandom numbers (which I\nwill simply call \u201crandom\u201d from here on).\nThe function random returns a random \ufb02oat between 0.0 and 1.0 (including 0.0 but not 1.0).\nEach time you call random, you get the next number in a long series. To see a sample, run\nthis loop:\nimport random\nfor i in range(10):",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_325",
    "text": "Each time you call random, you get the next number in a long series. To see a sample, run\nthis loop:\nimport random\nfor i in range(10):\nx = random.random()\nprint(x)\nThe function randint takes parameters low and high and returns an integer between low\nand high (including both).\n>>> random.randint(5, 10)\n5\n>>> random.randint(5, 10)\n9\nTo choose an element from a sequence at random, you can use choice:\n>>> t = [1, 2, 3]\n>>> random.choice(t)\n2\n>>> random.choice(t)\n3\nThe random module also provides functions to generate random values from continuous\ndistributions including Gaussian, exponential, gamma, and a few more.\nExercise 13.5. Write a function named choose_from_hist that takes a histogram as de\ufb01ned in\nSection 11.2 and returns a random value from the histogram, chosen with probability in proportion\nto frequency. For example, for this histogram:\n13.3. Word histogram\n127\n>>> t = ['a', 'a', 'b']\n>>> hist = histogram(t)\n>>> hist\n{'a': 2, 'b': 1}",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_326",
    "text": "to frequency. For example, for this histogram:\n13.3. Word histogram\n127\n>>> t = ['a', 'a', 'b']\n>>> hist = histogram(t)\n>>> hist\n{'a': 2, 'b': 1}\nyour function should return 'a' with probability 2/3 and 'b' with probability 1/3.\n13.3\nWord histogram\nYou should attempt the previous exercises before you go on.\nYou can download my\nsolution from https://thinkpython.com/code/analyze_book1.py. You will also need\nhttps://thinkpython.com/code/emma.txt.\nHere is a program that reads a \ufb01le and builds a histogram of the words in the \ufb01le:\nimport string\ndef process_file(filename):\nhist = dict()\nfp = open(filename)\nfor line in fp:\nprocess_line(line, hist)\nreturn hist\ndef process_line(line, hist):\nline = line.replace('-', ' ')\nfor word in line.split():\nword = word.strip(string.punctuation + string.whitespace)\nword = word.lower()\nhist[word] = hist.get(word, 0) + 1\nhist = process_file('emma.txt')\nThis program reads emma.txt, which contains the text of Emma by Jane Austen.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_327",
    "text": "word = word.lower()\nhist[word] = hist.get(word, 0) + 1\nhist = process_file('emma.txt')\nThis program reads emma.txt, which contains the text of Emma by Jane Austen.\nprocess_file loops through the lines of the \ufb01le, passing them one at a time to\nprocess_line. The histogram hist is being used as an accumulator.\nprocess_line uses the string method replace to replace hyphens with spaces before using\nsplit to break the line into a list of strings. It traverses the list of words and uses strip\nand lower to remove punctuation and convert to lower case. (It is a shorthand to say that\nstrings are \u201cconverted\u201d; remember that strings are immutable, so methods like strip and\nlower return new strings.)\nFinally, process_line updates the histogram by creating a new item or incrementing an\nexisting one.\nTo count the total number of words in the \ufb01le, we can add up the frequencies in the his-\ntogram:\ndef total_words(hist):\nreturn sum(hist.values())\n128\nChapter 13. Case study: data structure selection",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_328",
    "text": "To count the total number of words in the \ufb01le, we can add up the frequencies in the his-\ntogram:\ndef total_words(hist):\nreturn sum(hist.values())\n128\nChapter 13. Case study: data structure selection\nThe number of different words is just the number of items in the dictionary:\ndef different_words(hist):\nreturn len(hist)\nHere is some code to print the results:\nprint('Total number of words:', total_words(hist))\nprint('Number of different words:', different_words(hist))\nAnd the results:\nTotal number of words: 161080\nNumber of different words: 7214\n13.4\nMost common words\nTo \ufb01nd the most common words, we can make a list of tuples, where each tuple contains a\nword and its frequency, and sort it.\nThe following function takes a histogram and returns a list of word-frequency tuples:\ndef most_common(hist):\nt = []\nfor key, value in hist.items():\nt.append((value, key))\nt.sort(reverse=True)\nreturn t\nIn each tuple, the frequency appears \ufb01rst, so the resulting list is sorted by frequency. Here",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_329",
    "text": "t = []\nfor key, value in hist.items():\nt.append((value, key))\nt.sort(reverse=True)\nreturn t\nIn each tuple, the frequency appears \ufb01rst, so the resulting list is sorted by frequency. Here\nis a loop that prints the ten most common words:\nt = most_common(hist)\nprint('The most common words are:')\nfor freq, word in t[:10]:\nprint(word, freq, sep='\\t')\nI use the keyword argument sep to tell print to use a tab character as a \u201cseparator\u201d, rather\nthan a space, so the second column is lined up. Here are the results from Emma:\nThe most common words are:\nto\n5242\nthe\n5205\nand\n4897\nof\n4295\ni\n3191\na\n3130\nit\n2529\nher\n2483\nwas\n2400\nshe\n2364\nThis code can be simpli\ufb01ed using the key parameter of the sort function. If you are curi-\nous, you can read about it at https://wiki.python.org/moin/HowTo/Sorting.\n13.5. Optional parameters\n129\n13.5\nOptional parameters\nWe have seen built-in functions and methods that take optional arguments. It is possible",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_330",
    "text": "13.5. Optional parameters\n129\n13.5\nOptional parameters\nWe have seen built-in functions and methods that take optional arguments. It is possible\nto write programmer-de\ufb01ned functions with optional arguments, too. For example, here is\na function that prints the most common words in a histogram\ndef print_most_common(hist, num=10):\nt = most_common(hist)\nprint('The most common words are:')\nfor freq, word in t[:num]:\nprint(word, freq, sep='\\t')\nThe \ufb01rst parameter is required; the second is optional. The default value of num is 10.\nIf you only provide one argument:\nprint_most_common(hist)\nnum gets the default value. If you provide two arguments:\nprint_most_common(hist, 20)\nnum gets the value of the argument instead. In other words, the optional argument over-\nrides the default value.\nIf a function has both required and optional parameters, all the required parameters have\nto come \ufb01rst, followed by the optional ones.\n13.6\nDictionary subtraction",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_331",
    "text": "rides the default value.\nIf a function has both required and optional parameters, all the required parameters have\nto come \ufb01rst, followed by the optional ones.\n13.6\nDictionary subtraction\nFinding the words from the book that are not in the word list from words.txt is a problem\nyou might recognize as set subtraction; that is, we want to \ufb01nd all the words from one set\n(the words in the book) that are not in the other (the words in the list).\nsubtract takes dictionaries d1 and d2 and returns a new dictionary that contains all the\nkeys from d1 that are not in d2. Since we don\u2019t really care about the values, we set them all\nto None.\ndef subtract(d1, d2):\nres = dict()\nfor key in d1:\nif key not in d2:\nres[key] = None\nreturn res\nTo \ufb01nd the words in the book that are not in words.txt, we can use process_file to build\na histogram for words.txt, and then subtract:\nwords = process_file('words.txt')\ndiff = subtract(hist, words)\nprint(\"Words in the book that aren't in the word list:\")",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_332",
    "text": "a histogram for words.txt, and then subtract:\nwords = process_file('words.txt')\ndiff = subtract(hist, words)\nprint(\"Words in the book that aren't in the word list:\")\nfor word in diff:\nprint(word, end=' ')\nHere are some of the results from Emma:\n130\nChapter 13. Case study: data structure selection\nWords in the book that aren't in the word list:\nrencontre jane's blanche woodhouses disingenuousness\nfriend's venice apartment ...\nSome of these words are names and possessives. Others, like \u201crencontre\u201d, are no longer in\ncommon use. But a few are common words that should really be in the list!\nExercise 13.6. Python provides a data structure called set that provides many common set\noperations.\nYou can read about them in Section 19.5, or read the documentation at http:\n// docs. python. org/ 3/ library/ stdtypes. html# types-set .\nWrite a program that uses set subtraction to \ufb01nd words in the book that are not in the word list.\nSolution: https: // thinkpython. com/ code/ analyze_ book2. py .\n13.7",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_333",
    "text": "Write a program that uses set subtraction to \ufb01nd words in the book that are not in the word list.\nSolution: https: // thinkpython. com/ code/ analyze_ book2. py .\n13.7\nRandom words\nTo choose a random word from the histogram, the simplest algorithm is to build a list with\nmultiple copies of each word, according to the observed frequency, and then choose from\nthe list:\ndef random_word(h):\nt = []\nfor word, freq in h.items():\nt.extend([word] * freq)\nreturn random.choice(t)\nThe expression [word] * freq creates a list with freq copies of the string word.\nThe\nextend method is similar to append except that the argument is a sequence.\nThis algorithm works, but it is not very ef\ufb01cient; each time you choose a random word, it\nrebuilds the list, which is as big as the original book. An obvious improvement is to build\nthe list once and then make multiple selections, but the list is still big.\nAn alternative is:\n1. Use keys to get a list of the words in the book.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_334",
    "text": "the list once and then make multiple selections, but the list is still big.\nAn alternative is:\n1. Use keys to get a list of the words in the book.\n2. Build a list that contains the cumulative sum of the word frequencies (see Exer-\ncise 10.2). The last item in this list is the total number of words in the book, n.\n3. Choose a random number from 1 to n. Use a bisection search (See Exercise 10.10) to\n\ufb01nd the index where the random number would be inserted in the cumulative sum.\n4. Use the index to \ufb01nd the corresponding word in the word list.\nExercise 13.7. Write a program that uses this algorithm to choose a random word from the book.\nSolution: https: // thinkpython. com/ code/ analyze_ book3. py .\n13.8\nMarkov analysis\nIf you choose words from the book at random, you can get a sense of the vocabulary, but\nyou probably won\u2019t get a sentence:\n13.8. Markov analysis\n131\nthis the small regard harriet which knightley's it most things",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_335",
    "text": "you probably won\u2019t get a sentence:\n13.8. Markov analysis\n131\nthis the small regard harriet which knightley's it most things\nA series of random words seldom makes sense because there is no relationship between\nsuccessive words. For example, in a real sentence you would expect an article like \u201cthe\u201d to\nbe followed by an adjective or a noun, and probably not a verb or adverb.\nOne way to measure these kinds of relationships is Markov analysis, which characterizes,\nfor a given sequence of words, the probability of the words that might come next. For\nexample, the song Eric, the Half a Bee begins:\nHalf a bee, philosophically,\nMust, ipso facto, half not be.\nBut half the bee has got to be\nVis a vis, its entity. D\u2019you see?\nBut can a bee be said to be\nOr not to be an entire bee\nWhen half the bee is not a bee\nDue to some ancient injury?\nIn this text, the phrase \u201chalf the\u201d is always followed by the word \u201cbee\u201d, but the phrase \u201cthe\nbee\u201d might be followed by either \u201chas\u201d or \u201cis\u201d.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_336",
    "text": "When half the bee is not a bee\nDue to some ancient injury?\nIn this text, the phrase \u201chalf the\u201d is always followed by the word \u201cbee\u201d, but the phrase \u201cthe\nbee\u201d might be followed by either \u201chas\u201d or \u201cis\u201d.\nThe result of Markov analysis is a mapping from each pre\ufb01x (like \u201chalf the\u201d and \u201cthe bee\u201d)\nto all possible suf\ufb01xes (like \u201chas\u201d and \u201cis\u201d).\nGiven this mapping, you can generate a random text by starting with any pre\ufb01x and choos-\ning at random from the possible suf\ufb01xes. Next, you can combine the end of the pre\ufb01x and\nthe new suf\ufb01x to form the next pre\ufb01x, and repeat.\nFor example, if you start with the pre\ufb01x \u201cHalf a\u201d, then the next word has to be \u201cbee\u201d,\nbecause the pre\ufb01x only appears once in the text. The next pre\ufb01x is \u201ca bee\u201d, so the next\nsuf\ufb01x might be \u201cphilosophically\u201d, \u201cbe\u201d or \u201cdue\u201d.\nIn this example the length of the pre\ufb01x is always two, but you can do Markov analysis with\nany pre\ufb01x length.\nExercise 13.8. Markov analysis:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_337",
    "text": "suf\ufb01x might be \u201cphilosophically\u201d, \u201cbe\u201d or \u201cdue\u201d.\nIn this example the length of the pre\ufb01x is always two, but you can do Markov analysis with\nany pre\ufb01x length.\nExercise 13.8. Markov analysis:\n1. Write a program to read a text from a \ufb01le and perform Markov analysis. The result should be\na dictionary that maps from pre\ufb01xes to a collection of possible suf\ufb01xes. The collection might\nbe a list, tuple, or dictionary; it is up to you to make an appropriate choice. You can test your\nprogram with pre\ufb01x length two, but you should write the program in a way that makes it easy\nto try other lengths.\n2. Add a function to the previous program to generate random text based on the Markov analysis.\nHere is an example from Emma with pre\ufb01x length 2:\nHe was very clever, be it sweetness or be angry, ashamed or only amused, at such\na stroke. She had never thought of Hannah till you were never meant for me?\" \"I\ncannot make speeches, Emma:\" he soon cut it all himself.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_338",
    "text": "a stroke. She had never thought of Hannah till you were never meant for me?\" \"I\ncannot make speeches, Emma:\" he soon cut it all himself.\nFor this example, I left the punctuation attached to the words. The result is almost syntacti-\ncally correct, but not quite. Semantically, it almost makes sense, but not quite.\nWhat happens if you increase the pre\ufb01x length? Does the random text make more sense?\n132\nChapter 13. Case study: data structure selection\n3. Once your program is working, you might want to try a mash-up: if you combine text from\ntwo or more books, the random text you generate will blend the vocabulary and phrases from\nthe sources in interesting ways.\nCredit: This case study is based on an example from Kernighan and Pike, The Practice of Pro-\ngramming, Addison-Wesley, 1999.\nYou should attempt this exercise before you go on; then you can download my so-\nlution from https://thinkpython.com/code/markov.py. You will also need https://\nthinkpython.com/code/emma.txt.\n13.9",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_339",
    "text": "You should attempt this exercise before you go on; then you can download my so-\nlution from https://thinkpython.com/code/markov.py. You will also need https://\nthinkpython.com/code/emma.txt.\n13.9\nData structures\nUsing Markov analysis to generate random text is fun, but there is also a point to this\nexercise: data structure selection. In your solution to the previous exercises, you had to\nchoose:\n\u2022 How to represent the pre\ufb01xes.\n\u2022 How to represent the collection of possible suf\ufb01xes.\n\u2022 How to represent the mapping from each pre\ufb01x to the collection of possible suf\ufb01xes.\nThe last one is easy: a dictionary is the obvious choice for a mapping from keys to corre-\nsponding values.\nFor the pre\ufb01xes, the most obvious options are string, list of strings, or tuple of strings.\nFor the suf\ufb01xes, one option is a list; another is a histogram (dictionary).\nHow should you choose? The \ufb01rst step is to think about the operations you will need to",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_340",
    "text": "For the suf\ufb01xes, one option is a list; another is a histogram (dictionary).\nHow should you choose? The \ufb01rst step is to think about the operations you will need to\nimplement for each data structure. For the pre\ufb01xes, we need to be able to remove words\nfrom the beginning and add to the end. For example, if the current pre\ufb01x is \u201cHalf a\u201d, and\nthe next word is \u201cbee\u201d, you need to be able to form the next pre\ufb01x, \u201ca bee\u201d.\nYour \ufb01rst choice might be a list, since it is easy to add and remove elements, but we also\nneed to be able to use the pre\ufb01xes as keys in a dictionary, so that rules out lists. With tuples,\nyou can\u2019t append or remove, but you can use the addition operator to form a new tuple:\ndef shift(prefix, word):\nreturn prefix[1:] + (word,)\nshift takes a tuple of words, prefix, and a string, word, and forms a new tuple that has\nall the words in prefix except the \ufb01rst, and word added to the end.\nFor the collection of suf\ufb01xes, the operations we need to perform include adding a new",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_341",
    "text": "all the words in prefix except the \ufb01rst, and word added to the end.\nFor the collection of suf\ufb01xes, the operations we need to perform include adding a new\nsuf\ufb01x (or increasing the frequency of an existing one), and choosing a random suf\ufb01x.\nAdding a new suf\ufb01x is equally easy for the list implementation or the histogram. Choosing\na random element from a list is easy; choosing from a histogram is harder to do ef\ufb01ciently\n(see Exercise 13.7).\nSo far we have been talking mostly about ease of implementation, but there are other fac-\ntors to consider in choosing data structures. One is run time. Sometimes there is a theoreti-\ncal reason to expect one data structure to be faster than other; for example, I mentioned that\n13.10. Debugging\n133\nthe in operator is faster for dictionaries than for lists, at least when the number of elements\nis large.\nBut often you don\u2019t know ahead of time which implementation will be faster. One option is",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_342",
    "text": "133\nthe in operator is faster for dictionaries than for lists, at least when the number of elements\nis large.\nBut often you don\u2019t know ahead of time which implementation will be faster. One option is\nto implement both of them and see which is better. This approach is called benchmarking.\nA practical alternative is to choose the data structure that is easiest to implement, and then\nsee if it is fast enough for the intended application. If so, there is no need to go on. If not,\nthere are tools, like the profile module, that can identify the places in a program that take\nthe most time.\nThe other factor to consider is storage space. For example, using a histogram for the col-\nlection of suf\ufb01xes might take less space because you only have to store each word once, no\nmatter how many times it appears in the text. In some cases, saving space can also make\nyour program run faster, and in the extreme, your program might not run at all if you run",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_343",
    "text": "matter how many times it appears in the text. In some cases, saving space can also make\nyour program run faster, and in the extreme, your program might not run at all if you run\nout of memory. But for many applications, space is a secondary consideration after run\ntime.\nOne \ufb01nal thought: in this discussion, I have implied that we should use one data structure\nfor both analysis and generation. But since these are separate phases, it would also be pos-\nsible to use one structure for analysis and then convert to another structure for generation.\nThis would be a net win if the time saved during generation exceeded the time spent in\nconversion.\n13.10\nDebugging\nWhen you are debugging a program, and especially if you are working on a hard bug,\nthere are \ufb01ve things to try:\nReading: Examine your code, read it back to yourself, and check that it says what you\nmeant to say.\nRunning: Experiment by making changes and running different versions. Often if you",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_344",
    "text": "Reading: Examine your code, read it back to yourself, and check that it says what you\nmeant to say.\nRunning: Experiment by making changes and running different versions. Often if you\ndisplay the right thing at the right place in the program, the problem becomes obvi-\nous, but sometimes you have to build scaffolding.\nRuminating: Take some time to think! What kind of error is it: syntax, runtime, or seman-\ntic? What information can you get from the error messages, or from the output of the\nprogram? What kind of error could cause the problem you\u2019re seeing? What did you\nchange last, before the problem appeared?\nRubberducking: If you explain the problem to someone else, you sometimes \ufb01nd the\nanswer before you \ufb01nish asking the question.\nOften you don\u2019t need the other\nperson; you could just talk to a rubber duck.\nAnd that\u2019s the origin of the well-\nknown strategy called rubber duck debugging.\nI am not making this up; see\nhttps://en.wikipedia.org/wiki/Rubber_duck_debugging.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_345",
    "text": "And that\u2019s the origin of the well-\nknown strategy called rubber duck debugging.\nI am not making this up; see\nhttps://en.wikipedia.org/wiki/Rubber_duck_debugging.\nRetreating: At some point, the best thing to do is back off, undoing recent changes, until\nyou get back to a program that works and that you understand. Then you can start\nrebuilding.\n134\nChapter 13. Case study: data structure selection\nBeginning programmers sometimes get stuck on one of these activities and forget the oth-\ners. Each activity comes with its own failure mode.\nFor example, reading your code might help if the problem is a typographical error, but\nnot if the problem is a conceptual misunderstanding. If you don\u2019t understand what your\nprogram does, you can read it 100 times and never see the error, because the error is in\nyour head.\nRunning experiments can help, especially if you run small, simple tests. But if you run\nexperiments without thinking or reading your code, you might fall into a pattern I call",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_346",
    "text": "your head.\nRunning experiments can help, especially if you run small, simple tests. But if you run\nexperiments without thinking or reading your code, you might fall into a pattern I call\n\u201crandom walk programming\u201d, which is the process of making random changes until the\nprogram does the right thing. Needless to say, random walk programming can take a long\ntime.\nYou have to take time to think. Debugging is like an experimental science. You should have\nat least one hypothesis about what the problem is. If there are two or more possibilities, try\nto think of a test that would eliminate one of them.\nBut even the best debugging techniques will fail if there are too many errors, or if the code\nyou are trying to \ufb01x is too big and complicated. Sometimes the best option is to retreat,\nsimplifying the program until you get to something that works and that you understand.\nBeginning programmers are often reluctant to retreat because they can\u2019t stand to delete a",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_347",
    "text": "simplifying the program until you get to something that works and that you understand.\nBeginning programmers are often reluctant to retreat because they can\u2019t stand to delete a\nline of code (even if it\u2019s wrong). If it makes you feel better, copy your program into another\n\ufb01le before you start stripping it down. Then you can copy the pieces back one at a time.\nFinding a hard bug requires reading, running, ruminating, and sometimes retreating. If\nyou get stuck on one of these activities, try the others.\n13.11\nGlossary\ndeterministic: Pertaining to a program that does the same thing each time it runs, given\nthe same inputs.\npseudorandom: Pertaining to a sequence of numbers that appears to be random, but is\ngenerated by a deterministic program.\ndefault value: The value given to an optional parameter if no argument is provided.\noverride: To replace a default value with an argument.\nbenchmarking: The process of choosing between data structures by implementing alter-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_348",
    "text": "override: To replace a default value with an argument.\nbenchmarking: The process of choosing between data structures by implementing alter-\nnatives and testing them on a sample of the possible inputs.\nrubber duck debugging: Debugging by explaining your problem to an inanimate object\nsuch as a rubber duck. Articulating the problem can help you solve it, even if the\nrubber duck doesn\u2019t know Python.\n13.12\nExercises\nExercise 13.9. The \u201crank\u201d of a word is its position in a list of words sorted by frequency: the most\ncommon word has rank 1, the second most common has rank 2, etc.\n13.12. Exercises\n135\nZipf\u2019s law describes a relationship between the ranks and frequencies of words in natural languages\n(http: // en. wikipedia. org/ wiki/ Zipf\u2019s_ law ). Speci\ufb01cally, it predicts that the frequency,\nf, of the word with rank r is:\nf = cr\u2212s\nwhere s and c are parameters that depend on the language and the text. If you take the logarithm of\nboth sides of this equation, you get:\nlog f = log c \u2212s log r",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_349",
    "text": "f, of the word with rank r is:\nf = cr\u2212s\nwhere s and c are parameters that depend on the language and the text. If you take the logarithm of\nboth sides of this equation, you get:\nlog f = log c \u2212s log r\nSo if you plot log f versus log r, you should get a straight line with slope \u2212s and intercept log c.\nWrite a program that reads a text from a \ufb01le, counts word frequencies, and prints one line for each\nword, in descending order of frequency, with log f and log r. Use the graphing program of your\nchoice to plot the results and check whether they form a straight line. Can you estimate the value of\ns?\nSolution: https: // thinkpython. com/ code/ zipf. py . To run my solution, you need the plot-\nting module matplotlib. If you installed Anaconda, you already have matplotlib; otherwise you\nmight have to install it.\n136\nChapter 13. Case study: data structure selection\nChapter 14\nFiles\nThis chapter introduces the idea of \u201cpersistent\u201d programs that keep data in permanent stor-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_350",
    "text": "might have to install it.\n136\nChapter 13. Case study: data structure selection\nChapter 14\nFiles\nThis chapter introduces the idea of \u201cpersistent\u201d programs that keep data in permanent stor-\nage, and shows how to use different kinds of permanent storage, like \ufb01les and databases.\n14.1\nPersistence\nMost of the programs we have seen so far are transient in the sense that they run for a short\ntime and produce some output, but when they end, their data disappears. If you run the\nprogram again, it starts with a clean slate.\nOther programs are persistent: they run for a long time (or all the time); they keep at least\nsome of their data in permanent storage (a hard drive, for example); and if they shut down\nand restart, they pick up where they left off.\nExamples of persistent programs are operating systems, which run pretty much whenever\na computer is on, and web servers, which run all the time, waiting for requests to come in\non the network.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_351",
    "text": "Examples of persistent programs are operating systems, which run pretty much whenever\na computer is on, and web servers, which run all the time, waiting for requests to come in\non the network.\nOne of the simplest ways for programs to maintain their data is by reading and writing\ntext \ufb01les. We have already seen programs that read text \ufb01les; in this chapter we will see\nprograms that write them.\nAn alternative is to store the state of the program in a database. In this chapter I will present\na simple database and a module, pickle, that makes it easy to store program data.\n14.2\nReading and writing\nA text \ufb01le is a sequence of characters stored on a permanent medium like a hard drive,\n\ufb02ash memory, or CD-ROM. We saw how to open and read a \ufb01le in Section 9.1.\nTo write a \ufb01le, you have to open it with mode 'w' as a second parameter:\n>>> fout = open('output.txt', 'w')\n138\nChapter 14. Files\nIf the \ufb01le already exists, opening it in write mode clears out the old data and starts fresh,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_352",
    "text": ">>> fout = open('output.txt', 'w')\n138\nChapter 14. Files\nIf the \ufb01le already exists, opening it in write mode clears out the old data and starts fresh,\nso be careful! If the \ufb01le doesn\u2019t exist, a new one is created.\nopen returns a \ufb01le object that provides methods for working with the \ufb01le. The write\nmethod puts data into the \ufb01le.\n>>> line1 = \"This here's the wattle,\\n\"\n>>> fout.write(line1)\n24\nThe return value is the number of characters that were written. The \ufb01le object keeps track\nof where it is, so if you call write again, it adds the new data to the end of the \ufb01le.\n>>> line2 = \"the emblem of our land.\\n\"\n>>> fout.write(line2)\n24\nWhen you are done writing, you should close the \ufb01le.\n>>> fout.close()\nIf you don\u2019t close the \ufb01le, it gets closed for you when the program ends.\n14.3\nFormat operator\nThe argument of write has to be a string, so if we want to put other values in a \ufb01le, we\nhave to convert them to strings. The easiest way to do that is with str:\n>>> x = 52\n>>> fout.write(str(x))",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_353",
    "text": "The argument of write has to be a string, so if we want to put other values in a \ufb01le, we\nhave to convert them to strings. The easiest way to do that is with str:\n>>> x = 52\n>>> fout.write(str(x))\nAn alternative is to use the format operator, %. When applied to integers, % is the modulus\noperator. But when the \ufb01rst operand is a string, % is the format operator.\nThe \ufb01rst operand is the format string, which contains one or more format sequences,\nwhich specify how the second operand is formatted. The result is a string.\nFor example, the format sequence '%d' means that the second operand should be format-\nted as a decimal integer:\n>>> camels = 42\n>>> '%d' % camels\n'42'\nThe result is the string '42', which is not to be confused with the integer value 42.\nA format sequence can appear anywhere in the string, so you can embed a value in a\nsentence:\n>>> 'I have spotted %d camels.' % camels\n'I have spotted 42 camels.'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_354",
    "text": "A format sequence can appear anywhere in the string, so you can embed a value in a\nsentence:\n>>> 'I have spotted %d camels.' % camels\n'I have spotted 42 camels.'\nIf there is more than one format sequence in the string, the second argument has to be a\ntuple. Each format sequence is matched with an element of the tuple, in order.\nThe following example uses '%d' to format an integer, '%g' to format a \ufb02oating-point num-\nber, and '%s' to format a string:\n>>> 'In %d years I have spotted %g %s.' % (3, 0.1, 'camels')\n'In 3 years I have spotted 0.1 camels.'\n14.4. Filenames and paths\n139\nThe number of elements in the tuple has to match the number of format sequences in the\nstring. Also, the types of the elements have to match the format sequences:\n>>> '%d %d %d' % (1, 2)\nTypeError: not enough arguments for format string\n>>> '%d' % 'dollars'\nTypeError: %d format: a number is required, not str\nIn the \ufb01rst example, there aren\u2019t enough elements; in the second, the element is the wrong\ntype.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_355",
    "text": ">>> '%d' % 'dollars'\nTypeError: %d format: a number is required, not str\nIn the \ufb01rst example, there aren\u2019t enough elements; in the second, the element is the wrong\ntype.\nFor more information on the format operator, see https://docs.python.org/3/library/\nstdtypes.html#printf-style-string-formatting.\nA more powerful alternative is\nthe string format method, which you can read about at https://docs.python.org/3/\nlibrary/stdtypes.html#str.format.\n14.4\nFilenames and paths\nFiles are organized into directories (also called \u201cfolders\u201d). Every running program has a\n\u201ccurrent directory\u201d, which is the default directory for most operations. For example, when\nyou open a \ufb01le for reading, Python looks for it in the current directory.\nThe os module provides functions for working with \ufb01les and directories (\u201cos\u201d stands for\n\u201coperating system\u201d). os.getcwd returns the name of the current directory:\n>>> import os\n>>> cwd = os.getcwd()\n>>> cwd\n'/home/dinsdale'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_356",
    "text": "\u201coperating system\u201d). os.getcwd returns the name of the current directory:\n>>> import os\n>>> cwd = os.getcwd()\n>>> cwd\n'/home/dinsdale'\ncwd stands for \u201ccurrent working directory\u201d. The result in this example is /home/dinsdale,\nwhich is the home directory of a user named dinsdale.\nA string like '/home/dinsdale' that identi\ufb01es a \ufb01le or directory is called a path.\nA simple \ufb01lename, like memo.txt is also considered a path, but it is a relative path because\nit relates to the current directory. If the current directory is /home/dinsdale, the \ufb01lename\nmemo.txt would refer to /home/dinsdale/memo.txt.\nA path that begins with / does not depend on the current directory; it is called an absolute\npath. To \ufb01nd the absolute path to a \ufb01le, you can use os.path.abspath:\n>>> os.path.abspath('memo.txt')\n'/home/dinsdale/memo.txt'\nos.path provides other functions for working with \ufb01lenames and paths. For example,\nos.path.exists checks whether a \ufb01le or directory exists:\n>>> os.path.exists('memo.txt')\nTrue",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_357",
    "text": "os.path provides other functions for working with \ufb01lenames and paths. For example,\nos.path.exists checks whether a \ufb01le or directory exists:\n>>> os.path.exists('memo.txt')\nTrue\nIf it exists, os.path.isdir checks whether it\u2019s a directory:\n>>> os.path.isdir('memo.txt')\nFalse\n>>> os.path.isdir('/home/dinsdale')\nTrue\n140\nChapter 14. Files\nSimilarly, os.path.isfile checks whether it\u2019s a \ufb01le.\nos.listdir returns a list of the \ufb01les (and other directories) in the given directory:\n>>> os.listdir(cwd)\n['music', 'photos', 'memo.txt']\nTo demonstrate these functions, the following example \u201cwalks\u201d through a directory, prints\nthe names of all the \ufb01les, and calls itself recursively on all the directories.\ndef walk(dirname):\nfor name in os.listdir(dirname):\npath = os.path.join(dirname, name)\nif os.path.isfile(path):\nprint(path)\nelse:\nwalk(path)\nos.path.join takes a directory and a \ufb01le name and joins them into a complete path.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_358",
    "text": "path = os.path.join(dirname, name)\nif os.path.isfile(path):\nprint(path)\nelse:\nwalk(path)\nos.path.join takes a directory and a \ufb01le name and joins them into a complete path.\nThe os module provides a function called walk that is similar to this one but more ver-\nsatile.\nAs an exercise, read the documentation and use it to print the names of the\n\ufb01les in a given directory and its subdirectories.\nYou can download my solution from\nhttps://thinkpython.com/code/walk.py.\n14.5\nCatching exceptions\nA lot of things can go wrong when you try to read and write \ufb01les. If you try to open a \ufb01le\nthat doesn\u2019t exist, you get an FileNotFoundError:\n>>> fin = open('bad_file')\nFileNotFoundError: [Errno 2] No such file or directory: 'bad_file'\nIf you don\u2019t have permission to access a \ufb01le:\n>>> fout = open('/etc/passwd', 'w')\nPermissionError: [Errno 13] Permission denied: '/etc/passwd'\nAnd if you try to open a directory for reading, you get\n>>> fin = open('/home')",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_359",
    "text": ">>> fout = open('/etc/passwd', 'w')\nPermissionError: [Errno 13] Permission denied: '/etc/passwd'\nAnd if you try to open a directory for reading, you get\n>>> fin = open('/home')\nIsADirectoryError: [Errno 21] Is a directory: '/home'\nTo avoid these errors, you could use functions like os.path.exists and os.path.isfile,\nbut it would take a lot of time and code to check all the possibilities (if \u201cErrno 21\u201d is any\nindication, there are at least 21 things that can go wrong).\nIt is better to go ahead and try\u2014and deal with problems if they happen\u2014which is exactly\nwhat the try statement does. The syntax is similar to an if...else statement:\ntry:\nfin = open('bad_file')\nexcept:\nprint('Something went wrong.')\n14.6. Databases\n141\nPython starts by executing the try clause. If all goes well, it skips the except clause and\nproceeds. If an exception occurs, it jumps out of the try clause and runs the except clause.\nHandling an exception with a try statement is called catching an exception. In this exam-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_360",
    "text": "proceeds. If an exception occurs, it jumps out of the try clause and runs the except clause.\nHandling an exception with a try statement is called catching an exception. In this exam-\nple, the except clause prints an error message that is not very helpful. In general, catching\nan exception gives you a chance to \ufb01x the problem, or try again, or at least end the program\ngracefully.\n14.6\nDatabases\nA database is a \ufb01le that is organized for storing data. Many databases are organized like a\ndictionary in the sense that they map from keys to values. The biggest difference between\na database and a dictionary is that the database is on disk (or other permanent storage), so\nit persists after the program ends.\nThe module dbm provides an interface for creating and updating database \ufb01les. As an\nexample, I\u2019ll create a database that contains captions for image \ufb01les.\nOpening a database is similar to opening other \ufb01les:\n>>> import dbm\n>>> db = dbm.open('captions', 'c')",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_361",
    "text": "example, I\u2019ll create a database that contains captions for image \ufb01les.\nOpening a database is similar to opening other \ufb01les:\n>>> import dbm\n>>> db = dbm.open('captions', 'c')\nThe mode 'c' means that the database should be created if it doesn\u2019t already exist. The\nresult is a database object that can be used (for most operations) like a dictionary.\nWhen you create a new item, dbm updates the database \ufb01le.\n>>> db['cleese.png'] = 'Photo of John Cleese.'\nWhen you access one of the items, dbm reads the \ufb01le:\n>>> db['cleese.png']\nb'Photo of John Cleese.'\nThe result is a bytes object, which is why it begins with b. A bytes object is similar to a\nstring in many ways. When you get farther into Python, the difference becomes important,\nbut for now we can ignore it.\nIf you make another assignment to an existing key, dbm replaces the old value:\n>>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'\n>>> db['cleese.png']\nb'Photo of John Cleese doing a silly walk.'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_362",
    "text": ">>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'\n>>> db['cleese.png']\nb'Photo of John Cleese doing a silly walk.'\nSome dictionary methods, like keys and items, don\u2019t work with database objects. But\niteration with a for loop works:\nfor key in db.keys():\nprint(key, db[key])\nAs with other \ufb01les, you should close the database when you are done:\n>>> db.close()\n142\nChapter 14. Files\n14.7\nPickling\nA limitation of dbm is that the keys and values have to be strings or bytes. If you try to use\nany other type, you get an error.\nThe pickle module can help. It translates almost any type of object into a string suitable\nfor storage in a database, and then translates strings back into objects.\npickle.dumps takes an object as a parameter and returns a string representation (dumps is\nshort for \u201cdump string\u201d):\n>>> import pickle\n>>> t = [1, 2, 3]\n>>> pickle.dumps(t)\nb'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_363",
    "text": "short for \u201cdump string\u201d):\n>>> import pickle\n>>> t = [1, 2, 3]\n>>> pickle.dumps(t)\nb'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'\nThe format isn\u2019t obvious to human readers; it is meant to be easy for pickle to interpret.\npickle.loads (\u201cload string\u201d) reconstitutes the object:\n>>> t1 = [1, 2, 3]\n>>> s = pickle.dumps(t1)\n>>> t2 = pickle.loads(s)\n>>> t2\n[1, 2, 3]\nAlthough the new object has the same value as the old, it is not (in general) the same object:\n>>> t1 == t2\nTrue\n>>> t1 is t2\nFalse\nIn other words, pickling and then unpickling has the same effect as copying the object.\nYou can use pickle to store non-strings in a database. In fact, this combination is so com-\nmon that it has been encapsulated in a module called shelve.\n14.8\nPipes\nMost operating systems provide a command-line interface, also known as a shell. Shells\nusually provide commands to navigate the \ufb01le system and launch applications. For exam-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_364",
    "text": "14.8\nPipes\nMost operating systems provide a command-line interface, also known as a shell. Shells\nusually provide commands to navigate the \ufb01le system and launch applications. For exam-\nple, in Unix you can change directories with cd, display the contents of a directory with ls,\nand launch a web browser by typing (for example) firefox.\nAny program that you can launch from the shell can also be launched from Python using\na pipe object, which represents a running program.\nFor example, the Unix command ls -l normally displays the contents of the current di-\nrectory in long format. You can launch ls with os.popen1:\n>>> cmd = 'ls -l'\n>>> fp = os.popen(cmd)\n1popen is deprecated now, which means we are supposed to stop using it and start using the subprocess\nmodule. But for simple cases, I \ufb01nd subprocess more complicated than necessary. So I am going to keep using\npopen until they take it away.\n14.9. Writing modules\n143",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_365",
    "text": "module. But for simple cases, I \ufb01nd subprocess more complicated than necessary. So I am going to keep using\npopen until they take it away.\n14.9. Writing modules\n143\nThe argument is a string that contains a shell command. The return value is an object that\nbehaves like an open \ufb01le. You can read the output from the ls process one line at a time\nwith readline or get the whole thing at once with read:\n>>> res = fp.read()\nWhen you are done, you close the pipe like a \ufb01le:\n>>> stat = fp.close()\n>>> print(stat)\nNone\nThe return value is the \ufb01nal status of the ls process; None means that it ended normally\n(with no errors).\nFor example, most Unix systems provide a command called md5sum that reads the contents\nof a \ufb01le and computes a \u201cchecksum\u201d. You can read about MD5 at http://en.wikipedia.\norg/wiki/Md5. This command provides an ef\ufb01cient way to check whether two \ufb01les have\nthe same contents. The probability that different contents yield the same checksum is very",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_366",
    "text": "org/wiki/Md5. This command provides an ef\ufb01cient way to check whether two \ufb01les have\nthe same contents. The probability that different contents yield the same checksum is very\nsmall (that is, unlikely to happen before the universe collapses).\nYou can use a pipe to run md5sum from Python and get the result:\n>>> filename = 'book.tex'\n>>> cmd = 'md5sum ' + filename\n>>> fp = os.popen(cmd)\n>>> res = fp.read()\n>>> stat = fp.close()\n>>> print(res)\n1e0033f0ed0656636de0d75144ba32e0\nbook.tex\n>>> print(stat)\nNone\n14.9\nWriting modules\nAny \ufb01le that contains Python code can be imported as a module. For example, suppose\nyou have a \ufb01le named wc.py with the following code:\ndef linecount(filename):\ncount = 0\nfor line in open(filename):\ncount += 1\nreturn count\nprint(linecount('wc.py'))\nIf you run this program, it reads itself and prints the number of lines in the \ufb01le, which is 7.\nYou can also import it like this:\n>>> import wc\n7\nNow you have a module object wc:\n>>> wc\n<module 'wc' from 'wc.py'>\n144",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_367",
    "text": "You can also import it like this:\n>>> import wc\n7\nNow you have a module object wc:\n>>> wc\n<module 'wc' from 'wc.py'>\n144\nChapter 14. Files\nThe module object provides linecount:\n>>> wc.linecount('wc.py')\n7\nSo that\u2019s how you write modules in Python.\nThe only problem with this example is that when you import the module it runs the test\ncode at the bottom. Normally when you import a module, it de\ufb01nes new functions but it\ndoesn\u2019t run them.\nPrograms that will be imported as modules often use the following idiom:\nif __name__ == '__main__':\nprint(linecount('wc.py'))\n__name__ is a built-in variable that is set when the program starts. If the program is running\nas a script, __name__ has the value '__main__'; in that case, the test code runs. Otherwise,\nif the module is being imported, the test code is skipped.\nAs an exercise, type this example into a \ufb01le named wc.py and run it as a script. Then run\nthe Python interpreter and import wc. What is the value of __name__ when the module is",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_368",
    "text": "As an exercise, type this example into a \ufb01le named wc.py and run it as a script. Then run\nthe Python interpreter and import wc. What is the value of __name__ when the module is\nbeing imported?\nWarning: If you import a module that has already been imported, Python does nothing. It\ndoes not re-read the \ufb01le, even if it has changed.\nIf you want to reload a module, you can use the built-in function reload, but it can be\ntricky, so the safest thing to do is restart the interpreter and then import the module again.\n14.10\nDebugging\nWhen you are reading and writing \ufb01les, you might run into problems with whitespace.\nThese errors can be hard to debug because spaces, tabs and newlines are normally invisible:\n>>> s = '1 2\\t 3\\n 4'\n>>> print(s)\n1 2\n3\n4\nThe built-in function repr can help. It takes any object as an argument and returns a string\nrepresentation of the object. For strings, it represents whitespace characters with backslash\nsequences:\n>>> print(repr(s))\n'1 2\\t 3\\n 4'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_369",
    "text": "representation of the object. For strings, it represents whitespace characters with backslash\nsequences:\n>>> print(repr(s))\n'1 2\\t 3\\n 4'\nThis can be helpful for debugging.\nOne other problem you might run into is that different systems use different characters to\nindicate the end of a line. Some systems use a newline, represented \\n. Others use a return\ncharacter, represented \\r. Some use both. If you move \ufb01les between different systems,\nthese inconsistencies can cause problems.\nFor most systems, there are applications to convert from one format to another. You can\n\ufb01nd them (and read more about this issue) at http://en.wikipedia.org/wiki/Newline.\nOr, of course, you could write one yourself.\n14.11. Glossary\n145\n14.11\nGlossary\npersistent: Pertaining to a program that runs inde\ufb01nitely and keeps at least some of its\ndata in permanent storage.\nformat operator: An operator, %, that takes a format string and a tuple and generates a",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_370",
    "text": "data in permanent storage.\nformat operator: An operator, %, that takes a format string and a tuple and generates a\nstring that includes the elements of the tuple formatted as speci\ufb01ed by the format\nstring.\nformat string: A string, used with the format operator, that contains format sequences.\nformat sequence: A sequence of characters in a format string, like %d, that speci\ufb01es how a\nvalue should be formatted.\ntext \ufb01le: A sequence of characters stored in permanent storage like a hard drive.\ndirectory: A named collection of \ufb01les, also called a folder.\npath: A string that identi\ufb01es a \ufb01le.\nrelative path: A path that starts from the current directory.\nabsolute path: A path that starts from the topmost directory in the \ufb01le system.\ncatch: To prevent an exception from terminating a program using the try and except state-\nments.\ndatabase: A \ufb01le whose contents are organized like a dictionary with keys that correspond\nto values.\nbytes object: An object similar to a string.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_371",
    "text": "ments.\ndatabase: A \ufb01le whose contents are organized like a dictionary with keys that correspond\nto values.\nbytes object: An object similar to a string.\nshell: A program that allows users to type commands and then executes them by starting\nother programs.\npipe object: An object that represents a running program, allowing a Python program to\nrun commands and read the results.\n14.12\nExercises\nExercise 14.1. Write a function called sed that takes as arguments a pattern string, a replacement\nstring, and two \ufb01lenames; it should read the \ufb01rst \ufb01le and write the contents into the second \ufb01le\n(creating it if necessary). If the pattern string appears anywhere in the \ufb01le, it should be replaced\nwith the replacement string.\nIf an error occurs while opening, reading, writing or closing \ufb01les, your program should catch the\nexception, print an error message, and exit. Solution: https: // thinkpython. com/ code/ sed.\npy .",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_372",
    "text": "If an error occurs while opening, reading, writing or closing \ufb01les, your program should catch the\nexception, print an error message, and exit. Solution: https: // thinkpython. com/ code/ sed.\npy .\nExercise 14.2. If you download my solution to Exercise 12.2 from https: // thinkpython. com/\ncode/ anagram_ sets. py , you\u2019ll see that it creates a dictionary that maps from a sorted string of\nletters to the list of words that can be spelled with those letters. For example, 'opst' maps to the\nlist ['opts', 'post', 'pots', 'spot', 'stop', 'tops'].\nWrite a module that imports anagram_sets and provides two new functions: store_anagrams\nshould store the anagram dictionary in a \u201cshelf\u201d; read_anagrams should look up a word and return\na list of its anagrams. Solution: https: // thinkpython. com/ code/ anagram_ db. py .\n146\nChapter 14. Files\nExercise 14.3. In a large collection of MP3 \ufb01les, there may be more than one copy of the same song,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_373",
    "text": "146\nChapter 14. Files\nExercise 14.3. In a large collection of MP3 \ufb01les, there may be more than one copy of the same song,\nstored in different directories or with different \ufb01le names. The goal of this exercise is to search for\nduplicates.\n1. Write a program that searches a directory and all of its subdirectories, recursively, and returns\na list of complete paths for all \ufb01les with a given suf\ufb01x (like .mp3). Hint: os.path provides\nseveral useful functions for manipulating \ufb01le and path names.\n2. To recognize duplicates, you can use md5sum to compute a \u201cchecksum\u201d for each \ufb01les. If two\n\ufb01les have the same checksum, they probably have the same contents.\n3. To double-check, you can use the Unix command diff.\nSolution: https: // thinkpython. com/ code/ find_ duplicates. py .\nChapter 15\nClasses and objects\nAt this point you know how to use functions to organize code and built-in types to organize\ndata. The next step is to learn \u201cobject-oriented programming\u201d, which uses programmer-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_374",
    "text": "Classes and objects\nAt this point you know how to use functions to organize code and built-in types to organize\ndata. The next step is to learn \u201cobject-oriented programming\u201d, which uses programmer-\nde\ufb01ned types to organize both code and data. Object-oriented programming is a big topic;\nit will take a few chapters to get there.\nCode examples from this chapter are available from https://thinkpython.com/code/\nPoint1.py; solutions to the exercises are available from https://thinkpython.com/code/\nPoint1_soln.py.\n15.1\nProgrammer-de\ufb01ned types\nWe have used many of Python\u2019s built-in types; now we are going to de\ufb01ne a new type. As\nan example, we will create a type called Point that represents a point in two-dimensional\nspace.\nIn mathematical notation, points are often written in parentheses with a comma separating\nthe coordinates. For example, (0, 0) represents the origin, and (x, y) represents the point x\nunits to the right and y units up from the origin.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_375",
    "text": "the coordinates. For example, (0, 0) represents the origin, and (x, y) represents the point x\nunits to the right and y units up from the origin.\nThere are several ways we might represent points in Python:\n\u2022 We could store the coordinates separately in two variables, x and y.\n\u2022 We could store the coordinates as elements in a list or tuple.\n\u2022 We could create a new type to represent points as objects.\nCreating a new type is more complicated than the other options, but it has advantages that\nwill be apparent soon.\nA programmer-de\ufb01ned type is also called a class. A class de\ufb01nition looks like this:\nclass Point:\n\"\"\"Represents a point in 2-D space.\"\"\"\n148\nChapter 15. Classes and objects\nx\ny\n3.0\n4.0\nblank\nPoint\nFigure 15.1: Object diagram.\nThe header indicates that the new class is called Point. The body is a docstring that ex-\nplains what the class is for. You can de\ufb01ne variables and methods inside a class de\ufb01nition,\nbut we will get back to that later.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_376",
    "text": "plains what the class is for. You can de\ufb01ne variables and methods inside a class de\ufb01nition,\nbut we will get back to that later.\nDe\ufb01ning a class named Point creates a class object.\n>>> Point\n<class '__main__.Point'>\nBecause Point is de\ufb01ned at the top level, its \u201cfull name\u201d is __main__.Point.\nThe class object is like a factory for creating objects. To create a Point, you call Point as if it\nwere a function.\n>>> blank = Point()\n>>> blank\n<__main__.Point object at 0xb7e9d3ac>\nThe return value is a reference to a Point object, which we assign to blank.\nCreating a new object is called instantiation, and the object is an instance of the class.\nWhen you print an instance, Python tells you what class it belongs to and where it is stored\nin memory (the pre\ufb01x 0x means that the following number is in hexadecimal).\nEvery object is an instance of some class, so \u201cobject\u201d and \u201cinstance\u201d are interchangeable.\nBut in this chapter I use \u201cinstance\u201d to indicate that I am talking about a programmer-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_377",
    "text": "Every object is an instance of some class, so \u201cobject\u201d and \u201cinstance\u201d are interchangeable.\nBut in this chapter I use \u201cinstance\u201d to indicate that I am talking about a programmer-\nde\ufb01ned type.\n15.2\nAttributes\nYou can assign values to an instance using dot notation:\n>>> blank.x = 3.0\n>>> blank.y = 4.0\nThis syntax is similar to the syntax for selecting a variable from a module, such as math.pi\nor string.whitespace. In this case, though, we are assigning values to named elements of\nan object. These elements are called attributes.\nAs a noun, \u201cAT-trib-ute\u201d is pronounced with emphasis on the \ufb01rst syllable, as opposed to\n\u201ca-TRIB-ute\u201d, which is a verb.\nFigure 15.1 is a state diagram that shows the result of these assignments. A state diagram\nthat shows an object and its attributes is called an object diagram.\nThe variable blank refers to a Point object, which contains two attributes. Each attribute\nrefers to a \ufb02oating-point number.\nYou can read the value of an attribute using the same syntax:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_378",
    "text": "The variable blank refers to a Point object, which contains two attributes. Each attribute\nrefers to a \ufb02oating-point number.\nYou can read the value of an attribute using the same syntax:\n15.3. Rectangles\n149\n>>> blank.y\n4.0\n>>> x = blank.x\n>>> x\n3.0\nThe expression blank.x means, \u201cGo to the object blank refers to and get the value of x.\u201d In\nthe example, we assign that value to a variable named x. There is no con\ufb02ict between the\nvariable x and the attribute x.\nYou can use dot notation as part of any expression. For example:\n>>> '(%g, %g)' % (blank.x, blank.y)\n'(3.0, 4.0)'\n>>> distance = math.sqrt(blank.x**2 + blank.y**2)\n>>> distance\n5.0\nYou can pass an instance as an argument in the usual way. For example:\ndef print_point(p):\nprint('(%g, %g)' % (p.x, p.y))\nprint_point takes a point as an argument and displays it in mathematical notation. To\ninvoke it, you can pass blank as an argument:\n>>> print_point(blank)\n(3.0, 4.0)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_379",
    "text": "print('(%g, %g)' % (p.x, p.y))\nprint_point takes a point as an argument and displays it in mathematical notation. To\ninvoke it, you can pass blank as an argument:\n>>> print_point(blank)\n(3.0, 4.0)\nInside the function, p is an alias for blank, so if the function modi\ufb01es p, blank changes.\nAs an exercise, write a function called distance_between_points that takes two Points as\narguments and returns the distance between them.\n15.3\nRectangles\nSometimes it is obvious what the attributes of an object should be, but other times you have\nto make decisions. For example, imagine you are designing a class to represent rectangles.\nWhat attributes would you use to specify the location and size of a rectangle? You can ig-\nnore angle; to keep things simple, assume that the rectangle is either vertical or horizontal.\nThere are at least two possibilities:\n\u2022 You could specify one corner of the rectangle (or the center), the width, and the\nheight.\n\u2022 You could specify two opposing corners.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_380",
    "text": "There are at least two possibilities:\n\u2022 You could specify one corner of the rectangle (or the center), the width, and the\nheight.\n\u2022 You could specify two opposing corners.\nAt this point it is hard to say whether either is better than the other, so we\u2019ll implement the\n\ufb01rst one, just as an example.\nHere is the class de\ufb01nition:\n150\nChapter 15. Classes and objects\ny\n0.0\nx\n0.0\nwidth\n100.0\ncorner\n200.0\nPoint\nRectangle\nbox\nheight\nFigure 15.2: Object diagram.\nclass Rectangle:\n\"\"\"Represents a rectangle.\nattributes: width, height, corner.\n\"\"\"\nThe docstring lists the attributes: width and height are numbers; corner is a Point object\nthat speci\ufb01es the lower-left corner.\nTo represent a rectangle, you have to instantiate a Rectangle object and assign values to the\nattributes:\nbox = Rectangle()\nbox.width = 100.0\nbox.height = 200.0\nbox.corner = Point()\nbox.corner.x = 0.0\nbox.corner.y = 0.0\nThe expression box.corner.x means, \u201cGo to the object box refers to and select the attribute",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_381",
    "text": "box.width = 100.0\nbox.height = 200.0\nbox.corner = Point()\nbox.corner.x = 0.0\nbox.corner.y = 0.0\nThe expression box.corner.x means, \u201cGo to the object box refers to and select the attribute\nnamed corner; then go to that object and select the attribute named x.\u201d\nFigure 15.2 shows the state of this object. An object that is an attribute of another object is\nembedded.\n15.4\nInstances as return values\nFunctions can return instances. For example, find_center takes a Rectangle as an argu-\nment and returns a Point that contains the coordinates of the center of the Rectangle:\ndef find_center(rect):\np = Point()\np.x = rect.corner.x + rect.width/2\np.y = rect.corner.y + rect.height/2\nreturn p\nHere is an example that passes box as an argument and assigns the resulting Point to\ncenter:\n>>> center = find_center(box)\n>>> print_point(center)\n(50, 100)\n15.5. Objects are mutable\n151\n15.5\nObjects are mutable\nYou can change the state of an object by making an assignment to one of its attributes. For",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_382",
    "text": ">>> print_point(center)\n(50, 100)\n15.5. Objects are mutable\n151\n15.5\nObjects are mutable\nYou can change the state of an object by making an assignment to one of its attributes. For\nexample, to change the size of a rectangle without changing its position, you can modify\nthe values of width and height:\nbox.width = box.width + 50\nbox.height = box.height + 100\nYou can also write functions that modify objects. For example, grow_rectangle takes a\nRectangle object and two numbers, dwidth and dheight, and adds the numbers to the\nwidth and height of the rectangle:\ndef grow_rectangle(rect, dwidth, dheight):\nrect.width += dwidth\nrect.height += dheight\nHere is an example that demonstrates the effect:\n>>> box.width, box.height\n(150.0, 300.0)\n>>> grow_rectangle(box, 50, 100)\n>>> box.width, box.height\n(200.0, 400.0)\nInside the function, rect is an alias for box, so when the function modi\ufb01es rect, box\nchanges.\nAs an exercise, write a function named move_rectangle that takes a Rectangle and two",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_383",
    "text": "(200.0, 400.0)\nInside the function, rect is an alias for box, so when the function modi\ufb01es rect, box\nchanges.\nAs an exercise, write a function named move_rectangle that takes a Rectangle and two\nnumbers named dx and dy. It should change the location of the rectangle by adding dx to\nthe x coordinate of corner and adding dy to the y coordinate of corner.\n15.6\nCopying\nAliasing can make a program dif\ufb01cult to read because changes in one place might have\nunexpected effects in another place. It is hard to keep track of all the variables that might\nrefer to a given object.\nCopying an object is often an alternative to aliasing. The copy module contains a function\ncalled copy that can duplicate any object:\n>>> p1 = Point()\n>>> p1.x = 3.0\n>>> p1.y = 4.0\n>>> import copy\n>>> p2 = copy.copy(p1)\np1 and p2 contain the same data, but they are not the same Point.\n>>> print_point(p1)\n(3, 4)\n>>> print_point(p2)\n(3, 4)\n>>> p1 is p2\nFalse\n152\nChapter 15. Classes and objects\ny\n0.0\nx\n0.0\nwidth\nheight\n100.0",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_384",
    "text": ">>> print_point(p1)\n(3, 4)\n>>> print_point(p2)\n(3, 4)\n>>> p1 is p2\nFalse\n152\nChapter 15. Classes and objects\ny\n0.0\nx\n0.0\nwidth\nheight\n100.0\ncorner\n200.0\nbox\n100.0\n200.0\nwidth\nheight\ncorner\nbox2\nFigure 15.3: Object diagram.\n>>> p1 == p2\nFalse\nThe is operator indicates that p1 and p2 are not the same object, which is what we ex-\npected. But you might have expected == to yield True because these points contain the\nsame data. In that case, you will be disappointed to learn that for instances, the default\nbehavior of the == operator is the same as the is operator; it checks object identity, not\nobject equivalence. That\u2019s because for programmer-de\ufb01ned types, Python doesn\u2019t know\nwhat should be considered equivalent. At least, not yet.\nIf you use copy.copy to duplicate a Rectangle, you will \ufb01nd that it copies the Rectangle\nobject but not the embedded Point.\n>>> box2 = copy.copy(box)\n>>> box2 is box\nFalse\n>>> box2.corner is box.corner\nTrue\nFigure 15.3 shows what the object diagram looks like.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_385",
    "text": "object but not the embedded Point.\n>>> box2 = copy.copy(box)\n>>> box2 is box\nFalse\n>>> box2.corner is box.corner\nTrue\nFigure 15.3 shows what the object diagram looks like.\nThis operation is called a shallow\ncopy because it copies the object and any references it contains, but not the embedded\nobjects.\nFor most applications,\nthis is not what you want.\nIn this example,\ninvoking\ngrow_rectangle on one of the Rectangles would not affect the other, but invoking\nmove_rectangle on either would affect both! This behavior is confusing and error-prone.\nFortunately, the copy module provides a method named deepcopy that copies not only the\nobject but also the objects it refers to, and the objects they refer to, and so on. You will not\nbe surprised to learn that this operation is called a deep copy.\n>>> box3 = copy.deepcopy(box)\n>>> box3 is box\nFalse\n>>> box3.corner is box.corner\nFalse\nbox3 and box are completely separate objects.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_386",
    "text": "be surprised to learn that this operation is called a deep copy.\n>>> box3 = copy.deepcopy(box)\n>>> box3 is box\nFalse\n>>> box3.corner is box.corner\nFalse\nbox3 and box are completely separate objects.\nAs an exercise, write a version of move_rectangle that creates and returns a new Rectangle\ninstead of modifying the old one.\n15.7\nDebugging\nWhen you start working with objects, you are likely to encounter some new exceptions. If\nyou try to access an attribute that doesn\u2019t exist, you get an AttributeError:\n15.8. Glossary\n153\n>>> p = Point()\n>>> p.x = 3\n>>> p.y = 4\n>>> p.z\nAttributeError: Point instance has no attribute 'z'\nIf you are not sure what type an object is, you can ask:\n>>> type(p)\n<class '__main__.Point'>\nYou can also use isinstance to check whether an object is an instance of a class:\n>>> isinstance(p, Point)\nTrue\nIf you are not sure whether an object has a particular attribute, you can use the built-in\nfunction hasattr:\n>>> hasattr(p, 'x')\nTrue\n>>> hasattr(p, 'z')\nFalse",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_387",
    "text": ">>> isinstance(p, Point)\nTrue\nIf you are not sure whether an object has a particular attribute, you can use the built-in\nfunction hasattr:\n>>> hasattr(p, 'x')\nTrue\n>>> hasattr(p, 'z')\nFalse\nThe \ufb01rst argument can be any object; the second argument is a string that contains the name\nof the attribute.\nYou can also use a try statement to see if the object has the attributes you need:\ntry:\nx = p.x\nexcept AttributeError:\nx = 0\nThis approach can make it easier to write functions that work with different types; more\non that topic is coming up in Section 17.9.\n15.8\nGlossary\nclass: A programmer-de\ufb01ned type. A class de\ufb01nition creates a new class object.\nclass object: An object that contains information about a programmer-de\ufb01ned type. The\nclass object can be used to create instances of the type.\ninstance: An object that belongs to a class.\ninstantiate: To create a new object.\nattribute: One of the named values associated with an object.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_388",
    "text": "instance: An object that belongs to a class.\ninstantiate: To create a new object.\nattribute: One of the named values associated with an object.\nembedded object: An object that is stored as an attribute of another object.\nshallow copy: To copy the contents of an object, including any references to embedded\nobjects; implemented by the copy function in the copy module.\ndeep copy: To copy the contents of an object as well as any embedded objects, and any\nobjects embedded in them, and so on; implemented by the deepcopy function in the\ncopy module.\nobject diagram: A diagram that shows objects, their attributes, and the values of the at-\ntributes.\n154\nChapter 15. Classes and objects\n15.9\nExercises\nExercise 15.1. Write a de\ufb01nition for a class named Circle with attributes center and radius,\nwhere center is a Point object and radius is a number.\nInstantiate a Circle object that represents a circle with its center at (150, 100) and radius 75.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_389",
    "text": "where center is a Point object and radius is a number.\nInstantiate a Circle object that represents a circle with its center at (150, 100) and radius 75.\nWrite a function named point_in_circle that takes a Circle and a Point and returns True if the\nPoint lies in or on the boundary of the circle.\nWrite a function named rect_in_circle that takes a Circle and a Rectangle and returns True if\nthe Rectangle lies entirely in or on the boundary of the circle.\nWrite a function named rect_circle_overlap that takes a Circle and a Rectangle and returns\nTrue if any of the corners of the Rectangle fall inside the Circle. Or as a more challenging version,\nreturn True if any part of the Rectangle falls inside the Circle.\nSolution: https: // thinkpython. com/ code/ Circle. py .\nExercise 15.2. Write a function called draw_rect that takes a Turtle object and a Rectangle and\nuses the Turtle to draw the Rectangle. See Chapter 4 for examples using Turtle objects.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_390",
    "text": "Exercise 15.2. Write a function called draw_rect that takes a Turtle object and a Rectangle and\nuses the Turtle to draw the Rectangle. See Chapter 4 for examples using Turtle objects.\nWrite a function called draw_circle that takes a Turtle and a Circle and draws the Circle.\nSolution: https: // thinkpython. com/ code/ draw. py .\nChapter 16\nClasses and functions\nNow that we know how to create new types, the next step is to write functions that take\nprogrammer-de\ufb01ned objects as parameters and return them as results. In this chapter I\nalso present \u201cfunctional programming style\u201d and two new program development plans.\nCode examples from this chapter are available from https://thinkpython.com/code/\nTime1.py. Solutions to the exercises are at https://thinkpython.com/code/Time1_soln.\npy.\n16.1\nTime\nAs another example of a programmer-de\ufb01ned type, we\u2019ll de\ufb01ne a class called Time that\nrecords the time of day. The class de\ufb01nition looks like this:\nclass Time:\n\"\"\"Represents the time of day.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_391",
    "text": "16.1\nTime\nAs another example of a programmer-de\ufb01ned type, we\u2019ll de\ufb01ne a class called Time that\nrecords the time of day. The class de\ufb01nition looks like this:\nclass Time:\n\"\"\"Represents the time of day.\nattributes: hour, minute, second\n\"\"\"\nWe can create a new Time object and assign attributes for hours, minutes, and seconds:\ntime = Time()\ntime.hour = 11\ntime.minute = 59\ntime.second = 30\nThe state diagram for the Time object looks like Figure 16.1.\nAs an exercise, write a function called print_time that takes a Time object and prints it in\nthe form hour:minute:second. Hint: the format sequence '%.2d' prints an integer using\nat least two digits, including a leading zero if necessary.\nWrite a boolean function called is_after that takes two Time objects, t1 and t2, and re-\nturns True if t1 follows t2 chronologically and False otherwise. Challenge: don\u2019t use an\nif statement.\n156\nChapter 16. Classes and functions\n59\n30\nhour\nminute\nsecond\n11\nTime\ntime\nFigure 16.1: Object diagram.\n16.2",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_392",
    "text": "if statement.\n156\nChapter 16. Classes and functions\n59\n30\nhour\nminute\nsecond\n11\nTime\ntime\nFigure 16.1: Object diagram.\n16.2\nPure functions\nIn the next few sections, we\u2019ll write two functions that add time values. They demonstrate\ntwo kinds of functions: pure functions and modi\ufb01ers. They also demonstrate a develop-\nment plan I\u2019ll call prototype and patch, which is a way of tackling a complex problem by\nstarting with a simple prototype and incrementally dealing with the complications.\nHere is a simple prototype of add_time:\ndef add_time(t1, t2):\nsum = Time()\nsum.hour = t1.hour + t2.hour\nsum.minute = t1.minute + t2.minute\nsum.second = t1.second + t2.second\nreturn sum\nThe function creates a new Time object, initializes its attributes, and returns a reference to\nthe new object. This is called a pure function because it does not modify any of the objects\npassed to it as arguments and it has no effect, like displaying a value or getting user input,\nother than returning a value.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_393",
    "text": "passed to it as arguments and it has no effect, like displaying a value or getting user input,\nother than returning a value.\nTo test this function, I\u2019ll create two Time objects: start contains the start time of a movie,\nlike Monty Python and the Holy Grail, and duration contains the run time of the movie,\nwhich is one hour 35 minutes.\nadd_time \ufb01gures out when the movie will be done.\n>>> start = Time()\n>>> start.hour = 9\n>>> start.minute = 45\n>>> start.second =\n0\n>>> duration = Time()\n>>> duration.hour = 1\n>>> duration.minute = 35\n>>> duration.second = 0\n>>> done = add_time(start, duration)\n>>> print_time(done)\n10:80:00\nThe result, 10:80:00 might not be what you were hoping for. The problem is that this\nfunction does not deal with cases where the number of seconds or minutes adds up to\nmore than sixty. When that happens, we have to \u201ccarry\u201d the extra seconds into the minute\ncolumn or the extra minutes into the hour column.\nHere\u2019s an improved version:\n16.3. Modi\ufb01ers\n157",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_394",
    "text": "more than sixty. When that happens, we have to \u201ccarry\u201d the extra seconds into the minute\ncolumn or the extra minutes into the hour column.\nHere\u2019s an improved version:\n16.3. Modi\ufb01ers\n157\ndef add_time(t1, t2):\nsum = Time()\nsum.hour = t1.hour + t2.hour\nsum.minute = t1.minute + t2.minute\nsum.second = t1.second + t2.second\nif sum.second >= 60:\nsum.second -= 60\nsum.minute += 1\nif sum.minute >= 60:\nsum.minute -= 60\nsum.hour += 1\nreturn sum\nAlthough this function is correct, it is starting to get big. We will see a shorter alternative\nlater.\n16.3\nModi\ufb01ers\nSometimes it is useful for a function to modify the objects it gets as parameters. In that case,\nthe changes are visible to the caller. Functions that work this way are called modi\ufb01ers.\nincrement, which adds a given number of seconds to a Time object, can be written naturally\nas a modi\ufb01er. Here is a rough draft:\ndef increment(time, seconds):\ntime.second += seconds\nif time.second >= 60:\ntime.second -= 60\ntime.minute += 1\nif time.minute >= 60:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_395",
    "text": "as a modi\ufb01er. Here is a rough draft:\ndef increment(time, seconds):\ntime.second += seconds\nif time.second >= 60:\ntime.second -= 60\ntime.minute += 1\nif time.minute >= 60:\ntime.minute -= 60\ntime.hour += 1\nThe \ufb01rst line performs the basic operation; the remainder deals with the special cases we\nsaw before.\nIs this function correct? What happens if seconds is much greater than sixty?\nIn that case, it is not enough to carry once; we have to keep doing it until time.second is\nless than sixty. One solution is to replace the if statements with while statements. That\nwould make the function correct, but not very ef\ufb01cient. As an exercise, write a correct\nversion of increment that doesn\u2019t contain any loops.\nAnything that can be done with modi\ufb01ers can also be done with pure functions. In fact,\nsome programming languages only allow pure functions. There is some evidence that\nprograms that use pure functions are faster to develop and less error-prone than programs",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_396",
    "text": "some programming languages only allow pure functions. There is some evidence that\nprograms that use pure functions are faster to develop and less error-prone than programs\nthat use modi\ufb01ers. But modi\ufb01ers are convenient at times, and functional programs tend to\nbe less ef\ufb01cient.\n158\nChapter 16. Classes and functions\nIn general, I recommend that you write pure functions whenever it is reasonable and resort\nto modi\ufb01ers only if there is a compelling advantage. This approach might be called a\nfunctional programming style.\nAs an exercise, write a \u201cpure\u201d version of increment that creates and returns a new Time\nobject rather than modifying the parameter.\n16.4\nPrototyping versus planning\nThe development plan I am demonstrating is called \u201cprototype and patch\u201d. For each func-\ntion, I wrote a prototype that performed the basic calculation and then tested it, patching\nerrors along the way.\nThis approach can be effective, especially if you don\u2019t yet have a deep understanding\nof the problem.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_397",
    "text": "errors along the way.\nThis approach can be effective, especially if you don\u2019t yet have a deep understanding\nof the problem.\nBut incremental corrections can generate code that is unnecessarily\ncomplicated\u2014since it deals with many special cases\u2014and unreliable\u2014since it is hard to\nknow if you have found all the errors.\nAn alternative is designed development, in which high-level insight into the problem can\nmake the programming much easier. In this case, the insight is that a Time object is really\na three-digit number in base 60 (see http://en.wikipedia.org/wiki/Sexagesimal). The\nsecond attribute is the \u201cones column\u201d, the minute attribute is the \u201csixties column\u201d, and the\nhour attribute is the \u201cthirty-six hundreds column\u201d.\nWhen we wrote add_time and increment, we were effectively doing addition in base 60,\nwhich is why we had to carry from one column to the next.\nThis observation suggests another approach to the whole problem\u2014we can convert Time",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_398",
    "text": "which is why we had to carry from one column to the next.\nThis observation suggests another approach to the whole problem\u2014we can convert Time\nobjects to integers and take advantage of the fact that the computer knows how to do\ninteger arithmetic.\nHere is a function that converts Times to integers:\ndef time_to_int(time):\nminutes = time.hour * 60 + time.minute\nseconds = minutes * 60 + time.second\nreturn seconds\nAnd here is a function that converts an integer to a Time (recall that divmod divides the \ufb01rst\nargument by the second and returns the quotient and remainder as a tuple).\ndef int_to_time(seconds):\ntime = Time()\nminutes, time.second = divmod(seconds, 60)\ntime.hour, time.minute = divmod(minutes, 60)\nreturn time\nYou might have to think a bit, and run some tests, to convince yourself that these functions\nare correct. One way to test them is to check that time_to_int(int_to_time(x)) == x for\nmany values of x. This is an example of a consistency check.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_399",
    "text": "are correct. One way to test them is to check that time_to_int(int_to_time(x)) == x for\nmany values of x. This is an example of a consistency check.\nOnce you are convinced they are correct, you can use them to rewrite add_time:\ndef add_time(t1, t2):\nseconds = time_to_int(t1) + time_to_int(t2)\nreturn int_to_time(seconds)\n16.5. Debugging\n159\nThis version is shorter than the original, and easier to verify.\nAs an exercise, rewrite\nincrement using time_to_int and int_to_time.\nIn some ways, converting from base 60 to base 10 and back is harder than just dealing with\ntimes. Base conversion is more abstract; our intuition for dealing with time values is better.\nBut if we have the insight to treat times as base 60 numbers and make the investment of\nwriting the conversion functions (time_to_int and int_to_time), we get a program that\nis shorter, easier to read and debug, and more reliable.\nIt is also easier to add features later. For example, imagine subtracting two Times to \ufb01nd",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_400",
    "text": "is shorter, easier to read and debug, and more reliable.\nIt is also easier to add features later. For example, imagine subtracting two Times to \ufb01nd\nthe duration between them. The naive approach would be to implement subtraction with\nborrowing. Using the conversion functions would be easier and more likely to be correct.\nIronically, sometimes making a problem harder (or more general) makes it easier (because\nthere are fewer special cases and fewer opportunities for error).\n16.5\nDebugging\nA Time object is well-formed if the values of minute and second are between 0 and 60\n(including 0 but not 60) and if hour is positive. hour and minute should be integer values,\nbut we might allow second to have a fraction part.\nRequirements like these are called invariants because they should always be true. To put\nit a different way, if they are not true, something has gone wrong.\nWriting code to check invariants can help detect errors and \ufb01nd their causes. For example,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_401",
    "text": "it a different way, if they are not true, something has gone wrong.\nWriting code to check invariants can help detect errors and \ufb01nd their causes. For example,\nyou might have a function like valid_time that takes a Time object and returns False if it\nviolates an invariant:\ndef valid_time(time):\nif time.hour < 0 or time.minute < 0 or time.second < 0:\nreturn False\nif time.minute >= 60 or time.second >= 60:\nreturn False\nreturn True\nAt the beginning of each function you could check the arguments to make sure they are\nvalid:\ndef add_time(t1, t2):\nif not valid_time(t1) or not valid_time(t2):\nraise ValueError('invalid Time object in add_time')\nseconds = time_to_int(t1) + time_to_int(t2)\nreturn int_to_time(seconds)\nOr you could use an assert statement, which checks a given invariant and raises an excep-\ntion if it fails:\ndef add_time(t1, t2):\nassert valid_time(t1) and valid_time(t2)\nseconds = time_to_int(t1) + time_to_int(t2)\nreturn int_to_time(seconds)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_402",
    "text": "tion if it fails:\ndef add_time(t1, t2):\nassert valid_time(t1) and valid_time(t2)\nseconds = time_to_int(t1) + time_to_int(t2)\nreturn int_to_time(seconds)\nassert statements are useful because they distinguish code that deals with normal condi-\ntions from code that checks for errors.\n160\nChapter 16. Classes and functions\n16.6\nGlossary\nprototype and patch: A development plan that involves writing a rough draft of a pro-\ngram, testing, and correcting errors as they are found.\ndesigned development: A development plan that involves high-level insight into the\nproblem and more planning than incremental development or prototype develop-\nment.\npure function: A function that does not modify any of the objects it receives as arguments.\nMost pure functions are fruitful.\nmodi\ufb01er: A function that changes one or more of the objects it receives as arguments. Most\nmodi\ufb01ers are void; that is, they return None.\nfunctional programming style: A style of program design in which the majority of func-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_403",
    "text": "modi\ufb01ers are void; that is, they return None.\nfunctional programming style: A style of program design in which the majority of func-\ntions are pure.\ninvariant: A condition that should always be true during the execution of a program.\nassert statement: A statement that checks a condition and raises an exception if it fails.\n16.7\nExercises\nCode examples from this chapter are available from https://thinkpython.com/code/\nTime1.py; solutions to the exercises are available from https://thinkpython.com/code/\nTime1_soln.py.\nExercise 16.1. Write a function called mul_time that takes a Time object and a number and returns\na new Time object that contains the product of the original Time and the number.\nThen use mul_time to write a function that takes a Time object that represents the \ufb01nishing time\nin a race, and a number that represents the distance, and returns a Time object that represents the\naverage pace (time per mile).",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_404",
    "text": "in a race, and a number that represents the distance, and returns a Time object that represents the\naverage pace (time per mile).\nExercise 16.2. The datetime module provides time objects that are similar to the Time objects\nin this chapter, but they provide a rich set of methods and operators. Read the documentation at\nhttp: // docs. python. org/ 3/ library/ datetime. html .\n1. Use the datetime module to write a program that gets the current date and prints the day of\nthe week.\n2. Write a program that takes a birthday as input and prints the user\u2019s age and the number of\ndays, hours, minutes and seconds until their next birthday.\n3. For two people born on different days, there is a day when one is twice as old as the other.\nThat\u2019s their Double Day. Write a program that takes two birth dates and computes their\nDouble Day.\n4. For a little more challenge, write the more general version that computes the day when one\nperson is n times older than the other.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_405",
    "text": "Double Day.\n4. For a little more challenge, write the more general version that computes the day when one\nperson is n times older than the other.\nSolution: https: // thinkpython. com/ code/ double. py\nChapter 17\nClasses and methods\nAlthough we are using some of Python\u2019s object-oriented features, the programs from the\nlast two chapters are not really object-oriented because they don\u2019t represent the relation-\nships between programmer-de\ufb01ned types and the functions that operate on them. The next\nstep is to transform those functions into methods that make the relationships explicit.\nCode examples from this chapter are available from https://thinkpython.com/code/\nTime2.py, and solutions to the exercises are in https://thinkpython.com/code/Point2_\nsoln.py.\n17.1\nObject-oriented features\nPython is an object-oriented programming language, which means that it provides fea-\ntures that support object-oriented programming, which has these de\ufb01ning characteristics:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_406",
    "text": "Object-oriented features\nPython is an object-oriented programming language, which means that it provides fea-\ntures that support object-oriented programming, which has these de\ufb01ning characteristics:\n\u2022 Programs include class and method de\ufb01nitions.\n\u2022 Most of the computation is expressed in terms of operations on objects.\n\u2022 Objects often represent things in the real world, and methods often correspond to the\nways things in the real world interact.\nFor example, the Time class de\ufb01ned in Chapter 16 corresponds to the way people record\nthe time of day, and the functions we de\ufb01ned correspond to the kinds of things people do\nwith times. Similarly, the Point and Rectangle classes in Chapter 15 correspond to the\nmathematical concepts of a point and a rectangle.\nSo far, we have not taken advantage of the features Python provides to support object-\noriented programming. These features are not strictly necessary; most of them provide",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_407",
    "text": "So far, we have not taken advantage of the features Python provides to support object-\noriented programming. These features are not strictly necessary; most of them provide\nalternative syntax for things we have already done. But in many cases, the alternative is\nmore concise and more accurately conveys the structure of the program.\nFor example, in Time1.py there is no obvious connection between the class de\ufb01nition and\nthe function de\ufb01nitions that follow. With some examination, it is apparent that every func-\ntion takes at least one Time object as an argument.\n162\nChapter 17. Classes and methods\nThis observation is the motivation for methods; a method is a function that is associated\nwith a particular class. We have seen methods for strings, lists, dictionaries and tuples. In\nthis chapter, we will de\ufb01ne methods for programmer-de\ufb01ned types.\nMethods are semantically the same as functions, but there are two syntactic differences:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_408",
    "text": "this chapter, we will de\ufb01ne methods for programmer-de\ufb01ned types.\nMethods are semantically the same as functions, but there are two syntactic differences:\n\u2022 Methods are de\ufb01ned inside a class de\ufb01nition in order to make the relationship be-\ntween the class and the method explicit.\n\u2022 The syntax for invoking a method is different from the syntax for calling a function.\nIn the next few sections, we will take the functions from the previous two chapters and\ntransform them into methods. This transformation is purely mechanical; you can do it by\nfollowing a sequence of steps. If you are comfortable converting from one form to another,\nyou will be able to choose the best form for whatever you are doing.\n17.2\nPrinting objects\nIn Chapter 16, we de\ufb01ned a class named Time and in Section 16.1, you wrote a function\nnamed print_time:\nclass Time:\n\"\"\"Represents the time of day.\"\"\"\ndef print_time(time):\nprint('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_409",
    "text": "named print_time:\nclass Time:\n\"\"\"Represents the time of day.\"\"\"\ndef print_time(time):\nprint('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))\nTo call this function, you have to pass a Time object as an argument:\n>>> start = Time()\n>>> start.hour = 9\n>>> start.minute = 45\n>>> start.second = 00\n>>> print_time(start)\n09:45:00\nTo make print_time a method, all we have to do is move the function de\ufb01nition inside the\nclass de\ufb01nition. Notice the change in indentation.\nclass Time:\ndef print_time(time):\nprint('%.2d:%.2d:%.2d' % (time.hour, time.minute, time.second))\nNow there are two ways to call print_time. The \ufb01rst (and less common) way is to use\nfunction syntax:\n>>> Time.print_time(start)\n09:45:00\nIn this use of dot notation, Time is the name of the class, and print_time is the name of the\nmethod. start is passed as a parameter.\nThe second (and more concise) way is to use method syntax:\n>>> start.print_time()\n09:45:00\n17.3. Another example\n163",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_410",
    "text": "method. start is passed as a parameter.\nThe second (and more concise) way is to use method syntax:\n>>> start.print_time()\n09:45:00\n17.3. Another example\n163\nIn this use of dot notation, print_time is the name of the method (again), and start is\nthe object the method is invoked on, which is called the subject. Just as the subject of\na sentence is what the sentence is about, the subject of a method invocation is what the\nmethod is about.\nInside the method, the subject is assigned to the \ufb01rst parameter, so in this case start is\nassigned to time.\nBy convention, the \ufb01rst parameter of a method is called self, so it would be more common\nto write print_time like this:\nclass Time:\ndef print_time(self):\nprint('%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second))\nThe reason for this convention is an implicit metaphor:\n\u2022 The syntax for a function call, print_time(start), suggests that the function is the\nactive agent. It says something like, \u201cHey print_time! Here\u2019s an object for you to\nprint.\u201d",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_411",
    "text": "\u2022 The syntax for a function call, print_time(start), suggests that the function is the\nactive agent. It says something like, \u201cHey print_time! Here\u2019s an object for you to\nprint.\u201d\n\u2022 In object-oriented programming, the objects are the active agents. A method invoca-\ntion like start.print_time() says \u201cHey start! Please print yourself.\u201d\nThis change in perspective might be more polite, but it is not obvious that it is useful. In the\nexamples we have seen so far, it may not be. But sometimes shifting responsibility from the\nfunctions onto the objects makes it possible to write more versatile functions (or methods),\nand makes it easier to maintain and reuse code.\nAs an exercise, rewrite time_to_int (from Section 16.4) as a method. You might be tempted\nto rewrite int_to_time as a method, too, but that doesn\u2019t really make sense because there\nwould be no object to invoke it on.\n17.3\nAnother example\nHere\u2019s a version of increment (from Section 16.3) rewritten as a method:\n# inside class Time:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_412",
    "text": "would be no object to invoke it on.\n17.3\nAnother example\nHere\u2019s a version of increment (from Section 16.3) rewritten as a method:\n# inside class Time:\ndef increment(self, seconds):\nseconds += self.time_to_int()\nreturn int_to_time(seconds)\nThis version assumes that time_to_int is written as a method. Also, note that it is a pure\nfunction, not a modi\ufb01er.\nHere\u2019s how you would invoke increment:\n>>> start.print_time()\n09:45:00\n>>> end = start.increment(1337)\n>>> end.print_time()\n10:07:17\n164\nChapter 17. Classes and methods\nThe subject, start, gets assigned to the \ufb01rst parameter, self. The argument, 1337, gets\nassigned to the second parameter, seconds.\nThis mechanism can be confusing, especially if you make an error. For example, if you\ninvoke increment with two arguments, you get:\n>>> end = start.increment(1337, 460)\nTypeError: increment() takes 2 positional arguments but 3 were given\nThe error message is initially confusing, because there are only two arguments in paren-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_413",
    "text": ">>> end = start.increment(1337, 460)\nTypeError: increment() takes 2 positional arguments but 3 were given\nThe error message is initially confusing, because there are only two arguments in paren-\ntheses. But the subject is also considered an argument, so all together that\u2019s three.\nBy the way, a positional argument is an argument that doesn\u2019t have a parameter name;\nthat is, it is not a keyword argument. In this function call:\nsketch(parrot, cage, dead=True)\nparrot and cage are positional, and dead is a keyword argument.\n17.4\nA more complicated example\nRewriting is_after (from Section 16.1) is slightly more complicated because it takes two\nTime objects as parameters. In this case it is conventional to name the \ufb01rst parameter self\nand the second parameter other:\n# inside class Time:\ndef is_after(self, other):\nreturn self.time_to_int() > other.time_to_int()\nTo use this method, you have to invoke it on one object and pass the other as an argument:\n>>> end.is_after(start)\nTrue",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_414",
    "text": "def is_after(self, other):\nreturn self.time_to_int() > other.time_to_int()\nTo use this method, you have to invoke it on one object and pass the other as an argument:\n>>> end.is_after(start)\nTrue\nOne nice thing about this syntax is that it almost reads like English: \u201cend is after start?\u201d\n17.5\nThe init method\nThe init method (short for \u201cinitialization\u201d) is a special method that gets invoked when an\nobject is instantiated. Its full name is __init__ (two underscore characters, followed by\ninit, and then two more underscores). An init method for the Time class might look like\nthis:\n# inside class Time:\ndef __init__(self, hour=0, minute=0, second=0):\nself.hour = hour\nself.minute = minute\nself.second = second\nIt is common for the parameters of __init__ to have the same names as the attributes. The\nstatement\nself.hour = hour\n17.6. The __str__ method\n165\nstores the value of the parameter hour as an attribute of self.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_415",
    "text": "statement\nself.hour = hour\n17.6. The __str__ method\n165\nstores the value of the parameter hour as an attribute of self.\nThe parameters are optional, so if you call Time with no arguments, you get the default\nvalues.\n>>> time = Time()\n>>> time.print_time()\n00:00:00\nIf you provide one argument, it overrides hour:\n>>> time = Time (9)\n>>> time.print_time()\n09:00:00\nIf you provide two arguments, they override hour and minute.\n>>> time = Time(9, 45)\n>>> time.print_time()\n09:45:00\nAnd if you provide three arguments, they override all three default values.\nAs an exercise, write an init method for the Point class that takes x and y as optional\nparameters and assigns them to the corresponding attributes.\n17.6\nThe __str__ method\n__str__ is a special method, like __init__, that is supposed to return a string representa-\ntion of an object.\nFor example, here is a str method for Time objects:\n# inside class Time:\ndef __str__(self):\nreturn '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_416",
    "text": "tion of an object.\nFor example, here is a str method for Time objects:\n# inside class Time:\ndef __str__(self):\nreturn '%.2d:%.2d:%.2d' % (self.hour, self.minute, self.second)\nWhen you print an object, Python invokes the str method:\n>>> time = Time(9, 45)\n>>> print(time)\n09:45:00\nWhen I write a new class, I almost always start by writing __init__, which makes it easier\nto instantiate objects, and __str__, which is useful for debugging.\nAs an exercise, write a str method for the Point class. Create a Point object and print it.\n17.7\nOperator overloading\nBy de\ufb01ning other special methods, you can specify the behavior of operators on\nprogrammer-de\ufb01ned types. For example, if you de\ufb01ne a method named __add__ for the\nTime class, you can use the + operator on Time objects.\nHere is what the de\ufb01nition might look like:\n166\nChapter 17. Classes and methods\n# inside class Time:\ndef __add__(self, other):\nseconds = self.time_to_int() + other.time_to_int()\nreturn int_to_time(seconds)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_417",
    "text": "166\nChapter 17. Classes and methods\n# inside class Time:\ndef __add__(self, other):\nseconds = self.time_to_int() + other.time_to_int()\nreturn int_to_time(seconds)\nAnd here is how you could use it:\n>>> start = Time(9, 45)\n>>> duration = Time(1, 35)\n>>> print(start + duration)\n11:20:00\nWhen you apply the + operator to Time objects, Python invokes __add__. When you print\nthe result, Python invokes __str__. So there is a lot happening behind the scenes!\nChanging the behavior of an operator so that it works with programmer-de\ufb01ned types is\ncalled operator overloading. For every operator in Python there is a corresponding spe-\ncial method, like __add__. For more details, see http://docs.python.org/3/reference/\ndatamodel.html#specialnames.\nAs an exercise, write an add method for the Point class.\n17.8\nType-based dispatch\nIn the previous section we added two Time objects, but you also might want to add an\ninteger to a Time object. The following is a version of __add__ that checks the type of",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_418",
    "text": "17.8\nType-based dispatch\nIn the previous section we added two Time objects, but you also might want to add an\ninteger to a Time object. The following is a version of __add__ that checks the type of\nother and invokes either add_time or increment:\n# inside class Time:\ndef __add__(self, other):\nif isinstance(other, Time):\nreturn self.add_time(other)\nelse:\nreturn self.increment(other)\ndef add_time(self, other):\nseconds = self.time_to_int() + other.time_to_int()\nreturn int_to_time(seconds)\ndef increment(self, seconds):\nseconds += self.time_to_int()\nreturn int_to_time(seconds)\nThe built-in function isinstance takes a value and a class object, and returns True if the\nvalue is an instance of the class.\nIf other is a Time object, __add__ invokes add_time. Otherwise it assumes that the param-\neter is a number and invokes increment. This operation is called a type-based dispatch\nbecause it dispatches the computation to different methods based on the type of the argu-\nments.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_419",
    "text": "eter is a number and invokes increment. This operation is called a type-based dispatch\nbecause it dispatches the computation to different methods based on the type of the argu-\nments.\nHere are examples that use the + operator with different types:\n17.9. Polymorphism\n167\n>>> start = Time(9, 45)\n>>> duration = Time(1, 35)\n>>> print(start + duration)\n11:20:00\n>>> print(start + 1337)\n10:07:17\nUnfortunately, this implementation of addition is not commutative. If the integer is the\n\ufb01rst operand, you get\n>>> print(1337 + start)\nTypeError: unsupported operand type(s) for +: 'int' and 'instance'\nThe problem is, instead of asking the Time object to add an integer, Python is asking an\ninteger to add a Time object, and it doesn\u2019t know how. But there is a clever solution for this\nproblem: the special method __radd__, which stands for \u201cright-side add\u201d. This method\nis invoked when a Time object appears on the right side of the + operator. Here\u2019s the\nde\ufb01nition:\n# inside class Time:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_420",
    "text": "is invoked when a Time object appears on the right side of the + operator. Here\u2019s the\nde\ufb01nition:\n# inside class Time:\ndef __radd__(self, other):\nreturn self.__add__(other)\nAnd here\u2019s how it\u2019s used:\n>>> print(1337 + start)\n10:07:17\nAs an exercise, write an add method for Points that works with either a Point object or a\ntuple:\n\u2022 If the second operand is a Point, the method should return a new Point whose x\ncoordinate is the sum of the x coordinates of the operands, and likewise for the y\ncoordinates.\n\u2022 If the second operand is a tuple, the method should add the \ufb01rst element of the tuple\nto the x coordinate and the second element to the y coordinate, and return a new\nPoint with the result.\n17.9\nPolymorphism\nType-based dispatch is useful when it is necessary, but (fortunately) it is not always neces-\nsary. Often you can avoid it by writing functions that work correctly for arguments with\ndifferent types.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_421",
    "text": "Type-based dispatch is useful when it is necessary, but (fortunately) it is not always neces-\nsary. Often you can avoid it by writing functions that work correctly for arguments with\ndifferent types.\nMany of the functions we wrote for strings also work for other sequence types. For exam-\nple, in Section 11.2 we used histogram to count the number of times each letter appears in\na word.\ndef histogram(s):\nd = dict()\nfor c in s:\nif c not in d:\nd[c] = 1\n168\nChapter 17. Classes and methods\nelse:\nd[c] = d[c]+1\nreturn d\nThis function also works for lists, tuples, and even dictionaries, as long as the elements of\ns are hashable, so they can be used as keys in d.\n>>> t = ['spam', 'egg', 'spam', 'spam', 'bacon', 'spam']\n>>> histogram(t)\n{'bacon': 1, 'egg': 1, 'spam': 4}\nFunctions that work with several types are called polymorphic. Polymorphism can fa-\ncilitate code reuse. For example, the built-in function sum, which adds the elements of a",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_422",
    "text": "Functions that work with several types are called polymorphic. Polymorphism can fa-\ncilitate code reuse. For example, the built-in function sum, which adds the elements of a\nsequence, works as long as the elements of the sequence support addition.\nSince Time objects provide an add method, they work with sum:\n>>> t1 = Time(7, 43)\n>>> t2 = Time(7, 41)\n>>> t3 = Time(7, 37)\n>>> total = sum([t1, t2, t3])\n>>> print(total)\n23:01:00\nIn general, if all of the operations inside a function work with a given type, the function\nworks with that type.\nThe best kind of polymorphism is the unintentional kind, where you discover that a func-\ntion you already wrote can be applied to a type you never planned for.\n17.10\nDebugging\nIt is legal to add attributes to objects at any point in the execution of a program, but if\nyou have objects with the same type that don\u2019t have the same attributes, it is easy to make\nmistakes. It is considered a good idea to initialize all of an object\u2019s attributes in the init",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_423",
    "text": "you have objects with the same type that don\u2019t have the same attributes, it is easy to make\nmistakes. It is considered a good idea to initialize all of an object\u2019s attributes in the init\nmethod.\nIf you are not sure whether an object has a particular attribute, you can use the built-in\nfunction hasattr (see Section 15.7).\nAnother way to access attributes is the built-in function vars, which takes an object and\nreturns a dictionary that maps from attribute names (as strings) to their values:\n>>> p = Point(3, 4)\n>>> vars(p)\n{'y': 4, 'x': 3}\nFor purposes of debugging, you might \ufb01nd it useful to keep this function handy:\ndef print_attributes(obj):\nfor attr in vars(obj):\nprint(attr, getattr(obj, attr))\nprint_attributes traverses the dictionary and prints each attribute name and its corre-\nsponding value.\nThe built-in function getattr takes an object and an attribute name (as a string) and returns\nthe attribute\u2019s value.\n17.11. Interface and implementation\n169\n17.11",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_424",
    "text": "sponding value.\nThe built-in function getattr takes an object and an attribute name (as a string) and returns\nthe attribute\u2019s value.\n17.11. Interface and implementation\n169\n17.11\nInterface and implementation\nOne of the goals of object-oriented design is to make software more maintainable, which\nmeans that you can keep the program working when other parts of the system change, and\nmodify the program to meet new requirements.\nA design principle that helps achieve that goal is to keep interfaces separate from imple-\nmentations. For objects, that means that the methods a class provides should not depend\non how the attributes are represented.\nFor example, in this chapter we developed a class that represents a time of day. Methods\nprovided by this class include time_to_int, is_after, and add_time.\nWe could implement those methods in several ways. The details of the implementation\ndepend on how we represent time. In this chapter, the attributes of a Time object are hour,\nminute, and second.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_425",
    "text": "We could implement those methods in several ways. The details of the implementation\ndepend on how we represent time. In this chapter, the attributes of a Time object are hour,\nminute, and second.\nAs an alternative, we could replace these attributes with a single integer representing the\nnumber of seconds since midnight. This implementation would make some methods, like\nis_after, easier to write, but it makes other methods harder.\nAfter you deploy a new class, you might discover a better implementation. If other parts\nof the program are using your class, it might be time-consuming and error-prone to change\nthe interface.\nBut if you designed the interface carefully, you can change the implementation without\nchanging the interface, which means that other parts of the program don\u2019t have to change.\n17.12\nGlossary\nobject-oriented language: A language that provides features, such as programmer-\nde\ufb01ned types and methods, that facilitate object-oriented programming.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_426",
    "text": "17.12\nGlossary\nobject-oriented language: A language that provides features, such as programmer-\nde\ufb01ned types and methods, that facilitate object-oriented programming.\nobject-oriented programming: A style of programming in which data and the operations\nthat manipulate it are organized into classes and methods.\nmethod: A function that is de\ufb01ned inside a class de\ufb01nition and is invoked on instances of\nthat class.\nsubject: The object a method is invoked on.\npositional argument: An argument that does not include a parameter name, so it is not a\nkeyword argument.\noperator overloading: Changing the behavior of an operator like + so it works with a\nprogrammer-de\ufb01ned type.\ntype-based dispatch: A programming pattern that checks the type of an operand and in-\nvokes different functions for different types.\npolymorphic: Pertaining to a function that can work with more than one type.\n170\nChapter 17. Classes and methods\n17.13\nExercises",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_427",
    "text": "vokes different functions for different types.\npolymorphic: Pertaining to a function that can work with more than one type.\n170\nChapter 17. Classes and methods\n17.13\nExercises\nExercise 17.1. Download the code from this chapter from https: // thinkpython. com/ code/\nTime2. py . Change the attributes of Time to be a single integer representing seconds since mid-\nnight. Then modify the methods (and the function int_to_time) to work with the new implemen-\ntation. You should not have to modify the test code in main. When you are done, the output should\nbe the same as before. Solution: https: // thinkpython. com/ code/ Time2_ soln. py .\nExercise 17.2. This exercise is a cautionary tale about one of the most common, and dif\ufb01cult to\n\ufb01nd, errors in Python. Write a de\ufb01nition for a class named Kangaroo with the following methods:\n1. An __init__ method that initializes an attribute named pouch_contents to an empty list.\n2. A method named put_in_pouch that takes an object of any type and adds it to",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_428",
    "text": "1. An __init__ method that initializes an attribute named pouch_contents to an empty list.\n2. A method named put_in_pouch that takes an object of any type and adds it to\npouch_contents.\n3. A __str__ method that returns a string representation of the Kangaroo object and the con-\ntents of the pouch.\nTest your code by creating two Kangaroo objects, assigning them to variables named kanga and\nroo, and then adding roo to the contents of kanga\u2019s pouch.\nDownload https: // thinkpython. com/ code/ BadKangaroo. py . It contains a solution to the\nprevious problem with one big, nasty bug. Find and \ufb01x the bug.\nIf you get stuck, you can download https: // thinkpython. com/ code/ GoodKangaroo. py ,\nwhich explains the problem and demonstrates a solution.\nChapter 18\nInheritance\nThe language feature most often associated with object-oriented programming is inheri-\ntance. Inheritance is the ability to de\ufb01ne a new class that is a modi\ufb01ed version of an ex-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_429",
    "text": "Chapter 18\nInheritance\nThe language feature most often associated with object-oriented programming is inheri-\ntance. Inheritance is the ability to de\ufb01ne a new class that is a modi\ufb01ed version of an ex-\nisting class. In this chapter I demonstrate inheritance using classes that represent playing\ncards, decks of cards, and poker hands.\nIf you don\u2019t play poker, you can read about it at http://en.wikipedia.org/wiki/Poker,\nbut you don\u2019t have to; I\u2019ll tell you what you need to know for the exercises.\nCode examples from this chapter are available from https://thinkpython.com/code/\nCard.py.\n18.1\nCard objects\nThere are \ufb01fty-two cards in a deck, each of which belongs to one of four suits and one of\nthirteen ranks. The suits are Spades, Hearts, Diamonds, and Clubs (in descending order in\nbridge). The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King. Depending on\nthe game that you are playing, an Ace may be higher than King or lower than 2.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_430",
    "text": "bridge). The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King. Depending on\nthe game that you are playing, an Ace may be higher than King or lower than 2.\nIf we want to de\ufb01ne a new object to represent a playing card, it is obvious what the at-\ntributes should be: rank and suit. It is not as obvious what type the attributes should be.\nOne possibility is to use strings containing words like 'Spade' for suits and 'Queen' for\nranks. One problem with this implementation is that it would not be easy to compare cards\nto see which had a higher rank or suit.\nAn alternative is to use integers to encode the ranks and suits. In this context, \u201cencode\u201d\nmeans that we are going to de\ufb01ne a mapping between numbers and suits, or between\nnumbers and ranks. This kind of encoding is not meant to be a secret (that would be\n\u201cencryption\u201d).\nFor example, this table shows the suits and the corresponding integer codes:\nSpades\n7\u2192\n3\nHearts\n7\u2192\n2\nDiamonds\n7\u2192\n1\nClubs\n7\u2192\n0\n172\nChapter 18. Inheritance",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_431",
    "text": "\u201cencryption\u201d).\nFor example, this table shows the suits and the corresponding integer codes:\nSpades\n7\u2192\n3\nHearts\n7\u2192\n2\nDiamonds\n7\u2192\n1\nClubs\n7\u2192\n0\n172\nChapter 18. Inheritance\nThis code makes it easy to compare cards; because higher suits map to higher numbers, we\ncan compare suits by comparing their codes.\nThe mapping for ranks is fairly obvious; each of the numerical ranks maps to the corre-\nsponding integer, and for face cards:\nJack\n7\u2192\n11\nQueen\n7\u2192\n12\nKing\n7\u2192\n13\nI am using the 7\u2192symbol to make it clear that these mappings are not part of the Python\nprogram. They are part of the program design, but they don\u2019t appear explicitly in the code.\nThe class de\ufb01nition for Card looks like this:\nclass Card:\n\"\"\"Represents a standard playing card.\"\"\"\ndef __init__(self, suit=0, rank=2):\nself.suit = suit\nself.rank = rank\nAs usual, the init method takes an optional parameter for each attribute. The default card\nis the 2 of Clubs.\nTo create a Card, you call Card with the suit and rank of the card you want.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_432",
    "text": "As usual, the init method takes an optional parameter for each attribute. The default card\nis the 2 of Clubs.\nTo create a Card, you call Card with the suit and rank of the card you want.\nqueen_of_diamonds = Card(1, 12)\n18.2\nClass attributes\nIn order to print Card objects in a way that people can easily read, we need a mapping\nfrom the integer codes to the corresponding ranks and suits. A natural way to do that is\nwith lists of strings. We assign these lists to class attributes:\n# inside class Card:\nsuit_names = ['Clubs', 'Diamonds', 'Hearts', 'Spades']\nrank_names = [None, 'Ace', '2', '3', '4', '5', '6', '7',\n'8', '9', '10', 'Jack', 'Queen', 'King']\ndef __str__(self):\nreturn '%s of %s' % (Card.rank_names[self.rank],\nCard.suit_names[self.suit])\nVariables like suit_names and rank_names, which are de\ufb01ned inside a class but outside\nof any method, are called class attributes because they are associated with the class object\nCard.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_433",
    "text": "Variables like suit_names and rank_names, which are de\ufb01ned inside a class but outside\nof any method, are called class attributes because they are associated with the class object\nCard.\nThis term distinguishes them from variables like suit and rank, which are called instance\nattributes because they are associated with a particular instance.\nBoth kinds of attribute are accessed using dot notation. For example, in __str__, self\nis a Card object, and self.rank is its rank.\nSimilarly, Card is a class object, and\nCard.rank_names is a list of strings associated with the class.\n18.3. Comparing cards\n173\nlist\nsuit_names\nlist\nrank_names\nCard\ntype\n1\n11\nsuit\nrank\ncard1\nCard\nFigure 18.1: Object diagram.\nEvery card has its own suit and rank, but there is only one copy of suit_names and\nrank_names.\nPutting it all together, the expression Card.rank_names[self.rank] means \u201cuse the at-\ntribute rank from the object self as an index into the list rank_names from the class Card,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_434",
    "text": "rank_names.\nPutting it all together, the expression Card.rank_names[self.rank] means \u201cuse the at-\ntribute rank from the object self as an index into the list rank_names from the class Card,\nand select the appropriate string.\u201d\nThe \ufb01rst element of rank_names is None because there is no card with rank zero. By includ-\ning None as a place-keeper, we get a mapping with the nice property that the index 2 maps\nto the string '2', and so on. To avoid this tweak, we could have used a dictionary instead\nof a list.\nWith the methods we have so far, we can create and print cards:\n>>> card1 = Card(2, 11)\n>>> print(card1)\nJack of Hearts\nFigure 18.1 is a diagram of the Card class object and one Card instance. Card is a class\nobject; its type is type. card1 is an instance of Card, so its type is Card. To save space, I\ndidn\u2019t draw the contents of suit_names and rank_names.\n18.3\nComparing cards\nFor built-in types, there are relational operators (<, >, ==, etc.) that compare values and de-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_435",
    "text": "didn\u2019t draw the contents of suit_names and rank_names.\n18.3\nComparing cards\nFor built-in types, there are relational operators (<, >, ==, etc.) that compare values and de-\ntermine when one is greater than, less than, or equal to another. For programmer-de\ufb01ned\ntypes, we can override the behavior of the built-in operators by providing a method named\n__lt__, which stands for \u201cless than\u201d.\n__lt__ takes two parameters, self and other, and returns True if self is strictly less than\nother.\nThe correct ordering for cards is not obvious. For example, which is better, the 3 of Clubs\nor the 2 of Diamonds? One has a higher rank, but the other has a higher suit. In order to\ncompare cards, you have to decide whether rank or suit is more important.\nThe answer might depend on what game you are playing, but to keep things simple, we\u2019ll\nmake the arbitrary choice that suit is more important, so all of the Spades outrank all of the\nDiamonds, and so on.\n174\nChapter 18. Inheritance",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_436",
    "text": "make the arbitrary choice that suit is more important, so all of the Spades outrank all of the\nDiamonds, and so on.\n174\nChapter 18. Inheritance\nWith that decided, we can write __lt__:\n# inside class Card:\ndef __lt__(self, other):\n# check the suits\nif self.suit < other.suit: return True\nif self.suit > other.suit: return False\n# suits are the same... check ranks\nreturn self.rank < other.rank\nYou can write this more concisely using tuple comparison:\n# inside class Card:\ndef __lt__(self, other):\nt1 = self.suit, self.rank\nt2 = other.suit, other.rank\nreturn t1 < t2\nAs an exercise, write an __lt__ method for Time objects. You can use tuple comparison,\nbut you also might consider comparing integers.\n18.4\nDecks\nNow that we have Cards, the next step is to de\ufb01ne Decks. Since a deck is made up of cards,\nit is natural for each Deck to contain a list of cards as an attribute.\nThe following is a class de\ufb01nition for Deck. The init method creates the attribute cards and",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_437",
    "text": "it is natural for each Deck to contain a list of cards as an attribute.\nThe following is a class de\ufb01nition for Deck. The init method creates the attribute cards and\ngenerates the standard set of \ufb01fty-two cards:\nclass Deck:\ndef __init__(self):\nself.cards = []\nfor suit in range(4):\nfor rank in range(1, 14):\ncard = Card(suit, rank)\nself.cards.append(card)\nThe easiest way to populate the deck is with a nested loop. The outer loop enumerates the\nsuits from 0 to 3. The inner loop enumerates the ranks from 1 to 13. Each iteration creates\na new Card with the current suit and rank, and appends it to self.cards.\n18.5\nPrinting the deck\nHere is a __str__ method for Deck:\n# inside class Deck:\ndef __str__(self):\nres = []\n18.6. Add, remove, shuf\ufb02e and sort\n175\nfor card in self.cards:\nres.append(str(card))\nreturn '\\n'.join(res)\nThis method demonstrates an ef\ufb01cient way to accumulate a large string: building a list\nof strings and then using the string method join. The built-in function str invokes the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_438",
    "text": "return '\\n'.join(res)\nThis method demonstrates an ef\ufb01cient way to accumulate a large string: building a list\nof strings and then using the string method join. The built-in function str invokes the\n__str__ method on each card and returns the string representation.\nSince we invoke join on a newline character, the cards are separated by newlines. Here\u2019s\nwhat the result looks like:\n>>> deck = Deck()\n>>> print(deck)\nAce of Clubs\n2 of Clubs\n3 of Clubs\n...\n10 of Spades\nJack of Spades\nQueen of Spades\nKing of Spades\nEven though the result appears on 52 lines, it is one long string that contains newlines.\n18.6\nAdd, remove, shuf\ufb02e and sort\nTo deal cards, we would like a method that removes a card from the deck and returns it.\nThe list method pop provides a convenient way to do that:\n# inside class Deck:\ndef pop_card(self):\nreturn self.cards.pop()\nSince pop removes the last card in the list, we are dealing from the bottom of the deck.\nTo add a card, we can use the list method append:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_439",
    "text": "def pop_card(self):\nreturn self.cards.pop()\nSince pop removes the last card in the list, we are dealing from the bottom of the deck.\nTo add a card, we can use the list method append:\n# inside class Deck:\ndef add_card(self, card):\nself.cards.append(card)\nA method like this that uses another method without doing much work is sometimes called\na veneer. The metaphor comes from woodworking, where a veneer is a thin layer of good\nquality wood glued to the surface of a cheaper piece of wood to improve the appearance.\nIn this case add_card is a \u201cthin\u201d method that expresses a list operation in terms appropriate\nfor decks. It improves the appearance, or interface, of the implementation.\nAs another example, we can write a Deck method named shuffle using the function\nshuffle from the random module:\n# inside class Deck:\ndef shuffle(self):\nrandom.shuffle(self.cards)\n176\nChapter 18. Inheritance\nDon\u2019t forget to import random.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_440",
    "text": "shuffle from the random module:\n# inside class Deck:\ndef shuffle(self):\nrandom.shuffle(self.cards)\n176\nChapter 18. Inheritance\nDon\u2019t forget to import random.\nAs an exercise, write a Deck method named sort that uses the list method sort to sort the\ncards in a Deck. sort uses the __lt__ method we de\ufb01ned to determine the order.\n18.7\nInheritance\nInheritance is the ability to de\ufb01ne a new class that is a modi\ufb01ed version of an existing class.\nAs an example, let\u2019s say we want a class to represent a \u201chand\u201d, that is, the cards held by\none player. A hand is similar to a deck: both are made up of a collection of cards, and both\nrequire operations like adding and removing cards.\nA hand is also different from a deck; there are operations we want for hands that don\u2019t\nmake sense for a deck. For example, in poker we might compare two hands to see which\none wins. In bridge, we might compute a score for a hand in order to make a bid.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_441",
    "text": "make sense for a deck. For example, in poker we might compare two hands to see which\none wins. In bridge, we might compute a score for a hand in order to make a bid.\nThis relationship between classes\u2014similar, but different\u2014lends itself to inheritance. To\nde\ufb01ne a new class that inherits from an existing class, you put the name of the existing\nclass in parentheses:\nclass Hand(Deck):\n\"\"\"Represents a hand of playing cards.\"\"\"\nThis de\ufb01nition indicates that Hand inherits from Deck; that means we can use methods like\npop_card and add_card for Hands as well as Decks.\nWhen a new class inherits from an existing one, the existing one is called the parent and\nthe new class is called the child.\nIn this example, Hand inherits __init__ from Deck, but it doesn\u2019t really do what we want:\ninstead of populating the hand with 52 new cards, the init method for Hands should ini-\ntialize cards with an empty list.\nIf we provide an init method in the Hand class, it overrides the one in the Deck class:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_442",
    "text": "tialize cards with an empty list.\nIf we provide an init method in the Hand class, it overrides the one in the Deck class:\n# inside class Hand:\ndef __init__(self, label=''):\nself.cards = []\nself.label = label\nWhen you create a Hand, Python invokes this init method, not the one in Deck.\n>>> hand = Hand('new hand')\n>>> hand.cards\n[]\n>>> hand.label\n'new hand'\nThe other methods are inherited from Deck, so we can use pop_card and add_card to deal\na card:\n>>> deck = Deck()\n>>> card = deck.pop_card()\n>>> hand.add_card(card)\n>>> print(hand)\nKing of Spades\n18.8. Class diagrams\n177\nA natural next step is to encapsulate this code in a method called move_cards:\n# inside class Deck:\ndef move_cards(self, hand, num):\nfor i in range(num):\nhand.add_card(self.pop_card())\nmove_cards takes two arguments, a Hand object and the number of cards to deal. It modi-\n\ufb01es both self and hand, and returns None.\nIn some games, cards are moved from one hand to another, or from a hand back to the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_443",
    "text": "\ufb01es both self and hand, and returns None.\nIn some games, cards are moved from one hand to another, or from a hand back to the\ndeck. You can use move_cards for any of these operations: self can be either a Deck or a\nHand, and hand, despite the name, can also be a Deck.\nInheritance is a useful feature. Some programs that would be repetitive without inheritance\ncan be written more elegantly with it. Inheritance can facilitate code reuse, since you can\ncustomize the behavior of parent classes without having to modify them. In some cases,\nthe inheritance structure re\ufb02ects the natural structure of the problem, which makes the\ndesign easier to understand.\nOn the other hand, inheritance can make programs dif\ufb01cult to read. When a method is\ninvoked, it is sometimes not clear where to \ufb01nd its de\ufb01nition. The relevant code may be\nspread across several modules. Also, many of the things that can be done using inheritance\ncan be done as well or better without it.\n18.8\nClass diagrams",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_444",
    "text": "spread across several modules. Also, many of the things that can be done using inheritance\ncan be done as well or better without it.\n18.8\nClass diagrams\nSo far we have seen stack diagrams, which show the state of a program, and object dia-\ngrams, which show the attributes of an object and their values. These diagrams represent\na snapshot in the execution of a program, so they change as the program runs.\nThey are also highly detailed; for some purposes, too detailed. A class diagram is a more\nabstract representation of the structure of a program. Instead of showing individual ob-\njects, it shows classes and the relationships between them.\nThere are several kinds of relationship between classes:\n\u2022 Objects in one class might contain references to objects in another class. For example,\neach Rectangle contains a reference to a Point, and each Deck contains references to\nmany Cards. This kind of relationship is called HAS-A, as in, \u201ca Rectangle has a\nPoint.\u201d",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_445",
    "text": "each Rectangle contains a reference to a Point, and each Deck contains references to\nmany Cards. This kind of relationship is called HAS-A, as in, \u201ca Rectangle has a\nPoint.\u201d\n\u2022 One class might inherit from another. This relationship is called IS-A, as in, \u201ca Hand\nis a kind of a Deck.\u201d\n\u2022 One class might depend on another in the sense that objects in one class take ob-\njects in the second class as parameters, or use objects in the second class as part of a\ncomputation. This kind of relationship is called a dependency.\nA class diagram is a graphical representation of these relationships. For example, Fig-\nure 18.2 shows the relationships between Card, Deck and Hand.\n178\nChapter 18. Inheritance\nHand\nDeck\n*\nCard\nFigure 18.2: Class diagram.\nThe arrow with a hollow triangle head represents an IS-A relationship; in this case it indi-\ncates that Hand inherits from Deck.\nThe standard arrow head represents a HAS-A relationship; in this case a Deck has refer-\nences to Card objects.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_446",
    "text": "cates that Hand inherits from Deck.\nThe standard arrow head represents a HAS-A relationship; in this case a Deck has refer-\nences to Card objects.\nThe star (*) near the arrow head is a multiplicity; it indicates how many Cards a Deck has.\nA multiplicity can be a simple number, like 52, a range, like 5..7 or a star, which indicates\nthat a Deck can have any number of Cards.\nThere are no dependencies in this diagram. They would normally be shown with a dashed\narrow. Or if there are a lot of dependencies, they are sometimes omitted.\nA more detailed diagram might show that a Deck actually contains a list of Cards, but\nbuilt-in types like list and dict are usually not included in class diagrams.\n18.9\nDebugging\nInheritance can make debugging dif\ufb01cult because when you invoke a method on an object,\nit might be hard to \ufb01gure out which method will be invoked.\nSuppose you are writing a function that works with Hand objects. You would like it to",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_447",
    "text": "it might be hard to \ufb01gure out which method will be invoked.\nSuppose you are writing a function that works with Hand objects. You would like it to\nwork with all kinds of Hands, like PokerHands, BridgeHands, etc. If you invoke a method\nlike shuffle, you might get the one de\ufb01ned in Deck, but if any of the subclasses override\nthis method, you\u2019ll get that version instead. This behavior is usually a good thing, but it\ncan be confusing.\nAny time you are unsure about the \ufb02ow of execution through your program, the sim-\nplest solution is to add print statements at the beginning of the relevant methods.\nIf\nDeck.shuffle prints a message that says something like Running Deck.shuffle, then as\nthe program runs it traces the \ufb02ow of execution.\nAs an alternative, you could use this function, which takes an object and a method name\n(as a string) and returns the class that provides the de\ufb01nition of the method:\ndef find_defining_class(obj, meth_name):\nfor ty in type(obj).mro():\nif meth_name in ty.__dict__:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_448",
    "text": "(as a string) and returns the class that provides the de\ufb01nition of the method:\ndef find_defining_class(obj, meth_name):\nfor ty in type(obj).mro():\nif meth_name in ty.__dict__:\nreturn ty\nHere\u2019s an example:\n>>> hand = Hand()\n>>> find_defining_class(hand, 'shuffle')\n<class '__main__.Deck'>\n18.10. Data encapsulation\n179\nSo the shuffle method for this Hand is the one in Deck.\nfind_defining_class uses the mro method to get the list of class objects (types) that will be\nsearched for methods. \u201cMRO\u201d stands for \u201cmethod resolution order\u201d, which is the sequence\nof classes Python searches to \u201cresolve\u201d a method name.\nHere\u2019s a design suggestion: when you override a method, the interface of the new method\nshould be the same as the old. It should take the same parameters, return the same type,\nand obey the same preconditions and postconditions. If you follow this rule, you will \ufb01nd\nthat any function designed to work with an instance of a parent class, like a Deck, will also",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_449",
    "text": "and obey the same preconditions and postconditions. If you follow this rule, you will \ufb01nd\nthat any function designed to work with an instance of a parent class, like a Deck, will also\nwork with instances of child classes like a Hand and PokerHand.\nIf you violate this rule, which is called the \u201cLiskov substitution principle\u201d, your code will\ncollapse like (sorry) a house of cards.\n18.10\nData encapsulation\nThe previous chapters demonstrate a development plan we might call \u201cobject-oriented\ndesign\u201d. We identi\ufb01ed objects we needed\u2014like Point, Rectangle and Time\u2014and de\ufb01ned\nclasses to represent them. In each case there is an obvious correspondence between the\nobject and some entity in the real world (or at least a mathematical world).\nBut sometimes it is less obvious what objects you need and how they should interact. In\nthat case you need a different development plan. In the same way that we discovered\nfunction interfaces by encapsulation and generalization, we can discover class interfaces",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_450",
    "text": "that case you need a different development plan. In the same way that we discovered\nfunction interfaces by encapsulation and generalization, we can discover class interfaces\nby data encapsulation.\nMarkov analysis, from Section 13.8, provides a good example.\nIf you download my\ncode from https://thinkpython.com/code/markov.py, you\u2019ll see that it uses two global\nvariables\u2014suffix_map and prefix\u2014that are read and written from several functions.\nsuffix_map = {}\nprefix = ()\nBecause these variables are global, we can only run one analysis at a time. If we read two\ntexts, their pre\ufb01xes and suf\ufb01xes would be added to the same data structures (which makes\nfor some interesting generated text).\nTo run multiple analyses, and keep them separate, we can encapsulate the state of each\nanalysis in an object. Here\u2019s what that looks like:\nclass Markov:\ndef __init__(self):\nself.suffix_map = {}\nself.prefix = ()\nNext, we transform the functions into methods. For example, here\u2019s process_word:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_451",
    "text": "class Markov:\ndef __init__(self):\nself.suffix_map = {}\nself.prefix = ()\nNext, we transform the functions into methods. For example, here\u2019s process_word:\ndef process_word(self, word, order=2):\nif len(self.prefix) < order:\nself.prefix += (word,)\nreturn\n180\nChapter 18. Inheritance\ntry:\nself.suffix_map[self.prefix].append(word)\nexcept KeyError:\n# if there is no entry for this prefix, make one\nself.suffix_map[self.prefix] = [word]\nself.prefix = shift(self.prefix, word)\nTransforming a program like this\u2014changing the design without changing the behavior\u2014is\nanother example of refactoring (see Section 4.7).\nThis example suggests a development plan for designing objects and methods:\n1. Start by writing functions that read and write global variables (when necessary).\n2. Once you get the program working, look for associations between global variables\nand the functions that use them.\n3. Encapsulate related variables as attributes of an object.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_452",
    "text": "2. Once you get the program working, look for associations between global variables\nand the functions that use them.\n3. Encapsulate related variables as attributes of an object.\n4. Transform the associated functions into methods of the new class.\nAs an exercise, download my Markov code from https://thinkpython.com/code/\nmarkov.py, and follow the steps described above to encapsulate the global variables\nas attributes of a new class called Markov. Solution: https://thinkpython.com/code/\nmarkov2.py.\n18.11\nGlossary\nencode: To represent one set of values using another set of values by constructing a map-\nping between them.\nclass attribute: An attribute associated with a class object. Class attributes are de\ufb01ned\ninside a class de\ufb01nition but outside any method.\ninstance attribute: An attribute associated with an instance of a class.\nveneer: A method or function that provides a different interface to another function with-\nout doing much computation.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_453",
    "text": "instance attribute: An attribute associated with an instance of a class.\nveneer: A method or function that provides a different interface to another function with-\nout doing much computation.\ninheritance: The ability to de\ufb01ne a new class that is a modi\ufb01ed version of a previously\nde\ufb01ned class.\nparent class: The class from which a child class inherits.\nchild class: A new class created by inheriting from an existing class; also called a \u201csub-\nclass\u201d.\nIS-A relationship: A relationship between a child class and its parent class.\nHAS-A relationship: A relationship between two classes where instances of one class con-\ntain references to instances of the other.\ndependency: A relationship between two classes where instances of one class use in-\nstances of the other class, but do not store them as attributes.\n18.12. Exercises\n181\nclass diagram: A diagram that shows the classes in a program and the relationships be-\ntween them.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_454",
    "text": "stances of the other class, but do not store them as attributes.\n18.12. Exercises\n181\nclass diagram: A diagram that shows the classes in a program and the relationships be-\ntween them.\nmultiplicity: A notation in a class diagram that shows, for a HAS-A relationship, how\nmany references there are to instances of another class.\ndata encapsulation: A program development plan that involves a prototype using global\nvariables and a \ufb01nal version that makes the global variables into instance attributes.\n18.12\nExercises\nExercise 18.1. For the following program, draw a UML class diagram that shows these classes and\nthe relationships among them.\nclass PingPongParent:\npass\nclass Ping(PingPongParent):\ndef __init__(self, pong):\nself.pong = pong\nclass Pong(PingPongParent):\ndef __init__(self, pings=None):\nif pings is None:\nself.pings = []\nelse:\nself.pings = pings\ndef add_ping(self, ping):\nself.pings.append(ping)\npong = Pong()\nping = Ping(pong)\npong.add_ping(ping)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_455",
    "text": "def __init__(self, pings=None):\nif pings is None:\nself.pings = []\nelse:\nself.pings = pings\ndef add_ping(self, ping):\nself.pings.append(ping)\npong = Pong()\nping = Ping(pong)\npong.add_ping(ping)\nExercise 18.2. Write a Deck method called deal_hands that takes two parameters, the number of\nhands and the number of cards per hand. It should create the appropriate number of Hand objects,\ndeal the appropriate number of cards per hand, and return a list of Hands.\nExercise 18.3. The following are the possible hands in poker, in increasing order of value and\ndecreasing order of probability:\npair: two cards with the same rank\ntwo pair: two pairs of cards with the same rank\nthree of a kind: three cards with the same rank\nstraight: \ufb01ve cards with ranks in sequence (aces can be high or low, so Ace-2-3-4-5 is a straight\nand so is 10-Jack-Queen-King-Ace, but Queen-King-Ace-2-3 is not.)\n\ufb02ush: \ufb01ve cards with the same suit\nfull house: three cards with one rank, two cards with another\n182",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_456",
    "text": "and so is 10-Jack-Queen-King-Ace, but Queen-King-Ace-2-3 is not.)\n\ufb02ush: \ufb01ve cards with the same suit\nfull house: three cards with one rank, two cards with another\n182\nChapter 18. Inheritance\nfour of a kind: four cards with the same rank\nstraight \ufb02ush: \ufb01ve cards in sequence (as de\ufb01ned above) and with the same suit\nThe goal of these exercises is to estimate the probability of drawing these various hands.\n1. Download the following \ufb01les from https: // thinkpython. com/ code :\nCard.py : A complete version of the Card, Deck and Hand classes in this chapter.\nPokerHand.py : An incomplete implementation of a class that represents a poker hand, and\nsome code that tests it.\n2. If you run PokerHand.py, it deals seven 7-card poker hands and checks to see if any of them\ncontains a \ufb02ush. Read this code carefully before you go on.\n3. Add methods to PokerHand.py named has_pair, has_twopair, etc. that return True or\nFalse according to whether or not the hand meets the relevant criteria. Your code should",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_457",
    "text": "3. Add methods to PokerHand.py named has_pair, has_twopair, etc. that return True or\nFalse according to whether or not the hand meets the relevant criteria. Your code should\nwork correctly for \u201chands\u201d that contain any number of cards (although 5 and 7 are the most\ncommon sizes).\n4. Write a method named classify that \ufb01gures out the highest-value classi\ufb01cation for a hand\nand sets the label attribute accordingly. For example, a 7-card hand might contain a \ufb02ush\nand a pair; it should be labeled \u201c\ufb02ush\u201d.\n5. When you are convinced that your classi\ufb01cation methods are working, the next step is to esti-\nmate the probabilities of the various hands. Write a function in PokerHand.py that shuf\ufb02es\na deck of cards, divides it into hands, classi\ufb01es the hands, and counts the number of times\nvarious classi\ufb01cations appear.\n6. Print a table of the classi\ufb01cations and their probabilities. Run your program with larger and\nlarger numbers of hands until the output values converge to a reasonable degree of accu-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_458",
    "text": "6. Print a table of the classi\ufb01cations and their probabilities. Run your program with larger and\nlarger numbers of hands until the output values converge to a reasonable degree of accu-\nracy. Compare your results to the values at http: // en. wikipedia. org/ wiki/ Hand_\nrankings .\nSolution: https: // thinkpython. com/ code/ PokerHandSoln. py .\nChapter 19\nThe Goodies\nOne of my goals for this book has been to teach you as little Python as possible. When\nthere were two ways to do something, I picked one and avoided mentioning the other. Or\nsometimes I put the second one into an exercise.\nNow I want to go back for some of the good bits that got left behind. Python provides a\nnumber of features that are not really necessary\u2014you can write good code without them\u2014\nbut with them you can sometimes write code that\u2019s more concise, readable or ef\ufb01cient, and\nsometimes all three.\n19.1\nConditional expressions\nWe saw conditional statements in Section 5.4. Conditional statements are often used to",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_459",
    "text": "sometimes all three.\n19.1\nConditional expressions\nWe saw conditional statements in Section 5.4. Conditional statements are often used to\nchoose one of two values; for example:\nif x > 0:\ny = math.log(x)\nelse:\ny = float('nan')\nThis statement checks whether x is positive. If so, it computes math.log. If not, math.log\nwould raise a ValueError. To avoid stopping the program, we generate a \u201cNaN\u201d, which is\na special \ufb02oating-point value that represents \u201cNot a Number\u201d.\nWe can write this statement more concisely using a conditional expression:\ny = math.log(x) if x > 0 else float('nan')\nYou can almost read this line like English: \u201cy gets log-x if x is greater than 0; otherwise it\ngets NaN\u201d.\nRecursive functions can sometimes be rewritten using conditional expressions. For exam-\nple, here is a recursive version of factorial:\ndef factorial(n):\nif n == 0:\nreturn 1\nelse:\nreturn n * factorial(n-1)\n184\nChapter 19. The Goodies\nWe can rewrite it like this:\ndef factorial(n):",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_460",
    "text": "ple, here is a recursive version of factorial:\ndef factorial(n):\nif n == 0:\nreturn 1\nelse:\nreturn n * factorial(n-1)\n184\nChapter 19. The Goodies\nWe can rewrite it like this:\ndef factorial(n):\nreturn 1 if n == 0 else n * factorial(n-1)\nAnother use of conditional expressions is handling optional arguments. For example, here\nis the init method from GoodKangaroo (see Exercise 17.2):\ndef __init__(self, name, contents=None):\nself.name = name\nif contents == None:\ncontents = []\nself.pouch_contents = contents\nWe can rewrite this one like this:\ndef __init__(self, name, contents=None):\nself.name = name\nself.pouch_contents = [] if contents == None else contents\nIn general, you can replace a conditional statement with a conditional expression if both\nbranches contain simple expressions that are either returned or assigned to the same vari-\nable.\n19.2\nList comprehensions\nIn Section 10.7 we saw the map and \ufb01lter patterns. For example, this function takes a list",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_461",
    "text": "able.\n19.2\nList comprehensions\nIn Section 10.7 we saw the map and \ufb01lter patterns. For example, this function takes a list\nof strings, maps the string method capitalize to the elements, and returns a new list of\nstrings:\ndef capitalize_all(t):\nres = []\nfor s in t:\nres.append(s.capitalize())\nreturn res\nWe can write this more concisely using a list comprehension:\ndef capitalize_all(t):\nreturn [s.capitalize() for s in t]\nThe bracket operators indicate that we are constructing a new list. The expression inside\nthe brackets speci\ufb01es the elements of the list, and the for clause indicates what sequence\nwe are traversing.\nThe syntax of a list comprehension is a little awkward because the loop variable, s in this\nexample, appears in the expression before we get to the de\ufb01nition.\nList comprehensions can also be used for \ufb01ltering. For example, this function selects only\nthe elements of t that are upper case, and returns a new list:\ndef only_upper(t):\nres = []\nfor s in t:\nif s.isupper():",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_462",
    "text": "the elements of t that are upper case, and returns a new list:\ndef only_upper(t):\nres = []\nfor s in t:\nif s.isupper():\nres.append(s)\nreturn res\n19.3. Generator expressions\n185\nWe can rewrite it using a list comprehension\ndef only_upper(t):\nreturn [s for s in t if s.isupper()]\nList comprehensions are concise and easy to read, at least for simple expressions. And they\nare usually faster than the equivalent for loops, sometimes much faster. So if you are mad\nat me for not mentioning them earlier, I understand.\nBut, in my defense, list comprehensions are harder to debug because you can\u2019t put a print\nstatement inside the loop. I suggest that you use them only if the computation is simple\nenough that you are likely to get it right the \ufb01rst time. And for beginners that means never.\n19.3\nGenerator expressions\nGenerator expressions are similar to list comprehensions, but with parentheses instead of\nsquare brackets:\n>>> g = (x**2 for x in range(5))\n>>> g",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_463",
    "text": "19.3\nGenerator expressions\nGenerator expressions are similar to list comprehensions, but with parentheses instead of\nsquare brackets:\n>>> g = (x**2 for x in range(5))\n>>> g\n<generator object <genexpr> at 0x7f4c45a786c0>\nThe result is a generator object that knows how to iterate through a sequence of values. But\nunlike a list comprehension, it does not compute the values all at once; it waits to be asked.\nThe built-in function next gets the next value from the generator:\n>>> next(g)\n0\n>>> next(g)\n1\nWhen you get to the end of the sequence, next raises a StopIteration exception. You can\nalso use a for loop to iterate through the values:\n>>> for val in g:\n...\nprint(val)\n4\n9\n16\nThe generator object keeps track of where it is in the sequence, so the for loop picks up\nwhere next left off. Once the generator is exhausted, it continues to raise StopIteration:\n>>> next(g)\nStopIteration\nGenerator expressions are often used with functions like sum, max, and min:\n>>> sum(x**2 for x in range(5))\n30",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_464",
    "text": ">>> next(g)\nStopIteration\nGenerator expressions are often used with functions like sum, max, and min:\n>>> sum(x**2 for x in range(5))\n30\n19.4\nany and all\nPython provides a built-in function, any, that takes a sequence of boolean values and re-\nturns True if any of the values are True. It works on lists:\n186\nChapter 19. The Goodies\n>>> any([False, False, True])\nTrue\nBut it is often used with generator expressions:\n>>> any(letter == 't' for letter in 'monty')\nTrue\nThat example isn\u2019t very useful because it does the same thing as the in operator. But we\ncould use any to rewrite some of the search functions we wrote in Section 9.3. For example,\nwe could write avoids like this:\ndef avoids(word, forbidden):\nreturn not any(letter in forbidden for letter in word)\nThe function almost reads like English, \u201cword avoids forbidden if there are not any forbid-\nden letters in word.\u201d\nUsing any with a generator expression is ef\ufb01cient because it stops immediately if it \ufb01nds a",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_465",
    "text": "den letters in word.\u201d\nUsing any with a generator expression is ef\ufb01cient because it stops immediately if it \ufb01nds a\nTrue value, so it doesn\u2019t have to evaluate the whole sequence.\nPython provides another built-in function, all, that returns True if every element of the\nsequence is True. As an exercise, use all to re-write uses_all from Section 9.3.\n19.5\nSets\nIn Section 13.6 I use dictionaries to \ufb01nd the words that appear in a document but not in a\nword list. The function I wrote takes d1, which contains the words from the document as\nkeys, and d2, which contains the list of words. It returns a dictionary that contains the keys\nfrom d1 that are not in d2.\ndef subtract(d1, d2):\nres = dict()\nfor key in d1:\nif key not in d2:\nres[key] = None\nreturn res\nIn all of these dictionaries, the values are None because we never use them. As a result, we\nwaste some storage space.\nPython provides another built-in type, called a set, that behaves like a collection of dic-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_466",
    "text": "waste some storage space.\nPython provides another built-in type, called a set, that behaves like a collection of dic-\ntionary keys with no values. Adding elements to a set is fast; so is checking membership.\nAnd sets provide methods and operators to compute common set operations.\nFor example, set subtraction is available as a method called difference or as an operator,\n-. So we can rewrite subtract like this:\ndef subtract(d1, d2):\nreturn set(d1) - set(d2)\nThe result is a set instead of a dictionary, but for operations like iteration, the behavior is\nthe same.\nSome of the exercises in this book can be done concisely and ef\ufb01ciently with sets. For\nexample, here is a solution to has_duplicates, from Exercise 10.7, that uses a dictionary:\n19.6. Counters\n187\ndef has_duplicates(t):\nd = {}\nfor x in t:\nif x in d:\nreturn True\nd[x] = True\nreturn False\nWhen an element appears for the \ufb01rst time, it is added to the dictionary. If the same element\nappears again, the function returns True.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_467",
    "text": "for x in t:\nif x in d:\nreturn True\nd[x] = True\nreturn False\nWhen an element appears for the \ufb01rst time, it is added to the dictionary. If the same element\nappears again, the function returns True.\nUsing sets, we can write the same function like this:\ndef has_duplicates(t):\nreturn len(set(t)) < len(t)\nAn element can only appear in a set once, so if an element in t appears more than once, the\nset will be smaller than t. If there are no duplicates, the set will be the same size as t.\nWe can also use sets to do some of the exercises in Chapter 9. For example, here\u2019s a version\nof uses_only with a loop:\ndef uses_only(word, available):\nfor letter in word:\nif letter not in available:\nreturn False\nreturn True\nuses_only checks whether all letters in word are in available. We can rewrite it like this:\ndef uses_only(word, available):\nreturn set(word) <= set(available)\nThe <= operator checks whether one set is a subset of another, including the possibility that",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_468",
    "text": "def uses_only(word, available):\nreturn set(word) <= set(available)\nThe <= operator checks whether one set is a subset of another, including the possibility that\nthey are equal, which is true if all the letters in word appear in available.\nAs an exercise, rewrite avoids using sets.\n19.6\nCounters\nA Counter is like a set, except that if an element appears more than once, the Counter\nkeeps track of how many times it appears. If you are familiar with the mathematical idea\nof a multiset, a Counter is a natural way to represent a multiset.\nCounter is de\ufb01ned in a standard module called collections, so you have to import it. You\ncan initialize a Counter with a string, list, or anything else that supports iteration:\n>>> from collections import Counter\n>>> count = Counter('parrot')\n>>> count\nCounter({'r': 2, 't': 1, 'o': 1, 'p': 1, 'a': 1})\nCounters behave like dictionaries in many ways; they map from each key to the number of\ntimes it appears. As in dictionaries, the keys have to be hashable.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_469",
    "text": "Counters behave like dictionaries in many ways; they map from each key to the number of\ntimes it appears. As in dictionaries, the keys have to be hashable.\nUnlike dictionaries, Counters don\u2019t raise an exception if you access an element that doesn\u2019t\nappear. Instead, they return 0:\n188\nChapter 19. The Goodies\n>>> count['d']\n0\nWe can use Counters to rewrite is_anagram from Exercise 10.6:\ndef is_anagram(word1, word2):\nreturn Counter(word1) == Counter(word2)\nIf two words are anagrams, they contain the same letters with the same counts, so their\nCounters are equivalent.\nCounters provide methods and operators to perform set-like operations, including ad-\ndition, subtraction, union and intersection. And they provide an often-useful method,\nmost_common, which returns a list of value-frequency pairs, sorted from most common to\nleast:\n>>> count = Counter('parrot')\n>>> for val, freq in count.most_common(3):\n...\nprint(val, freq)\nr 2\np 1\na 1\n19.7\ndefaultdict",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_470",
    "text": "least:\n>>> count = Counter('parrot')\n>>> for val, freq in count.most_common(3):\n...\nprint(val, freq)\nr 2\np 1\na 1\n19.7\ndefaultdict\nThe collections module also provides defaultdict, which is like a dictionary except that\nif you access a key that doesn\u2019t exist, it can generate a new value on the \ufb02y.\nWhen you create a defaultdict, you provide a function that\u2019s used to create new values. A\nfunction used to create objects is sometimes called a factory. The built-in functions that\ncreate lists, sets, and other types can be used as factories:\n>>> from collections import defaultdict\n>>> d = defaultdict(list)\nNotice that the argument is list, which is a class object, not list(), which is a new list.\nThe function you provide doesn\u2019t get called unless you access a key that doesn\u2019t exist.\n>>> t = d['new key']\n>>> t\n[]\nThe new list, which we\u2019re calling t, is also added to the dictionary. So if we modify t, the\nchange appears in d:\n>>> t.append('new value')\n>>> d",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_471",
    "text": ">>> t = d['new key']\n>>> t\n[]\nThe new list, which we\u2019re calling t, is also added to the dictionary. So if we modify t, the\nchange appears in d:\n>>> t.append('new value')\n>>> d\ndefaultdict(<class 'list'>, {'new key': ['new value']})\nIf you are making a dictionary of lists, you can often write simpler code using defaultdict.\nIn my solution to Exercise 12.2, which you can get from https://thinkpython.com/code/\nanagram_sets.py, I make a dictionary that maps from a sorted string of letters to the list of\nwords that can be spelled with those letters. For example, \u2019opst\u2019 maps to the list [\u2019opts\u2019,\n\u2019post\u2019, \u2019pots\u2019, \u2019spot\u2019, \u2019stop\u2019, \u2019tops\u2019].\nHere\u2019s the original code:\n19.8. Named tuples\n189\ndef all_anagrams(filename):\nd = {}\nfor line in open(filename):\nword = line.strip().lower()\nt = signature(word)\nif t not in d:\nd[t] = [word]\nelse:\nd[t].append(word)\nreturn d\nThis can be simpli\ufb01ed using setdefault, which you might have used in Exercise 11.2:\ndef all_anagrams(filename):\nd = {}",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_472",
    "text": "t = signature(word)\nif t not in d:\nd[t] = [word]\nelse:\nd[t].append(word)\nreturn d\nThis can be simpli\ufb01ed using setdefault, which you might have used in Exercise 11.2:\ndef all_anagrams(filename):\nd = {}\nfor line in open(filename):\nword = line.strip().lower()\nt = signature(word)\nd.setdefault(t, []).append(word)\nreturn d\nThis solution has the drawback that it makes a new list every time, regardless of whether\nit is needed. For lists, that\u2019s no big deal, but if the factory function is complicated, it might\nbe.\nWe can avoid this problem and simplify the code using a defaultdict:\ndef all_anagrams(filename):\nd = defaultdict(list)\nfor line in open(filename):\nword = line.strip().lower()\nt = signature(word)\nd[t].append(word)\nreturn d\nMy solution to Exercise 18.3, which you can download from https://thinkpython.com/\ncode/PokerHandSoln.py, uses setdefault in the function has_straightflush. This solu-\ntion has the drawback of creating a Hand object every time through the loop, whether it is",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_473",
    "text": "code/PokerHandSoln.py, uses setdefault in the function has_straightflush. This solu-\ntion has the drawback of creating a Hand object every time through the loop, whether it is\nneeded or not. As an exercise, rewrite it using a defaultdict.\n19.8\nNamed tuples\nMany simple objects are basically collections of related values. For example, the Point\nobject de\ufb01ned in Chapter 15 contains two numbers, x and y. When you de\ufb01ne a class like\nthis, you usually start with an init method and a str method:\nclass Point:\ndef __init__(self, x=0, y=0):\nself.x = x\nself.y = y\ndef __str__(self):\nreturn '(%g, %g)' % (self.x, self.y)\n190\nChapter 19. The Goodies\nThis is a lot of code to convey a small amount of information. Python provides a more\nconcise way to say the same thing:\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\nThe \ufb01rst argument is the name of the class you want to create. The second is a list of the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_474",
    "text": "concise way to say the same thing:\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\nThe \ufb01rst argument is the name of the class you want to create. The second is a list of the\nattributes Point objects should have, as strings. The return value from namedtuple is a class\nobject:\n>>> Point\n<class '__main__.Point'>\nPoint automatically provides methods like __init__ and __str__ so you don\u2019t have to\nwrite them.\nTo create a Point object, you use the Point class as a function:\n>>> p = Point(1, 2)\n>>> p\nPoint(x=1, y=2)\nThe init method assigns the arguments to attributes using the names you provided. The\nstr method prints a representation of the Point object and its attributes.\nYou can access the elements of the named tuple by name:\n>>> p.x, p.y\n(1, 2)\nBut you can also treat a named tuple as a tuple:\n>>> p[0], p[1]\n(1, 2)\n>>> x, y = p\n>>> x, y\n(1, 2)\nNamed tuples provide a quick way to de\ufb01ne simple classes. The drawback is that simple",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_475",
    "text": "(1, 2)\nBut you can also treat a named tuple as a tuple:\n>>> p[0], p[1]\n(1, 2)\n>>> x, y = p\n>>> x, y\n(1, 2)\nNamed tuples provide a quick way to de\ufb01ne simple classes. The drawback is that simple\nclasses don\u2019t always stay simple. You might decide later that you want to add methods\nto a named tuple. In that case, you could de\ufb01ne a new class that inherits from the named\ntuple:\nclass Pointier(Point):\n# add more methods here\nOr you could switch to a conventional class de\ufb01nition.\n19.9\nGathering keyword args\nIn Section 12.4, we saw how to write a function that gathers its arguments into a tuple:\ndef printall(*args):\nprint(args)\nYou can call this function with any number of positional arguments (that is, arguments that\ndon\u2019t have keywords):\n19.10. Glossary\n191\n>>> printall(1, 2.0, '3')\n(1, 2.0, '3')\nBut the * operator doesn\u2019t gather keyword arguments:\n>>> printall(1, 2.0, third='3')\nTypeError: printall() got an unexpected keyword argument 'third'",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_476",
    "text": "191\n>>> printall(1, 2.0, '3')\n(1, 2.0, '3')\nBut the * operator doesn\u2019t gather keyword arguments:\n>>> printall(1, 2.0, third='3')\nTypeError: printall() got an unexpected keyword argument 'third'\nTo gather keyword arguments, you can use the ** operator:\ndef printall(*args, **kwargs):\nprint(args, kwargs)\nYou can call the keyword gathering parameter anything you want, but kwargs is a common\nchoice. The result is a dictionary that maps from keywords to values:\n>>> printall(1, 2.0, third='3')\n(1, 2.0) {'third': '3'}\nIf you have a dictionary of keywords and values, you can use the scatter operator, ** to\ncall a function:\n>>> d = dict(x=1, y=2)\n>>> Point(**d)\nPoint(x=1, y=2)\nWithout the scatter operator, the function would treat d as a single positional argument, so\nit would assign d to x and complain because there\u2019s nothing to assign to y:\n>>> d = dict(x=1, y=2)\n>>> Point(d)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_477",
    "text": "it would assign d to x and complain because there\u2019s nothing to assign to y:\n>>> d = dict(x=1, y=2)\n>>> Point(d)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: __new__() missing 1 required positional argument: 'y'\nWhen you are working with functions that have a large number of parameters, it is often\nuseful to create and pass around dictionaries that specify frequently used options.\n19.10\nGlossary\nconditional expression: An expression that has one of two values, depending on a condi-\ntion.\nlist comprehension: An expression with a for loop in square brackets that yields a new\nlist.\ngenerator expression: An expression with a for loop in parentheses that yields a genera-\ntor object.\nmultiset: A mathematical entity that represents a mapping between the elements of a set\nand the number of times they appear.\nfactory: A function, usually passed as a parameter, used to create objects.\n192\nChapter 19. The Goodies\n19.11\nExercises",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_478",
    "text": "and the number of times they appear.\nfactory: A function, usually passed as a parameter, used to create objects.\n192\nChapter 19. The Goodies\n19.11\nExercises\nExercise 19.1. The following is a function that computes the binomial coef\ufb01cient recursively.\ndef binomial_coeff(n, k):\n\"\"\"Compute the binomial coefficient \"n choose k\".\nn: number of trials\nk: number of successes\nreturns: int\n\"\"\"\nif k == 0:\nreturn 1\nif n == 0:\nreturn 0\nres = binomial_coeff(n-1, k) + binomial_coeff(n-1, k-1)\nreturn res\nRewrite the body of the function using nested conditional expressions.\nOne note: this function is not very ef\ufb01cient because it ends up computing the same values over and\nover. You could make it more ef\ufb01cient by memoizing (see Section 11.6). But you will \ufb01nd that it\u2019s\nharder to memoize if you write it using conditional expressions.\nAppendix A\nDebugging\nWhen you are debugging, you should distinguish among different kinds of errors in order\nto track them down more quickly:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_479",
    "text": "Appendix A\nDebugging\nWhen you are debugging, you should distinguish among different kinds of errors in order\nto track them down more quickly:\n\u2022 Syntax errors are discovered by the interpreter when it is translating the source code\ninto byte code. They indicate that there is something wrong with the structure of the\nprogram. Example: Omitting the colon at the end of a def statement generates the\nsomewhat redundant message SyntaxError:\ninvalid syntax.\n\u2022 Runtime errors are produced by the interpreter if something goes wrong while the\nprogram is running. Most runtime error messages include information about where\nthe error occurred and what functions were executing. Example: An in\ufb01nite recur-\nsion eventually causes the runtime error \u201cmaximum recursion depth exceeded\u201d.\n\u2022 Semantic errors are problems with a program that runs without producing error mes-\nsages but doesn\u2019t do the right thing. Example: An expression may not be evaluated\nin the order you expect, yielding an incorrect result.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_480",
    "text": "sages but doesn\u2019t do the right thing. Example: An expression may not be evaluated\nin the order you expect, yielding an incorrect result.\nThe \ufb01rst step in debugging is to \ufb01gure out which kind of error you are dealing with. Al-\nthough the following sections are organized by error type, some techniques are applicable\nin more than one situation.\nA.1\nSyntax errors\nSyntax errors are usually easy to \ufb01x once you \ufb01gure out what they are. Unfortunately,\nthe error messages are often not helpful. The most common messages are SyntaxError:\ninvalid syntax and SyntaxError:\ninvalid token, neither of which is very informa-\ntive.\nOn the other hand, the message does tell you where in the program the problem occurred.\nActually, it tells you where Python noticed a problem, which is not necessarily where the\nerror is. Sometimes the error is prior to the location of the error message, often on the\npreceding line.\n194\nAppendix A. Debugging",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_481",
    "text": "error is. Sometimes the error is prior to the location of the error message, often on the\npreceding line.\n194\nAppendix A. Debugging\nIf you are building the program incrementally, you should have a good idea about where\nthe error is. It will be in the last line you added.\nIf you are copying code from a book, start by comparing your code to the book\u2019s code\nvery carefully. Check every character. At the same time, remember that the book might be\nwrong, so if you see something that looks like a syntax error, it might be.\nHere are some ways to avoid the most common syntax errors:\n1. Make sure you are not using a Python keyword for a variable name.\n2. Check that you have a colon at the end of the header of every compound statement,\nincluding for, while, if, and def statements.\n3. Make sure that any strings in the code have matching quotation marks. Make sure\nthat all quotation marks are \u201cstraight quotes\u201d, not \u201ccurly quotes\u201d.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_482",
    "text": "including for, while, if, and def statements.\n3. Make sure that any strings in the code have matching quotation marks. Make sure\nthat all quotation marks are \u201cstraight quotes\u201d, not \u201ccurly quotes\u201d.\n4. If you have multiline strings with triple quotes (single or double), make sure you\nhave terminated the string properly. An unterminated string may cause an invalid\ntoken error at the end of your program, or it may treat the following part of the\nprogram as a string until it comes to the next string. In the second case, it might not\nproduce an error message at all!\n5. An unclosed opening operator\u2014(, {, or [\u2014makes Python continue with the next line\nas part of the current statement. Generally, an error occurs almost immediately in the\nnext line.\n6. Check for the classic = instead of == inside a conditional.\n7. Check the indentation to make sure it lines up the way it is supposed to. Python\ncan handle space and tabs, but if you mix them it can cause problems. The best way",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_483",
    "text": "7. Check the indentation to make sure it lines up the way it is supposed to. Python\ncan handle space and tabs, but if you mix them it can cause problems. The best way\nto avoid this problem is to use a text editor that knows about Python and generates\nconsistent indentation.\n8. If you have non-ASCII characters in the code (including strings and comments), that\nmight cause a problem, although Python 3 usually handles non-ASCII characters. Be\ncareful if you paste in text from a web page or other source.\nIf nothing works, move on to the next section...\nA.1.1\nI keep making changes and it makes no difference.\nIf the interpreter says there is an error and you don\u2019t see it, that might be because you and\nthe interpreter are not looking at the same code. Check your programming environment to\nmake sure that the program you are editing is the one Python is trying to run.\nIf you are not sure, try putting an obvious and deliberate syntax error at the beginning of",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_484",
    "text": "make sure that the program you are editing is the one Python is trying to run.\nIf you are not sure, try putting an obvious and deliberate syntax error at the beginning of\nthe program. Now run it again. If the interpreter doesn\u2019t \ufb01nd the new error, you are not\nrunning the new code.\nThere are a few likely culprits:\n\u2022 You edited the \ufb01le and forgot to save the changes before running it again. Some\nprogramming environments do this for you, but some don\u2019t.\nA.2. Runtime errors\n195\n\u2022 You changed the name of the \ufb01le, but you are still running the old name.\n\u2022 Something in your development environment is con\ufb01gured incorrectly.\n\u2022 If you are writing a module and using import, make sure you don\u2019t give your module\nthe same name as one of the standard Python modules.\n\u2022 If you are using import to read a module, remember that you have to restart the\ninterpreter or use reload to read a modi\ufb01ed \ufb01le. If you import the module again, it\ndoesn\u2019t do anything.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_485",
    "text": "\u2022 If you are using import to read a module, remember that you have to restart the\ninterpreter or use reload to read a modi\ufb01ed \ufb01le. If you import the module again, it\ndoesn\u2019t do anything.\nIf you get stuck and you can\u2019t \ufb01gure out what is going on, one approach is to start again\nwith a new program like \u201cHello, World!\u201d, and make sure you can get a known program to\nrun. Then gradually add the pieces of the original program to the new one.\nA.2\nRuntime errors\nOnce your program is syntactically correct, Python can read it and at least start running it.\nWhat could possibly go wrong?\nA.2.1\nMy program does absolutely nothing.\nThis problem is most common when your \ufb01le consists of functions and classes but does\nnot actually invoke a function to start execution. This may be intentional if you only plan\nto import this module to supply classes and functions.\nIf it is not intentional, make sure there is a function call in the program, and make sure the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_486",
    "text": "to import this module to supply classes and functions.\nIf it is not intentional, make sure there is a function call in the program, and make sure the\n\ufb02ow of execution reaches it (see \u201cFlow of Execution\u201d below).\nA.2.2\nMy program hangs.\nIf a program stops and seems to be doing nothing, it is \u201changing\u201d. Often that means that it\nis caught in an in\ufb01nite loop or in\ufb01nite recursion.\n\u2022 If there is a particular loop that you suspect is the problem, add a print statement\nimmediately before the loop that says \u201centering the loop\u201d and another immediately\nafter that says \u201cexiting the loop\u201d.\nRun the program. If you get the \ufb01rst message and not the second, you\u2019ve got an\nin\ufb01nite loop. Go to the \u201cIn\ufb01nite Loop\u201d section below.\n\u2022 Most of the time, an in\ufb01nite recursion will cause the program to run for a while and\nthen produce a \u201cRuntimeError: Maximum recursion depth exceeded\u201d error. If that\nhappens, go to the \u201cIn\ufb01nite Recursion\u201d section below.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_487",
    "text": "then produce a \u201cRuntimeError: Maximum recursion depth exceeded\u201d error. If that\nhappens, go to the \u201cIn\ufb01nite Recursion\u201d section below.\nIf you are not getting this error but you suspect there is a problem with a recursive\nmethod or function, you can still use the techniques in the \u201cIn\ufb01nite Recursion\u201d sec-\ntion.\n\u2022 If neither of those steps works, start testing other loops and other recursive functions\nand methods.\n\u2022 If that doesn\u2019t work, then it is possible that you don\u2019t understand the \ufb02ow of execu-\ntion in your program. Go to the \u201cFlow of Execution\u201d section below.\n196\nAppendix A. Debugging\nIn\ufb01nite Loop\nIf you think you have an in\ufb01nite loop and you think you know what loop is causing the\nproblem, add a print statement at the end of the loop that prints the values of the variables\nin the condition and the value of the condition.\nFor example:\nwhile x > 0 and y < 0 :\n# do something to x\n# do something to y\nprint('x: ', x)\nprint('y: ', y)\nprint(\"condition: \", (x > 0 and y < 0))",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_488",
    "text": "in the condition and the value of the condition.\nFor example:\nwhile x > 0 and y < 0 :\n# do something to x\n# do something to y\nprint('x: ', x)\nprint('y: ', y)\nprint(\"condition: \", (x > 0 and y < 0))\nNow when you run the program, you will see three lines of output for each time through\nthe loop. The last time through the loop, the condition should be False. If the loop keeps\ngoing, you will be able to see the values of x and y, and you might \ufb01gure out why they are\nnot being updated correctly.\nIn\ufb01nite Recursion\nMost of the time, in\ufb01nite recursion causes the program to run for a while and then produce\na Maximum recursion depth exceeded error.\nIf you suspect that a function is causing an in\ufb01nite recursion, make sure that there is a base\ncase. There should be some condition that causes the function to return without making a\nrecursive invocation. If not, you need to rethink the algorithm and identify a base case.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_489",
    "text": "case. There should be some condition that causes the function to return without making a\nrecursive invocation. If not, you need to rethink the algorithm and identify a base case.\nIf there is a base case but the program doesn\u2019t seem to be reaching it, add a print state-\nment at the beginning of the function that prints the parameters. Now when you run the\nprogram, you will see a few lines of output every time the function is invoked, and you\nwill see the parameter values. If the parameters are not moving toward the base case, you\nwill get some ideas about why not.\nFlow of Execution\nIf you are not sure how the \ufb02ow of execution is moving through your program, add print\nstatements to the beginning of each function with a message like \u201centering function foo\u201d,\nwhere foo is the name of the function.\nNow when you run the program, it will print a trace of each function as it is invoked.\nA.2.3\nWhen I run the program I get an exception.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_490",
    "text": "where foo is the name of the function.\nNow when you run the program, it will print a trace of each function as it is invoked.\nA.2.3\nWhen I run the program I get an exception.\nIf something goes wrong during runtime, Python prints a message that includes the name\nof the exception, the line of the program where the problem occurred, and a traceback.\nThe traceback identi\ufb01es the function that is currently running, and then the function that\ncalled it, and then the function that called that, and so on. In other words, it traces the\nA.2. Runtime errors\n197\nsequence of function calls that got you to where you are, including the line number in your\n\ufb01le where each call occurred.\nThe \ufb01rst step is to examine the place in the program where the error occurred and see if\nyou can \ufb01gure out what happened. These are some of the most common runtime errors:\nNameError: You are trying to use a variable that doesn\u2019t exist in the current environment.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_491",
    "text": "you can \ufb01gure out what happened. These are some of the most common runtime errors:\nNameError: You are trying to use a variable that doesn\u2019t exist in the current environment.\nCheck if the name is spelled right, or at least consistently. And remember that local\nvariables are local; you cannot refer to them from outside the function where they are\nde\ufb01ned.\nTypeError: There are several possible causes:\n\u2022 You are trying to use a value improperly. Example: indexing a string, list, or\ntuple with something other than an integer.\n\u2022 There is a mismatch between the items in a format string and the items passed\nfor conversion. This can happen if either the number of items does not match or\nan invalid conversion is called for.\n\u2022 You are passing the wrong number of arguments to a function. For methods,\nlook at the method de\ufb01nition and check that the \ufb01rst parameter is self. Then\nlook at the method invocation; make sure you are invoking the method on an",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_492",
    "text": "look at the method de\ufb01nition and check that the \ufb01rst parameter is self. Then\nlook at the method invocation; make sure you are invoking the method on an\nobject with the right type and providing the other arguments correctly.\nKeyError: You are trying to access an element of a dictionary using a key that the dictio-\nnary does not contain. If the keys are strings, remember that capitalization matters.\nAttributeError: You are trying to access an attribute or method that does not exist. Check\nthe spelling! You can use the built-in function vars to list the attributes that do exist.\nIf an AttributeError indicates that an object has NoneType, that means that it is None.\nSo the problem is not the attribute name, but the object.\nThe reason the object is none might be that you forgot to return a value from a func-\ntion; if you get to the end of a function without hitting a return statement, it returns\nNone. Another common cause is using the result from a list method, like sort, that\nreturns None.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_493",
    "text": "tion; if you get to the end of a function without hitting a return statement, it returns\nNone. Another common cause is using the result from a list method, like sort, that\nreturns None.\nIndexError: The index you are using to access a list, string, or tuple is greater than its\nlength minus one. Immediately before the site of the error, add a print statement to\ndisplay the value of the index and the length of the array. Is the array the right size?\nIs the index the right value?\nThe Python debugger (pdb) is useful for tracking down exceptions because it allows you to\nexamine the state of the program immediately before the error. You can read about pdb at\nhttps://docs.python.org/3/library/pdb.html.\nA.2.4\nI added so many print statements I get inundated with output.\nOne of the problems with using print statements for debugging is that you can end up\nburied in output. There are two ways to proceed: simplify the output or simplify the\nprogram.\n198\nAppendix A. Debugging",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_494",
    "text": "buried in output. There are two ways to proceed: simplify the output or simplify the\nprogram.\n198\nAppendix A. Debugging\nTo simplify the output, you can remove or comment out print statements that aren\u2019t help-\ning, or combine them, or format the output so it is easier to understand.\nTo simplify the program, there are several things you can do. First, scale down the problem\nthe program is working on. For example, if you are searching a list, search a small list. If\nthe program takes input from the user, give it the simplest input that causes the problem.\nSecond, clean up the program. Remove dead code and reorganize the program to make\nit as easy to read as possible. For example, if you suspect that the problem is in a deeply\nnested part of the program, try rewriting that part with simpler structure. If you suspect a\nlarge function, try splitting it into smaller functions and testing them separately.\nOften the process of \ufb01nding the minimal test case leads you to the bug. If you \ufb01nd that",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_495",
    "text": "large function, try splitting it into smaller functions and testing them separately.\nOften the process of \ufb01nding the minimal test case leads you to the bug. If you \ufb01nd that\na program works in one situation but not in another, that gives you a clue about what is\ngoing on.\nSimilarly, rewriting a piece of code can help you \ufb01nd subtle bugs. If you make a change\nthat you think shouldn\u2019t affect the program, and it does, that can tip you off.\nA.3\nSemantic errors\nIn some ways, semantic errors are the hardest to debug, because the interpreter provides\nno information about what is wrong. Only you know what the program is supposed to do.\nThe \ufb01rst step is to make a connection between the program text and the behavior you are\nseeing. You need a hypothesis about what the program is actually doing. One of the things\nthat makes that hard is that computers run so fast.\nYou will often wish that you could slow the program down to human speed, and with",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_496",
    "text": "that makes that hard is that computers run so fast.\nYou will often wish that you could slow the program down to human speed, and with\nsome debuggers you can. But the time it takes to insert a few well-placed print statements\nis often short compared to setting up the debugger, inserting and removing breakpoints,\nand \u201cstepping\u201d the program to where the error is occurring.\nA.3.1\nMy program doesn\u2019t work.\nYou should ask yourself these questions:\n\u2022 Is there something the program was supposed to do but which doesn\u2019t seem to be\nhappening? Find the section of the code that performs that function and make sure\nit is executing when you think it should.\n\u2022 Is something happening that shouldn\u2019t? Find code in your program that performs\nthat function and see if it is executing when it shouldn\u2019t.\n\u2022 Is a section of code producing an effect that is not what you expected? Make sure that\nyou understand the code in question, especially if it involves functions or methods in",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_497",
    "text": "\u2022 Is a section of code producing an effect that is not what you expected? Make sure that\nyou understand the code in question, especially if it involves functions or methods in\nother Python modules. Read the documentation for the functions you call. Try them\nout by writing simple test cases and checking the results.\nA.3. Semantic errors\n199\nIn order to program, you need a mental model of how programs work. If you write a\nprogram that doesn\u2019t do what you expect, often the problem is not in the program; it\u2019s in\nyour mental model.\nThe best way to correct your mental model is to break the program into its components\n(usually the functions and methods) and test each component independently. Once you\n\ufb01nd the discrepancy between your model and reality, you can solve the problem.\nOf course, you should be building and testing components as you develop the program.\nIf you encounter a problem, there should be only a small amount of new code that is not\nknown to be correct.\nA.3.2",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_498",
    "text": "Of course, you should be building and testing components as you develop the program.\nIf you encounter a problem, there should be only a small amount of new code that is not\nknown to be correct.\nA.3.2\nI\u2019ve got a big hairy expression and it doesn\u2019t do what I expect.\nWriting complex expressions is \ufb01ne as long as they are readable, but they can be hard to\ndebug. It is often a good idea to break a complex expression into a series of assignments to\ntemporary variables.\nFor example:\nself.hands[i].addCard(self.hands[self.findNeighbor(i)].popCard())\nThis can be rewritten as:\nneighbor = self.findNeighbor(i)\npickedCard = self.hands[neighbor].popCard()\nself.hands[i].addCard(pickedCard)\nThe explicit version is easier to read because the variable names provide additional docu-\nmentation, and it is easier to debug because you can check the types of the intermediate\nvariables and display their values.\nAnother problem that can occur with big expressions is that the order of evaluation may",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_499",
    "text": "variables and display their values.\nAnother problem that can occur with big expressions is that the order of evaluation may\nnot be what you expect. For example, if you are translating the expression\nx\n2\u03c0 into Python,\nyou might write:\ny = x / 2 * math.pi\nThat is not correct because multiplication and division have the same precedence and are\nevaluated from left to right. So this expression computes x\u03c0/2.\nA good way to debug expressions is to add parentheses to make the order of evaluation\nexplicit:\ny = x / (2 * math.pi)\nWhenever you are not sure of the order of evaluation, use parentheses. Not only will the\nprogram be correct (in the sense of doing what you intended), it will also be more readable\nfor other people who haven\u2019t memorized the order of operations.\nA.3.3\nI\u2019ve got a function that doesn\u2019t return what I expect.\nIf you have a return statement with a complex expression, you don\u2019t have a chance to",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_500",
    "text": "A.3.3\nI\u2019ve got a function that doesn\u2019t return what I expect.\nIf you have a return statement with a complex expression, you don\u2019t have a chance to\nprint the result before returning. Again, you can use a temporary variable. For example,\ninstead of:\nreturn self.hands[i].removeMatches()\n200\nAppendix A. Debugging\nyou could write:\ncount = self.hands[i].removeMatches()\nreturn count\nNow you have the opportunity to display the value of count before returning.\nA.3.4\nI\u2019m really, really stuck and I need help.\nFirst, try getting away from the computer for a few minutes. Computers emit waves that\naffect the brain, causing these symptoms:\n\u2022 Frustration and rage.\n\u2022 Superstitious beliefs (\u201cthe computer hates me\u201d) and magical thinking (\u201cthe program\nonly works when I wear my hat backward\u201d).\n\u2022 Random walk programming (the attempt to program by writing every possible pro-\ngram and choosing the one that does the right thing).",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_501",
    "text": "only works when I wear my hat backward\u201d).\n\u2022 Random walk programming (the attempt to program by writing every possible pro-\ngram and choosing the one that does the right thing).\nIf you \ufb01nd yourself suffering from any of these symptoms, get up and go for a walk. When\nyou are calm, think about the program. What is it doing? What are some possible causes\nof that behavior? When was the last time you had a working program, and what did you\ndo next?\nSometimes it just takes time to \ufb01nd a bug. I often \ufb01nd bugs when I am away from the\ncomputer and let my mind wander. Some of the best places to \ufb01nd bugs are trains, showers,\nand in bed, just before you fall asleep.\nA.3.5\nNo, I really need help.\nIt happens. Even the best programmers occasionally get stuck. Sometimes you work on a\nprogram so long that you can\u2019t see the error. You need a fresh pair of eyes.\nBefore you bring someone else in, make sure you are prepared. Your program should be as",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_502",
    "text": "program so long that you can\u2019t see the error. You need a fresh pair of eyes.\nBefore you bring someone else in, make sure you are prepared. Your program should be as\nsimple as possible, and you should be working on the smallest input that causes the error.\nYou should have print statements in the appropriate places (and the output they produce\nshould be comprehensible). You should understand the problem well enough to describe\nit concisely.\nWhen you bring someone in to help, be sure to give them the information they need:\n\u2022 If there is an error message, what is it and what part of the program does it indicate?\n\u2022 What was the last thing you did before this error occurred? What were the last lines\nof code that you wrote, or what is the new test case that fails?\n\u2022 What have you tried so far, and what have you learned?\nWhen you \ufb01nd the bug, take a second to think about what you could have done to \ufb01nd it",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_503",
    "text": "\u2022 What have you tried so far, and what have you learned?\nWhen you \ufb01nd the bug, take a second to think about what you could have done to \ufb01nd it\nfaster. Next time you see something similar, you will be able to \ufb01nd the bug more quickly.\nRemember, the goal is not just to make the program work. The goal is to learn how to make\nthe program work.\nAppendix B\nAnalysis of Algorithms\nThis appendix is an edited excerpt from Think Complexity, by Allen B. Downey,\nalso published by O\u2019Reilly Media (2012). When you are done with this book,\nyou might want to move on to that one.\nAnalysis of algorithms is a branch of computer science that studies the performance of\nalgorithms, especially their run time and space requirements. See http://en.wikipedia.\norg/wiki/Analysis_of_algorithms.\nThe practical goal of algorithm analysis is to predict the performance of different algo-\nrithms in order to guide design decisions.\nDuring the 2008 United States Presidential Campaign, candidate Barack Obama was asked",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_504",
    "text": "rithms in order to guide design decisions.\nDuring the 2008 United States Presidential Campaign, candidate Barack Obama was asked\nto perform an impromptu analysis when he visited Google. Chief executive Eric Schmidt\njokingly asked him for \u201cthe most ef\ufb01cient way to sort a million 32-bit integers.\u201d Obama\nhad apparently been tipped off, because he quickly replied, \u201cI think the bubble sort would\nbe the wrong way to go.\u201d See http://www.youtube.com/watch?v=k4RRi_ntQc8.\nThis is true: bubble sort is conceptually simple but slow for large datasets.\nThe an-\nswer Schmidt was probably looking for is \u201cradix sort\u201d (http://en.wikipedia.org/wiki/\nRadix_sort)1.\nThe goal of algorithm analysis is to make meaningful comparisons between algorithms,\nbut there are some problems:\n\u2022 The relative performance of the algorithms might depend on characteristics of the\nhardware, so one algorithm might be faster on Machine A, another on Machine B.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_505",
    "text": "but there are some problems:\n\u2022 The relative performance of the algorithms might depend on characteristics of the\nhardware, so one algorithm might be faster on Machine A, another on Machine B.\nThe general solution to this problem is to specify a machine model and analyze the\nnumber of steps, or operations, an algorithm requires under a given model.\n\u2022 Relative performance might depend on the details of the dataset. For example, some\nsorting algorithms run faster if the data are already partially sorted; other algorithms\n1But if you get a question like this in an interview, I think a better answer is, \u201cThe fastest way to sort a million\nintegers is to use whatever sort function is provided by the language I\u2019m using. Its performance is good enough\nfor the vast majority of applications, but if it turned out that my application was too slow, I would use a pro\ufb01ler\nto see where the time was being spent. If it looked like a faster sort algorithm would have a signi\ufb01cant effect on",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_506",
    "text": "to see where the time was being spent. If it looked like a faster sort algorithm would have a signi\ufb01cant effect on\nperformance, then I would look around for a good implementation of radix sort.\u201d\n202\nAppendix B. Analysis of Algorithms\nrun slower in this case. A common way to avoid this problem is to analyze the worst\ncase scenario. It is sometimes useful to analyze average case performance, but that\u2019s\nusually harder, and it might not be obvious what set of cases to average over.\n\u2022 Relative performance also depends on the size of the problem. A sorting algorithm\nthat is fast for small lists might be slow for long lists. The usual solution to this\nproblem is to express run time (or number of operations) as a function of problem\nsize, and group functions into categories depending on how quickly they grow as\nproblem size increases.\nThe good thing about this kind of comparison is that it lends itself to simple classi\ufb01cation",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_507",
    "text": "size, and group functions into categories depending on how quickly they grow as\nproblem size increases.\nThe good thing about this kind of comparison is that it lends itself to simple classi\ufb01cation\nof algorithms. For example, if I know that the run time of Algorithm A tends to be pro-\nportional to the size of the input, n, and Algorithm B tends to be proportional to n2, then I\nexpect A to be faster than B, at least for large values of n.\nThis kind of analysis comes with some caveats, but we\u2019ll get to that later.\nB.1\nOrder of growth\nSuppose you have analyzed two algorithms and expressed their run times in terms of the\nsize of the input: Algorithm A takes 100n + 1 steps to solve a problem with size n; Algo-\nrithm B takes n2 + n + 1 steps.\nThe following table shows the run time of these algorithms for different problem sizes:\nInput\nRun time of\nRun time of\nsize\nAlgorithm A\nAlgorithm B\n10\n1 001\n111\n100\n10 001\n10 101\n1 000\n100 001\n1 001 001\n10 000\n1 000 001\n100 010 001",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_508",
    "text": "Input\nRun time of\nRun time of\nsize\nAlgorithm A\nAlgorithm B\n10\n1 001\n111\n100\n10 001\n10 101\n1 000\n100 001\n1 001 001\n10 000\n1 000 001\n100 010 001\nAt n = 10, Algorithm A looks pretty bad; it takes almost 10 times longer than Algorithm\nB. But for n = 100 they are about the same, and for larger values A is much better.\nThe fundamental reason is that for large values of n, any function that contains an n2 term\nwill grow faster than a function whose leading term is n. The leading term is the term with\nthe highest exponent.\nFor Algorithm A, the leading term has a large coef\ufb01cient, 100, which is why B does better\nthan A for small n. But regardless of the coef\ufb01cients, there will always be some value of n\nwhere an2 > bn, for any values of a and b.\nThe same argument applies to the non-leading terms. Even if the run time of Algorithm A\nwere n + 1000000, it would still be better than Algorithm B for suf\ufb01ciently large n.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_509",
    "text": "The same argument applies to the non-leading terms. Even if the run time of Algorithm A\nwere n + 1000000, it would still be better than Algorithm B for suf\ufb01ciently large n.\nIn general, we expect an algorithm with a smaller leading term to be a better algorithm for\nlarge problems, but for smaller problems, there may be a crossover point where another\nalgorithm is better. The location of the crossover point depends on the details of the algo-\nrithms, the inputs, and the hardware, so it is usually ignored for purposes of algorithmic\nanalysis. But that doesn\u2019t mean you can forget about it.\nB.1. Order of growth\n203\nIf two algorithms have the same leading order term, it is hard to say which is better; again,\nthe answer depends on the details. So for algorithmic analysis, functions with the same\nleading term are considered equivalent, even if they have different coef\ufb01cients.\nAn order of growth is a set of functions whose growth behavior is considered equivalent.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_510",
    "text": "leading term are considered equivalent, even if they have different coef\ufb01cients.\nAn order of growth is a set of functions whose growth behavior is considered equivalent.\nFor example, 2n, 100n and n + 1 belong to the same order of growth, which is written O(n)\nin Big-Oh notation and often called linear because every function in the set grows linearly\nwith n.\nAll functions with the leading term n2 belong to O(n2); they are called quadratic.\nThe following table shows some of the orders of growth that appear most commonly in\nalgorithmic analysis, in increasing order of badness.\nOrder of\nName\ngrowth\nO(1)\nconstant\nO(logb n)\nlogarithmic (for any b)\nO(n)\nlinear\nO(n logb n)\nlinearithmic\nO(n2)\nquadratic\nO(n3)\ncubic\nO(cn)\nexponential (for any c)\nFor the logarithmic terms, the base of the logarithm doesn\u2019t matter; changing bases is the\nequivalent of multiplying by a constant, which doesn\u2019t change the order of growth. Sim-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_511",
    "text": "For the logarithmic terms, the base of the logarithm doesn\u2019t matter; changing bases is the\nequivalent of multiplying by a constant, which doesn\u2019t change the order of growth. Sim-\nilarly, all exponential functions belong to the same order of growth regardless of the base\nof the exponent. Exponential functions grow very quickly, so exponential algorithms are\nonly useful for small problems.\nExercise B.1. Read the Wikipedia page on Big-Oh notation at http: // en. wikipedia. org/\nwiki/ Big_ O_ notation and answer the following questions:\n1. What is the order of growth of n3 + n2? What about 1000000n3 + n2? What about n3 +\n1000000n2?\n2. What is the order of growth of (n2 + n) \u00b7 (n + 1)? Before you start multiplying, remember\nthat you only need the leading term.\n3. If f is in O(g), for some unspeci\ufb01ed function g, what can we say about a f + b, where a and\nb are constants?\n4. If f1 and f2 are in O(g), what can we say about f1 + f2?",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_512",
    "text": "3. If f is in O(g), for some unspeci\ufb01ed function g, what can we say about a f + b, where a and\nb are constants?\n4. If f1 and f2 are in O(g), what can we say about f1 + f2?\n5. If f1 is in O(g) and f2 is in O(h), what can we say about f1 + f2?\n6. If f1 is in O(g) and f2 is O(h), what can we say about f1 \u00b7 f2?\nProgrammers who care about performance often \ufb01nd this kind of analysis hard to swal-\nlow. They have a point: sometimes the coef\ufb01cients and the non-leading terms make a real\ndifference. Sometimes the details of the hardware, the programming language, and the\ncharacteristics of the input make a big difference. And for small problems, order of growth\nis irrelevant.\nBut if you keep those caveats in mind, algorithmic analysis is a useful tool. At least for\nlarge problems, the \u201cbetter\u201d algorithm is usually better, and sometimes it is much better.\nThe difference between two algorithms with the same order of growth is usually a constant",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_513",
    "text": "large problems, the \u201cbetter\u201d algorithm is usually better, and sometimes it is much better.\nThe difference between two algorithms with the same order of growth is usually a constant\nfactor, but the difference between a good algorithm and a bad algorithm is unbounded!\n204\nAppendix B. Analysis of Algorithms\nB.2\nAnalysis of basic Python operations\nIn Python, most arithmetic operations are constant time; multiplication usually takes\nlonger than addition and subtraction, and division takes even longer, but these run times\ndon\u2019t depend on the magnitude of the operands. Very large integers are an exception; in\nthat case the run time increases with the number of digits.\nIndexing operations\u2014reading or writing elements in a sequence or dictionary\u2014are also\nconstant time, regardless of the size of the data structure.\nA for loop that traverses a sequence or dictionary is usually linear, as long as all of the\noperations in the body of the loop are constant time. For example, adding up the elements",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_514",
    "text": "A for loop that traverses a sequence or dictionary is usually linear, as long as all of the\noperations in the body of the loop are constant time. For example, adding up the elements\nof a list is linear:\ntotal = 0\nfor x in t:\ntotal += x\nThe built-in function sum is also linear because it does the same thing, but it tends to be\nfaster because it is a more ef\ufb01cient implementation; in the language of algorithmic analysis,\nit has a smaller leading coef\ufb01cient.\nAs a rule of thumb, if the body of a loop is in O(na) then the whole loop is in O(na+1). The\nexception is if you can show that the loop exits after a constant number of iterations. If a\nloop runs k times regardless of n, then the loop is in O(na), even for large k.\nMultiplying by k doesn\u2019t change the order of growth, but neither does dividing. So if the\nbody of a loop is in O(na) and it runs n/k times, the loop is in O(na+1), even for large k.\nMost string and tuple operations are linear, except indexing and len, which are constant",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_515",
    "text": "body of a loop is in O(na) and it runs n/k times, the loop is in O(na+1), even for large k.\nMost string and tuple operations are linear, except indexing and len, which are constant\ntime. The built-in functions min and max are linear. The run-time of a slice operation is\nproportional to the length of the output, but independent of the size of the input.\nString concatenation is linear; the run time depends on the sum of the lengths of the\noperands.\nAll string methods are linear, but if the lengths of the strings are bounded by a constant\u2014\nfor example, operations on single characters\u2014they are considered constant time.\nThe\nstring method join is linear; the run time depends on the total length of the strings.\nMost list methods are linear, but there are some exceptions:\n\u2022 Adding an element to the end of a list is constant time on average; when it runs\nout of room it occasionally gets copied to a bigger location, but the total time for n",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_516",
    "text": "\u2022 Adding an element to the end of a list is constant time on average; when it runs\nout of room it occasionally gets copied to a bigger location, but the total time for n\noperations is O(n), so the average time for each operation is O(1).\n\u2022 Removing an element from the end of a list is constant time.\n\u2022 Sorting is O(n log n).\nMost dictionary operations and methods are constant time, but there are some exceptions:\n\u2022 The run time of update is proportional to the size of the dictionary passed as a pa-\nrameter, not the dictionary being updated.\n\u2022 keys, values and items are constant time because they return iterators. But if you\nloop through the iterators, the loop will be linear.\nB.3. Analysis of search algorithms\n205\nThe performance of dictionaries is one of the minor miracles of computer science. We will\nsee how they work in Section B.4.\nExercise B.2. Read the Wikipedia page on sorting algorithms at http: // en. wikipedia. org/\nwiki/ Sorting_ algorithm and answer the following questions:",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_517",
    "text": "see how they work in Section B.4.\nExercise B.2. Read the Wikipedia page on sorting algorithms at http: // en. wikipedia. org/\nwiki/ Sorting_ algorithm and answer the following questions:\n1. What is a \u201ccomparison sort?\u201d What is the best worst-case order of growth for a comparison\nsort? What is the best worst-case order of growth for any sort algorithm?\n2. What is the order of growth of bubble sort, and why does Barack Obama think it is \u201cthe wrong\nway to go?\u201d\n3. What is the order of growth of radix sort? What preconditions do we need to use it?\n4. What is a stable sort and why might it matter in practice?\n5. What is the worst sorting algorithm (that has a name)?\n6. What sort algorithm does the C library use? What sort algorithm does Python use? Are these\nalgorithms stable? You might have to Google around to \ufb01nd these answers.\n7. Many of the non-comparison sorts are linear, so why does Python use an O(n log n) compar-\nison sort?\nB.3\nAnalysis of search algorithms",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_518",
    "text": "7. Many of the non-comparison sorts are linear, so why does Python use an O(n log n) compar-\nison sort?\nB.3\nAnalysis of search algorithms\nA search is an algorithm that takes a collection and a target item and determines whether\nthe target is in the collection, often returning the index of the target.\nThe simplest search algorithm is a \u201clinear search\u201d, which traverses the items of the collec-\ntion in order, stopping if it \ufb01nds the target. In the worst case it has to traverse the entire\ncollection, so the run time is linear.\nThe in operator for sequences uses a linear search; so do string methods like find and\ncount.\nIf the elements of the sequence are in order, you can use a bisection search, which is\nO(log n). Bisection search is similar to the algorithm you might use to look a word up\nin a dictionary (a paper dictionary, not the data structure). Instead of starting at the be-\nginning and checking each item in order, you start with the item in the middle and check",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_519",
    "text": "in a dictionary (a paper dictionary, not the data structure). Instead of starting at the be-\nginning and checking each item in order, you start with the item in the middle and check\nwhether the word you are looking for comes before or after. If it comes before, then you\nsearch the \ufb01rst half of the sequence. Otherwise you search the second half. Either way, you\ncut the number of remaining items in half.\nIf the sequence has 1,000,000 items, it will take about 20 steps to \ufb01nd the word or conclude\nthat it\u2019s not there. So that\u2019s about 50,000 times faster than a linear search.\nBisection search can be much faster than linear search, but it requires the sequence to be in\norder, which might require extra work.\nThere is another data structure, called a hashtable that is even faster\u2014it can do a search\nin constant time\u2014and it doesn\u2019t require the items to be sorted. Python dictionaries are\nimplemented using hashtables, which is why most dictionary operations, including the in",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_520",
    "text": "in constant time\u2014and it doesn\u2019t require the items to be sorted. Python dictionaries are\nimplemented using hashtables, which is why most dictionary operations, including the in\noperator, are constant time.\n206\nAppendix B. Analysis of Algorithms\nB.4\nHashtables\nTo explain how hashtables work and why their performance is so good, I start with a simple\nimplementation of a map and gradually improve it until it\u2019s a hashtable.\nI use Python to demonstrate these implementations, but in real life you wouldn\u2019t write\ncode like this in Python; you would just use a dictionary! So for the rest of this chapter, you\nhave to imagine that dictionaries don\u2019t exist and you want to implement a data structure\nthat maps from keys to values. The operations you have to implement are:\nadd(k, v): Add a new item that maps from key k to value v. With a Python dictionary, d,\nthis operation is written d[k] = v.\nget(k): Look up and return the value that corresponds to key k. With a Python dictionary,",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_521",
    "text": "this operation is written d[k] = v.\nget(k): Look up and return the value that corresponds to key k. With a Python dictionary,\nd, this operation is written d[k] or d.get(k).\nFor now, I assume that each key only appears once. The simplest implementation of this\ninterface uses a list of tuples, where each tuple is a key-value pair.\nclass LinearMap:\ndef __init__(self):\nself.items = []\ndef add(self, k, v):\nself.items.append((k, v))\ndef get(self, k):\nfor key, val in self.items:\nif key == k:\nreturn val\nraise KeyError\nadd appends a key-value tuple to the list of items, which takes constant time.\nget uses a for loop to search the list: if it \ufb01nds the target key it returns the corresponding\nvalue; otherwise it raises a KeyError. So get is linear.\nAn alternative is to keep the list sorted by key. Then get could use a bisection search, which\nis O(log n). But inserting a new item in the middle of a list is linear, so this might not be the",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_522",
    "text": "An alternative is to keep the list sorted by key. Then get could use a bisection search, which\nis O(log n). But inserting a new item in the middle of a list is linear, so this might not be the\nbest option. There are other data structures that can implement add and get in log time,\nbut that\u2019s still not as good as constant time, so let\u2019s move on.\nOne way to improve LinearMap is to break the list of key-value pairs into smaller lists.\nHere\u2019s an implementation called BetterMap, which is a list of 100 LinearMaps. As we\u2019ll\nsee in a second, the order of growth for get is still linear, but BetterMap is a step on the\npath toward hashtables:\nclass BetterMap:\ndef __init__(self, n=100):\nself.maps = []\nfor i in range(n):\nself.maps.append(LinearMap())\nB.4. Hashtables\n207\ndef find_map(self, k):\nindex = hash(k) % len(self.maps)\nreturn self.maps[index]\ndef add(self, k, v):\nm = self.find_map(k)\nm.add(k, v)\ndef get(self, k):\nm = self.find_map(k)\nreturn m.get(k)\n__init__ makes a list of n LinearMaps.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_523",
    "text": "return self.maps[index]\ndef add(self, k, v):\nm = self.find_map(k)\nm.add(k, v)\ndef get(self, k):\nm = self.find_map(k)\nreturn m.get(k)\n__init__ makes a list of n LinearMaps.\nfind_map is used by add and get to \ufb01gure out which map to put the new item in, or which\nmap to search.\nfind_map uses the built-in function hash, which takes almost any Python object and returns\nan integer. A limitation of this implementation is that it only works with hashable keys.\nMutable types like lists and dictionaries are unhashable.\nHashable objects that are considered equivalent return the same hash value, but the con-\nverse is not necessarily true: two objects with different values can return the same hash\nvalue.\nfind_map uses the modulus operator to wrap the hash values into the range from 0 to\nlen(self.maps), so the result is a legal index into the list. Of course, this means that many\ndifferent hash values will wrap onto the same index. But if the hash function spreads things",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_524",
    "text": "len(self.maps), so the result is a legal index into the list. Of course, this means that many\ndifferent hash values will wrap onto the same index. But if the hash function spreads things\nout pretty evenly (which is what hash functions are designed to do), then we expect n/100\nitems per LinearMap.\nSince the run time of LinearMap.get is proportional to the number of items, we expect\nBetterMap to be about 100 times faster than LinearMap. The order of growth is still linear,\nbut the leading coef\ufb01cient is smaller. That\u2019s nice, but still not as good as a hashtable.\nHere (\ufb01nally) is the crucial idea that makes hashtables fast: if you can keep the maximum\nlength of the LinearMaps bounded, LinearMap.get is constant time. All you have to do is\nkeep track of the number of items and when the number of items per LinearMap exceeds\na threshold, resize the hashtable by adding more LinearMaps.\nHere is an implementation of a hashtable:\nclass HashMap:\ndef __init__(self):\nself.maps = BetterMap(2)",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_525",
    "text": "a threshold, resize the hashtable by adding more LinearMaps.\nHere is an implementation of a hashtable:\nclass HashMap:\ndef __init__(self):\nself.maps = BetterMap(2)\nself.num = 0\ndef get(self, k):\nreturn self.maps.get(k)\ndef add(self, k, v):\nif self.num == len(self.maps.maps):\n208\nAppendix B. Analysis of Algorithms\nself.resize()\nself.maps.add(k, v)\nself.num += 1\ndef resize(self):\nnew_maps = BetterMap(self.num * 2)\nfor m in self.maps.maps:\nfor k, v in m.items:\nnew_maps.add(k, v)\nself.maps = new_maps\n__init__ creates a BetterMap and initializes num, which keeps track of the number of items.\nget just dispatches to BetterMap. The real work happens in add, which checks the number\nof items and the size of the BetterMap: if they are equal, the average number of items per\nLinearMap is 1, so it calls resize.\nresize makes a new BetterMap, twice as big as the previous one, and then \u201crehashes\u201d the\nitems from the old map to the new.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_526",
    "text": "LinearMap is 1, so it calls resize.\nresize makes a new BetterMap, twice as big as the previous one, and then \u201crehashes\u201d the\nitems from the old map to the new.\nRehashing is necessary because changing the number of LinearMaps changes the denomi-\nnator of the modulus operator in find_map. That means that some objects that used to hash\ninto the same LinearMap will get split up (which is what we wanted, right?).\nRehashing is linear, so resize is linear, which might seem bad, since I promised that add\nwould be constant time. But remember that we don\u2019t have to resize every time, so add is\nusually constant time and only occasionally linear. The total amount of work to run add n\ntimes is proportional to n, so the average time of each add is constant time!\nTo see how this works, think about starting with an empty HashTable and adding a se-\nquence of items. We start with 2 LinearMaps, so the \ufb01rst 2 adds are fast (no resizing re-",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_527",
    "text": "To see how this works, think about starting with an empty HashTable and adding a se-\nquence of items. We start with 2 LinearMaps, so the \ufb01rst 2 adds are fast (no resizing re-\nquired). Let\u2019s say that they take one unit of work each. The next add requires a resize, so\nwe have to rehash the \ufb01rst two items (let\u2019s call that 2 more units of work) and then add the\nthird item (one more unit). Adding the next item costs 1 unit, so the total so far is 6 units\nof work for 4 items.\nThe next add costs 5 units, but the next three are only one unit each, so the total is 14 units\nfor the \ufb01rst 8 adds.\nThe next add costs 9 units, but then we can add 7 more before the next resize, so the total is\n30 units for the \ufb01rst 16 adds.\nAfter 32 adds, the total cost is 62 units, and I hope you are starting to see a pattern. After n\nadds, where n is a power of two, the total cost is 2n \u22122 units, so the average work per add",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_528",
    "text": "After 32 adds, the total cost is 62 units, and I hope you are starting to see a pattern. After n\nadds, where n is a power of two, the total cost is 2n \u22122 units, so the average work per add\nis a little less than 2 units. When n is a power of two, that\u2019s the best case; for other values of\nn the average work is a little higher, but that\u2019s not important. The important thing is that it\nis O(1).\nFigure B.1 shows how this works graphically. Each block represents a unit of work. The\ncolumns show the total work for each add in order from left to right: the \ufb01rst two adds cost\n1 unit each, the third costs 3 units, etc.\nB.5. Glossary\n209\nFigure B.1: The cost of a hashtable add.\nThe extra work of rehashing appears as a sequence of increasingly tall towers with increas-\ning space between them. Now if you knock over the towers, spreading the cost of resizing\nover all adds, you can see graphically that the total cost after n adds is 2n \u22122.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_529",
    "text": "ing space between them. Now if you knock over the towers, spreading the cost of resizing\nover all adds, you can see graphically that the total cost after n adds is 2n \u22122.\nAn important feature of this algorithm is that when we resize the HashTable it grows\ngeometrically; that is, we multiply the size by a constant.\nIf you increase the size\narithmetically\u2014adding a \ufb01xed number each time\u2014the average time per add is linear.\nYou can download my implementation of HashMap from https://thinkpython.com/\ncode/Map.py, but remember that there is no reason to use it; if you want a map, just use a\nPython dictionary.\nB.5\nGlossary\nanalysis of algorithms: A way to compare algorithms in terms of their run time and/or\nspace requirements.\nmachine model: A simpli\ufb01ed representation of a computer used to describe algorithms.\nworst case: The input that makes a given algorithm run slowest (or require the most\nspace).\nleading term: In a polynomial, the term with the highest exponent.",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_530",
    "text": "worst case: The input that makes a given algorithm run slowest (or require the most\nspace).\nleading term: In a polynomial, the term with the highest exponent.\ncrossover point: The problem size where two algorithms require the same run time or\nspace.\norder of growth: A set of functions that all grow in a way considered equivalent for pur-\nposes of analysis of algorithms. For example, all functions that grow linearly belong\nto the same order of growth.\nBig-Oh notation: Notation for representing an order of growth; for example, O(n) repre-\nsents the set of functions that grow linearly.\nlinear: An algorithm whose run time is proportional to problem size, at least for large\nproblem sizes.\nquadratic: An algorithm whose run time is proportional to n2, where n is a measure of\nproblem size.\nsearch: The problem of locating an element of a collection (like a list or dictionary) or\ndetermining that it is not present.\n210\nAppendix B. Analysis of Algorithms",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_531",
    "text": "problem size.\nsearch: The problem of locating an element of a collection (like a list or dictionary) or\ndetermining that it is not present.\n210\nAppendix B. Analysis of Algorithms\nhashtable: A data structure that represents a collection of key-value pairs and performs\nsearch in constant time.\nIndex\nabecedarian, 73, 84\nabs function, 52\nabsolute path, 139, 145\naccess, 90\naccumulator, 100\nhistogram, 127\nlist, 93\nstring, 175\nsum, 93\nAckermann function, 61, 113\nadd method, 165\naddition with carrying, 68\nalgorithm, 67, 69, 130, 201\nMD5, 146\nsquare root, 69\naliasing, 95, 96, 100, 149, 151, 170\ncopying to avoid, 99\nall, 186\nalphabet, 37\nalternative execution, 41\nambiguity, 5\nanagram, 101\nanagram set, 123, 145\nanalysis of algorithms, 201, 209\nanalysis of primitives, 204\nand operator, 40\nany, 185\nappend method, 92, 97, 101, 174, 175\narc function, 31\nArchimedian spiral, 38\nargument, 17, 19, 21, 22, 26, 97\ngather, 118\nkeyword, 33, 36, 191\nlist, 97\noptional, 76, 79, 95, 107, 184",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_532",
    "text": "any, 185\nappend method, 92, 97, 101, 174, 175\narc function, 31\nArchimedian spiral, 38\nargument, 17, 19, 21, 22, 26, 97\ngather, 118\nkeyword, 33, 36, 191\nlist, 97\noptional, 76, 79, 95, 107, 184\npositional, 164, 169, 190\nvariable-length tuple, 118\nargument scatter, 118\narithmetic operator, 3\nassert statement, 159, 160\nassignment, 14, 63, 89\naugmented, 93, 100\nitem, 74, 90, 116\ntuple, 116, 117, 119, 122\nassignment statement, 9\nattribute, 153, 169\n__dict__, 168\nclass, 172, 180\ninitializing, 168\ninstance, 148, 153, 172, 180\nAttributeError, 152, 197\naugmented assignment, 93, 100\nAusten, Jane, 127\naverage case, 202\naverage cost, 208\nbadness, 203\nbase case, 44, 47\nbenchmarking, 133, 134\nBetterMap, 206\nbig, hairy expression, 199\nBig-Oh notation, 209\nbig-oh notation, 203\nbinary search, 101\nbingo, 123\nbirthday, 160\nbirthday paradox, 101\nbisect module, 101\nbisection search, 101, 205\nbisection, debugging by, 68\nbitwise operator, 3\nbody, 19, 26, 65\nbool type, 40\nboolean expression, 40, 47",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_533",
    "text": "bingo, 123\nbirthday, 160\nbirthday paradox, 101\nbisect module, 101\nbisection search, 101, 205\nbisection, debugging by, 68\nbitwise operator, 3\nbody, 19, 26, 65\nbool type, 40\nboolean expression, 40, 47\nboolean function, 54\nboolean operator, 76\nborrowing, subtraction with, 68, 159\nbounded, 207\nbracket\nsquiggly, 103\nbracket operator, 71, 90, 116\nbranch, 41, 47\n212\nIndex\nbreak statement, 66\nbubble sort, 201\nbug, 6, 7, 13\nworst, 170\nbuilt-in function\nany, 185, 186\nbytes object, 141, 145\ncalculator, 8, 15\ncall graph, 109, 112\nCar Talk, 88, 113, 124\nCard class, 172\ncard, playing, 171\ncarrying, addition with, 68, 156, 158\ncatch, 145\nchained conditional, 41, 47\ncharacter, 71\nchecksum, 143, 146\nchild class, 176, 180\nchoice function, 126\ncircle function, 31\ncircular de\ufb01nition, 55\nclass, 4, 147, 153\nCard, 172\nchild, 176, 180\nDeck, 174\nHand, 176\nKangaroo, 170\nparent, 176\nPoint, 148, 165\nRectangle, 149\nTime, 155\nclass attribute, 172, 180\nclass de\ufb01nition, 147\nclass diagram, 177, 181",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_534",
    "text": "Card, 172\nchild, 176, 180\nDeck, 174\nHand, 176\nKangaroo, 170\nparent, 176\nPoint, 148, 165\nRectangle, 149\nTime, 155\nclass attribute, 172, 180\nclass de\ufb01nition, 147\nclass diagram, 177, 181\nclass object, 148, 153, 190\nclose method, 138, 141, 143\n__cmp__ method, 173\nCollatz conjecture, 65\ncollections, 187, 188, 190\ncolon, 19, 194\ncomment, 12, 14\ncommutativity, 12, 167\ncompare function, 52\ncomparing algorithms, 201\ncomparison\nstring, 77\ntuple, 116, 174\ncomparison sort, 205\ncomposition, 19, 22, 26, 54, 174\ncompound statement, 41, 47\nconcatenation, 12, 14, 22, 73, 74, 95\nlist, 91, 97, 101\ncondition, 41, 47, 65, 196\nconditional, 194\nchained, 41, 47\nnested, 42, 47\nconditional execution, 41\nconditional expression, 183, 191\nconditional statement, 41, 47, 55, 184\nconsistency check, 111, 158\nconstant time, 208\ncontributors, vii\nconversion\ntype, 17\ncopy\ndeep, 152\nshallow, 152\nslice, 74, 92\nto avoid aliasing, 99\ncopy module, 151\ncopying objects, 151\ncount method, 79\nCounter, 187",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_535",
    "text": "constant time, 208\ncontributors, vii\nconversion\ntype, 17\ncopy\ndeep, 152\nshallow, 152\nslice, 74, 92\nto avoid aliasing, 99\ncopy module, 151\ncopying objects, 151\ncount method, 79\nCounter, 187\ncounter, 75, 79, 104, 111\ncounting and looping, 75\nCreative Commons, vi\ncrossover point, 202, 209\ncrosswords, 83\ncumulative sum, 100\ndata encapsulation, 179, 181\ndata structure, 122, 123, 132\ndatabase, 141, 145\ndatabase object, 141\ndatetime module, 160\ndbm module, 141\ndead code, 52, 60, 198\ndebugger (pdb), 197\ndebugging, 6, 7, 13, 36, 46, 59, 77, 87, 98, 111,\n122, 133, 144, 152, 159, 168, 178,\n185, 193\nby bisection, 68\nemotional response, 6, 200\nexperimental, 25\nrubber duck, 134\nsuperstition, 200\ndeck, 171\nDeck class, 174\ndeck, playing cards, 174\nIndex\n213\ndeclaration, 110, 112\ndecrement, 64, 69\ndeep copy, 152, 153\ndeepcopy function, 152\ndef keyword, 19\ndefault value, 129, 134, 165\navoiding mutable, 170\ndefaultdict, 188\nde\ufb01nition\ncircular, 55\nclass, 147\nfunction, 19\nrecursive, 124\ndel operator, 94",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_536",
    "text": "deepcopy function, 152\ndef keyword, 19\ndefault value, 129, 134, 165\navoiding mutable, 170\ndefaultdict, 188\nde\ufb01nition\ncircular, 55\nclass, 147\nfunction, 19\nrecursive, 124\ndel operator, 94\ndeletion, element of list, 94\ndelimiter, 95, 100\ndesigned development, 160\ndeterministic, 126, 134\ndevelopment plan, 36\ndata encapsulation, 179, 181\ndesigned, 158\nencapsulation and generalization, 35\nincremental, 52, 193\nprototype and patch, 156, 158\nrandom walk programming, 134, 200\nreduction, 85, 87\ndiagram\ncall graph, 112\nclass, 177, 181\nobject, 148, 150, 152, 153, 155, 173\nstack, 23, 97\nstate, 9, 63, 78, 90, 96, 108, 120, 148, 150,\n152, 155, 173\n__dict__ attribute, 168\ndict function, 103\ndictionary, 103, 112, 120, 197\ninitialize, 120\ninvert, 107\nlookup, 106\nlooping with, 106\nreverse lookup, 106\nsubtraction, 129\ntraversal, 120, 168\ndictionary methods, 204\ndbm module, 141\ndictionary subtraction, 186\ndiff, 146\nDijkstra, Edsger, 87\ndir function, 197\ndirectory, 139, 145\nwalk, 140\nworking, 139\ndispatch",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_537",
    "text": "traversal, 120, 168\ndictionary methods, 204\ndbm module, 141\ndictionary subtraction, 186\ndiff, 146\nDijkstra, Edsger, 87\ndir function, 197\ndirectory, 139, 145\nwalk, 140\nworking, 139\ndispatch\ntype-based, 167\ndispatch, type-based, 166\ndivisibility, 39\ndivision\n\ufb02oating-point, 39\n\ufb02oor, 39, 46, 47\ndivmod, 117, 158\ndocstring, 35, 37, 148\ndot notation, 18, 26, 76, 148, 162, 172\nDouble Day, 160\ndouble letters, 88\nDoyle, Arthur Conan, 25\nduplicate, 101, 113, 146, 187\nelement, 89, 100\nelement deletion, 94\nelif keyword, 42\nElkner, Jeff, v, vi\nellipses, 19\nelse keyword, 41\nemail address, 117\nembedded object, 150, 153, 170\ncopying, 152\nemotional debugging, 6, 200\nempty list, 89\nempty string, 79, 95\nencapsulation, 32, 36, 54, 69, 75, 177\nencode, 171, 180\nencrypt, 171\nend of line character, 144\nenumerate function, 119\nenumerate object, 119\nepsilon, 67\nequality and assignment, 63\nequivalence, 96, 152\nequivalent, 100\nerror\nruntime, 13, 44, 46, 193\nsemantic, 13, 193, 198\nshape, 122\nsyntax, 13, 193",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_538",
    "text": "enumerate object, 119\nepsilon, 67\nequality and assignment, 63\nequivalence, 96, 152\nequivalent, 100\nerror\nruntime, 13, 44, 46, 193\nsemantic, 13, 193, 198\nshape, 122\nsyntax, 13, 193\nerror checking, 58\nerror message, 7, 13, 193\neval function, 69\nevaluate, 10\nexception, 13, 14, 193, 196\nAttributeError, 152, 197\n214\nIndex\nFileNotFoundError, 140\nIndexError, 72, 78, 90, 197\nKeyError, 104, 197\nLookupError, 107\nNameError, 22, 197\nOver\ufb02owError, 46\nRuntimeError, 45\nStopIteration, 185\nSyntaxError, 19\nTypeError, 72, 74, 108, 116, 118, 139, 164,\n197\nUnboundLocalError, 110\nValueError, 46, 117\nexception, catching, 140\nexecute, 11, 14\nexists function, 139\nexperimental debugging, 25, 134\nexponent, 202\nexponential growth, 203\nexpression, 10, 14\nbig and hairy, 199\nboolean, 40, 47\nconditional, 183, 191\ngenerator, 185, 186, 191\nextend method, 92\nfactorial, 183\nfactorial function, 56, 58\nfactory, 191\nfactory function, 188, 189\nFalse special value, 40\nFermat\u2019s Last Theorem, 48\n\ufb01bonacci function, 57, 109",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_539",
    "text": "extend method, 92\nfactorial, 183\nfactorial function, 56, 58\nfactory, 191\nfactory function, 188, 189\nFalse special value, 40\nFermat\u2019s Last Theorem, 48\n\ufb01bonacci function, 57, 109\n\ufb01le, 137\npermission, 140\nreading and writing, 137\n\ufb01le object, 83, 87\n\ufb01lename, 139\nFileNotFoundError, 140\n\ufb01lter pattern, 93, 100, 184\n\ufb01nd function, 74\n\ufb02ag, 110, 112\n\ufb02oat function, 17\n\ufb02oat type, 4\n\ufb02oating-point, 4, 7, 67, 183\n\ufb02oating-point division, 39\n\ufb02oor division, 39, 46, 47\n\ufb02ow of execution, 21, 26, 58, 59, 65, 178, 196\n\ufb02ower, 37\nfolder, 139\nfor loop, 30, 44, 72, 91, 119, 184\nformal language, 4, 7\nformat operator, 138, 145, 197\nformat sequence, 138, 145\nformat string, 138, 145\nframe, 23, 26, 44, 56, 109\nFree Documentation License, GNU, v, vi\nfrequency, 105\nletter, 123\nword, 125, 134\nfruitful function, 24, 26\nfrustration, 200\nfunction, 3, 17, 19, 25, 161\nabs, 52\nack, 61, 113\narc, 31\nchoice, 126\ncircle, 31\ncompare, 52\ndeepcopy, 152\ndict, 103\ndir, 197\nenumerate, 119\neval, 69\nexists, 139\nfactorial, 56, 183",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_540",
    "text": "frustration, 200\nfunction, 3, 17, 19, 25, 161\nabs, 52\nack, 61, 113\narc, 31\nchoice, 126\ncircle, 31\ncompare, 52\ndeepcopy, 152\ndict, 103\ndir, 197\nenumerate, 119\neval, 69\nexists, 139\nfactorial, 56, 183\n\ufb01bonacci, 57, 109\n\ufb01nd, 74\n\ufb02oat, 17\nfruitful, 24\ngetattr, 168\ngetcwd, 139\nhasattr, 153, 168\ninput, 45\nint, 17\nisinstance, 58, 153, 166\nlen, 26, 72, 104\nlist, 94\nlog, 18\nmath, 18\nmax, 117, 118\nmin, 117, 118\nopen, 83, 84, 137, 140, 141\npolygon, 31\npopen, 142\nprogrammer de\ufb01ned, 22, 129\nrandint, 101, 126\nrandom, 126\nreasons for, 24\nrecursive, 43\nIndex\n215\nreload, 144, 195\nrepr, 144\nreversed, 121\nshuf\ufb02e, 175\nsorted, 99, 106, 121\nsqrt, 18, 53\nstr, 18\nsum, 118, 185\ntrigonometric, 18\ntuple, 115\ntuple as return value, 117\ntype, 153\nvoid, 24\nzip, 118\nfunction argument, 21\nfunction call, 17, 26\nfunction composition, 54\nfunction de\ufb01nition, 19, 20, 25\nfunction frame, 23, 26, 44, 56, 109\nfunction object, 27\nfunction parameter, 21\nfunction syntax, 162\nfunction type, 20\nmodi\ufb01er, 157\npure, 156",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_541",
    "text": "function composition, 54\nfunction de\ufb01nition, 19, 20, 25\nfunction frame, 23, 26, 44, 56, 109\nfunction object, 27\nfunction parameter, 21\nfunction syntax, 162\nfunction type, 20\nmodi\ufb01er, 157\npure, 156\nfunctional programming style, 158, 160\ngamma function, 58\ngather, 118, 123, 190\nGCD (greatest common divisor), 61\ngeneralization, 32, 36, 85, 159\ngenerator expression, 185, 186, 191\ngenerator object, 185\ngeometric resizing, 209\nget method, 105\ngetattr function, 168\ngetcwd function, 139\nglobal statement, 110, 112\nglobal variable, 110, 112\nupdate, 110\nGNU Free Documentation License, v, vi\ngreatest common divisor (GCD), 61\ngrid, 27\nguardian pattern, 59, 60, 78\nHand class, 176\nhanging, 195\nHAS-A relationship, 177, 180\nhasattr function, 153, 168\nhash function, 108, 112, 207\nhashable, 108, 112, 120\nHashMap, 207\nhashtable, 112, 206, 210\nheader, 19, 25, 194\nHello, World, 3\nhexadecimal, 148\nhigh-level language, 6\nhistogram, 105\nrandom choice, 126, 130\nword frequencies, 127\nHolmes, Sherlock, 25",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_542",
    "text": "HashMap, 207\nhashtable, 112, 206, 210\nheader, 19, 25, 194\nHello, World, 3\nhexadecimal, 148\nhigh-level language, 6\nhistogram, 105\nrandom choice, 126, 130\nword frequencies, 127\nHolmes, Sherlock, 25\nhomophone, 113\nhypotenuse, 54\nidentical, 100\nidentity, 96, 152\nif statement, 41\nimmutability, 74, 79, 97, 108, 115, 121\nimplementation, 105, 112, 132, 169\nimport statement, 26, 144\nin operator, 205\nin operator, 76, 85, 90, 104\nincrement, 64, 69, 157, 163\nincremental development, 60, 193\nindentation, 19, 162, 194\nindex, 71, 78, 79, 90, 103, 197\nlooping with, 86, 91\nnegative, 72\nslice, 73, 91\nstarting at zero, 71, 90\nIndexError, 72, 78, 90, 197\nindexing, 204\nin\ufb01nite loop, 65, 69, 195, 196\nin\ufb01nite recursion, 44, 47, 58, 195, 196\ninheritance, 176, 178, 180, 190\ninit method, 164, 168, 172, 174, 176\ninitialization\nvariable, 69\ninitialization (before update), 64\ninput function, 45\ninstance, 148, 153\nas argument, 149\nas return value, 150\ninstance attribute, 148, 153, 172, 180\ninstantiate, 153",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_543",
    "text": "initialization\nvariable, 69\ninitialization (before update), 64\ninput function, 45\ninstance, 148, 153\nas argument, 149\nas return value, 150\ninstance attribute, 148, 153, 172, 180\ninstantiate, 153\ninstantiation, 148\nint function, 17\nint type, 4\ninteger, 4, 7\ninteractive mode, 11, 14, 24\n216\nIndex\ninterface, 33, 36, 169, 179\ninterlocking words, 101\ninterpret, 6\ninterpreter, 2\ninvariant, 159, 160\ninvert dictionary, 107\ninvocation, 76, 79\nis operator, 95, 152\nIS-A relationship, 177, 180\nisinstance function, 58, 153, 166\nitem, 74, 79, 89, 103\ndictionary, 112\nitem assignment, 74, 90, 116\nitem update, 91\nitems method, 120\niteration, 64, 69\niterator, 119\u2013121, 123, 204\njoin, 204\njoin method, 95, 175\nKangaroo class, 170\nkey, 103, 112\nkey-value pair, 103, 112, 120\nkeyboard input, 45\nKeyError, 104, 197\nKeyError, 206\nkeyword, 10, 14, 194\ndef, 19\nelif, 42\nelse, 41\nkeyword argument, 33, 36, 191\nKoch curve, 49\nlanguage\nformal, 4\nnatural, 4\nsafe, 13\nTuring complete, 55\nleading coef\ufb01cient, 202",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_544",
    "text": "KeyError, 206\nkeyword, 10, 14, 194\ndef, 19\nelif, 42\nelse, 41\nkeyword argument, 33, 36, 191\nKoch curve, 49\nlanguage\nformal, 4\nnatural, 4\nsafe, 13\nTuring complete, 55\nleading coef\ufb01cient, 202\nleading term, 202, 209\nleap of faith, 57\nlen function, 26, 72, 104\nletter frequency, 123\nletter rotation, 80, 113\nlinear, 209\nlinear growth, 203\nlinear search, 205\nLinearMap, 206\nLinux, 25\nlipogram, 84\nLiskov substitution principle, 179\nlist, 89, 94, 100, 121, 184\nas argument, 97\nconcatenation, 91, 97, 101\ncopy, 92\nelement, 90\nempty, 89\nfunction, 94\nindex, 90\nmembership, 90\nmethod, 92\nnested, 89, 91\nof objects, 174\nof tuples, 119\noperation, 91\nrepetition, 91\nslice, 91\ntraversal, 91\nlist comprehension, 184, 191\nlist methods, 204\nliteralness, 5\nlocal variable, 22, 26\nlog function, 18\nlogarithm, 135\nlogarithmic growth, 203\nlogical operator, 40\nlookup, 112\nlookup, dictionary, 106\nLookupError, 107\nloop, 31, 36, 65, 119\ncondition, 196\nfor, 30, 44, 72, 91\nin\ufb01nite, 65, 196\nnested, 174\ntraversal, 72\nwhile, 64",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_545",
    "text": "logical operator, 40\nlookup, 112\nlookup, dictionary, 106\nLookupError, 107\nloop, 31, 36, 65, 119\ncondition, 196\nfor, 30, 44, 72, 91\nin\ufb01nite, 65, 196\nnested, 174\ntraversal, 72\nwhile, 64\nloop variable, 184\nlooping\nwith dictionaries, 106\nwith indices, 86, 91\nwith strings, 75\nlooping and counting, 75\nlow-level language, 6\nls (Unix command), 142\nmachine model, 201, 209\nmain, 23, 43, 110, 144\nmaintainable, 169\nmap pattern, 93, 100\nmap to, 171\nIndex\n217\nmapping, 112, 131\nMarkov analysis, 130\nmash-up, 132\nmath function, 18\nmatplotlib, 135\nmax function, 117, 118\nMcCloskey, Robert, 73\nmd5, 143\nMD5 algorithm, 146\nmd5sum, 146\nmembership\nbinary search, 101\nbisection search, 101\ndictionary, 104\nlist, 90\nset, 113\nmemo, 109, 112\nmental model, 199\nmetaphor, method invocation, 163\nmetathesis, 123\nmethod, 36, 75, 161, 169\n__cmp__, 173\n__str__, 165, 174\nadd, 165\nappend, 92, 97, 101, 174, 175\nclose, 138, 141, 143\ncount, 79\nextend, 92\nget, 105\ninit, 164, 172, 174, 176\nitems, 120\njoin, 95, 175\nmro, 179",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_546",
    "text": "__cmp__, 173\n__str__, 165, 174\nadd, 165\nappend, 92, 97, 101, 174, 175\nclose, 138, 141, 143\ncount, 79\nextend, 92\nget, 105\ninit, 164, 172, 174, 176\nitems, 120\njoin, 95, 175\nmro, 179\npop, 94, 175\nradd, 167\nread, 143\nreadline, 83, 143\nremove, 94\nreplace, 125\nsetdefault, 113\nsort, 92, 99, 176\nsplit, 95, 117\nstring, 79\nstrip, 84, 125\ntranslate, 125\nupdate, 120\nvalues, 104\nvoid, 92\nmethod resolution order, 179\nmethod syntax, 162\nmethod, list, 92\nMeyers, Chris, vi\nmin function, 117, 118\nMoby Project, 83\nmodel, mental, 199\nmodi\ufb01er, 157, 160\nmodule, 18, 26\nbisect, 101\ncollections, 187, 188, 190\ncopy, 151\ndatetime, 160\ndbm, 141\nos, 139\npickle, 137, 142\npprint, 112\npro\ufb01le, 133\nrandom, 101, 126, 175\nreload, 144, 195\nshelve, 142\nstring, 125\nstructshape, 122\ntime, 101\nmodule object, 18, 143\nmodule, writing, 143\nmodulus operator, 39, 47\nMonty Python and the Holy Grail, 156\nMP3, 146\nmro method, 179\nmultiline string, 35, 194\nmultiplicity (in class diagram), 178, 181\nmultiset, 187",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_547",
    "text": "module, writing, 143\nmodulus operator, 39, 47\nMonty Python and the Holy Grail, 156\nMP3, 146\nmro method, 179\nmultiline string, 35, 194\nmultiplicity (in class diagram), 178, 181\nmultiset, 187\nmutability, 74, 90, 92, 96, 111, 115, 121, 151\nmutable object, as default value, 170\nname built-in variable, 144\nnamedtuple, 190\nNameError, 22, 197\nNaN, 183\nnatural language, 4, 7\nnegative index, 72\nnested conditional, 42, 47\nnested list, 89, 91, 100\nnewline, 45, 175\nNewton\u2019s method, 66\nNone special value, 24, 26, 52, 92, 94\nNoneType type, 24\nnot operator, 40\nnumber, random, 126\nObama, Barack, 201\n218\nIndex\nobject, 74, 79, 95, 96, 100\nbytes, 141, 145\nclass, 147, 148, 153, 190\ncopying, 151\nCounter, 187\ndatabase, 141\ndefaultdict, 188\nembedded, 150, 153, 170\nenumerate, 119\n\ufb01le, 83, 87\nfunction, 27\ngenerator, 185\nmodule, 143\nmutable, 151\nnamedtuple, 190\npipe, 145\nprinting, 162\nset, 186\nzip, 123\nobject diagram, 148, 150, 152, 153, 155, 173\nobject-oriented design, 169\nobject-oriented language, 169",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_548",
    "text": "generator, 185\nmodule, 143\nmutable, 151\nnamedtuple, 190\npipe, 145\nprinting, 162\nset, 186\nzip, 123\nobject diagram, 148, 150, 152, 153, 155, 173\nobject-oriented design, 169\nobject-oriented language, 169\nobject-oriented programming, 147, 161, 169,\n176\nodometer, 88\nOlin College, v\nopen function, 83, 84, 137, 140, 141\noperand, 14\noperator, 7\nand, 40\narithmetic, 3\nbitwise, 3\nboolean, 76\nbracket, 71, 90, 116\ndel, 94\nformat, 138, 145, 197\nin, 76, 85, 90, 104\nis, 95, 152\nlogical, 40\nmodulus, 39, 47\nnot, 40\nor, 40\noverloading, 169\nrelational, 40, 173\nslice, 73, 79, 91, 98, 116\nstring, 12\nupdate, 93\noperator overloading, 166, 173\noptional argument, 76, 79, 95, 107, 184\noptional parameter, 129, 165\nor operator, 40\norder of growth, 202, 209\norder of operations, 11, 14, 199\nos module, 139\nother (parameter name), 164\nOver\ufb02owError, 46\noverloading, 169\noverride, 129, 134, 165, 173, 176, 179\npalindrome, 61, 80, 86, 88\nparameter, 21, 23, 26, 97\ngather, 118\noptional, 129, 165\nother, 164\nself, 163",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_549",
    "text": "Over\ufb02owError, 46\noverloading, 169\noverride, 129, 134, 165, 173, 176, 179\npalindrome, 61, 80, 86, 88\nparameter, 21, 23, 26, 97\ngather, 118\noptional, 129, 165\nother, 164\nself, 163\nparent class, 176, 180\nparentheses\nargument in, 17\nempty, 19, 76\nparameters in, 21, 22\nparent class in, 176\ntuples in, 115\nparse, 5, 7\npass statement, 41\npath, 139, 145\nabsolute, 139\nrelative, 139\npattern\n\ufb01lter, 93, 100, 184\nguardian, 59, 60, 78\nmap, 93, 100\nreduce, 93, 100\nsearch, 75, 79, 85, 107, 186\nswap, 116\npdb (Python debugger), 197\nPEMDAS, 11\npermission, \ufb01le, 140\npersistence, 137, 145\npi, 18, 70\npickle module, 137, 142\npickling, 142\npie, 37\npipe, 142\npipe object, 145\nplain text, 83, 125\nplanned development, 158\npoetry, 5\nPoint class, 148, 165\npoint, mathematical, 147\npoker, 171, 181\nIndex\n219\npolygon function, 31\npolymorphism, 168, 169\npop method, 94, 175\npopen function, 142\nportability, 6\npositional argument, 164, 169, 190\npostcondition, 36, 59, 179\npprint module, 112\nprecedence, 199",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_550",
    "text": "219\npolygon function, 31\npolymorphism, 168, 169\npop method, 94, 175\npopen function, 142\nportability, 6\npositional argument, 164, 169, 190\npostcondition, 36, 59, 179\npprint module, 112\nprecedence, 199\nprecondition, 36, 37, 59, 179\npre\ufb01x, 131\npretty print, 112\nprint function, 3\nprint statement, 3, 7, 165, 197\nproblem solving, 1, 6\npro\ufb01le module, 133\nprogram, 1, 6\nprogram testing, 87\nprogrammer-de\ufb01ned function, 22, 129\nprogrammer-de\ufb01ned type, 147, 153, 155,\n162, 165, 173\nProject Gutenberg, 125\nprompt, 2, 6, 45\nprose, 5\nprototype and patch, 156, 158, 160\npseudorandom, 126, 134\npure function, 156, 160\nPuzzler, 88, 113, 124\nPythagorean theorem, 52\nPython\nrunning, 2\nPython 2, 2, 3, 33, 40, 45\nPython in a browser, 2\nPythonAnywhere, 2\nquadratic, 209\nquadratic growth, 203\nquotation mark, 3, 4, 35, 74, 194\nradd method, 167\nradian, 18\nradix sort, 201\nrage, 200\nraise statement, 107, 112, 159\nRamanujan, Srinivasa, 70\nrandint function, 101, 126\nrandom function, 126\nrandom module, 101, 126, 175",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_551",
    "text": "radd method, 167\nradian, 18\nradix sort, 201\nrage, 200\nraise statement, 107, 112, 159\nRamanujan, Srinivasa, 70\nrandint function, 101, 126\nrandom function, 126\nrandom module, 101, 126, 175\nrandom number, 126\nrandom text, 131\nrandom walk programming, 134, 200\nrank, 171\nread method, 143\nreadline method, 83, 143\nreassignment, 63, 68, 90, 110\nRectangle class, 149\nrecursion, 43, 47, 55, 57\nbase case, 44\nin\ufb01nite, 44, 58, 196\nrecursive de\ufb01nition, 56, 124\nred-black tree, 206\nreduce pattern, 93, 100\nreducible word, 113, 124\nreduction to a previously solved problem,\n85\nreduction to a previously solved problem,\n87\nredundancy, 5\nrefactoring, 34\u201336, 180\nreference, 96, 97, 100\naliasing, 96\nrehashing, 208\nrelational operator, 40, 173\nrelative path, 139, 145\nreload function, 144, 195\nremove method, 94\nrepetition, 30\nlist, 91\nreplace method, 125\nrepr function, 144\nrepresentation, 147, 149, 171\nreturn statement, 44, 51, 199\nreturn value, 17, 26, 51, 150\ntuple, 117\nreverse lookup, 112",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_552",
    "text": "repetition, 30\nlist, 91\nreplace method, 125\nrepr function, 144\nrepresentation, 147, 149, 171\nreturn statement, 44, 51, 199\nreturn value, 17, 26, 51, 150\ntuple, 117\nreverse lookup, 112\nreverse lookup, dictionary, 106\nreverse word pair, 101\nreversed function, 121\nrotation\nletters, 113\nrotation, letter, 80\nrubber duck debugging, 134\nrunning pace, 8, 15, 160\nrunning Python, 2\nruntime error, 13, 44, 46, 193, 196\nRuntimeError, 45, 58\nsafe language, 13\nsanity check, 111\nscaffolding, 53, 60, 112\n220\nIndex\nscatter, 118, 123, 191\nSchmidt, Eric, 201\nScrabble, 123\nscript, 11, 14\nscript mode, 11, 14, 24\nsearch, 107, 205, 209\nsearch pattern, 75, 79, 85, 186\nsearch, binary, 101\nsearch, bisection, 101\nself (parameter name), 163\nsemantic error, 13, 14, 193, 198\nsemantics, 14, 162\nsequence, 4, 71, 79, 89, 94, 115, 121\nset, 130, 186\nanagram, 123, 145\nset membership, 113\nset subtraction, 186\nsetdefault, 189\nsetdefault method, 113\nsexagesimal, 158\nshallow copy, 152, 153\nshape, 123\nshape error, 122",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_553",
    "text": "set, 130, 186\nanagram, 123, 145\nset membership, 113\nset subtraction, 186\nsetdefault, 189\nsetdefault method, 113\nsexagesimal, 158\nshallow copy, 152, 153\nshape, 123\nshape error, 122\nshell, 142, 145\nshelve module, 142\nshuf\ufb02e function, 175\nsine function, 18\nsingleton, 108, 112, 115\nslice, 79\ncopy, 74, 92\nlist, 91\nstring, 73\ntuple, 116\nupdate, 92\nslice operator, 73, 79, 91, 98, 116\nsort method, 92, 99, 176\nsorted\nfunction, 99, 106\nsorted function, 121\nsorting, 204, 205\nspecial case, 87, 157\nspecial value\nFalse, 40\nNone, 24, 26, 52, 92, 94\nTrue, 40\nspiral, 38\nsplit method, 95, 117\nsqrt, 53\nsqrt function, 18\nsquare root, 66\nsquiggly bracket, 103\nstable sort, 205\nstack diagram, 23, 26, 37, 44, 56, 60, 97\nstate diagram, 9, 14, 63, 78, 90, 96, 108, 120,\n148, 150, 152, 155, 173\nstatement, 10, 14\nassert, 159, 160\nassignment, 9, 63\nbreak, 66\ncompound, 41\nconditional, 41, 47, 55, 184\nfor, 30, 72, 91\nglobal, 110, 112\nif, 41\nimport, 26, 144\npass, 41\nprint, 3, 7, 165, 197\nraise, 107, 112, 159",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_554",
    "text": "assert, 159, 160\nassignment, 9, 63\nbreak, 66\ncompound, 41\nconditional, 41, 47, 55, 184\nfor, 30, 72, 91\nglobal, 110, 112\nif, 41\nimport, 26, 144\npass, 41\nprint, 3, 7, 165, 197\nraise, 107, 112, 159\nreturn, 44, 51, 199\ntry, 140, 153\nwhile, 64\nstep size, 79\nStopIteration, 185\nstr function, 18\n__str__ method, 165, 174\nstring, 4, 7, 94, 121\naccumulator, 175\ncomparison, 77\nempty, 95\nimmutable, 74\nmethod, 75\nmultiline, 35, 194\noperation, 12\nslice, 73\ntriple-quoted, 35\nstring concatenation, 204\nstring method, 79\nstring methods, 204\nstring module, 125\nstring representation, 144, 165\nstring type, 4\nstrip method, 84, 125\nstructshape module, 122\nstructure, 5\nsubject, 163, 169\nsubset, 187\nsubtraction\ndictionary, 129\nwith borrowing, 68\nsubtraction with borrowing, 159\nIndex\n221\nsuf\ufb01x, 131\nsuit, 171\nsum, 185\nsum function, 118\nsuperstitious debugging, 200\nswap pattern, 116\nsyntax, 5, 7, 13, 162, 194\nsyntax error, 13, 14, 193\nSyntaxError, 19\ntemporary variable, 51, 60, 199\ntest case, minimal, 198\ntesting",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_555",
    "text": "sum function, 118\nsuperstitious debugging, 200\nswap pattern, 116\nsyntax, 5, 7, 13, 162, 194\nsyntax error, 13, 14, 193\nSyntaxError, 19\ntemporary variable, 51, 60, 199\ntest case, minimal, 198\ntesting\nand absence of bugs, 87\nincremental development, 52\nis hard, 87\nknowing the answer, 53\nleap of faith, 57\nminimal test case, 198\ntext\nplain, 83, 125\nrandom, 131\ntext \ufb01le, 145\nTime class, 155\ntime module, 101\ntoken, 5, 7\ntraceback, 24, 26, 44, 46, 107, 196\ntranslate method, 125\ntraversal, 72, 75, 77, 79, 85, 93, 100, 105, 106,\n119, 127\ndictionary, 168\nlist, 91\ntraverse\ndictionary, 120\ntriangle, 48\ntrigonometric function, 18\ntriple-quoted string, 35\nTrue special value, 40\ntry statement, 140, 153\ntuple, 115, 117, 121, 122\nas key in dictionary, 120, 132\nassignment, 116\ncomparison, 116, 174\nin brackets, 120\nsingleton, 115\nslice, 116\ntuple assignment, 117, 119, 122\ntuple function, 115\ntuple methods, 204\nTuring complete language, 55\nTuring Thesis, 55\nTuring, Alan, 55\nturtle module, 48",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_556",
    "text": "in brackets, 120\nsingleton, 115\nslice, 116\ntuple assignment, 117, 119, 122\ntuple function, 115\ntuple methods, 204\nTuring complete language, 55\nTuring Thesis, 55\nTuring, Alan, 55\nturtle module, 48\nturtle typewriter, 37\ntype, 4, 7\nbool, 40\ndict, 103\n\ufb01le, 137\n\ufb02oat, 4\nfunction, 20\nint, 4\nlist, 89\nNoneType, 24\nprogrammer-de\ufb01ned, 147, 153, 155, 162,\n165, 173\nset, 130\nstr, 4\ntuple, 115\ntype checking, 58\ntype conversion, 17\ntype function, 153\ntype-based dispatch, 166, 167, 169\nTypeError, 72, 74, 108, 116, 118, 139, 164, 197\ntypewriter, turtle, 37\ntypographical error, 134\nUnboundLocalError, 110\nunderscore character, 10\nuniqueness, 101\nUnix command\nls, 142\nupdate, 64, 67, 69\ndatabase, 141\nglobal variable, 110\nhistogram, 127\nitem, 91\nslice, 92\nupdate method, 120\nupdate operator, 93\nuse before def, 20\nvalue, 4, 7, 95, 96, 112\ndefault, 129\ntuple, 117\nValueError, 46, 117\nvalues method, 104\nvariable, 9, 14\nglobal, 110\nlocal, 22\ntemporary, 51, 60, 199\n222\nIndex\nupdating, 64",
    "metadata": {
      "source": "thinkpython2"
    }
  },
  {
    "id": "thinkpython2_557",
    "text": "use before def, 20\nvalue, 4, 7, 95, 96, 112\ndefault, 129\ntuple, 117\nValueError, 46, 117\nvalues method, 104\nvariable, 9, 14\nglobal, 110\nlocal, 22\ntemporary, 51, 60, 199\n222\nIndex\nupdating, 64\nvariable-length argument tuple, 118\nveneer, 175, 180\nvoid function, 24, 26\nvoid method, 92\nvorpal, 55\nwalk, directory, 140\nwhile loop, 64\nwhitespace, 46, 84, 144, 194\nword count, 143\nword frequency, 125, 134\nword, reducible, 113, 124\nworking directory, 139\nworst bug, 170\nworst case, 202, 209\nzero, index starting at, 71\nzero, index starting at, 90\nzip function, 118\nuse with dict, 120\nzip object, 123\nZipf\u2019s law, 134",
    "metadata": {
      "source": "thinkpython2"
    }
  }
]